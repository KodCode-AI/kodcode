{
  "metadata": {
    "prompt_id": "00000044",
    "row_id": 44,
    "seed_ids": [
      "847",
      "1820",
      "963"
    ],
    "mode": "leetcode"
  },
  "instruction": "You are given a list of `n` flights, each represented as a triplet `(i, j, k)` where `i` is the starting city, `j` is the destination city, and `k` is the cost of the flight. The cities are labeled from `0` to `n-1`. You are also given a list of `m` reservations, each represented as a pair `(i, j)` indicating that a reservation is made from city `i` to city `j`. A reservation is valid if there exists a direct flight between the two cities. \n\nReturn the total cost of the cheapest valid itinerary that visits every city exactly once, or `-1` if no such itinerary exists. You may start and end at any city, and you may revisit cities and use the same flight multiple times. \n\nIf there are multiple valid itineraries with the same total cost, return the one with the lexicographically smallest itinerary. An itinerary is lexicographically smaller if the sequence of city labels is lexicographically smaller.",
  "solution_code": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find_cheapest_itinerary(flights, reservations):\n    \"\"\"\n    Finds the cheapest valid itinerary visiting every city exactly once. If no such itinerary exists, returns -1.\n    \"\"\"\n    graph = defaultdict(list)\n    for i, j, k in flights:\n        graph[i].append((j, k))\n    \n    start = None\n    reservation_map = defaultdict(list)\n    for i, j in reservations:\n        reservation_map[i].append(j)\n    \n    def dfs(city, visited, path, cost, cities):\n        nonlocal cheapest_cost, cheapest_path\n        \n        if len(visited) == len(cities):\n            if cost < cheapest_cost or (cost == cheapest_cost and ''.join(map(str, path)) < ''.join(map(str, cheapest_path))):\n                cheapest_cost, cheapest_path = cost, path.copy()\n            return\n        \n        for next_city, flight_cost in graph[city]:\n            if next_city in visited:\n                continue\n            if next_city not in reservation_map[city] and next_city not in visited:\n                continue\n            visited.add(next_city)\n            path.append(next_city)\n            dfs(next_city, visited, path, cost + flight_cost, cities)\n            path.pop()\n            visited.remove(next_city)\n    \n    cities = list(reservation_map.keys())\n    cheapest_cost, cheapest_path = float('inf'), []\n    for city in cities:\n        visited = set([city])\n        path = [city]\n        dfs(city, visited, path, 0, cities)\n    \n    return cheapest_cost if cheapest_cost != float('inf') else -1",
  "test_code": "from solution import find_cheapest_itinerary\n\ndef test_find_cheapest_itinerary():\n    assert find_cheapest_itinerary([(\"SFO\", \"ATL\", 100), (\"ATL\", \"SFO\", 100), (\"ATL\", \"NHM\", 450), (\"NHM\", \"ATL\", 450), (\"NHM\", \"EWR\", 800)], [(\"SFO\", \"ATL\"), (\"ATL\", \"SFO\")]) == 650\n    assert find_cheapest_itinerary([(\"SFO\", \"ATL\", 100), (\"ATL\", \"SFO\", 100), (\"ATL\", \"NHM\", 450), (\"NHM\", \"ATL\", 450), (\"NHM\", \"EWR\", 800)], [(\"SFO\", \"ATL\"), (\"ATL\", \"NHM\")]) == 1300\n    assert find_cheapest_itinerary([(\"SFO\", \"ATL\", 100), (\"ATL\", \"NHM\", 450), (\"NHM\", \"EWR\", 800), (\"EWR\", \"SFO\", 500), (\"ATL\", \"SFO\", 100)], [(\"SFO\", \"ATL\")]) == 650\n    assert find_cheapest_itinerary([(\"SFO\", \"ATL\", 100), (\"ATL\", \"NHM\", 450), (\"NHM\", \"EWR\", 800), (\"EWR\", \"SFO\", 500), (\"ATL\", \"SFO\", 100)], [(\"SFO\", \"ATL\")], \"SFO\") == -1  # No valid itinerary\n    assert find_cheapest_itinerary([(\"SFO\", \"ATL\", 100), (\"ATL\", \"NHM\", 450), (\"NHM\", \"EWR\", 800)], [(\"SFO\", \"ATL\"), (\"ATL\", \"NHM\"), (\"NHM\", \"EWR\")]) == 1800",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results2.jsonl"
}