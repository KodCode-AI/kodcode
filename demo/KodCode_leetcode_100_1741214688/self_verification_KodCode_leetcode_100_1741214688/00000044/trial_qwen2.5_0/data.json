{
  "metadata": {
    "prompt_id": "00000044",
    "row_id": 44,
    "seed_ids": [
      "847",
      "1820",
      "963"
    ],
    "mode": "leetcode"
  },
  "instruction": "You are given a list of `n` flights, each represented as a triplet `(i, j, k)` where `i` is the starting city, `j` is the destination city, and `k` is the cost of the flight. The cities are labeled from `0` to `n-1`. You are also given a list of `m` reservations, each represented as a pair `(i, j)` indicating that a reservation is made from city `i` to city `j`. A reservation is valid if there exists a direct flight between the two cities. \n\nReturn the total cost of the cheapest valid itinerary that visits every city exactly once, or `-1` if no such itinerary exists. You may start and end at any city, and you may revisit cities and use the same flight multiple times. \n\nIf there are multiple valid itineraries with the same total cost, return the one with the lexicographically smallest itinerary. An itinerary is lexicographically smaller if the sequence of city labels is lexicographically smaller.",
  "solution_code": "from collections import defaultdict\nfrom itertools import permutations\n\ndef cheapest_itinerary(flights, reservations):\n    \"\"\"\n    Returns the total cost of the cheapest valid itinerary that visits every city exactly once,\n    or -1 if no such itinerary exists.\n    \"\"\"\n    # Create a graph from the flights list\n    graph = defaultdict(list)\n    for i, j, k in flights:\n        graph[i].append((j, k))\n        graph[j].append((i, k))\n    \n    # Filter out airports where no direct flights are made according to reservations\n    airports = set()\n    for i, j in reservations:\n        airports.add(i)\n        airports.add(j)\n    airports = list(airports)\n    \n    # Find all possible permutations of the itinerary\n    min_cost = float('inf')\n    best_path = []\n    for perm in permutations(airports):\n        current_cost = 0\n        valid = True\n        for i in range(len(perm) - 1):\n            u, v = perm[i], perm[i + 1]\n            if (u, v) in graph and (v, u) in graph:\n                for j, k in graph[u]:\n                    if j == v:\n                        current_cost += k\n                        break\n                else:\n                    valid = False\n                    break\n            elif (v, u) in graph:\n                for j, k in graph[v]:\n                    if j == u:\n                        current_cost += k\n                        break\n                else:\n                    valid = False\n                    break\n        \n        if valid and current_cost < min_cost:\n            min_cost = current_cost\n            best_path = perm\n    \n    return min_cost if min_cost != float('inf') else -1",
  "test_code": "def test_cheapest_itinerary():\n    assert cheapest_itinerary([(0, 1, 100), (1, 2, 100), (2, 0, 100), (1, 2, 600)], [(0, 1), (1, 2)]) == 260\n    assert cheapest_itinerary([(0,1,10),(1,2,100),(2,0,100),(1,2,100),(2,0,100)], [(0,1)]) == -1\n    assert cheapest_itinerary([(0,1,100),(1,2,100),(2,0,100)], [(0,1),(1,2)]) == 200\n    assert cheapest_itinerary([(0,1,100),(1,2,100),(2,0,100)], [(0,1),(2,0)]) == -1\n    assert cheapest_itinerary([(1,2,5), (1,3,5), (3,2,5)], [(2,1)]) == -1",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results0.jsonl"
}