{
  "metadata": {
    "prompt_id": "00000044",
    "row_id": 44,
    "seed_ids": [
      "847",
      "1820",
      "963"
    ],
    "mode": "leetcode"
  },
  "instruction": "You are given a list of `n` flights, each represented as a triplet `(i, j, k)` where `i` is the starting city, `j` is the destination city, and `k` is the cost of the flight. The cities are labeled from `0` to `n-1`. You are also given a list of `m` reservations, each represented as a pair `(i, j)` indicating that a reservation is made from city `i` to city `j`. A reservation is valid if there exists a direct flight between the two cities. \n\nReturn the total cost of the cheapest valid itinerary that visits every city exactly once, or `-1` if no such itinerary exists. You may start and end at any city, and you may revisit cities and use the same flight multiple times. \n\nIf there are multiple valid itineraries with the same total cost, return the one with the lexicographically smallest itinerary. An itinerary is lexicographically smaller if the sequence of city labels is lexicographically smaller.",
  "solution_code": "from collections import defaultdict\nfrom itertools import permutations\n\ndef cheapest_itinerary(flights, reservations):\n    \"\"\"\n    Returns the total cost of the cheapest valid itinerary that visits every city exactly once.\n    \"\"\"\n    # Build the graph and filter out invalid reservations\n    graph = defaultdict(dict)\n    for i, j, k in flights:\n        graph[i][j] = k\n    valid_reservations = [[i, j] for i, j in reservations if j in graph[i]]\n    \n    # Check if there are enough flights to cover reservations\n    if len(valid_reservations) != len(reservations):\n        return -1\n    \n    # Generate all possible itineraries\n    itineraries = []\n    for perm in permutations(range(len(flights))):\n        itinerary = [i for i in range(len(flights))]\n        for i in range(len(perm)):\n            if perm[i] != i and itinerary[perm[i]] != itinerary[i]:\n                break\n        else:\n            itineraries.append(itinerary)\n    \n    # Calculate the total cost for each valid itinerary\n    costs = [sum(graph[from_city][to_city] for from_city, to_city in zip(itinerary, itinerary[1:])) for itinerary in itineraries if all(graph[from_city][to_city] for from_city, to_city in zip(itinerary, itinerary[1:]))]\n    \n    # Return the cheapest valid itinerary or -1 if none exist\n    if costs:\n        min_cost = min(costs)\n        min_index = costs.index(min_cost)\n        return min_cost, itineraries[min_index]\n    return -1",
  "test_code": "def test_cheapest_itinerary():\n    # Test case 1: Basic case\n    flights = [(0, 1, 100), (1, 2, 100), (2, 0, 100)]\n    reservations = [(0, 1), (1, 2), (2, 0)]\n    assert cheapest_itinerary(flights, reservations) == (300, [0, 1, 2])\n    \n    # Test case 2: No valid itininerary\n    flights = [(0, 1, 100), (1, 2, 100), (2, 0, 100)]\n    reservations = [(0, 2), (2, 1)]\n    assert cheapest_itinerary(flights, reservations) == -1\n    \n    # Test case 3: Lexicographically smallest itinerary\n    flights = [(0, 1, 100), (1, 2, 100), (2, 0, 100)]\n    reservations = [(0, 1), (1, 2), (1, 2)]\n    assert cheapest_itinerary(flights, reservations) == (200, [0, 1, 1, 2])\n\n# To run the tests, use pytest",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results1.jsonl"
}