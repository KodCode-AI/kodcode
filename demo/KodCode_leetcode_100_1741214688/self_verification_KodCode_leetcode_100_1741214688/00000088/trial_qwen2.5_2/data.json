{
  "metadata": {
    "prompt_id": "00000088",
    "row_id": 88,
    "seed_ids": [
      "497",
      "933",
      "1271"
    ],
    "mode": "leetcode"
  },
  "instruction": "You are given a list of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]`. Design a data structure to efficiently manage these intervals and answer the following operations:\n\n1. `addInterval(start, end)`: Add a new interval `[start, end]` to the data structure. Ensure that the new interval does not overlap with any existing interval.\n2. `removeInterval(start, end)`: Remove an existing interval `[start, end]` from the data structure if it exists.\n3. `mergeIntervals()`: Merge all overlapping intervals in the data structure and return the merged intervals as a list.\n4. `queryInterval(start, end)`: Check if there is any interval in the data structure that overlaps with the given interval `[start, end]`.\n\nImplement the `IntervalManager` class:\n\n*   `IntervalManager()`: Initializes the data structure with an empty list of intervals.\n*   `void addInterval(start, end)`: Adds a new interval `[start, end]` to the data structure.\n*   `void removeInterval(start, end)`: Removes an interval `[start, end]` from the data structure if it exists.\n*   `List<int[]> mergeIntervals()`: Merges all overlapping intervals and returns the merged intervals as a list.\n*   `boolean queryInterval(start, end)`: Checks if there is any interval in the data structure that overlaps with the given interval `[start, end]`.\n\nEnsure that the intervals are stored in a way that allows for efficient operations, and the intervals stored in the data structure are sorted by their start times.",
  "solution_code": "from typing import List\n\nclass IntervalManager:\n    def __init__(self):\n        self.intervals = []\n    \n    def addInterval(self, start: int, end: int) -> None:\n        # This function will add a new interval if it does not overlap with any existing interval\n        new_interval = [start, end]\n        # Insert the new interval in a sorted manner\n        idx = 0\n        while idx < len(self.intervals) and new_interval[0] > self.intervals[idx][1]:\n            idx += 1\n        if idx < len(self.intervals) and new_interval[0] < self.intervals[idx][1]:\n            # New interval overlaps with existing one, do not add\n            return\n        elif idx > 0 and self.intervals[idx-1][1] >= new_interval[0]:\n            # New interval overlaps with the interval just before the insertion point, merge them\n            self.intervals[idx-1][1] = max(self.intervals[idx-1][1], end)\n            if idx < len(self.intervals) and self.intervals[idx][0] <= self.intervals[idx-1][1]:\n                # Merge with the next interval as well if applicable\n                self.intervals[idx-1][1] = max(self.intervals[idx-1][1], self.intervals[idx][1])\n                self.intervals.pop(idx)\n        else:\n            # No overlap found, insert the new interval\n            self.intervals.insert(idx, new_interval)\n    \n    def removeInterval(self, start: int, end: int) -> None:\n        # This function will remove an existing interval if it exists\n        self.intervals = [interval for interval in self.intervals if interval[1] < start or interval[0] > end]\n    \n    def mergeIntervals(self) -> List[int]:\n        # Merge all overlapping intervals\n        if not self.intervals:\n            return []\n        \n        merged = [self.intervals[0]]\n        for interval in self.intervals[1:]:\n            if interval[0] <= merged[-1][1]:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n            else:\n                merged.append(interval)\n        \n        return merged\n    \n    def queryInterval(self, start: int, end: int) -> bool:\n        # Query if there is any interval that overlaps with the given interval\n        for interval in self.intervals:\n            if interval[0] <= end and interval[1] >= start:\n                return True\n        return False",
  "test_code": "def test_interval_manager():\n    manager = IntervalManager()\n\n    # Add intervals\n    manager.addInterval(1, 2)\n    manager.addInterval(3, 4)\n    manager.addInterval(5, 7)\n    assert manager.queryInterval(2, 3) == True\n    assert manager.queryInterval(1, 1) == True\n    assert manager.queryInterval(4, 4) == True\n    assert manager.queryInterval(7, 8) == True\n    assert manager.queryInterval(0, 0) == False\n\n    # Remove interval\n    manager.removeInterval(3, 4)\n    assert manager.queryInterval(2, 3) == False\n    assert manager.queryInterval(3, 3) == False\n\n    # Merge intervals\n    assert manager.mergeIntervals() == [[1, 2], [5, 7]]\n\n    # Add interval that overlaps but does not merge\n    manager.addInterval(3, 10)\n    assert manager.mergeIntervals() == [[1, 2], [3, 10], [5, 7]]\n\n    # Add and merge adjacent intervals\n    manager.addInterval(2, 3)\n    assert manager.mergeIntervals() == [[1, 3], [5, 7], [10, 10]]\n\n    # Add and merge over multiple intervals\n    manager.addInterval(8, 8)\n    manager.addInterval(9, 9)\n    assert manager.mergeIntervals() == [[1, 3], [5, 7], [8, 10]]\n\n    # Complex queries and interval manipulation\n    manager.addInterval(0, 10)\n    assert manager.queryInterval(0, 0) == True\n    assert manager.queryInterval(0, 1) == True\n    assert manager.queryInterval(6, 10) == True\n    assert manager.queryInterval(12, 15) == False\n   (manager.removeInterval(12, 15) not in manager.intervals)\n\ntest_interval_manager()",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results2.jsonl"
}