{
  "metadata": {
    "prompt_id": "00000088",
    "row_id": 88,
    "seed_ids": [
      "497",
      "933",
      "1271"
    ],
    "mode": "leetcode"
  },
  "instruction": "You are given a list of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]`. Design a data structure to efficiently manage these intervals and answer the following operations:\n\n1. `addInterval(start, end)`: Add a new interval `[start, end]` to the data structure. Ensure that the new interval does not overlap with any existing interval.\n2. `removeInterval(start, end)`: Remove an existing interval `[start, end]` from the data structure if it exists.\n3. `mergeIntervals()`: Merge all overlapping intervals in the data structure and return the merged intervals as a list.\n4. `queryInterval(start, end)`: Check if there is any interval in the data structure that overlaps with the given interval `[start, end]`.\n\nImplement the `IntervalManager` class:\n\n*   `IntervalManager()`: Initializes the data structure with an empty list of intervals.\n*   `void addInterval(start, end)`: Adds a new interval `[start, end]` to the data structure.\n*   `void removeInterval(start, end)`: Removes an interval `[start, end]` from the data structure if it exists.\n*   `List<int[]> mergeIntervals()`: Merges all overlapping intervals and returns the merged intervals as a list.\n*   `boolean queryInterval(start, end)`: Checks if there is any interval in the data structure that overlaps with the given interval `[start, end]`.\n\nEnsure that the intervals are stored in a way that allows for efficient operations, and the intervals stored in the data structure are sorted by their start times.",
  "solution_code": "from bisect import bisect_left, bisect_right\nfrom itertools import chain\n\nclass Interval:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\n    def __eq__(self, other):\n        return (self.start, self.end) == (other.start, other.end)\n\n    def __lt__(self, other):\n        return self.start < other.start or (self.start == other.start and self.end < other.end)\n\nclass IntervalManager:\n    def __init__(self):\n        self.intervals = []\n        self._add_queue = []\n\n    def addInterval(self, start, end):\n        new_interval = Interval(start, end)\n        \n        # Remove intervals if the new interval overlaps with any of them\n        start_index = bisect_right(self.intervals, new_interval, key=lambda x: x.end)\n        end_index = bisect_left(self.intervals, new_interval, key=lambda x: x.start)\n        \n        self.intervals = self.intervals[:start_index] + [new_interval] + self.intervals[end_index:]\n        self._add_queue = []\n\n    def removeInterval(self, start, end):\n        interval_to_remove = Interval(start, end)\n        \n        # Find and remove the interval\n        index = bisect_left(self.intervals, interval_to_remove)\n        if index < len(self.intervals) and self.intervals[index] == interval_to_remove:\n            self.intervals.pop(index)\n\n    def mergeIntervals(self):\n        merged_intervals = []\n        for interval in self.intervals:\n            if merged_intervals and merged_intervals[-1].end >= interval.start - 1:\n                merged_intervals[-1].end = max(merged_intervals[-1].end, interval.end)\n            else:\n                merged_intervals.append(interval)\n        return merged_intervals\n\n    def queryInterval(self, start, end):\n        query_interval = Interval(start, end)\n        return bisect_right(self.intervals, query_interval, key=lambda x: x.end) > bisect_left(self.intervals, query_interval, key=lambda x: x.start)",
  "test_code": "from solution import IntervalManager, Interval\n\ndef test_addInterval():\n    manager = IntervalManager()\n    manager.addInterval(1, 2)\n    manager.addInterval(3, 4)\n    manager.addInterval(5, 6)\n    assert manager.mergeIntervals() == [Interval(1, 2), Interval(3, 4), Interval(5, 6)]\n\ndef test_removeInterval():\n    manager = IntervalManager()\n    manager.addInterval(1, 10)\n    manager.addInterval(2, 5)\n    manager.removeInterval(2, 5)\n    assert manager.mergeIntervals() == [Interval(1, 1), Interval(5, 10)]\n\ndef test_mergeIntervals():\n    manager = IntervalManager()\n    manager.addInterval(1, 5)\n    manager.addInterval(3, 7)\n    manager.addInterval(8, 10)\n    assert manager.mergeIntervals() == [Interval(1, 7), Interval(8, 10)]\n\ndef test_queryInterval():\n    manager = IntervalManager()\n    manager.addInterval(1, 10)\n    manager.addInterval(5, 8)\n    assert manager.queryInterval(6, 7) == True\n    assert manager.queryInterval(2, 3) == True\n    assert manager.queryInterval(11, 15) == False",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results0.jsonl"
}