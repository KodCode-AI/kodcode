{
  "metadata": {
    "prompt_id": "00000088",
    "row_id": 88,
    "seed_ids": [
      "497",
      "933",
      "1271"
    ],
    "mode": "leetcode"
  },
  "instruction": "You are given a list of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]`. Design a data structure to efficiently manage these intervals and answer the following operations:\n\n1. `addInterval(start, end)`: Add a new interval `[start, end]` to the data structure. Ensure that the new interval does not overlap with any existing interval.\n2. `removeInterval(start, end)`: Remove an existing interval `[start, end]` from the data structure if it exists.\n3. `mergeIntervals()`: Merge all overlapping intervals in the data structure and return the merged intervals as a list.\n4. `queryInterval(start, end)`: Check if there is any interval in the data structure that overlaps with the given interval `[start, end]`.\n\nImplement the `IntervalManager` class:\n\n*   `IntervalManager()`: Initializes the data structure with an empty list of intervals.\n*   `void addInterval(start, end)`: Adds a new interval `[start, end]` to the data structure.\n*   `void removeInterval(start, end)`: Removes an interval `[start, end]` from the data structure if it exists.\n*   `List<int[]> mergeIntervals()`: Merges all overlapping intervals and returns the merged intervals as a list.\n*   `boolean queryInterval(start, end)`: Checks if there is any interval in the data structure that overlaps with the given interval `[start, end]`.\n\nEnsure that the intervals are stored in a way that allows for efficient operations, and the intervals stored in the data structure are sorted by their start times.",
  "solution_code": "from typing import List\n\nclass IntervalManager:\n    def __init__(self):\n        self.intervals = []\n\n    def addInterval(self, start: int, end: int) -> None:\n        intervals = self.intervals\n        new_interval = [start, end]\n        insert_pos = -1\n        \n        # Find the insert position to ensure intervals remain sorted\n        for i, interval in enumerate(intervals):\n            if end < interval[0]:\n                insert_pos = i\n                break\n        else:\n            insert_pos = len(intervals)\n        \n        inserted = False\n        for i, interval in enumerate(intervals):\n            if i == insert_pos:\n                # Check for overlapping intervals and merge if necessary\n                if start <= interval[0]:\n                    if end < interval[0]:\n                        # Fully to the left\n                        pass\n                    elif end < interval[1]:\n                        # Partial overlap on the right\n                        new_interval[1] = interval[1]\n                        insert_pos = i + 1\n                        inserted = True\n                        break\n                    elif end >= interval[1]:\n                        # Complete overlap or extends right\n                        new_interval = interval\n                        inserted = True\n                        continue\n                elif start > interval[0]:\n                    # No overlap\n                    if end < interval[0]:\n                        # Fully to the right\n                        pass\n                    else:\n                        # Overlap from the left\n                        new_interval[0] = interval[0]\n                        insert_pos = i\n                        inserted = True\n                        break\n                else:\n                    # Start is equal to interval[0]; cannot happen since insert_pos is found\n                    assert False\n            intervals[i] = new_interval\n        if not inserted:\n            intervals.insert(insert_pos, new_interval)\n\n    def removeInterval(self, start: int, end: int) -> None:\n        self.intervals = [interval for interval in self.intervals if interval != [start, end]]\n\n    def mergeIntervals(self) -> List[int:]:\n        if not self.intervals:\n            return []\n        \n        merged = []\n        current = self.intervals[0]\n        for interval in self.intervals[1:]:\n            if interval[0] <= current[1]:\n                current[1] = max(current[1], interval[1])\n            else:\n                merged.append(current)\n                current = interval\n        merged.append(current)\n        self.intervals = merged\n        return self.intervals\n\n    def queryInterval(self, start: int, end: int) -> bool:\n        intervals = self.intervals\n        for interval in intervals:\n            if interval[0] <= end and interval[1] >= start:\n                return True\n        return False",
  "test_code": "import pytest\n\ninterval_manager = IntervalManager()\n\ndef test_add_merge():\n    interval_manager.addInterval(1, 3)\n    interval_manager.addInterval(2, 6)\n    interval_manager.addInterval(8, 10)\n    interval_manager.addInterval(15, 18)\n    assert interval_manager.mergeIntervals() == [[1, 6], [8, 10], [15, 18]]\n    interval_manager.addInterval(5, 7)\n    assert interval_manager.mergeIntervals() == [[1, 7], [8, 10], [15, 18]]\n\ndef test_remove_merge():\n    interval_manager.addInterval(1, 4)\n    interval_manager.addInterval(4, 5)\n    interval_manager.removeInterval(1, 4)\n    assert interval_manager.mergeIntervals() == [[4, 5]]\n    interval_manager.addInterval(6, 8)\n    assert interval_manager.mergeIntervals() == [[4, 5], [6, 8]]\n\ndef test_query():\n    interval_manager.addInterval(1, 3)\n    interval_manager.addInterval(5, 9)\n    assert interval_manager.queryInterval(2, 4)\n    assert not interval_manager.queryInterval(4, 5)\n    assert interval_manager.queryInterval(5, 7)\n    assert interval_manager.queryInterval(7, 9)",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results1.jsonl"
}