{
  "metadata": {
    "prompt_id": "00000068",
    "row_id": 68,
    "seed_ids": [
      "2547",
      "1334",
      "133"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a binary tree, your task is to find the minimum **balance factor** of all its nodes. A node's balance factor is defined as the difference between the heights of its left and right subtrees, and the balance factor of the entire tree is the minimum balance factor of all its nodes. If the tree is empty, the balance factor is considered to be 0. Additionally, if a node does not have a left or right subtree, its balance factor is the height of the existing subtree. Return the minimum balance factor of the tree.\n\nFor example, consider the following tree:\n\n```\n    1\n   / \\\n  2   3\n /\n4\n```\n\nThe balance factors of the nodes are as follows:\n- Node 1: |2 - 1| = 1\n- Node 2: |1 - 0| = 1\n- Node 3: |0 - 0| = 0\n- Node 4: 1 (since it only has a left subtree)\n\nThe minimum balance factor is 0.\n\n**Note**: A node's height is defined as the number of edges on the longest path from the node to a leaf. A leaf node has a height of 0.",
  "solution_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef height(node):\n    \"\"\"\n    Returns the height of the given tree node.\n    \"\"\"\n    if node is None:\n        return -1\n    return 1 + max(height(node.left), height(node.right))\n\ndef balance_factor(node):\n    \"\"\"\n    Returns the balance factor of the given node.\n    \"\"\"\n    if node is None:\n        return 0\n    left_height = height(node.left)\n    right_height = height(node.right)\n    return abs(left_height - right_height)\n\ndef find_min_balance_factor(root):\n    \"\"\"\n    Traverses the tree to find the minimum balance factor of all nodes.\n    \"\"\"\n    min_bal = 0\n    stack = [root]\n    visited = set()\n    while stack:\n        cur_node = stack.pop()\n        if cur_node not in visited:\n            visited.add(cur_node)\n            min_bal = min(min_bal, balance_factor(cur_node))\n            if cur_node.left:\n                stack.append(cur_node.left)\n            if cur_node.right:\n                stack.append(cur_node.right)\n    return min_bal",
  "test_code": "import pytest\n\ndef create_tree(*values):\n    \"\"\"\n    Helper function to create a binary tree from a list of values.\n    \"\"\"\n    nodes = [TreeNode(val) if val is not None else None for val in values]\n    for idx, node in enumerate(nodes):\n        if 2 * idx + 1 < len(nodes):\n            node.left = nodes[2 * idx + 1]\n        if 2 * idx + 2 < len(nodes):\n            node.right = nodes[2 * idx + 2]\n    return nodes[0]\n\ndef test_find_min_balance_factor_empty_tree():\n    assert find_min_balance_factor(None) == 0\n\ndef test_find_min_balance_factor_balanced_tree():\n    root = create_tree(1, 2, 3, 4)\n    assert find_min_balance_factor(root) == 0\n\ndef test_find_min_balance_factor_unbalanced_tree():\n    root = create_tree(1, 2, 3, None, 4)\n    assert find_min_balance_factor(root) == 0\n\ndef test_find_min_balance_factor_complex_tree():\n    root = create_tree(1, 2, 3, 4, 5)\n    assert find_min_balance_factor(root) == 1\n\ndef test_find_min_balance_factor_single_node():\n    root = create_tree(1)\n    assert find_min_balance_factor(root) == 0",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results2.jsonl"
}