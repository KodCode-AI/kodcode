{
  "metadata": {
    "prompt_id": "00000068",
    "row_id": 68,
    "seed_ids": [
      "2547",
      "1334",
      "133"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a binary tree, your task is to find the minimum **balance factor** of all its nodes. A node's balance factor is defined as the difference between the heights of its left and right subtrees, and the balance factor of the entire tree is the minimum balance factor of all its nodes. If the tree is empty, the balance factor is considered to be 0. Additionally, if a node does not have a left or right subtree, its balance factor is the height of the existing subtree. Return the minimum balance factor of the tree.\n\nFor example, consider the following tree:\n\n```\n    1\n   / \\\n  2   3\n /\n4\n```\n\nThe balance factors of the nodes are as follows:\n- Node 1: |2 - 1| = 1\n- Node 2: |1 - 0| = 1\n- Node 3: |0 - 0| = 0\n- Node 4: 1 (since it only has a left subtree)\n\nThe minimum balance factor is 0.\n\n**Note**: A node's height is defined as the number of edges on the longest path from the node to a leaf. A leaf node has a height of 0.",
  "solution_code": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef height(node):\n    \"\"\"\n    Returns the height of the given node.\n    \"\"\"\n    if node is None:\n        return -1\n    return 1 + max(height(node.left), height(node.right))\n\ndef balance_factor(node):\n    \"\"\"\n    Returns the balance factor of the given node.\n    \"\"\"\n    if node is None:\n        return 0\n    left_height = height(node.left)\n    right_height = height(node.right)\n    return abs(left_height - right_height)\n\ndef min_balance_factor(root):\n    \"\"\"\n    Returns the minimum balance factor of all nodes in the tree.\n    \"\"\"\n    if root is None:\n        return 0\n    min_factor = [balance_factor(root)]\n    stack = [root]\n    while stack:\n        node = stack.pop()\n        if node.left:\n            min_factor.append(balance_factor(node.left))\n            stack.append(node.left)\n        if node.right:\n            min_factor.append(balance_factor(node.right))\n            stack.append(node.right)\n    return min(min_factor)\n\n# Example tree creation\nroot = TreeNode(1)\nroot.left = TreeNode(2, TreeNode(4))\nroot.right = TreeNode(3)\n\n# Function call to get the minimum balance factor\nresult = min_balance_factor(root)\nprint(result)  # Expected output: 0",
  "test_code": "from solution import TreeNode, min_balance_factor\n\ndef test_min_balance_factor_empty_tree():\n    assert min_balance_factor(None) == 0\n\ndef test_min_balance_factor_single_node():\n    root = TreeNode(1)\n    assert min_balance_factor(root) == 0\n\ndef test_min_balance_factor_balanced_tree():\n    root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3))\n    assert min_balance_factor(root) == 0\n\ndef test_min_balance_factor_skewed_left_tree():\n    root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))\n    assert min_balance_factor(root) == 3\n\ndef test_min_balance_factor_skewed_right_tree():\n    root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4))))\n    assert min_balance_factor(root) == 3\n\ndef test_min_balance_factor_mixed_tree():\n    root = TreeNode(1, TreeNode(2, TreeNode(4, None, TreeNode(5))), TreeNode(3))\n    assert min_balance_factor(root) == 1",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results1.jsonl"
}