{
  "metadata": {
    "prompt_id": "00000040",
    "row_id": 40,
    "seed_ids": [
      "1656",
      "733",
      "352"
    ],
    "mode": "leetcode"
  },
  "instruction": "Design a class `CustomQueue` that supports the following operations:\n\n- `CustomQueue(int capacity)` Initializes the queue with a given capacity.\n- `void enqueue(int value)` Adds a value to the end of the queue if there is still space. Returns `false` if the queue is full.\n- `int dequeue()` Removes and returns the value at the front of the queue. Returns `-1` if the queue is empty.\n- `bool isFull()` Returns `true` if the queue is full, otherwise returns `false`.\n- `bool isEmpty()` Returns `true` if the queue is empty, otherwise returns `false`.\n\nImplement the `CustomQueue` class such that all operations are performed in constant time, i.e., O(1). Additionally, provide a method `getQueue()` that returns the current elements in the queue as a list, maintaining the order of elements as they were added.",
  "solution_code": "class CustomQueue:\n    def __init__(self, capacity: int):\n        assert capacity > 0, \"Capacity must be greater than 0\"\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.head = 0\n        self.tail = 0\n        self.size = 0\n\n    def enqueue(self, value: int) -> bool:\n        if self.size < self.capacity:\n            self.queue[self.tail] = value\n            self.tail = (self.tail + 1) % self.capacity\n            self.size += 1\n            return True\n        return False\n\n    def dequeue(self) -> int:\n        if self.size == 0:\n            return -1\n        item = self.queue[self.head]\n        self.queue[self.head] = None\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n\n    def isFull(self) -> bool:\n        return self.size == self.capacity\n\n    def isEmpty(self) -> bool:\n        return self.size == 0\n\n    def getQueue(self) -> list:\n        if self.head < self.tail:\n            return self.queue[self.head:self.tail]\n        else:\n            return self.queue[self.head:] + self.queue[:self.tail]",
  "test_code": "import pytest\n\ndef test_custom_queue():\n    max_size = 5\n    custom_queue = CustomQueue(max_size)\n\n    assert custom_queue.isEmpty() == True\n    assert custom_queue.isFull() == False\n    \n    assert custom_queue.enqueue(10) == True\n    assert custom_queue.enqueue(20) == True\n    assert custom_queue.enqueue(30) == True\n    assert custom_queue.enqueue(40) == True\n    assert custom_queue.enqueue(50) == True\n    assert custom_queue.enqueue(60) == False  # Queue is full\n\n    assert custom_queue.isFull() == True\n    assert custom_queue.isEmpty() == False\n\n    assert custom_queue.getQueue() == [10, 20, 30, 40, 50]\n\n    assert custom_queue.dequeue() == 10\n    assert custom_queue.getQueue() == [20, 30, 40, 50, None]  # Note: The last None represent the tail pointer advancing\n\n    assert custom_queue.enqueue(70) == True\n\n    assert custom_queue.getQueue() == [20, 30, 40, 50, 70]\n\n    assert custom_queue.dequeue() == 20\n    assert custom_queue.dequeue() == 30\n    assert custom_queue.getQueue() == [40, 50, 70, None, None]\n\n    assert custom_queue.enqueue(80) == True\n    assert custom_queue.enqueue(90) == True\n    assert custom_queue.enqueue(100) == True\n    assert custom_queue.enqueue(110) == False  # Queue is already full\n\n    assert custom_queue.getQueue() == [40, 50, 70, 80, 90]\n\n    assert custom_queue.dequeue() == 40\n    assert custom_queue.dequeue() == 50\n    assert custom_queue.dequeue() == 70\n    assert custom_queue.dequeue() == 80\n    assert custom_queue.dequeue() == 90\n    assert custom_queue.getQueue() == [100, None, None, None, None]\n\n    assert custom_queue.enqueue(120) == True\n    assert custom_queue.dequeue() == 100\n    assert custom_queue.dequeue() == 120\n    assert custom_queue.dequeue() == -1  # Queue is now empty\n\n    assert custom_queue.isEmpty() == True",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results1.jsonl"
}