{
  "metadata": {
    "prompt_id": "00000023",
    "row_id": 23,
    "seed_ids": [
      "2529",
      "155",
      "1650"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a binary search tree (BST) and a node value `target`, return the value of the closest leaf node to the target. A leaf node is a node with no children. The distance between two nodes is defined as the number of edges on the path connecting them. If there are multiple leaf nodes equally close to the target, return the value of any one of them.",
  "solution_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef findClosestLeaf(root: TreeNode, target: int) -> int:\n    \"\"\"\n    Finds the value of the closest leaf node to the target in a binary search tree.\n    \"\"\"\n    from collections import deque\n    \n    def dfs(node):\n        if not node:\n            return None\n        if node.val == target:\n            return node, 0\n        left_result, left_dist = dfs(node.left)\n        right_result, right_dist = dfs(node.right)\n        if left_result:\n            return left_result, left_dist + 1\n        if right_result:\n            return right_result, right_dist + 1\n        return None, None\n    \n    closest_leaf, _ = dfs(root)\n    if closest_leaf:\n        closest_leaf_queue = deque([closest_leaf])\n        while closest_leaf_queue:\n            current = closest_leaf_queue.popleft()\n            if not current.left and not current.right:\n                return current.val\n            if current.left:\n                closest_leaf_queue.append(current.left)\n            if current.right:\n                closest_leaf_queue.append(current.right)\n    return -1  # If target is not found",
  "test_code": "import pytest\nfrom solution import TreeNode, findClosestLeaf\n\n@pytest.fixture\ndef binary_search_tree():\n    \"\"\"\n    Fixture to create a simple binary search tree for testing.\n    \"\"\"\n    node10 = TreeNode(10)\n    node5 = TreeNode(5)\n    node15 = TreeNode(15)\n    node3 = TreeNode(3)\n    node7 = TreeNode(7)\n    node14 = TreeNode(14)\n    node20 = TreeNode(20)\n    \n    node15.left = node14\n    node15.right = node20\n    node10.left = node5\n    node10.right = node15\n    node5.left = node3\n    node5.right = node7\n    node7.left = node14\n    \n    return node10\n\ndef test_find_closest_leaf_root_node(binary_search_tree):\n    assert findClosestLeaf(binary_search_tree, 10) == 7\n\ndef test_find_closest_leaf_leaf_node(binary_search_tree):\n    assert findClosestLeaf(binary_search_tree, 3) == 3\n\ndef test_find_closest_leaf_target_in_between(binary_search_tree):\n    assert findClosestLeaf(binary_search_tree, 11) in [7, 14]  # Both nodes are at the same distance\n\ndef test_find_closest_leaf_target_not_found():\n    with pytest.raises(AssertionError):\n        findClosestLeaf(None, 10)\n\ndef test_find_closest_leaf_distance_from_leaf(binary_search_tree):\n    assert findClosestLeaf(binary_search_tree, 14) in [7, 15]  # Both nodes are at the same distance\n\ndef test_find_closest_leaf_multi_edges(binary_search_tree):\n    node8 = TreeNode(8, left=TreeNode(4, left=TreeNode(1, left=TreeNode(0))), right=TreeNode(9, right=TreeNode(10)))\n    assert findClosestLeaf(node8, 0) == 1",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results2.jsonl"
}