{
  "metadata": {
    "prompt_id": "00000023",
    "row_id": 23,
    "seed_ids": [
      "2529",
      "155",
      "1650"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a binary search tree (BST) and a node value `target`, return the value of the closest leaf node to the target. A leaf node is a node with no children. The distance between two nodes is defined as the number of edges on the path connecting them. If there are multiple leaf nodes equally close to the target, return the value of any one of them.",
  "solution_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef findClosestLeaf(root: TreeNode, target: int) -> int:\n    closest_leaf_val = None\n    min_distance = float('inf')\n    \n    def dfs(node):\n        nonlocal closest_leaf_val, min_distance\n        if not node:\n            return 0, False\n\n        left_distance, left_is_leaf = dfs(node.left)\n        right_distance, right_is_leaf = dfs(node.right)\n        \n        if left_is_leaf and right_is_leaf:\n            return min(left_distance, right_distance) + 1, False  # Node is an internal node\n        elif not left_is_leaf and not right_is_leaf:\n            return min(left_distance, right_distance) + 1, True\n        else:\n            distance = left_distance + right_distance + 1\n            if distance < min_distance:\n                min_distance = distance\n                closest_leaf_val = node.val\n            return min(left_distance, right_distance) + 1, False\n\n        return 0, False\n\n    dfs(root)\n    return closest_leaf_val\n\n\nThis function performs a depth-first search (DFS) on the BST to find the closest leaf node to the target. It maintains the distance to the closest leaf node and updates it if a closer leaf is found. The function returns the value of the closest leaf node.",
  "test_code": "import pytest\n\ndef create_tree(*vals):\n    nodes = [TreeNode(val=val) for val in vals]\n    for i in range(len(nodes)//2):\n        if 2*i+1 < len(nodes):\n            nodes[i].left = nodes[2*i+1]\n        if 2*i+2 < len(nodes):\n            nodes[i].right = nodes[2*i+2]\n    return nodes[0]\n\n@pytest.fixture\ndef setup_bst():\n    root = create_tree(1, 2, 3, 4, 5)\n    root.left.right = TreeNode(val=6)\n    root.right.left = TreeNode(val=7)\n    return root\n\ndef test_findClosestLeaf(setup_bst):\n    assert findClosestLeaf(setup_bst, 4) in [4, 3]  # 4 and 3 are both 1 step away\n\ndef test_findClosestLeaf_target_closest_setup_bst():\n    assert findClosestLeaf(create_tree(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), 8) == 7  # 7 is 1 step away\n\ndef test_findClosestLeaf_multiple_clicked_leaves():\n    assert findClosestLeaf(create_tree(1, 2, 3), 3) == 3  # Node 3 is a leaf itself\n\ndef test_findClosestLeaf_empty_tree():\n    assert findClosestLeaf(None, 0) == None  # Should return None if tree is empty\n\ndef test_findClosestLeaf_root_is_target(setup_bst):\n    assert findClosestLeaf(setup_bst, 1) == 1  # 1 is a leaf itself\n\n\nThe provided unit tests cover a variety of scenarios, including multiple leaf nodes, where the root node is the target, and where the tree is empty. The tests ensure that the function behaves as expected in different contexts.",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results0.jsonl"
}