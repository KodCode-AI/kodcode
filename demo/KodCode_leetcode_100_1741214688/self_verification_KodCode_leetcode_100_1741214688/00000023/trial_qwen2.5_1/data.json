{
  "metadata": {
    "prompt_id": "00000023",
    "row_id": 23,
    "seed_ids": [
      "2529",
      "155",
      "1650"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a binary search tree (BST) and a node value `target`, return the value of the closest leaf node to the target. A leaf node is a node with no children. The distance between two nodes is defined as the number of edges on the path connecting them. If there are multiple leaf nodes equally close to the target, return the value of any one of them.",
  "solution_code": "To solve this problem, we need to traverse the BST and find the closest leaf node to the target. A leaf node is a node that has no children. The solution involves performing a BFS (Breadth-First Search) traversal starting from the root and tracking the distance to the target node. We stop at the first leaf node we encounter at the shallowest level that is closest to the target.\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef findClosestLeaf(root: TreeNode, target: int) -> int:\n    from collections import deque\n    \n    if not root:\n        return None\n    \n    queue = deque([root])\n    target_node = None\n    level = 0\n    \n    while queue:\n        level_size = len(queue)\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            \n            if node.val == target:\n                target_node = node\n                break\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        if target_node:\n            break\n    \n    # When target_node is found, perform a BFS to find the closest leaf node\n    if target_node:\n        queue = deque([target_node])\n        visited = set([target_node])\n        \n        while queue:\n            level_size = len(queue)\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                \n                if not node.left and not node.right:  # node is a leaf\n                    return node.val\n                \n                if node.left and node.left not in visited:\n                    queue.append(node.left)\n                    visited.add(node.left)\n                \n                if node.right and node.right not in visited:\n                    queue.append(node.right)\n                    visited.add(node.right)\n\n# Example usage\n# Constructing a simple BST for testing\n#         3\n#        / \\\n#       1   4\n#          / \\\n#         2   5\nroot = TreeNode(3)\nroot.left = TreeNode(1)\nroot.right = TreeNode(4, TreeNode(2), TreeNode(5))\n\n# Find the closest leaf node to the target value 3\nprint(findClosestLeaf(root, 3))  # Output: 4",
  "test_code": "from solution import findClosestLeaf\n\ndef test_closest_leaf_negative():\n    # Constructing a BST for the test case\n    #         3\n    #        / \\\n    #       1   4\n    #          / \\\n    #         2   5\n    root = TreeNode(3)\n    root.left = TreeNode(1)\n    root.right = TreeNode(4, TreeNode(2), TreeNode(5))\n\n    assert findClosestLeaf(root, 3) == 4\n    assert findClosestLeaf(root, 2) == 2\n    assert findClosestLeaf(root, 4) == 5\n\ndef test_closest_leaf_edge_cases():\n    # Empty tree case\n    assert findClosestLeaf(None, 3) is None\n    # One node tree case\n    root = TreeNode(3)\n    assert findClosestLeaf(root, 3) == 3\n\ndef test_closest_leaf_positive():\n    # Constructing a BST for the test case\n    #          1\n    #           \\\n    #            2\n    #             \\\n    #              3\n    root = TreeNode(1, right=TreeNode(2, right=TreeNode(3)))\n\n    assert findClosestLeaf(root, 1) == 3\n    assert findClosestLeaf(root, 3) == 3\n\ndef test_closest_leaf_multiple_targets():\n    # Constructing a BST for the test case\n    #         5\n    #        / \\\n    #       3   6\n    #      / \\ / \\\n    #     2  4 7  8\n    root = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6, TreeNode(7), TreeNode(8)))\n\n    assert findClosestLeaf(root, 6) in [7, 8]",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results1.jsonl"
}