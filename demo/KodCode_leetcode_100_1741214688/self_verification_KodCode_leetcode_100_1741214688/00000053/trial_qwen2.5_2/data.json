{
  "metadata": {
    "prompt_id": "00000053",
    "row_id": 53,
    "seed_ids": [
      "866",
      "2194",
      "2503"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a rectangular grid of size `m x n`, you are initially positioned at the top-left cell `(0, 0)`. You are allowed to move either down or right at any point in time. Each cell in the grid contains a unique integer. Design a function that returns the lexicographically smallest path of length `k` from the starting cell to the bottom-right cell `(m-1, n-1)`. A path is defined as a sequence of `k` cells from the grid, starting from `(0, 0)` and ending at `(m-1, n-1)`. The path must follow the movement rules (only down or right) and the cells must be distinct. The cells in the path are considered in the order they are visited. The lexicographically smallest path is the one where the sequence of cell values, when concatenated, forms the smallest possible number. For example, if the path is `[5, 7, 8]`, the value is `578`. If the path is `[1, 3, 2]`, the value is `132`. If two paths have the same sequence of cell values, the lexicographically smaller one is the one with the smaller first element.",
  "solution_code": "def find_smallest_path(grid, k):\n    \"\"\"\n    Returns the lexicographically smallest path of length k from the top-left to the bottom-right cell.\n    \n    :param grid: List[List[int]] - The grid of unique integers.\n    :param k: int - The length of the path.\n    :return: List[int] - The lexicographically smallest path.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    from itertools import combinations\n    \n    def is_valid_path(path):\n        x, y = 0, 0\n        for step in path:\n            dx, dy = step // n, step % n\n            if x + dx >= m or y + dy >= n or (x + dx, y + dy) == (0, 0):\n                return False\n            x, y = x + dx, y + dy\n        return True\n    \n    def paths_from(x, y, length):\n        if length == 1:\n            return [(x, y)]\n        \n        all_paths = set()\n        for dx, dy in [(1, 0), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n:\n                for sub_path in paths_from(nx, ny, length - 1):\n                    if (nx, ny) == (0, 0) or sub_path[-1] != (0, 0):\n                        all_paths.add((*sub_path, (nx, ny)))\n        \n        return list(all_paths)\n    \n    candidates = paths_from(0, 0, k - 1)\n    smallest_path = None\n    \n    for path in candidates:\n        if is_valid_path(path) and (smallest_path is None or path < smallest_path):\n            smallest_path = path + ((m - 1, n - 1),)\n    \n    return [grid[x][y] for x, y in smallest_path]",
  "test_code": "import pytest\n\ndef test_simple_case():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    k = 3\n    assert find_smallest_path(grid, k) == [1, 2, 3]\n\ndef test_more_complex():\n    grid = [[5, 9, 3], [4, 1, 6], [7, 8, 2]]\n    k = 4\n    assert find_smallest_path(grid, k) == [1, 3, 2, 6]\n\ndef test_large_k():\n    grid = [[10], [11], [12]]\n    k = 3\n    assert find_smallest_path(grid, k) == [10, 11, 12]\n\ndef test (*(([\"[1, 2, 3], [4, 5, 6], [7, 8, 9]\", 3], ['[1, 2, 3], [4, 5, 6], [7, 8, 9]\", 3])),\n           ([\"[5, 9, 3], [4, 1, 6], [7, 8, 2]\", 4], ['[1, 3, 2, 6]'), ([\"[10], [11], [12]\", 3], ['[10, 11, 12]')))",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results2.jsonl"
}