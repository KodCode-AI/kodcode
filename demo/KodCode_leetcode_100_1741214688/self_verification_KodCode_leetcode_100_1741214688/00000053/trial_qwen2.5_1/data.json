{
  "metadata": {
    "prompt_id": "00000053",
    "row_id": 53,
    "seed_ids": [
      "866",
      "2194",
      "2503"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a rectangular grid of size `m x n`, you are initially positioned at the top-left cell `(0, 0)`. You are allowed to move either down or right at any point in time. Each cell in the grid contains a unique integer. Design a function that returns the lexicographically smallest path of length `k` from the starting cell to the bottom-right cell `(m-1, n-1)`. A path is defined as a sequence of `k` cells from the grid, starting from `(0, 0)` and ending at `(m-1, n-1)`. The path must follow the movement rules (only down or right) and the cells must be distinct. The cells in the path are considered in the order they are visited. The lexicographically smallest path is the one where the sequence of cell values, when concatenated, forms the smallest possible number. For example, if the path is `[5, 7, 8]`, the value is `578`. If the path is `[1, 3, 2]`, the value is `132`. If two paths have the same sequence of cell values, the lexicographically smaller one is the one with the smaller first element.",
  "solution_code": "def find_smallest_path(grid, k):\n    \"\"\"\n    Returns the lexicographically smallest path of length k from (0, 0) to (m-1, n-1) in a grid.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    if k >= m + n - 1:\n        # If k is too large, return the entire path from (0, 0) to (m-1, n-1)\n        return [str(grid[i][j]) for i in range(m) for j in range(n) if i == m-1 or j == n-1][-k:]\n    \n    # Directions: right and down\n    directions = [(0, 1), (1, 0)]\n    memo = {}  # Memoization dictionary to store (path, last_position) -> path_value\n    \n    def dfs(i, j, path_length, path):\n        if path_length == k:\n            return ''.join(path)\n        \n        if (tuple(path), (i, j)) in memo:\n            return memo[(tuple(path), (i, j))]\n        \n        min_path = float('inf')\n        for dx, dy in directions:\n            nx, ny = i + dx, j + dy\n            if 0 <= nx < m and 0 <= ny < n:\n                current_value = dfs(nx, ny, path_length + 1, path + [str(grid[nx][ny])])\n                if current_value < min_path:\n                    min_path = current_value\n                memo[(tuple(path), (i, j))] = min_path\n        return min_path\n    \n    return dfs(0, 0, 1, [str(grid[0][0])]) if k > 0 else ''",
  "test_code": "import pytest\n\ndef test_find_smallest_path():\n    grid1 = [[1,2,3],[4,5,6],[7,8,9]]\n    k1 = 3\n    assert find_smallest_path(grid1, k1) == '147'\n    \n    grid2 = [[5,9,3],[4,1,6],[7,8,2]]\n    k2 = 1\n    assert find_smallest_path(grid2, k2) == '1'\n    \n    grid3 = [[5,3],[4,4]]\n    k3 = 2\n    assert find_smallest_path(grid3, k3) == '34'\n    \n    grid4 = [[1,1,1],[1,1,1],[1,1,1]]\n    k4 = 3\n    assert find_smallest_path(grid4, k4) == '111'\n    \n    grid5 = [[10,1,12],[11,2,13],[12,3,14]]\n    k5 = 5\n    assert find_smallest_path(grid5, k5) == '11213'\n\ndef test_find_smallest_path_edge_cases():\n    grid6 = [[]]\n    k6 = 0\n    assert find_smallest_path(grid6, k6) == ''\n    \n    grid7 = [[1]]\n    k7 = 1\n    assert find_smallest_path(grid7, k7) == '1'\n\npytest.main()",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results1.jsonl"
}