{
  "metadata": {
    "prompt_id": "00000066",
    "row_id": 66,
    "seed_ids": [
      "929",
      "376",
      "663"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a **binary search tree (BST)**, return the number of **valid** sequences of **node values** such that for every node, the value of that node is **strictly greater** than the sum of the values of all nodes that come before it and **strictly less** than the sum of the values of all nodes that come after it. In other words, a valid sequence is one where each node's value is the sum of a contiguous subsequence of its in-order traversal values. For example, in the tree:\n\n```\n    5\n   / \\\n  3   7\n / \\\n2   4\n```\n\nThe sequence `[2, 3, 4, 5, 7]` is valid because each node's value is greater than the sum of all previous nodes and less than the sum of all subsequent nodes. Note that the sequence must strictly follow the in-order traversal of the tree.",
  "solution_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef count_valid_sequences(root: TreeNode) -> int:\n    \"\"\"\n    Returns the number of valid node value sequences in a binary search tree.\n    \"\"\"\n    def traverse(node: TreeNode, prefix_sum: int, suffix_sum: int, min_val: int, max_val: int, is_valid: bool, memo):\n        if not node:\n            return 1 if is_valid else 0\n        \n        current_val = node.val\n        new_prefix_sum = prefix_sum + current_val\n        new_min_val = min_val\n        new_max_val = max_val\n        \n        if (prefix_sum, suffix_sum, new_min_val, new_max_val, is_valid, current_val) in memo:\n            return memo[(prefix_sum, suffix_sum, new_min_val, new_max_val, is_valid, current_val)]\n        \n        left_count = traverse(node.left, new_prefix_sum, suffix_sum + current_val, new_min_val, max(new_max_val, current_val), False, memo)\n        right_count = traverse(node.right, prefix_sum + current_val, suffix_sum, current_val, max_val, False, memo)\n        \n        if current_val > prefix_sum and current_val < suffix_sum and new_min_val < current_val < new_max_val and is_valid:\n            left_count += traverse(node.left, new_prefix_sum, suffix_sum + current_val, new_min_val, max(new_max_val, current_val), True, memo)\n            right_count += traverse(node.right, prefix_sum + current_val, suffix_sum, current_val, max_val, True, memo)\n        \n        memo[(prefix_sum, suffix_sum, new_min_val, new_max_val, is_valid, current_val)] = left_count + right_count\n        return left_count + right_count\n    \n    return traverse(root, 0, 0, float('-inf'), float('inf'), False, {})",
  "test_code": "from typing import List\nfrom solution import count_valid_sequences\n\ndef build_bst(from_list: List[int]) -> TreeNode:\n    if not from_list:\n        return None\n    import math\n    def build_tree(nodes: List[TreeNode], index: int) -> TreeNode:\n        if index < len(nodes) and nodes[index]:\n            node = nodes[index]\n            left_index = 2 * index + 1\n            right_index = 2 * index + 2\n            node.left = build_tree(nodes, left_index)\n            node.right = build_tree(nodes, right_index)\n            return node\n    nodes = [TreeNode(val) if val is not None else None for val in from_list]\n    return build_tree(nodes, 0)\n\n# Test case\ndef test_count_valid_sequences():\n    root = build_bst([5, 3, 7, 2, 4])\n    assert count_valid_sequences(root) == 3\n\ndef test_count_valid_sequences_with Repeat():\n    # This tree doesn't have the increasing/decreasing subsequence property\n    root = build_bst([8, 5, 9, 4, 7, 10, 11])\n    assert count_valid_sequences(root) == 0\n\ndef test_count_valid_sequences_with_only_leaf():\n    root = build_bst([1])\n    assert count_valid_sequences(root) == 1",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results1.jsonl"
}