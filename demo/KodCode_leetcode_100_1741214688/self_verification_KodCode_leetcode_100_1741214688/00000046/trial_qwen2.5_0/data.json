{
  "metadata": {
    "prompt_id": "00000046",
    "row_id": 46,
    "seed_ids": [
      "2055",
      "565",
      "2581"
    ],
    "mode": "leetcode"
  },
  "instruction": "You are given a binary tree where each node has a unique value. The tree is represented as a list of lists, where each sublist represents a level of the tree. Each element in a sublist is either `None` (indicating a null node) or an integer representing the value of a node. For example:\n\n```python\n[\n    [1],\n    [2, 3],\n    [4, 5, 6, 7]\n]\n```\n\nThis represents a tree with the following structure:\n\n```\n    1\n   / \\\n  2   3\n / \\ / \\\n4  5 6  7\n```\n\nYou are also given a list of **queries** where each query is a 2D integer array `queries[i] = [startValuei, destValuei]`. For each query, you need to find the lowest common ancestor (LCA) of the nodes with values `startValuei` and `destValuei`. The LCA of two nodes is defined as the lowest node that has both nodes in its subtree. If either node does not exist in the tree, return `-1`.\n\nReturn an integer array `answer` where `answer[i]` is the result of the `i-th` query.\n\nFor example, given the tree above and the queries:\n\n```python\nqueries = [[4, 7], [3, 5]]\n```\n\nThe answers would be `[2, 2]`, since the LCA of 4 and 7 is 2, and the LCA of 3 and 5 is also 2.",
  "solution_code": "class TreeNode:\n    def __init__(self, val=None, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree_from_list(lst):\n    if not lst:\n        return None\n    root = TreeNode(lst[0])\n    queue = [root]\n    i, n = 1, len(lst)\n    while i < n:\n        node = queue.pop(0)\n        if i < n:\n            node.left = TreeNode(lst[i]) if lst[i] is not None else None\n            queue.append(node.left)\n            i += 1\n            if i < n and lst[i] is not None:\n                node.right = TreeNode(lst[i])\n                queue.append(node.right)\n                i += 1\n    return root\n\ndef find_node(root, val):\n    if not root:\n        return None\n    if root.val == val:\n        return root\n    left = find_node(root.left, val)\n    if left:\n        return left\n    return find_node(root.right, val)\n\ndef find_lca(root, p, q):\n    if not root:\n        return None\n    if root.val == p.val or root.val == q.val:\n        return root\n    left_lca = find_lca(root.left, p, q)\n    right_lca = find_lca(root.right, p, q)\n    if left_lca and right_lca:\n        return root\n    return left_lca if left_lca else right_lca\n\ndef lca_in_binary_tree(tree_str, queries):\n    tree = build_tree_from_list(tree_str)\n    results = []\n    for p_val, q_val in queries:\n        p_node = find_node(tree, p_val)\n        q_node = find_node(tree, q_val)\n        if not p_node or not q_node:\n            results.append(-1)\n        else:\n            lca_node = find_lca(tree, p_node, q_node)\n            results.append(lca_node.val)\n    return results",
  "test_code": "from solution import build_tree_from_list, find_node, find_lca, lca_in_binary_tree\n\ndef test_tree_construction():\n    tree_str = [\n        [1],\n        [2, 3],\n        [4, 5, 6, 7]\n    ]\n    queries = [[4, 7], [3, 5]]\n    result = lca_in_binary_tree(tree_str, queries)\n    assert result == [2, 2]\n\ndef test_no_node():\n    tree_str = [\n        [1],\n        [2, 3],\n        [4, 5, 6, 7]\n    ]\n    queries = [[4, 8]]\n    result = lca_in_binary_tree(tree_str, queries)\n    assert result == [-1]\n\ndef test_root_lca():\n    tree_str = [\n        [1]\n    ]\n    queries = [[1, 1]]\n    result = lca_in_binary_tree(tree_str, queries)\n    assert result == [1]\n\ndef test_empty_queries():\n    tree_str = [\n        [1],\n        [2, 3],\n        [4, 5, 6, 7]\n    ]\n    queries = []\n    result = lca_in_binary_tree(tree_str, queries)\n    assert result == []\n\ndef test_different_trees():\n    tree_str1 = [\n        [1],\n        [2, 3],\n        [4, 5, 6, 7]\n    ]\n    queries1 = [[4, 7], [3, 5]]\n    result1 = lca_in_binary_tree(tree_str1, queries1)\n    tree_str2 = [\n        [1],\n        [2, 3],\n        [4, 5, 6]\n    ]\n    queries2 = [[4, 5], [3, 6]]\n    result2 = lca_in_binary_tree(tree_str2, queries2)\n    assert result1 == result2",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results0.jsonl"
}