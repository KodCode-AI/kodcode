{
  "metadata": {
    "prompt_id": "00000046",
    "row_id": 46,
    "seed_ids": [
      "2055",
      "565",
      "2581"
    ],
    "mode": "leetcode"
  },
  "instruction": "You are given a binary tree where each node has a unique value. The tree is represented as a list of lists, where each sublist represents a level of the tree. Each element in a sublist is either `None` (indicating a null node) or an integer representing the value of a node. For example:\n\n```python\n[\n    [1],\n    [2, 3],\n    [4, 5, 6, 7]\n]\n```\n\nThis represents a tree with the following structure:\n\n```\n    1\n   / \\\n  2   3\n / \\ / \\\n4  5 6  7\n```\n\nYou are also given a list of **queries** where each query is a 2D integer array `queries[i] = [startValuei, destValuei]`. For each query, you need to find the lowest common ancestor (LCA) of the nodes with values `startValuei` and `destValuei`. The LCA of two nodes is defined as the lowest node that has both nodes in its subtree. If either node does not exist in the tree, return `-1`.\n\nReturn an integer array `answer` where `answer[i]` is the result of the `i-th` query.\n\nFor example, given the tree above and the queries:\n\n```python\nqueries = [[4, 7], [3, 5]]\n```\n\nThe answers would be `[2, 2]`, since the LCA of 4 and 7 is 2, and the LCA of 3 and 5 is also 2.",
  "solution_code": "from collections import defaultdict\n\ndef build_tree(node_values):\n    \"\"\"\n    Builds a tree from the given node_values, where each node has a unique value.\n    :param node_values: List of lists representing the tree.\n    :return: A dictionary where the key is the node value, and the value is the Node object.\n    \"\"\"\n    # Assuming the tree is binary for simplicity, each node has at most two children\n    tree = defaultdict(list)\n    nodes = {value: i for i, value in enumerate(node_values[0]) if value is not None}\n    root = nodes[1]\n\n    for level in node_values[1:]:\n        parent_i = 0\n        for value in level:\n            if value is not None:\n                parent = node_values[parent_i][0] if parent_i in nodes else None\n                child = nodes[value] if value in nodes else None\n                tree[parent].append(child)\n                tree[child].append(parent)\n            parent_i += 1\n\n    return tree, root\n\ndef find_path_from_root(tree, root, value):\n    \"\"\"\n    Finds the path from the root to the node with the given value.\n    :param tree: The tree structure.\n    :param root: The root node value.\n    :param value: The target node value.\n    :return: A list of node values from root to the target node, or None if the node is not found.\n    \"\"\"\n    stack = [(root, [root])]\n    while stack:\n        node, path = stack.pop()\n        if node == value:\n            return path\n        for child in tree[node]:\n            if child in path:\n                continue\n            stack.append((child, path + [child]))\n    return None\n\ndef lowest_common_ancestor(tree, path1, path2):\n    \"\"\"\n    Finds the LCA of two paths.\n    :param tree: The tree structure.\n    :param path1: Path from root to the first node.\n    :param path2: Path from root to the second node.\n    :return: The LCA node value, or -1 if either node does not exist in the tree.\n    \"\"\"\n    for i in range(min(len(path1), len(path2))):\n        if path1[i] != path2[i]:\n            return path1[i-1]\n    return path1[len(path1) - 1] if len(path1) > len(path2) else path2[len(path2) - 1]\n\ndef findLCA(query, node_values):\n    \"\"\"\n    Finds the LCA for each query.\n    :param query: A list of queries.\n    :param node_values: List of lists representing the tree.\n    :return: A list of LCA node values for each query.\n    \"\"\"\n    tree, root = build_tree(node_values)\n    results = []\n    for start, dest in query:\n        if start in tree and dest in tree:\n            path_start = find_path_from_root(tree, root, start)\n            path_dest = find_path_from_root(tree, root, dest)\n            results.append(lowest_common_ancestor(tree, path_start, path_dest))\n        else:\n            results.append(-1)\n    return results",
  "test_code": "def test_findLCA():\n    node_values = [\n        [1],\n        [2, 3],\n        [4, 5, 6, 7]\n    ]\n    queries = [[4, 7], [3, 5]]\n    expected = [2, 2]\n    assert findLCA(queries, node_values) == expected\n\n    node_values = [\n        [1],\n        [2, 3],\n        [4, 5, 6, 7]\n    ]\n    queries = [[8, 9], [3, 4]]\n    expected = [-1, -1]\n    assert findLCA(queries, node_values) == expected\n\n    node_values = [\n        [1]\n    ]\n    queries = [[1, 1]]\n    expected = [1]\n    assert findLCA(queries, node_values) == expected\n\n    node_values = [\n        [1, 2],\n        [3, None, 4, 5]\n    ]\n    queries = [[1, 5], [4, 3]]\n    expected = [1, -1]\n    assert findLCA(queries, node_values) == expected",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results2.jsonl"
}