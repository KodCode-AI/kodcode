{
  "metadata": {
    "prompt_id": "00000046",
    "row_id": 46,
    "seed_ids": [
      "2055",
      "565",
      "2581"
    ],
    "mode": "leetcode"
  },
  "instruction": "You are given a binary tree where each node has a unique value. The tree is represented as a list of lists, where each sublist represents a level of the tree. Each element in a sublist is either `None` (indicating a null node) or an integer representing the value of a node. For example:\n\n```python\n[\n    [1],\n    [2, 3],\n    [4, 5, 6, 7]\n]\n```\n\nThis represents a tree with the following structure:\n\n```\n    1\n   / \\\n  2   3\n / \\ / \\\n4  5 6  7\n```\n\nYou are also given a list of **queries** where each query is a 2D integer array `queries[i] = [startValuei, destValuei]`. For each query, you need to find the lowest common ancestor (LCA) of the nodes with values `startValuei` and `destValuei`. The LCA of two nodes is defined as the lowest node that has both nodes in its subtree. If either node does not exist in the tree, return `-1`.\n\nReturn an integer array `answer` where `answer[i]` is the result of the `i-th` query.\n\nFor example, given the tree above and the queries:\n\n```python\nqueries = [[4, 7], [3, 5]]\n```\n\nThe answers would be `[2, 2]`, since the LCA of 4 and 7 is 2, and the LCA of 3 and 5 is also 2.",
  "solution_code": "from collections import defaultdict, deque\n\ndef build_tree(level_order):\n    if not level_order:\n        return None\n    root = TreeNode(level_order[0][0])\n    parent_dict = defaultdict(TreeNode)\n    parent_dict[None] = None\n    queue = deque([root])\n    for level in level_order[1:]:\n        while queue and len(queue[0].children) == len(level):\n            queue.popleft()\n        while queue:\n            parent = queue[0]\n            for val in level:\n                if val:\n                    node = TreeNode(val)\n                    parent.children.append(node)\n                    parent_dict[val] = parent\n                    if len(parent.children) == len(level):\n                        queue.popleft()\n                        queue.append(node)\n                else:\n                    queue.popleft()\n                    break\n    return root, parent_dict\n\ndef find_node(node, val, parent_dict):\n    if not node or not val in parent_dict:\n        return None\n    if node.val == val:\n        return node\n    for child in node.children:\n        found = find_node(child, val, parent_dict)\n        if found:\n            return found\n    return None\n\ndef lowest_common_ancestor(root, p, q, parent_dict):\n    if not root or not p or not q:\n        return -1\n    if p.val == q.val:\n        return p.val\n    path_p = set()\n    while p:\n        path_p.add(p.val)\n        p = parent_dict[p.val]\n    while q:\n        if q.val in path_p:\n            return q.val\n        q = parent_dict[q.val]\n    return -1\n\ndef find_lca_in_tree(level_order, queries):\n    root, parent_dict = build_tree(level_order)\n    answers = []\n    for query in queries:\n        p = find_node(root, query[0], parent_dict)\n        q = find_node(root, query[1], parent_dict)\n        if not p or not q:\n            answers.append(-1)\n        else:\n            answers.append(lowest_common_ancestor(root, p, q, parent_dict))\n    return answers\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\n# Example:\nlevel_order = [\n    [1],\n    [2, 3],\n    [4, 5, 6, 7]\n]\nqueries = [[4, 7], [3, 5]]\n\nprint(find_lca_in_tree(level_order, queries))",
  "test_code": "from solution import find_lca_in_tree, TreeNode\n\ndef test_find_lca_in_tree():\n    level_order = [\n        [1],\n        [2, 3],\n        [4, 5, 6, 7]\n    ]\n    queries = [[4, 7], [3, 5]]\n    assert find_lca_in_tree(level_order, queries) == [2, 2]\n\n    level_order = [\n        [1],\n        [2, 3],\n        [4, 5, 6, 7]\n    ]\n    queries = [[1, 3], [1, 5], [1, 7]]\n    assert find_lca_in_tree(level_order, queries) == [1, 1, 1]\n\n    level_order = [\n        [1],\n        [2, 3],\n        [4, 5, 6, 7]\n    ]\n    queries = [[4, 4], [5, 5]]\n    assert find_lca_in_tree(level_order, queries) == [4, 5]\n\n    level_order = [[1]]\n    queries = [[1, 1]]\n    assert find_lca_in_tree(level_order, queries) == [1]\n\n    level_order = [\n        [1],\n        [2, 3],\n        [4, 5, 6, 7]\n    ]\n    queries = [[8, 9]]\n    assert find_lca_in_tree(level_order, queries) == [-1]\n\ntest_find_lca_in_tree()",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results1.jsonl"
}