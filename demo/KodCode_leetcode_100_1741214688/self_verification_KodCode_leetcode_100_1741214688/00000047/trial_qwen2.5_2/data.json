{
  "metadata": {
    "prompt_id": "00000047",
    "row_id": 47,
    "seed_ids": [
      "952",
      "222",
      "232"
    ],
    "mode": "leetcode"
  },
  "instruction": "Design a class `MyStack` to implement a last in first out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `pop`, `top`, and `empty`). Implement the `MyStack` class:\n\n*   `void push(int x)` Pushes element x to the top of the stack.\n*   `int pop()` Removes the element from the top of the stack and returns it.\n*   `int top()` Returns the element at the top of the stack.\n*   `boolean empty()` Returns `true` if the stack is empty, `false` otherwise.\n\n**Notes:** \n\n*   You must use **only** standard operations of a queue, which means only `enqueue`, `deque`, `size`, and `is empty` operations are valid.\n*   Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.",
  "solution_code": "from collections import deque\n\nclass MyStack:\n    \"\"\"\n    Implements a stack using two queues.\n    \"\"\"\n    def __init__(self):\n        self.queue1 = deque()\n        self.queue2 = deque()\n    \n    def push(self, x: int) -> None:\n        \"\"\"\n        Pushes element x to the top of the stack.\n        \"\"\"\n        # Always enqueue to queue2\n        self.queue2.append(x)\n        # Swap the queues\n        self.queue1, self.queue2 = self.queue2, self.queue1\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from the top of the stack and returns it.\n        \"\"\"\n        # Ensure queue1 has at least one element\n        if self.empty():\n            raise IndexError(\"pop from an empty stack\")\n        # Pop from queue1 which now represents the top of the stack.\n        return self.queue1.popleft()\n\n    def top(self) -> int:\n        \"\"\"\n        Returns the element at the top of the stack.\n        \"\"\"\n        if self.empty():\n            raise IndexError(\"top from an empty stack\")\n        # Return the first element of queue1 which is the top of the stack.\n        return self.queue1[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns true if the stack is empty, false otherwise.\n        \"\"\"\n        return not self.queue1",
  "test_code": "def test_my_stack():\n    stack = MyStack()\n\n    # Test push\n    stack.push(1)\n    stack.push(2)\n    assert stack.top() == 2  # top() should return 2\n    assert stack.pop() == 2  # pop() should return 2\n\n    # Test multiple operations\n    stack.push(3)\n    assert stack.top() == 3  # top() should return 3\n    assert stack.pop() == 3  # pop() should return 3\n    assert stack.pop() == 1  # pop() should return 1\n\n    # Test empty stack\n    assert stack.empty() == True  # empty() should return True\n\n    # Test after all operations\n    stack.push(4)\n    assert stack.top() == 4  # top() should return 4\n    assert stack.pop() == 4  # pop() should return 4\n    assert stack.empty() == True  # empty() should return True\n\n    # Test empty stack again\n    stack.push(5)\n    assert stack.top() == 5  # top() should return 5\n    assert stack.pop() == 5  # pop() should return 5\n    assert stack.empty() == True  # empty() should return True\n\n    # Test pop from empty stack\n    stack.push(6)\n    assert stack.top() == 6  # top() should return 6\n    assert stack.pop() == 6  # pop() should return 6\n    try:\n        stack.pop()  # This should raise an error\n    except IndexError:\n        pass\n    else:\n        assert False, \"Expected IndexError for pop from an empty stack\"\n\n    try:\n        stack.top()  # This should raise an error\n    except IndexError:\n        pass\n    else:\n        assert False, \"Expected IndexError for top from an empty stack\"",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results2.jsonl"
}