{
  "metadata": {
    "prompt_id": "00000057",
    "row_id": 57,
    "seed_ids": [
      "2285",
      "637",
      "848"
    ],
    "mode": "leetcode"
  },
  "instruction": "You are given a string `s` consisting of lowercase English letters. You are also given an integer `k`. You can perform the following operation on the string any number of times:\n\n- Pick any substring of length `k` from `s` and reverse it.\n\nYour task is to determine the lexicographically smallest string that can be obtained after performing the above operation any number of times. Return the resulting string.\n\nExample:\n- If `s = \"cbaebabacd\"` and `k = 3`, you can reverse the substring `\"bac\"` to get `\"cbabcabad\"`. Reversing `\"bac\"` again gives `\"cbabcabad\"` which is the lexicographically smallest string possible. So, the answer is `\"abcabad\"`.",
  "solution_code": "def lexicographically_smallest_string(s: str, k: int) -> str:\n    \"\"\"\n    Returns the lexicographically smallest string that can be obtained by reversing any substring of length k.\n    \"\"\"\n    n = len(s)\n    if k >= n:\n        return ''.join(sorted(s))\n    \n    # Precompute the first character and the lexicographically smallest character\n    # that follows each position in the string.\n    first_chars = [s[0]] * n\n    smallest_after = [s[0]] * n\n    for i in range(1, n):\n        first_chars[i] = min(first_chars[i-1], s[i])\n        smallest_after[i] = min(smallest_after[i-1], s[i] if i < k else s[i-k])\n\n    result = list(s)\n\n    i = n - k\n    while i >= 0:\n        if s[i] > smallest_after[i]:\n            # Find the lexicographically smallest character in the range [i, i+k-1] that is strictly greater than the current character\n            j = i\n            while j < i + k and s[j] <= s[i]:\n                j += 1\n            # Swap the found character to position i\n            result[i], result[j] = result[j], result[i]\n            # Reverse the substring to get the smallest lexicographical order\n            result[i+1:i+k+1] = reversed(result[i+1:i+k+1])\n        elif s[i] > first_chars[i]:\n            # Swap the current character with the smallest character in the range [i, i+k-1] that is strictly greater than the first character of the range\n            j = i\n            while j < i + k and s[j] == s[i]:\n                j += 1\n            # Only swap if a different character is found\n            if j < i + k and s[j] > first_chars[i]:\n                result[i], result[j] = result[j], result[i]\n                break\n        i -= 1\n\n    return ''.join(result)",
  "test_code": "import pytest\n\ndef test_lexicographically_smallest_string():\n    assert lexicographically_smallest_string(\"cbaebabacd\", 3) == \"abcabad\"\n    assert lexicographically_smallest_string(\"edcba\", 3) == \"cbaed\"\n    assert lexicographically_smallest_string(\"aaa\", 1) == \"aaa\"\n    assert lexicographically_smallest_string(\"baaca\", 3) == \"aaabc\"\n    assert lexicographically_smallest_string(\"abab\", 2) == \"aaba\"\n\ndef test_edge_cases():\n    assert lexicographically_smallest_string(\"a\", 1) == \"a\"\n    assert lexicographically_smallest_string(\"aa\", 2) == \"aa\"\n    assert lexicographically_smallest_string(\"z\", 1) == \"z\"\n    assert lexicographically_smallest_string(\"zg\", 2) == \"gz\"\n    assert lexicographically_smallest_string(\"zzzzz\", 5) == \"zzzzz\"\n\ndef test_non_decreasing_k():\n    assert lexicographically_smallest_string(\"abc\", 1) == \"abc\"\n    assert lexicographically_smallest_string(\"abc\", 2) == \"acb\"\n    assert lexicographically_smallest_string(\"abc\", 3) == \"abc\"",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results2.jsonl"
}