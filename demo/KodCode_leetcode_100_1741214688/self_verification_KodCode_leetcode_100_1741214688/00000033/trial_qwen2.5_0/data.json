{
  "metadata": {
    "prompt_id": "00000033",
    "row_id": 33,
    "seed_ids": [
      "135",
      "2357",
      "1719"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a matrix `grid` of size `m x n` containing only `0`s and `1`s, where `1` represents land and `0` represents water, a **landlocked area** is a region of land completely surrounded by water, with no connection to the boundary of the grid. You are allowed to fill any number of `0`s (turning them into `1`s) to form additional land. The goal is to connect at least one landlocked area to the boundary to make it non-landlocked. Return the minimum number of `0`s you need to flip to achieve this. If it is impossible to make any landlocked area non-landlocked, return `-1`.\n\n**Example 1:**\n\nInput: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n\nOutput: 2\n\nExplanation: We can flip two `0`s at positions (1, 1) and (2, 2) to make the landlocked area non-landlocked.\n\n**Example 2:**\n\nInput: grid = [[0,0,0],[0,1,1],[0,1,0]]\n\nOutput: -1\n\nExplanation: It is impossible to make any landlocked area non-landlocked.",
  "solution_code": "def min_flips(grid):\n    \"\"\"\n    Returns the minimum number of flips required to make at least one landlocked area non-landlocked.\n    If it's impossible, returns -1.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    # Helper function to perform a flood fill\n    def flood_fill(x, y, prev_value):\n        if 0 <= x < m and 0 <= y < n and grid[x][y] == prev_value:\n            grid[x][y] = 2  # Mark as visited\n            flood_fill(x + 1, y, prev_value)\n            flood_fill(x - 1, y, prev_value)\n            flood_fill(x, y + 1, prev_value)\n            flood_fill(x, y - 1, prev_value)\n    \n    def is_landlocked():\n        for i in range(1, m - 1):\n            for j in range(1, n - 1):\n                if grid[i][j] == 1 and all(grid[x][y] != 0 for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1))):\n                    return (i, j)\n        return None\n    \n    flips = 0\n    landlocked = is_landlocked()\n    \n    while landlocked:\n        x, y = landlocked\n        flood_fill(x, y, 0)\n        grid[x][y] = 1\n        flips += 1\n        landlocked = is_landlocked()\n    \n    # Check if all land is connected to the boundary\n    def is_connected():\n        visited = set()\n        \n        def dfs(x, y):\n            if (x, y) in visited:\n                return\n            visited.add((x, y))\n            if x == 0 or y == 0 or x == m - 1 or y == n - 1:\n                return True\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                if 0 <= x + dx < m and 0 <= y + dy < n and grid[x + dx][y + dy] == 1:\n                    if dfs(x + dx, y + dy):\n                        return True\n            return False\n        \n        for i in range(1, m - 1):\n            for j in range(1, n - 1):\n                if grid[i][j] == 1 and (i, j) not in visited:\n                    if not dfs(i, j):\n                        return -1\n        return flips\n    \n    return is_connected()",
  "test_code": "from solution import min_flips\n\ndef test_min_flips():\n    assert min_flips([[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]) == 2\n    assert min_flips([[0,0,0],[0,1,1],[0,1,0]]) == -1\n    assert min_flips([[1,0,0],[0,0,0],[0,0,0]]) == 0\n    assert min_flips([[0,0,0,0],[0,0,0,0],[0,0,1,0],[0,0,0,0]]) == 1\n    assert min_flips([[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,0,0,0]]) == -1\n    assert min_flips([[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,1,0]]) == 0\n    assert min_flips([[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]) == 0",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results0.jsonl"
}