{
  "metadata": {
    "prompt_id": "00000092",
    "row_id": 92,
    "seed_ids": [
      "1298",
      "2511",
      "1926"
    ],
    "mode": "leetcode"
  },
  "instruction": "You are given a 2D grid representing a map of islands and water. The grid contains the following characters:\n- `'W'` for water (you cannot move through water).\n- `'L'` for land (you can move through land).\n- `'S'` for start (your starting position, guaranteed to be on land).\n\nYou can move up, down, left, or right from any land cell to an adjacent land cell. The goal is to find the shortest path from the start position to any border cell (a cell on the edge of the grid) that is also land. You cannot move diagonally. If there is no such path, return `-1`.\n\nReturn the number of steps in the shortest path, or `-1` if no such path exists.",
  "solution_code": "from collections import deque\n\ndef shortest_border_path(grid):\n    \"\"\"\n    Returns the shortest path from 'S' to any border land cell, or -1 if no such path exists.\n    \"\"\"\n    if not grid or not grid[0]:\n        return -1\n    \n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = set()\n    \n    start = None\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 'S':\n                start = (r, c)\n            elif grid[r][c] == 'W':\n                grid[r][c] = '#'\n    \n    queue = deque([(start, 0)])\n    visited.add(start)\n    \n    while queue:\n        (r, c), steps = queue.popleft()\n        if r in [0, rows-1] or c in [0, cols-1]:\n            return steps\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != '#' and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                queue.append(((nr, nc), steps + 1))\n                \n    return -1",
  "test_code": "import pytest\n\ndef test_shortest_border_path():\n    grid1 = ['S#L', 'LLL', 'LWL']\n    assert shortest_border_path(grid1) == 1\n\n    grid2 = ['W', 'L', 'L', 'L']\n    assert shortest_border_path(grid2) == -1\n\n    grid3 = ['L', 'L', 'L', 'S']\n    assert shortest_border_path(grid3) == 0\n\n    grid4 = ['SWL', 'LWL', 'LWL']\n    assert shortest_border_path(grid4) == 1\n\n    grid5 = ['LWL', 'SLL', 'WLW', 'WWW']\n    assert shortest_border_path(grid5) == 2\n\n    grid6 = ['W']\n    assert shortest_border_path(grid6) == -1\n\n    grid7 = ['S']\n    assert shortest_border_path(grid7) == 0\n\n    grid8 = ['L', 'S', 'L', 'L', 'L', 'L']\n    assert shortest_border_path(grid8) == 1\n\n    grid9 = ['L', 'L', 'L', 'L', 'L', 'S']\n    assert shortest_border_path(grid9) == 0\n\n    grid10 = ['L', 'S', 'L', 'L', 'L', 'L']\n    assert shortest_border_path(grid10) == 1\n\n    grid11 = ['L', 'L', 'L', 'L', 'L', 'L', 'S']\n    assert shortest_border_path(grid11) == 0\n\n    grid12 = ['L', 'S', 'L', 'L']\n    assert shortest_border_path(grid12) == 1\n\n    grid13 = ['S', 'L', 'L', 'L']\n    assert shortest_border_path(grid13) == 0\n\n    grid14 = ['L', 'L', 'L', 'S']\n    assert shortest_border_path(grid14) == 1\n\n    grid15 = ['S', 'S', 'S', 'S']\n    assert shortest_border_path(grid15) == -1\n\n    grid16 = ['L', 'L', 'L', 'L', 'L', 'L', 'S', 'L', 'L', 'L']\n    assert shortest_border_path(grid16) == 3\n\n    grid17 = ['L', 'L', 'L', 'L', 'L', 'L', 'S', 'L', 'L', 'L', 'L']\n    assert shortest_border_path(grid17) == 2\n\n    grid18 = ['S', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L']\n    assert shortest_border_path(grid18) == 0\n\n    grid19 = ['L', 'L', 'L', 'S', 'L', 'L', 'L', 'L', 'L', 'L']\n    assert shortest_border_path(grid19) == 1\n\n    grid20 = ['L', 'L', 'L', 'L', 'L', 'L', 'S', 'L', 'L', 'L', 'L', 'L']\n    assert shortest_border_path(grid20) == 3",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results2.jsonl"
}