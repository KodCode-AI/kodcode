{
  "metadata": {
    "prompt_id": "00000077",
    "row_id": 77,
    "seed_ids": [
      "1766",
      "2042",
      "2588"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a binary tree with `n` nodes labeled from `0` to `n-1`, where each node has a value associated with it, represented by an array `values`, and a 2D array `edges` that defines the tree's structure, you are tasked with finding the node that, when removed, results in the maximum number of connected components in the tree, where the values of the nodes in each component are coprime. If there are multiple nodes that result in the same maximum number of components, return the one with the smallest label.\n\nFormally, you need to:\n\n- Remove one node from the tree and determine the number of connected components that are formed.\n- Each component must consist of nodes whose values are coprime.\n- Return the label of the node that maximizes the number of such components. If there are multiple such nodes, return the one with the smallest label. If no such node exists, return `-1`.\n\nExample:\n```python\nvalues = [2, 3, 6, 9, 10]\nedges = [[0, 1], [1, 2], [1, 3], [3, 4]]\n```\nIn this example, removing node `1` results in two connected components where all nodes in each component are coprime: `[2]` and `[6, 9, 10]`. Thus, the answer is `1`.",
  "solution_code": "from collections import defaultdict\nfrom math import gcd\n\ndef are_coprime(a, b):\n    return gcd(a, b) == 1\n\ndef find_max_coprime_components(values, edges):\n    \"\"\"\n    Returns the node that, when removed, results in the maximum number of connected components with coprime values.\n    \"\"\"\n    if not values or not edges:\n        return -1\n    \n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        subtree_values = {values[node]}\n        for child in graph[node]:\n            if child != parent:\n                subtree_values.add(values[child])\n                subtree_values |= dfs(child, node)\n        return subtree_values\n    \n    n = len(values)\n    node_tuple = [(-1, -1)] * n\n    for i in range(n):\n        subtree = dfs(i, -1)\n        coprime_pairs = sum(1 for x in subtree for y in subtree if x != y and are_coprime(x, y))\n        node_tuple[i] = (coprime_pairs, i)\n    \n    node_tuple.sort(reverse=True)\n    return node_tuple[0][1] if node_tuple[0][0] > 0 else -1",
  "test_code": "from solution import find_max_coprime_components\n\ndef test_find_max_coprime_components():\n    assert find_max_coprime_components([2, 3, 6, 9, 10], [[0, 1], [1, 2], [1, 3], [3, 4]]) == 1\n    assert find_max_coprime_components([7], []) == -1\n    assert find_max_coprime_components([2, 3, 7, 6], [[0, 1], [0, 2], [1, 3]]) == 0\n    assert find_max_coprime_components([2, 3, 6, 9, 10], [[0, 1], [1, 2], [1, 3], [3, 4]]) == 1\n    assert find_max_coprime_components([2, 3, 6, 9, 10], [[0, 1], [0, 2], [0, 3], [0, 4]]) == 0\n    assert find_max_coprime_components([2, 3, 6, 9, 10], [[0, 1], [1, 2], [2, 3], [3, 4]]) == 3\n\ndef gcd(x, y):\n    \"\"\"Compute the greatest common divisor of x and y.\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\nif gcd(2, 3) != 1 or gcd(3, 6) != 3:\n    raise ValueError(\"GCD function is incorrect\")",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results1.jsonl"
}