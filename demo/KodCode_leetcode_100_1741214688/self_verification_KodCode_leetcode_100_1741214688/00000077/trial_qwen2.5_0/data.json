{
  "metadata": {
    "prompt_id": "00000077",
    "row_id": 77,
    "seed_ids": [
      "1766",
      "2042",
      "2588"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a binary tree with `n` nodes labeled from `0` to `n-1`, where each node has a value associated with it, represented by an array `values`, and a 2D array `edges` that defines the tree's structure, you are tasked with finding the node that, when removed, results in the maximum number of connected components in the tree, where the values of the nodes in each component are coprime. If there are multiple nodes that result in the same maximum number of components, return the one with the smallest label.\n\nFormally, you need to:\n\n- Remove one node from the tree and determine the number of connected components that are formed.\n- Each component must consist of nodes whose values are coprime.\n- Return the label of the node that maximizes the number of such components. If there are multiple such nodes, return the one with the smallest label. If no such node exists, return `-1`.\n\nExample:\n```python\nvalues = [2, 3, 6, 9, 10]\nedges = [[0, 1], [1, 2], [1, 3], [3, 4]]\n```\nIn this example, removing node `1` results in two connected components where all nodes in each component are coprime: `[2]` and `[6, 9, 10]`. Thus, the answer is `1`.",
  "solution_code": "from math import gcd\nfrom collections import defaultdict\n\ndef is_coprime(a, b):\n    return gcd(a, b) == 1\n\ndef dfs(tree, values, node, parent):\n    children = tree[node].difference({parent})\n    coprime_count = 1 if is_coprime(values[node], values[parent]) else 0\n    coprime_children = coprime_count\n    for child in children:\n        coprime_children_, coprime_count_ = dfs(tree, values, child, node)\n        coprime_children += coprime_children_\n        coprime_count += coprime_count_\n    return coprime_children, coprime_count\n\ndef max_coprime_components(edges, values, remove_node=None):\n    n = len(values)\n    tree = defaultdict(set)\n    for u, v in edges:\n        tree[u].add(v)\n        tree[v].add(u)\n    \n    if remove_node is None:\n        max_comp, max_count = 0, 0\n        for i in range(n):\n            coprime_children, coprime_count = dfs(tree, values, i, -1)\n            if coprime_count > max_count or (coprime_count == max_count and i < max_comp):\n                max_comp, max_count = i, coprime_count\n        return max_comp if max_count > 0 else -1\n    else:\n        coprime_children, coprime_count = dfs(tree, values, remove_node, -1)\n        return coprime_count\n\ndef find_node_for_max_components(values, edges):\n    return max_coprime_components(edges, values)",
  "test_code": "import pytest\nfrom solution import find_node_for_max_components\n\ndef test_empty_tree():\n    assert find_node_for_max_components([], []) == -1\n\ndef test_single_node():\n    assert find_node_for_max_components([1], []) == -1\n\ndef test_coprime_case1():\n    values = [2, 3, 6, 9, 10]\n    edges = [(0, 1), (1, 2), (1, 3), (3, 4)]\n    assert find_node_for_max_components(values, edges) == 1\n\ndef test_non_coprime_case1():\n    values = [4, 5, 6, 7, 8]\n    edges = [(0, 1), (1, 2), (2, 3), (3, 4)]\n    assert find_node_for_max_components(values, edges) == 3\n\ndef test_no_optimal_node():\n    values = [2, 4, 6, 8, 10]\n    edges = [(0, 1), (1, 2), (2, 3), (3, 4)]\n    assert find_node_for_max_components(values, edges) == -1",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results0.jsonl"
}