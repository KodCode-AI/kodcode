{
  "metadata": {
    "prompt_id": "00000077",
    "row_id": 77,
    "seed_ids": [
      "1766",
      "2042",
      "2588"
    ],
    "mode": "leetcode"
  },
  "instruction": "Given a binary tree with `n` nodes labeled from `0` to `n-1`, where each node has a value associated with it, represented by an array `values`, and a 2D array `edges` that defines the tree's structure, you are tasked with finding the node that, when removed, results in the maximum number of connected components in the tree, where the values of the nodes in each component are coprime. If there are multiple nodes that result in the same maximum number of components, return the one with the smallest label.\n\nFormally, you need to:\n\n- Remove one node from the tree and determine the number of connected components that are formed.\n- Each component must consist of nodes whose values are coprime.\n- Return the label of the node that maximizes the number of such components. If there are multiple such nodes, return the one with the smallest label. If no such node exists, return `-1`.\n\nExample:\n```python\nvalues = [2, 3, 6, 9, 10]\nedges = [[0, 1], [1, 2], [1, 3], [3, 4]]\n```\nIn this example, removing node `1` results in two connected components where all nodes in each component are coprime: `[2]` and `[6, 9, 10]`. Thus, the answer is `1`.",
  "solution_code": "from collections import defaultdict\nfrom math import gcd\nfrom typing import List\n\ndef max_coprime_components(values: List[int], edges: List[List[int]]) -> int:\n    \"\"\"\n    Finds the node whose removal leads to the maximum number of coprime components.\n    \"\"\"\n    n = len(values)\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Helper function to find the resulting components.\n    def dfs(node: int, parent: int) -> List[List[int]]:\n        result = [[node]]\n        for child in tree[node]:\n            if child != parent:\n                for comp in dfs(child, node):\n                    if any(gcd(values[node], values[x]) != 1 for x in comp):\n                        # If the values are not coprime, only add the current node\n                        result.append([node])\n                    else:\n                        # Otherwise, merge the component with the current node\n                        result[-1].extend(comp)\n        return result\n    \n    max_components = 0\n    result_node = -1\n    \n    for node in range(n):\n        components = dfs(node, -1)\n        count = len(components)\n        if count > max_components or (count == max_components and node < result_node):\n            max_components, result_node = count, node\n    \n    return result_node",
  "test_code": "def test_max_coprime_components():\n    values = [2, 3, 6, 9, 10]\n    edges = [[0, 1], [1, 2], [1, 3], [3, 4]]\n    assert max_coprime_components(values, edges) == 1\n\n    values = [4, 6, 15, 35]\n    edges = [[0, 1], [0, 2], [1, 3]]\n    assert max_coprime_components(values, edges) == 2\n\n    values = [2, 2, 2, 2]\n    edges = [[0, 1], [0, 2], [0, 3]]\n    assert max_coprime_components(values, edges) == -1\n\n    values = [2, 3, 5]\n    edges = [[0, 1], [0, 2]]\n    assert max_coprime_components(values, edges) == -1\n\ntest_max_coprime_components()",
  "file_source": "KodCode_questions2sv_leetcode_100_1741214688_sanitized_prepared_results2.jsonl"
}