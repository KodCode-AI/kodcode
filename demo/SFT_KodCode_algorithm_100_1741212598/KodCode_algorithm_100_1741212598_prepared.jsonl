{"messages": [{"role": "user", "content": "Design a function `interleave_strings` that takes two strings `first_str` and `second_str` and returns a new string where the characters from `first_str` and `second_str` are interleaved. If one string is longer, the extra characters should be appended to the end of the result string.\n\n**Function Signature**: `def interleave_strings(first_str: str, second_str: str) -> str:`\n\n**Input**:\n- `first_str` (1 <= len(first_str) <= 10^5): A string consisting of lowercase English letters.\n- `second_str` (1 <= len(second_str) <= 10^5): A string consisting of lowercase English letters.\n\n**Output**:\n- Return a single string that is the result of interleaving `first_str` and `second_str`.\n\n**Examples**:\n```python\n>>> interleave_strings(\"ABCD\", \"XY\")\n'AXBYCD'\n>>> interleave_strings(\"XY\", \"ABCD\")\n'XAYBCD'\n>>> interleave_strings(\"AB\", \"XYZ\")\n'AXBYZ'\n>>> interleave_strings(\"ABC\", \"\")\n'ABC'\n```\n\n**Constraints**:\n- The input strings contain only lowercase English letters.\n- The lengths of the input strings are between 1 and 10^5.\n\n**Performance Requirement**:\n- The function should handle the largest input size (10^5 characters) within 1 second."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000003_I", "question": "Design a function `interleave_strings` that takes two strings `first_str` and `second_str` and returns a new string where the characters from `first_str` and `second_str` are interleaved. If one string is longer, the extra characters should be appended to the end of the result string.\n\n**Function Signature**: `def interleave_strings(first_str: str, second_str: str) -> str:`\n\n**Input**:\n- `first_str` (1 <= len(first_str) <= 10^5): A string consisting of lowercase English letters.\n- `second_str` (1 <= len(second_str) <= 10^5): A string consisting of lowercase English letters.\n\n**Output**:\n- Return a single string that is the result of interleaving `first_str` and `second_str`.\n\n**Examples**:\n```python\n>>> interleave_strings(\"ABCD\", \"XY\")\n'AXBYCD'\n>>> interleave_strings(\"XY\", \"ABCD\")\n'XAYBCD'\n>>> interleave_strings(\"AB\", \"XYZ\")\n'AXBYZ'\n>>> interleave_strings(\"ABC\", \"\")\n'ABC'\n```\n\n**Constraints**:\n- The input strings contain only lowercase English letters.\n- The lengths of the input strings are between 1 and 10^5.\n\n**Performance Requirement**:\n- The function should handle the largest input size (10^5 characters) within 1 second.", "solution": "def interleave_strings(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Interleave the characters from two strings and return the result.\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(first_str) and j < len(second_str):\n        result.append(first_str[i])\n        result.append(second_str[j])\n        i += 1\n        j += 1\n    # Append remaining characters from first_str if any\n    result.extend(first_str[i:])\n    # Append remaining characters from second_str if any\n    result.extend(second_str[j:])\n    return ''.join(result)", "test_code": "from solution import interleave_strings\n\ndef test_interleave_strings():\n    assert interleave_strings(\"ABCD\", \"XY\") == \"AXBYCD\"\n    assert interleave_strings(\"XY\", \"ABCD\") == \"XAYBCD\"\n    assert interleave_strings(\"AB\", \"XYZ\") == \"AXBYZ\"\n    assert interleave_strings(\"ABC\", \"\") == \"ABC\"\n    assert interleave_strings(\"\", \"XYZ\") == \"XYZ\"\n    assert interleave_strings(\"a\" * 100000, \"b\" * 100000) == \"ab\" * 100000\n    assert interleave_strings(\"a\" * 100000, \"\") == \"a\" * 100000\n    assert interleave_strings(\"\", \"b\" * 100000) == \"b\" * 100000\n\ndef test_performance():\n    from timeit import timeit\n    # Check if the function can handle large input within 1 second\n    large_input = \"a\" * 100000\n    assert timeit(lambda: interleave_strings(large_input, large_input), number=1) < 1", "test_info": [{"function_name": "interleave_strings", "parameter_list": "(first_str, second_str)", "function_declaration": "def interleave_strings(first_str, second_str):", "docstring": "Interleave the characters from two strings and return the result."}], "gpt_pass_sequence": [1, 0, 0], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000003", "row_id": 3, "seed_ids": [289], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "You are given a Python function `integer_square_root` that calculates the integer square root of a non-negative integer using a binary search approach. Your task is to implement a more efficient version of this function. Specifically, you need to optimize the current implementation to reduce the number of iterations in the binary search while handling edge cases properly.\n\n**Function Signature**:\n```python\ndef optimized_integer_square_root(num: int) -> int:\n    pass\n```\n\n**Requirements**:\n- The function must handle non-negative integers as input and raise a `ValueError` if the input is negative.\n- The function should return the integer square root of `num` rounded down to the nearest integer.\n- The optimized version should have a time complexity of \\(O(\\log(n))\\) and use \\(O(1)\\) space complexity.\n- Implement an early return for perfect squares and optimize the bounds checking in the binary search.\n\n**Test Cases**:\n```python\nassert optimized_integer_square_root(15) == 3\nassert optimized_integer_square_root(31) == 5\nassert optimized_integer_square_root(25) == 5\nassert optimized_integer_square_root(1) == 1\nassert optimized_integer_square_root(0) == 0\nassert optimized_integer_square_root(2_147_483_647) == 46340\nassert optimized_integer_square_root(-1) is None  # Should raise ValueError\n```\n\n**Note**:\nEnsure that the edge cases and performance are handled correctly. Optimize the bounds checking and early returns to improve the efficiency of the function."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000004_I", "question": "You are given a Python function `integer_square_root` that calculates the integer square root of a non-negative integer using a binary search approach. Your task is to implement a more efficient version of this function. Specifically, you need to optimize the current implementation to reduce the number of iterations in the binary search while handling edge cases properly.\n\n**Function Signature**:\n```python\ndef optimized_integer_square_root(num: int) -> int:\n    pass\n```\n\n**Requirements**:\n- The function must handle non-negative integers as input and raise a `ValueError` if the input is negative.\n- The function should return the integer square root of `num` rounded down to the nearest integer.\n- The optimized version should have a time complexity of \\(O(\\log(n))\\) and use \\(O(1)\\) space complexity.\n- Implement an early return for perfect squares and optimize the bounds checking in the binary search.\n\n**Test Cases**:\n```python\nassert optimized_integer_square_root(15) == 3\nassert optimized_integer_square_root(31) == 5\nassert optimized_integer_square_root(25) == 5\nassert optimized_integer_square_root(1) == 1\nassert optimized_integer_square_root(0) == 0\nassert optimized_integer_square_root(2_147_483_647) == 46340\nassert optimized_integer_square_root(-1) is None  # Should raise ValueError\n```\n\n**Note**:\nEnsure that the edge cases and performance are handled correctly. Optimize the bounds checking and early returns to improve the efficiency of the function.", "solution": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"\n    Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid\n        else:\n            upper_bound = mid - 1\n    \n    return result", "test_code": "import pytest\n\ndef test_optimized_integer_square_root():\n    assert optimized_integer_square_root(15) == 3\n    assert optimized_integer_square_root(31) == 5\n    assert optimized_integer_square_root(25) == 5\n    assert optimized_integer_square_root(1) == 1\n    assert optimized_integer_square_root(0) == 0\n    assert optimized_integer_square_root(2_147_483_647) == 46340\n    with pytest.raises(ValueError):\n        optimized_integer_square_root(-1)", "test_info": [{"function_name": "optimized_integer_square_root", "parameter_list": "(num)", "function_declaration": "def optimized_integer_square_root(num):", "docstring": "Returns the integer square root of a non-negative integer num.\nRaises ValueError for negative inputs."}], "gpt_pass_sequence": [1, 1, 1], "gpt_pass_trial_num": 3, "gpt_difficulty": "easy", "gpt_pass_percentage": 1.0, "metadata": {"prompt_id": "00000004", "row_id": 4, "seed_ids": [691], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "### Scenario\n\nYou are given a sorted list of integers and a target sum. Your task is to implement a function that finds the indices of the two numbers in the list that add up to the target sum using the two-pointer technique.\n\n### Requirements\n\n- **Function Name**: `two_sum_indices`\n- **Input**:\n  - A list of integers, `nums`, which is sorted in non-decreasing order.\n  - An integer, `target`, representing the target sum.\n- **Output**:\n  - Return a list of two integers, representing the indices of the two numbers in `nums` that add up to `target`. If no such pair exists, return an empty list.\n\n### Constraints\n\n- The length of `nums` will be in the range \\([2, 10^4]\\).\n- The elements of `nums` will be in the range \\([-10^9, 10^9]\\).\n- There will be exactly one solution, and you may not use the same element twice.\n- `nums` is sorted in non-decreasing order.\n\n### Example\n\n```python\ndef test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()\n```\n\n### Performance Requirements\n\nThe function should run efficiently, with a time complexity of \\(O(n)\\) and a space complexity of \\(O(1)\\).\n\n### Question\n\nImplement the `two_sum_indices` function."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000005_I", "question": "### Scenario\n\nYou are given a sorted list of integers and a target sum. Your task is to implement a function that finds the indices of the two numbers in the list that add up to the target sum using the two-pointer technique.\n\n### Requirements\n\n- **Function Name**: `two_sum_indices`\n- **Input**:\n  - A list of integers, `nums`, which is sorted in non-decreasing order.\n  - An integer, `target`, representing the target sum.\n- **Output**:\n  - Return a list of two integers, representing the indices of the two numbers in `nums` that add up to `target`. If no such pair exists, return an empty list.\n\n### Constraints\n\n- The length of `nums` will be in the range \\([2, 10^4]\\).\n- The elements of `nums` will be in the range \\([-10^9, 10^9]\\).\n- There will be exactly one solution, and you may not use the same element twice.\n- `nums` is sorted in non-decreasing order.\n\n### Example\n\n```python\ndef test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()\n```\n\n### Performance Requirements\n\nThe function should run efficiently, with a time complexity of \\(O(n)\\) and a space complexity of \\(O(1)\\).\n\n### Question\n\nImplement the `two_sum_indices` function.", "solution": "def two_sum_indices(nums, target):\n    \"\"\"\n    Returns the indices of the two numbers in nums that add up to target.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "test_code": "def test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()", "test_info": [{"function_name": "two_sum_indices", "parameter_list": "(nums, target)", "function_declaration": "def two_sum_indices(nums, target):", "docstring": "Returns the indices of the two numbers in nums that add up to target."}], "gpt_pass_sequence": [1, 0, 0], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000005", "row_id": 5, "seed_ids": [716], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "You are given a singly linked list, and your task is to implement a function `detect_cycle` that detects whether a cycle exists in the linked list using Floyd's cycle detection algorithm.\n\n#### Function Signature\n\n```python\ndef detect_cycle(linked_list: LinkedList) -> bool:\n    pass\n```\n\n#### Input\n- `linked_list` (LinkedList): A singly linked list instance.\n\n#### Output\n- `bool`: `True` if a cycle exists in the linked list, otherwise `False`.\n\n#### Constraints\n- The linked list can contain up to \\(10^5\\) nodes.\n- Each node's data is an integer ranging from \\(-10^6\\) to \\(10^6\\).\n\n#### Performance Requirements\n- The function should run in \\(O(n)\\) time complexity.\n- The function should use \\(O(1)\\) space complexity.\n\n#### Example\n\n```python\nlinked_list = LinkedList()\nlinked_list.add_node(1)\nlinked_list.add_node(2)\nlinked_list.add_node(3)\nlinked_list.add_node(4)\n\n# Create a cycle in the linked list\nlinked_list.head.next_node.next_node.next_node = linked_list.head.next_node\n\nassert detect_cycle(linked_list) == True\n\nlinked_list2 = LinkedList()\nlinked_list2.add_node(1)\n\nassert detect_cycle(linked_list2) == False\n```\n\n### Additional Requirements\n\n- Ensure your implementation handles edge cases such as an empty list and a list with only one node.\n- Avoid any potential type errors by checking for `None` values before accessing `next_node`."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000008_I", "question": "You are given a singly linked list, and your task is to implement a function `detect_cycle` that detects whether a cycle exists in the linked list using Floyd's cycle detection algorithm.\n\n#### Function Signature\n\n```python\ndef detect_cycle(linked_list: LinkedList) -> bool:\n    pass\n```\n\n#### Input\n- `linked_list` (LinkedList): A singly linked list instance.\n\n#### Output\n- `bool`: `True` if a cycle exists in the linked list, otherwise `False`.\n\n#### Constraints\n- The linked list can contain up to \\(10^5\\) nodes.\n- Each node's data is an integer ranging from \\(-10^6\\) to \\(10^6\\).\n\n#### Performance Requirements\n- The function should run in \\(O(n)\\) time complexity.\n- The function should use \\(O(1)\\) space complexity.\n\n#### Example\n\n```python\nlinked_list = LinkedList()\nlinked_list.add_node(1)\nlinked_list.add_node(2)\nlinked_list.add_node(3)\nlinked_list.add_node(4)\n\n# Create a cycle in the linked list\nlinked_list.head.next_node.next_node.next_node = linked_list.head.next_node\n\nassert detect_cycle(linked_list) == True\n\nlinked_list2 = LinkedList()\nlinked_list2.add_node(1)\n\nassert detect_cycle(linked_list2) == False\n```\n\n### Additional Requirements\n\n- Ensure your implementation handles edge cases such as an empty list and a list with only one node.\n- Avoid any potential type errors by checking for `None` values before accessing `next_node`.", "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next_node = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def add_node(self, value):\n        if not self.head:\n            self.head = Node(value)\n        else:\n            current = self.head\n            while current.next_node:\n                current = current.next_node\n            current.next_node = Node(value)\n\ndef detect_cycle(linked_list: LinkedList) -> bool:\n    \"\"\"\n    Returns True if a cycle exists in the linked list using Floyd's cycle detection algorithm.\n    \"\"\"\n    if not linked_list.head:\n        return False\n\n    slow = linked_list.head\n    fast = linked_list.head\n\n    while fast and fast.next_node:\n        slow = slow.next_node\n        fast = fast.next_node.next_node\n        if slow == fast:\n            return True\n\n    return False", "test_code": "from solution import Node, LinkedList, detect_cycle\n\ndef test_detect_cycle_with_cycle():\n    linked_list = LinkedList()\n    linked_list.add_node(1)\n    linked_list.add_node(2)\n    linked_list.add_node(3)\n    linked_list.add_node(4)\n\n    # Create a cycle in the linked list\n    linked_list.head.next_node.next_node.next_node = linked_list.head.next_node\n\n    assert detect_cycle(linked_list) == True\n\ndef test_detect_cycle_with_no_cycle_one_node():\n    linked_list = LinkedList()\n    linked_list.add_node(1)\n\n    assert detect_cycle(linked_list) == False\n\ndef test_detect_cycle_with_no_cycle_two_nodes():\n    linked_list = LinkedList()\n    linked_list.add_node(1)\n    linked_list.add_node(2)\n    linked_list.head.next_node.next_node = None  # Break the cycle\n\n    assert detect_cycle(linked_list) == False\n\ndef test_detect_cycle_empty_list():\n    linked_list = LinkedList()\n\n    assert detect_cycle(linked_list) == False\n\ndef test_detect_cycle_with_cycle_in_middle():\n    linked_list = LinkedList()\n    linked_list.add_node(1)\n    linked_list.add_node(2)\n    linked_list.add_node(3)\n    linked_list.add_node(4)\n    linked_list.head.next_node.next_node.next_node.next_node = linked_list.head.next_node\n\n    assert detect_cycle(linked_list) == True\n\ndef test_detect_cycle_with_cycle_at_end():\n    linked_list = LinkedList()\n    linked_list.add_node(1)\n    linked_list.add_node(2)\n    linked_list.add_node(3)\n    linked_list.add_node(4)\n    linked_list.head.next_node.next_node.next_node.next_node = linked_list.head.next_node\n\n    assert detect_cycle(linked_list) == True", "test_info": null, "gpt_pass_sequence": [1, 1, 1], "gpt_pass_trial_num": 3, "gpt_difficulty": "easy", "gpt_pass_percentage": 1.0, "metadata": {"prompt_id": "00000008", "row_id": 8, "seed_ids": [327], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "<|Analysis Begin|>\n\n### Algorithm/Data Structure\n\n**Name and Type**: The provided code snippets demonstrate the calculation of Fibonacci numbers using several methods: iteration, recursion, memoization, and a simplified form of Binet's formula. Additionally, a matrix exponentiation method is used, which is a more advanced technique.\n\n**Core Operational Steps**:\n- **Iteration**: Uses a loop to iterate and calculate the Fibonacci sequence.\n- **Recursion**: Recursively calculates the Fibonacci sequence by dividing the problem into smaller subproblems.\n- **Memoization**: Stores the results of expensive function calls and reuses them when the same inputs occur again.\n- **Binet's Formula**: Uses mathematical formulas to calculate Fibonacci numbers, which is efficient but limited by floating-point precision.\n- **Matrix Exponentiation**: Utilizes matrix multiplication to compute the Fibonacci sequence, which is highly efficient for larger values of \\( n \\).\n\n**Time Complexity**:\n- **Iteration**: \\( O(n) \\)\n- **Recursion**: \\( O(2^n) \\) (without memoization), \\( O(n) \\) (with memoization)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(\\log n) \\)\n\n**Space Complexity**:\n- **Iteration**: \\( O(1) \\) (excluding the output list)\n- **Recursion**: \\( O(n) \\) (due to the call stack)\n- **Memoization**: \\( O(n) \\) (for storing intermediate results)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(1) \\) (excluding the output)\n\n### Characteristics & Applications\n\n**Properties**:\n- **Iteration**: Simple and easy to understand, but not efficient for large \\( n \\) due to its linear time complexity.\n- **Recursion**: Can lead to stack overflow for large \\( n \\) and is inefficient, but useful for teaching recursion.\n- **Memoization**: Efficient for large \\( n \\) and avoids redundant calculations, making it a good balance between speed and memory usage.\n- **Binet's Formula**: Efficient but limited by floating-point precision, making it less accurate for large values.\n- **Matrix Exponentiation**: Extremely efficient for very large \\( n \\) but requires understanding of matrix operations and logarithmic time complexity.\n\n**Common Use Cases**:\n- **Iteration**: Useful for small values of \\( n \\) where simplicity is preferred.\n- **Recursion**: Often used in teaching recursion, but not suitable for large \\( n \\).\n- **Memoization**: Good for practical applications where performance is critical and \\( n \\) is large.\n- **Binet's Formula**: Used in contexts where a quick, approximate solution is sufficient.\n- **Matrix Exponentiation**: Ideal for large \\( n \\) in performance-critical applications.\n\n**Strengths/Limitations**:\n- **Iteration**: Simple to implement, but inefficient for large \\( n \\).\n- **Recursion**: Elegant and easy to understand, but inefficient and prone to stack overflow.\n- **Memoization**: Efficient and avoids redundant calculations, but requires additional memory.\n- **Binet's Formula**: Fast but limited by floating-point precision, making it less accurate for large \\( n \\).\n- **Matrix Exponentiation**: Highly efficient with \\( O(\\log n) \\) time complexity but requires understanding of matrix operations.\n\n### Implementation Challenges\n\n**Edge Cases**:\n- **Negative Input**: All methods except the iterative yield version raise a `ValueError` for negative inputs.\n- **Large Input**: Binet's formula and matrix exponentiation have limitations for very large inputs due to floating-point precision and time complexity, respectively.\n\n**Performance Bottlenecks**:\n- **Recursion**: High stack usage and inefficiency, leading to stack overflow for large \\( n \\).\n- **Memoization**: Requires additional memory to"}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000025_I", "question": "<|Analysis Begin|>\n\n### Algorithm/Data Structure\n\n**Name and Type**: The provided code snippets demonstrate the calculation of Fibonacci numbers using several methods: iteration, recursion, memoization, and a simplified form of Binet's formula. Additionally, a matrix exponentiation method is used, which is a more advanced technique.\n\n**Core Operational Steps**:\n- **Iteration**: Uses a loop to iterate and calculate the Fibonacci sequence.\n- **Recursion**: Recursively calculates the Fibonacci sequence by dividing the problem into smaller subproblems.\n- **Memoization**: Stores the results of expensive function calls and reuses them when the same inputs occur again.\n- **Binet's Formula**: Uses mathematical formulas to calculate Fibonacci numbers, which is efficient but limited by floating-point precision.\n- **Matrix Exponentiation**: Utilizes matrix multiplication to compute the Fibonacci sequence, which is highly efficient for larger values of \\( n \\).\n\n**Time Complexity**:\n- **Iteration**: \\( O(n) \\)\n- **Recursion**: \\( O(2^n) \\) (without memoization), \\( O(n) \\) (with memoization)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(\\log n) \\)\n\n**Space Complexity**:\n- **Iteration**: \\( O(1) \\) (excluding the output list)\n- **Recursion**: \\( O(n) \\) (due to the call stack)\n- **Memoization**: \\( O(n) \\) (for storing intermediate results)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(1) \\) (excluding the output)\n\n### Characteristics & Applications\n\n**Properties**:\n- **Iteration**: Simple and easy to understand, but not efficient for large \\( n \\) due to its linear time complexity.\n- **Recursion**: Can lead to stack overflow for large \\( n \\) and is inefficient, but useful for teaching recursion.\n- **Memoization**: Efficient for large \\( n \\) and avoids redundant calculations, making it a good balance between speed and memory usage.\n- **Binet's Formula**: Efficient but limited by floating-point precision, making it less accurate for large values.\n- **Matrix Exponentiation**: Extremely efficient for very large \\( n \\) but requires understanding of matrix operations and logarithmic time complexity.\n\n**Common Use Cases**:\n- **Iteration**: Useful for small values of \\( n \\) where simplicity is preferred.\n- **Recursion**: Often used in teaching recursion, but not suitable for large \\( n \\).\n- **Memoization**: Good for practical applications where performance is critical and \\( n \\) is large.\n- **Binet's Formula**: Used in contexts where a quick, approximate solution is sufficient.\n- **Matrix Exponentiation**: Ideal for large \\( n \\) in performance-critical applications.\n\n**Strengths/Limitations**:\n- **Iteration**: Simple to implement, but inefficient for large \\( n \\).\n- **Recursion**: Elegant and easy to understand, but inefficient and prone to stack overflow.\n- **Memoization**: Efficient and avoids redundant calculations, but requires additional memory.\n- **Binet's Formula**: Fast but limited by floating-point precision, making it less accurate for large \\( n \\).\n- **Matrix Exponentiation**: Highly efficient with \\( O(\\log n) \\) time complexity but requires understanding of matrix operations.\n\n### Implementation Challenges\n\n**Edge Cases**:\n- **Negative Input**: All methods except the iterative yield version raise a `ValueError` for negative inputs.\n- **Large Input**: Binet's formula and matrix exponentiation have limitations for very large inputs due to floating-point precision and time complexity, respectively.\n\n**Performance Bottlenecks**:\n- **Recursion**: High stack usage and inefficiency, leading to stack overflow for large \\( n \\).\n- **Memoization**: Requires additional memory to", "solution": "def fibonacci_iterative(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using iteration.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\ndef fibonacci_recursive(n, memo={}):\n    \"\"\"\n    Returns the n-th Fibonacci number using recursion with memoization.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_recursive(n - 1, memo) + fibonacci_recursive(n - 2, memo)\n    return memo[n]\n\ndef fibonacci_binets(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using Binet's formula.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    phi = (1 + 5**0.5) / 2\n    return int((phi**n - (-phi)**(-n)) / 5**0.5)\n\ndef fibonacci_matrix(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using matrix exponentiation.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    if n == 0:\n        return 0\n    fib_matrix = [[1, 1], [1, 0]]\n    result = matrix_pow(fib_matrix, n - 1)\n    return result[0][0]\n\ndef matrix_pow(matrix, n):\n    \"\"\"\n    Raises a 2x2 matrix to the power of n using exponentiation by squaring.\n    \"\"\"\n    result = [[1, 0], [0, 1]]  # Identity matrix\n    base = matrix\n    while n:\n        if n % 2:\n            result = matrix_multiply(result, base)\n        base = matrix_multiply(base, base)\n        n //= 2\n    return result\ndef matrix_multiply(a, b):\n    \"\"\"\n    Multiplies two 2x2 matrices.\n    \"\"\"\n    return [[a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n            [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]]]", "test_code": "import pytest\nfrom solution import (\n    fibonacci_iterative, \n    fibonacci_recursive, \n    fibonacci_binets, \n    fibonacci_matrix\n)\n\ndef test_fibonacci_iterative():\n    assert fibonacci_iterative(0) == 0\n    assert fibonacci_iterative(1) == 1\n    assert fibonacci_iterative(2) == 1\n    assert fibonacci_iterative(10) == 55\n    assert fibonacci_iterative(20) == 6765\n\ndef test_fibonacci_recursive():\n    assert fibonacci_recursive(0) == 0\n    assert fibonacci_recursive(1) == 1\n    assert fibonacci_recursive(2) == 1\n    assert fibonacci_recursive(10) == 55\n    assert fibonacci_recursive(20) == 6765\n\ndef test_fibonacci_binets():\n    assert fibonacci_binets(0) == 0\n    assert fibonacci_binets(1) == 1\n    assert fibonacci_binets(2) == 1\n    assert fibonacci_binets(10) == 55\n    assert fibonacci_binets(20) == 6765\n\ndef test_fibonacci_matrix():\n    assert fibonacci_matrix(0) == 0\n    assert fibonacci_matrix(1) == 1\n    assert fibonacci_matrix(2) == 1\n    assert fibonacci_matrix(10) == 55\n    assert fibonacci_matrix(20) == 6765\n\ndef test_large_input_fibonacci_matrix():\n    assert fibonacci_matrix(50) == 12586269025\n\ndef test_negative_input():\n    with pytest.raises(ValueError):\n        fibonacci_iterative(-1)\n    with pytest.raises(ValueError):\n        fibonacci_recursive(-1)\n    with pytest.raises(ValueError):\n        fibonacci_binets(-1)\n    with pytest.raises(ValueError):\n        fibonacci_matrix(-1)", "test_info": [{"function_name": "fibonacci_iterative", "parameter_list": "(n)", "function_declaration": "def fibonacci_iterative(n):", "docstring": "Returns the n-th Fibonacci number using iteration."}, {"function_name": "fibonacci_recursive", "parameter_list": "(n, memo={})", "function_declaration": "def fibonacci_recursive(n, memo={}):", "docstring": "Returns the n-th Fibonacci number using recursion with memoization."}, {"function_name": "fibonacci_binets", "parameter_list": "(n)", "function_declaration": "def fibonacci_binets(n):", "docstring": "Returns the n-th Fibonacci number using Binet's formula."}, {"function_name": "fibonacci_matrix", "parameter_list": "(n)", "function_declaration": "def fibonacci_matrix(n):", "docstring": "Returns the n-th Fibonacci number using matrix exponentiation."}, {"function_name": "matrix_pow", "parameter_list": "(matrix, n)", "function_declaration": "def matrix_pow(matrix, n):", "docstring": "Raises a 2x2 matrix to the power of n using exponentiation by squaring."}, {"function_name": "matrix_multiply", "parameter_list": "(a, b)", "function_declaration": "def matrix_multiply(a, b):", "docstring": "Multiplies two 2x2 matrices."}], "gpt_pass_sequence": [0, 0, 1], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000025", "row_id": 25, "seed_ids": [699], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "**Problem Statement**:\nYou are given a sequence of integers. Your task is to implement a function to generate all possible subsequences of the given sequence using a backtracking algorithm. The function should print each subsequence in a separate line.\n\n**Input**:\n- A non-empty list of integers, `sequence`, where the length of the list is between 1 and 10 (inclusive).\n\n**Output**:\n- Print all possible subsequences of the given sequence, each on a new line. Ensure that the subsequences are printed in lexicographical order.\n\n**Example**:\n```python\nsequence = [1, 2, 3]\nOutput:\n[]\n[1]\n[1, 2]\n[1, 2, 3]\n[1, 3]\n[2]\n[2, 3]\n[3]\n```\n\n**Constraints**:\n- The length of `sequence` is between 1 and 10.\n- The elements in `sequence` are integers between 1 and 100.\n\n**Performance Requirement**:\n- Your solution should run efficiently for sequences of length up to 10.\n\n**Implementation**:\nImplement the function to generate and print all possible subsequences of the given sequence.\n\n```python\ndef generate_all_subsequences(sequence: List[int]) -> None:\n    \"\"\"\n    Generates and prints all possible subsequences of the given sequence using a backtracking algorithm.\n    \n    :param sequence: A list of integers.\n    \"\"\"\n    # Your implementation here\n```"}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000038_I", "question": "**Problem Statement**:\nYou are given a sequence of integers. Your task is to implement a function to generate all possible subsequences of the given sequence using a backtracking algorithm. The function should print each subsequence in a separate line.\n\n**Input**:\n- A non-empty list of integers, `sequence`, where the length of the list is between 1 and 10 (inclusive).\n\n**Output**:\n- Print all possible subsequences of the given sequence, each on a new line. Ensure that the subsequences are printed in lexicographical order.\n\n**Example**:\n```python\nsequence = [1, 2, 3]\nOutput:\n[]\n[1]\n[1, 2]\n[1, 2, 3]\n[1, 3]\n[2]\n[2, 3]\n[3]\n```\n\n**Constraints**:\n- The length of `sequence` is between 1 and 10.\n- The elements in `sequence` are integers between 1 and 100.\n\n**Performance Requirement**:\n- Your solution should run efficiently for sequences of length up to 10.\n\n**Implementation**:\nImplement the function to generate and print all possible subsequences of the given sequence.\n\n```python\ndef generate_all_subsequences(sequence: List[int]) -> None:\n    \"\"\"\n    Generates and prints all possible subsequences of the given sequence using a backtracking algorithm.\n    \n    :param sequence: A list of integers.\n    \"\"\"\n    # Your implementation here\n```", "solution": "from typing import List\n\ndef generate_all_subsequences(sequence: List[int]) -> None:\n    \"\"\"\n    Generates and prints all possible subsequences of the given sequence using a backtracking algorithm.\n    \n    :param sequence: A list of integers.\n    \"\"\"\n    def backtrack(start, current):\n        print(current)\n        for i in range(start, len(sequence)):\n            # Add the element at index i to the current subsequence\n            current.append(sequence[i])\n            # Recurse with the next element\n            backtrack(i + 1, current.copy())  # Use copy to avoid modifying the same subsequence\n            # Remove the last element to explore other subsequences\n            current.pop()\n    \n    backtrack(0, [])\n\nsequence = [1, 2, 3]\ngenerate_all_subsequences(sequence)", "test_code": "from solution import generate_all_subsequences\n\ndef test_generate_all_subsequences():\n    # Test with a single element\n    generate_all_subsequences([1])\n    assert True  # No assertion is needed, as the function should print the subsequence correctly\n\n    # Test with multiple elements\n    expected_output = ['[]', '[1]', '[1, 2]', '[1, 2, 3]', '[1, 3]', '[2]', '[2, 3]', '[3]']\n    sequence = [1, 2, 3]\n    captured_output = {}\n    import sys\n    original_stdout = sys.stdout\n    with open('output.txt', 'w') as f:\n        sys.stdout = f\n        generate_all_subsequences(sequence)\n    sys.stdout = original_stdout\n    with open('output.txt', 'r') as f:\n        lines = f.readlines()\n        captured_output = [line.strip() for line in lines]\n    assert captured_output == expected_output\n\ntest_generate_all_subsequences()", "test_info": [{"function_name": "generate_all_subsequences", "parameter_list": "(sequence)", "function_declaration": "def generate_all_subsequences(sequence):", "docstring": "Generates and prints all possible subsequences of the given sequence using a backtracking algorithm.\n\n:param sequence: A list of integers."}, {"function_name": "backtrack", "parameter_list": "(start, current)", "function_declaration": "def backtrack(start, current):", "docstring": null}], "gpt_pass_sequence": [1, 1, 1], "gpt_pass_trial_num": 3, "gpt_difficulty": "easy", "gpt_pass_percentage": 1.0, "metadata": {"prompt_id": "00000038", "row_id": 38, "seed_ids": [167], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "You are given a list of integers and are required to implement a quick sort algorithm. The provided code uses a simple random pivot selection and does not handle in-place sorting. Your task is to enhance the given implementation to achieve the following:\n\n1. Implement quick sort as an in-place sorting algorithm.\n2. Handle edge cases such as empty lists, single-element lists, and nearly sorted lists.\n3. Improve the pivot selection strategy to avoid worst-case performance.\n\n#### Function Signature\n\n```python\ndef quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm.\n\n    :param arr: A list of integers to be sorted.\n    \"\"\"\n```\n\n#### Constraints\n\n- \\(1 \\leq len(arr) \\leq 10^5\\)\n- Elements of `arr` are integers in the range \\([-10^3, 10^3]\\)\n\n#### Example\n\n```python\narr = [10, 5, 2, 3, 7, 6, 8, 4, 9, 1]\nquick_sort_in_place(arr)\nprint(arr)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n### Notes\n\n- You should modify the provided `quick_sort` function to work in-place.\n- Ensure that the function can handle edge cases such as already sorted or nearly sorted arrays.\n- Use a more sophisticated pivot selection strategy, such as the \"median-of-three\" pivot to improve performance.\n\n#### Performance Requirements\n\n- The algorithm should achieve an average-case time complexity of \\(O(n \\log n)\\)."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000041_I", "question": "You are given a list of integers and are required to implement a quick sort algorithm. The provided code uses a simple random pivot selection and does not handle in-place sorting. Your task is to enhance the given implementation to achieve the following:\n\n1. Implement quick sort as an in-place sorting algorithm.\n2. Handle edge cases such as empty lists, single-element lists, and nearly sorted lists.\n3. Improve the pivot selection strategy to avoid worst-case performance.\n\n#### Function Signature\n\n```python\ndef quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm.\n\n    :param arr: A list of integers to be sorted.\n    \"\"\"\n```\n\n#### Constraints\n\n- \\(1 \\leq len(arr) \\leq 10^5\\)\n- Elements of `arr` are integers in the range \\([-10^3, 10^3]\\)\n\n#### Example\n\n```python\narr = [10, 5, 2, 3, 7, 6, 8, 4, 9, 1]\nquick_sort_in_place(arr)\nprint(arr)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n### Notes\n\n- You should modify the provided `quick_sort` function to work in-place.\n- Ensure that the function can handle edge cases such as already sorted or nearly sorted arrays.\n- Use a more sophisticated pivot selection strategy, such as the \"median-of-three\" pivot to improve performance.\n\n#### Performance Requirements\n\n- The algorithm should achieve an average-case time complexity of \\(O(n \\log n)\\).", "solution": "def quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm with an in-place median-of-three pivot selection.\n    \"\"\"\n    def partition(low, high):\n        # Choosing the median of the first, middle, and last elements as the pivot\n        mid = (low + high) // 2\n        pivot_candidates = [arr[low], arr[mid], arr[high]]\n        pivot_candidates.sort()\n        pivot_value = pivot_candidates[1]\n\n        # Move the pivot to the end for partitioning\n        pivot_index = arr.index(pivot_value)\n        arr[pivot_index], arr[high] = arr[high], arr[pivot_index]\n        pivot_index = high\n\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot_value:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[pivot_index] = arr[pivot_index], arr[i + 1]\n        return i + 1\n\n    def _quick_sort(low, high):\n        if low < high:\n            pi = partition(low, high)\n            _quick_sort(low, pi - 1)\n            _quick_sort(pi + 1, high)\n\n    _quick_sort(0, len(arr) - 1)", "test_code": "import random\n\ndef quick_sort_in_place(arr):\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm with an in-place median-of-three pivot selection.\n    \"\"\"\n    def partition(low, high):\n        mid = (low + high) // 2\n        pivot_candidates = [arr[low], arr[mid], arr[high]]\n        pivot_candidates.sort()\n        pivot_value = pivot_candidates[1]\n        pivot_index = arr.index(pivot_value)\n        arr[pivot_index], arr[high] = arr[high], arr[pivot_index]\n        pivot_index = high\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot_value:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[pivot_index] = arr[pivot_index], arr[i + 1]\n        return i + 1\n\n    def _quick_sort(low, high):\n        if low < high:\n            pi = partition(low, high)\n            _quick_sort(low, pi - 1)\n            _quick_sort(pi + 1, high)\n\n    _quick_sort(0, len(arr) - 1)\n\n# Test Cases\ndef test_quick_sort_in_place():\n    arr = [10, 5, 2, 3, 7, 6, 8, 4, 9, 1]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    arr = [1, 2, 3, 4, 5]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5]\n\n    arr = [5, 4, 3, 2, 1]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5]\n\n    arr = []\n    quick_sort_in_place(arr)\n    assert arr == []\n\n    arr = [random.randint(-1000, 1000) for _ in range(10000)]\n    quick_sort_in_place(arr)\n    assert arr == sorted(arr)\n\ntest_quick_sort_in_place()", "test_info": [{"function_name": "quick_sort_in_place", "parameter_list": "(arr)", "function_declaration": "def quick_sort_in_place(arr):", "docstring": "Sorts the given list arr in-place using the quick sort algorithm with an in-place median-of-three pivot selection."}, {"function_name": "partition", "parameter_list": "(low, high)", "function_declaration": "def partition(low, high):", "docstring": null}, {"function_name": "_quick_sort", "parameter_list": "(low, high)", "function_declaration": "def _quick_sort(low, high):", "docstring": null}], "gpt_pass_sequence": [1, 1, 0], "gpt_pass_trial_num": 2, "gpt_difficulty": "easy", "gpt_pass_percentage": 0.667, "metadata": {"prompt_id": "00000041", "row_id": 41, "seed_ids": [233], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "### Scenario\nYou are working on a project where you need to efficiently traverse a large Binary Search Tree (BST) and output the values in sorted order. Given the provided code snippet, you have been tasked with implementing an enhanced version of the inorder traversal.\n\n### Requirements\n1. **Function Specification**:\n    - Implement a function `enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]` that performs an inorder traversal on a given BST.\n    - The function should return a list of integers representing the values of the nodes in sorted order.\n2. **Input**:\n    - `root: BinaryTreeNode | None`: The root node of a BST. If `None`, the function should return an empty list.\n3. **Output**:\n    - A list of integers representing the values of the nodes in sorted order.\n4. **Constraints**:\n    - The maximum number of nodes in the tree is \\(10^5\\).\n    - The value of each node is an integer within the range \\([-10^9, 10^9]\\).\n5. **Optimization**:\n    - Use an iterative approach to avoid potential stack overflow issues with deep trees.\n    - Ensure the solution is efficient and handles edge cases properly.\n\n### Example\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\n# Function to test the solution\ndef check_solution(func):\n    tree = make_tree()\n    result = func(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n    print(\"Solution is correct.\")\n\n# Test the function\ncheck_solution(enhanced_inorder_traversal)\n```\n\n### Note\nEnsure your implementation is efficient and handles edge cases such as an empty tree or very deep trees. Use an iterative approach to avoid stack overflow issues."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000051_I", "question": "### Scenario\nYou are working on a project where you need to efficiently traverse a large Binary Search Tree (BST) and output the values in sorted order. Given the provided code snippet, you have been tasked with implementing an enhanced version of the inorder traversal.\n\n### Requirements\n1. **Function Specification**:\n    - Implement a function `enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]` that performs an inorder traversal on a given BST.\n    - The function should return a list of integers representing the values of the nodes in sorted order.\n2. **Input**:\n    - `root: BinaryTreeNode | None`: The root node of a BST. If `None`, the function should return an empty list.\n3. **Output**:\n    - A list of integers representing the values of the nodes in sorted order.\n4. **Constraints**:\n    - The maximum number of nodes in the tree is \\(10^5\\).\n    - The value of each node is an integer within the range \\([-10^9, 10^9]\\).\n5. **Optimization**:\n    - Use an iterative approach to avoid potential stack overflow issues with deep trees.\n    - Ensure the solution is efficient and handles edge cases properly.\n\n### Example\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\n# Function to test the solution\ndef check_solution(func):\n    tree = make_tree()\n    result = func(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n    print(\"Solution is correct.\")\n\n# Test the function\ncheck_solution(enhanced_inorder_traversal)\n```\n\n### Note\nEnsure your implementation is efficient and handles edge cases such as an empty tree or very deep trees. Use an iterative approach to avoid stack overflow issues.", "solution": "from typing import List, Optional\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result", "test_code": "import pytest\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n\ndef test_enhanced_inorder_traversal_single_node():\n    root = BinaryTreeNode(10)\n    assert enhanced_inorder_traversal(root) == [10]\n\ndef test_enhanced_inorder_traversal_empty_tree():\n    assert enhanced_inorder_traversal(None) == []\n\ndef test_enhanced_inorder_traversal_balanced_tree():\n    tree = make_tree()\n    assert enhanced_inorder_traversal(tree) == [6, 10, 14, 15, 20, 25, 60]\n\ndef test_enhanced_inorder_traversal_degenerate_tree():\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    assert enhanced_inorder_traversal(root) == [10, 15, 25]\n\ndef test_enhanced_inorder_traversal_negative_numbers():\n    root = BinaryTreeNode(-10)\n    root.left_child = BinaryTreeNode(-20)\n    root.right_child = BinaryTreeNode(-5)\n    root.left_child.left_child = BinaryTreeNode(-30)\n    root.left_child.right_child = BinaryTreeNode(-15)\n    assert enhanced_inorder_traversal(root) == [-30, -20, -15, -10, -5]", "test_info": null, "gpt_pass_sequence": [0, 1, 0], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000051", "row_id": 51, "seed_ids": [358], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "You are tasked with extending the functionality of a given function to not only find the largest power of two less than or equal to a given non-negative integer but also to handle an additional constraint: finding the smallest power of two greater than a given non-negative integer. This new function will be used in scenarios where binary allocations or specific power levels are required.\n\n**Function Signature**: `def find_next_power_of_two(number: int) -> int:`\n\n**Input and Output**:\n- **Input**: A single non-negative integer `number`.\n- **Output**: The smallest power of two greater than the given integer. If the input is 0, return 1.\n\n**Constraints**:\n- The input number will be in the range \\(0 \\leq \\text{number} \\leq 10^9\\).\n\n**Performance Requirements**:\n- The function should be efficient and handle the constraints within a reasonable time.\n\n**Scenario**:\nImagine you are working on a system where you need to allocate memory in the form of powers of two. You have a function to allocate memory based on the smallest power of two greater than a given request size. For example, if a request is for 5 units of memory, the system should allocate 8 units (2^3).\n\n**Example**:\n```python\nassert find_next_power_of_two(0) == 1\nassert find_next_power_of_two(1) == 2\nassert find_next_power_of_two(15) == 16\nassert find_next_power_of_two(16) == 32\n```\n\n**Note**:\n- You are not allowed to use any built-in functions or libraries for calculating powers of two.\n- The function should handle edge cases as described in the constraints."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000052_I", "question": "You are tasked with extending the functionality of a given function to not only find the largest power of two less than or equal to a given non-negative integer but also to handle an additional constraint: finding the smallest power of two greater than a given non-negative integer. This new function will be used in scenarios where binary allocations or specific power levels are required.\n\n**Function Signature**: `def find_next_power_of_two(number: int) -> int:`\n\n**Input and Output**:\n- **Input**: A single non-negative integer `number`.\n- **Output**: The smallest power of two greater than the given integer. If the input is 0, return 1.\n\n**Constraints**:\n- The input number will be in the range \\(0 \\leq \\text{number} \\leq 10^9\\).\n\n**Performance Requirements**:\n- The function should be efficient and handle the constraints within a reasonable time.\n\n**Scenario**:\nImagine you are working on a system where you need to allocate memory in the form of powers of two. You have a function to allocate memory based on the smallest power of two greater than a given request size. For example, if a request is for 5 units of memory, the system should allocate 8 units (2^3).\n\n**Example**:\n```python\nassert find_next_power_of_two(0) == 1\nassert find_next_power_of_two(1) == 2\nassert find_next_power_of_two(15) == 16\nassert find_next_power_of_two(16) == 32\n```\n\n**Note**:\n- You are not allowed to use any built-in functions or libraries for calculating powers of two.\n- The function should handle edge cases as described in the constraints.", "solution": "def find_next_power_of_two(number: int) -> int:\n    \"\"\"\n    Returns the smallest power of two greater than the given non-negative integer.\n    If the input is 0, returns 1.\n    \"\"\"\n    if number == 0:\n        return 1\n    power = 1\n    while power <= number:\n        power *= 2\n    return power", "test_code": "import pytest\n\ndef test_find_next_power_of_two():\n    assert find_next_power_of_two(0) == 1\n    assert find_next_power_of_two(1) == 2\n    assert find_next_power_of_two(15) == 16\n    assert find_next_power_of_two(16) == 32\n    assert find_next_power_of_two(1023) == 1024\n    assert find_next_power_of_two(1024) == 2048\n    assert find_next_power_of_two(1048575) == 1048576\n    assert find_next_power_of_two(1048576) == 2097152\n    pytest.approx(find_next_power_of_two(999999999), 2_000_000_000)", "test_info": [{"function_name": "find_next_power_of_two", "parameter_list": "(number)", "function_declaration": "def find_next_power_of_two(number):", "docstring": "Returns the smallest power of two greater than the given non-negative integer.\nIf the input is 0, returns 1."}], "gpt_pass_sequence": [0, 1, 0], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000052", "row_id": 52, "seed_ids": [1050], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "**Scenario**: You are given a list of integers, and you need to find the peak element in the list, which is the maximum value in a unimodal list. A unimodal list is defined as a list that increases to a point and then decreases. If the input list does not strictly follow this pattern, the function should return `None`.\n\n**Function Signature**:\n```python\ndef find_peak(lst: List[int]) -> Optional[int]:\n    pass\n```\n\n**Input**:\n- The function takes a list of integers `lst`.\n\n**Output**:\n- The function returns the peak element of the list as an integer. If the list does not follow the unimodal pattern, the function should return `None`.\n\n**Constraints**:\n- \\(1 \\leq \\text{len}(lst) \\leq 10^6\\)\n- The list can contain duplicate values.\n\n**Performance Requirement**:\n- The function should be efficient, aiming for a time complexity of \\(O(\\log n)\\) where \\(n\\) is the length of the list.\n\n**Example**:\n```python\n>>> find_peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n5\n>>> find_peak([1, 10, 9, 8, 7, 6, 5, 4])\n10\n>>> find_peak([1, 9, 8, 7])\n9\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 0])\n7\n>>> find_peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n4\n>>> find_peak([1, 2, 2, 1, 0, -1, -2])\n2\n>>> find_peak([1, 1])\n1\n>>> find_peak([1])\n1\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10])\n12\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10, 9])\n12\n```\n\n**Note**: Ensure that your implementation handles edge cases correctly and efficiently."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000054_I", "question": "**Scenario**: You are given a list of integers, and you need to find the peak element in the list, which is the maximum value in a unimodal list. A unimodal list is defined as a list that increases to a point and then decreases. If the input list does not strictly follow this pattern, the function should return `None`.\n\n**Function Signature**:\n```python\ndef find_peak(lst: List[int]) -> Optional[int]:\n    pass\n```\n\n**Input**:\n- The function takes a list of integers `lst`.\n\n**Output**:\n- The function returns the peak element of the list as an integer. If the list does not follow the unimodal pattern, the function should return `None`.\n\n**Constraints**:\n- \\(1 \\leq \\text{len}(lst) \\leq 10^6\\)\n- The list can contain duplicate values.\n\n**Performance Requirement**:\n- The function should be efficient, aiming for a time complexity of \\(O(\\log n)\\) where \\(n\\) is the length of the list.\n\n**Example**:\n```python\n>>> find_peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n5\n>>> find_peak([1, 10, 9, 8, 7, 6, 5, 4])\n10\n>>> find_peak([1, 9, 8, 7])\n9\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 0])\n7\n>>> find_peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n4\n>>> find_peak([1, 2, 2, 1, 0, -1, -2])\n2\n>>> find_peak([1, 1])\n1\n>>> find_peak([1])\n1\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10])\n12\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10, 9])\n12\n```\n\n**Note**: Ensure that your implementation handles edge cases correctly and efficiently.", "solution": "from typing import List, Optional\n\ndef find_peak(lst: List[int]) -> Optional[int]:\n    \"\"\"\n    Returns the peak element in a unimodal list. If the list does not follow the unimodal pattern, returns None.\n    \"\"\"\n    if not lst:\n        return None\n    \n    left, right = 0, len(lst) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if lst[mid] < lst[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return lst[left]", "test_code": "import pytest\n\ndef test_find_peak():\n    assert find_peak([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5\n    assert find_peak([1, 10, 9, 8, 7, 6, 5, 4]) == 10\n    assert find_peak([1, 9, 8, 7]) == 9\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 0]) == 7\n    assert find_peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2]) == 4\n    assert find_peak([1, 2, 2, 1, 0, -1, -2]) == 2\n    assert find_peak([1, 1]) == 1\n    assert find_peak([1]) == 1\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10]) == 12\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10, 9]) == 12\n    assert find_peak([]) is None\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 10\n    assert find_peak([1, 2, 2, 2, 2, 2, 1]) == 2\n\ndef test_edge_cases():\n    assert find_peak([1]) == 1\n    assert find_peak([1, 2]) == 2\n    assert find_peak([2, 1]) == 2\n    assert find_peak([1, 1]) == 1", "test_info": [{"function_name": "find_peak", "parameter_list": "(lst)", "function_declaration": "def find_peak(lst):", "docstring": "Returns the peak element in a unimodal list. If the list does not follow the unimodal pattern, returns None."}], "gpt_pass_sequence": [0, 0, 1], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000054", "row_id": 54, "seed_ids": [942], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "You are given a 2x2 grid, and you are required to calculate the number of unique paths from the top-left corner to the bottom-right corner, where you can only move right or down. The general solution extends to an \\(n \\times n\\) grid.\n\nWrite a Python function `calculate_paths(n: int) -> int` that returns the number of unique paths in an \\(n \\times n\\) grid.\n\n**Function Signature**: `def calculate_paths(n: int) -> int:`\n\n**Input**\n- `n` (1 <= n <= 100): An integer representing the size of the grid.\n\n**Output**\n- An integer representing the number of unique paths in the \\(n \\times n\\) grid.\n\n**Constraints**\n- The input `n` will be a positive integer.\n\n**Example**\n```python\nprint(calculate_paths(2))  # Output: 6\nprint(calculate_paths(20))  # Output: 137846528820\n```\n\n**Note**\n- Use combinatorial mathematics to solve the problem efficiently.\n- Ensure your function handles edge cases correctly."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000055_I", "question": "You are given a 2x2 grid, and you are required to calculate the number of unique paths from the top-left corner to the bottom-right corner, where you can only move right or down. The general solution extends to an \\(n \\times n\\) grid.\n\nWrite a Python function `calculate_paths(n: int) -> int` that returns the number of unique paths in an \\(n \\times n\\) grid.\n\n**Function Signature**: `def calculate_paths(n: int) -> int:`\n\n**Input**\n- `n` (1 <= n <= 100): An integer representing the size of the grid.\n\n**Output**\n- An integer representing the number of unique paths in the \\(n \\times n\\) grid.\n\n**Constraints**\n- The input `n` will be a positive integer.\n\n**Example**\n```python\nprint(calculate_paths(2))  # Output: 6\nprint(calculate_paths(20))  # Output: 137846528820\n```\n\n**Note**\n- Use combinatorial mathematics to solve the problem efficiently.\n- Ensure your function handles edge cases correctly.", "solution": "def calculate_paths(n: int) -> int:\n    \"\"\"\n    Returns the number of unique paths in an n x n grid.\n    \"\"\"\n    from math import comb\n    return comb(2 * n, n)", "test_code": "import pytest\n\ndef test_calculate_paths():\n    assert calculate_paths(2) == 6\n    assert calculate_paths(3) == 20\n    assert calculate_paths(1) == 2\n    assert calculate_paths(20) == 137846528820\n\ndef test_calculate_paths_edge_cases():\n    assert calculate_paths(0) == 1  # Edge case: 0x0 grid\n    assert calculate_paths(1) == 2  # Edge case: 1x1 grid", "test_info": [{"function_name": "calculate_paths", "parameter_list": "(n)", "function_declaration": "def calculate_paths(n):", "docstring": "Returns the number of unique paths in an n x n grid."}], "gpt_pass_sequence": [0, 0, 1], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000055", "row_id": 55, "seed_ids": [474], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "**Scenario**: You are working on a project that requires generating Gray code sequences for various bit counts. The sequences are used in a digital communication system to ensure that only one bit changes between consecutive states.\n\n**Task**: Implement a function `generate_gray_code` that takes an integer \\( n \\) as input and returns a list of integers representing the \\( n \\)-bit Gray code sequence. The function should handle edge cases such as non-positive inputs and non-integer inputs.\n\n**Function Signature**: `def generate_gray_code(bit_count: int) -> List[int]:`\n\n**Input**:\n- \\( n \\) (1 \u2264 \\( n \\) \u2264 32): An integer representing the number of bits in the Gray code sequence.\n\n**Output**:\n- A list of integers representing the \\( n \\)-bit Gray code sequence.\n\n**Constraints**:\n- The function should handle inputs within the specified range.\n- The function should raise appropriate exceptions for invalid inputs.\n\n**Performance Requirements**:\n- The function should be efficient for \\( n \\leq 32 \\).\n\n**Example**:\n```python\n>>> generate_gray_code(2)\n[0, 1, 3, 2]\n>>> generate_gray_code(1)\n[0, 1]\n>>> generate_gray_code(3)\n[0, 1, 3, 2, 6, 7, 5, 4]\n```\n\n**Note**: You should not directly use the provided `gray_code` and `gray_code_sequence_string` functions. Implement your solution from scratch.\n\n**Hints**:\n- Consider the recursive nature of the problem and how you can build the sequence iteratively."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000056_I", "question": "**Scenario**: You are working on a project that requires generating Gray code sequences for various bit counts. The sequences are used in a digital communication system to ensure that only one bit changes between consecutive states.\n\n**Task**: Implement a function `generate_gray_code` that takes an integer \\( n \\) as input and returns a list of integers representing the \\( n \\)-bit Gray code sequence. The function should handle edge cases such as non-positive inputs and non-integer inputs.\n\n**Function Signature**: `def generate_gray_code(bit_count: int) -> List[int]:`\n\n**Input**:\n- \\( n \\) (1 \u2264 \\( n \\) \u2264 32): An integer representing the number of bits in the Gray code sequence.\n\n**Output**:\n- A list of integers representing the \\( n \\)-bit Gray code sequence.\n\n**Constraints**:\n- The function should handle inputs within the specified range.\n- The function should raise appropriate exceptions for invalid inputs.\n\n**Performance Requirements**:\n- The function should be efficient for \\( n \\leq 32 \\).\n\n**Example**:\n```python\n>>> generate_gray_code(2)\n[0, 1, 3, 2]\n>>> generate_gray_code(1)\n[0, 1]\n>>> generate_gray_code(3)\n[0, 1, 3, 2, 6, 7, 5, 4]\n```\n\n**Note**: You should not directly use the provided `gray_code` and `gray_code_sequence_string` functions. Implement your solution from scratch.\n\n**Hints**:\n- Consider the recursive nature of the problem and how you can build the sequence iteratively.", "solution": "from typing import List\n\ndef generate_gray_code(bit_count: int) -> List[int]:\n    \"\"\"\n    Generates an n-bit Gray code sequence.\n    \"\"\"\n    if not isinstance(bit_count, int) or bit_count <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    gray_code = [0]\n    for i in range(bit_count):\n        gray_code += [x + 2**i for x in reversed(gray_code)]\n    \n    return gray_code", "test_code": "import pytest\nfrom typing import List\n\ndef test_generate_gray_code():\n    assert generate_gray_code(2) == [0, 1, 3, 2]\n    assert generate_gray_code(1) == [0, 1]\n    assert generate_gray_code(3) == [0, 1, 3, 2, 6, 7, 5, 4]\n    assert generate_gray_code(4) == [0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8]\n\ndef test_invalid_input():\n    with pytest.raises(ValueError):\n        generate_gray_code(0)\n    with pytest.raises(ValueError):\n        generate_gray_code(-1)\n    with pytest.raises(ValueError):\n        generate_gray_code(3.5)", "test_info": [{"function_name": "generate_gray_code", "parameter_list": "(bit_count)", "function_declaration": "def generate_gray_code(bit_count):", "docstring": "Generates an n-bit Gray code sequence."}], "gpt_pass_sequence": [0, 0, 1], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000056", "row_id": 56, "seed_ids": [1055], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "**Scenario**: You are working on a machine learning project that requires an activation function for a neural network layer. The Binary Step function is a simple yet effective choice for your needs. However, you want to extend its functionality to handle multiple activation functions for different layers.\n\n**Task**: Implement a more generalized version of the activation function that can switch between different activation functions based on a given input vector. Specifically, your task is to implement a function `activation_function` that takes an input vector and a mode as input and applies the corresponding activation function.\n\n**Function Signature**: `def activation_function(vector: np.ndarray, mode: str) -> np.ndarray`\n\n- **Input**:\n  - `vector` (ndarray): A numpy array of numeric values.\n  - `mode` (str): A string indicating the activation mode to be used. The possible values are:\n    - `'binary_step'`: Applies the binary step function.\n    - `'relu'`: Applies the Rectified Linear Unit (ReLU) activation function, which returns 0 for negative values and the input value for non-negative values.\n    - `'sigmoid'`: Applies the sigmoid activation function, which maps the input to a range between 0 and 1.\n\n- **Output**:\n  - A numpy array `vector` after applying the specified activation function.\n\n- **Constraints**:\n  - The input vector will always be a 1D numpy array.\n  - The mode will always be one of the specified strings.\n\n- **Performance Requirement**:\n  - The function should be optimized for performance, especially for large input vectors.\n\n**Examples**:\n```python\nimport numpy as np\n\n# Binary Step Function\nvector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])\nprint(activation_function(vector, 'binary_step'))\n# Output: array([0, 1, 1, 1, 0, 1])\n\n# ReLU Function\nprint(activation_function(np.array([-1, 0, 1, -2, 2]), 'relu'))\n# Output: array([0, 0, 1, 0, 2])\n\n# Sigmoid Function\nprint(activation_function(np.array([-1, 0, 1]), 'sigmoid'))\n# Output: array([0.26894142, 0.5         , 0.73105858])\n```"}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000068_I", "question": "**Scenario**: You are working on a machine learning project that requires an activation function for a neural network layer. The Binary Step function is a simple yet effective choice for your needs. However, you want to extend its functionality to handle multiple activation functions for different layers.\n\n**Task**: Implement a more generalized version of the activation function that can switch between different activation functions based on a given input vector. Specifically, your task is to implement a function `activation_function` that takes an input vector and a mode as input and applies the corresponding activation function.\n\n**Function Signature**: `def activation_function(vector: np.ndarray, mode: str) -> np.ndarray`\n\n- **Input**:\n  - `vector` (ndarray): A numpy array of numeric values.\n  - `mode` (str): A string indicating the activation mode to be used. The possible values are:\n    - `'binary_step'`: Applies the binary step function.\n    - `'relu'`: Applies the Rectified Linear Unit (ReLU) activation function, which returns 0 for negative values and the input value for non-negative values.\n    - `'sigmoid'`: Applies the sigmoid activation function, which maps the input to a range between 0 and 1.\n\n- **Output**:\n  - A numpy array `vector` after applying the specified activation function.\n\n- **Constraints**:\n  - The input vector will always be a 1D numpy array.\n  - The mode will always be one of the specified strings.\n\n- **Performance Requirement**:\n  - The function should be optimized for performance, especially for large input vectors.\n\n**Examples**:\n```python\nimport numpy as np\n\n# Binary Step Function\nvector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])\nprint(activation_function(vector, 'binary_step'))\n# Output: array([0, 1, 1, 1, 0, 1])\n\n# ReLU Function\nprint(activation_function(np.array([-1, 0, 1, -2, 2]), 'relu'))\n# Output: array([0, 0, 1, 0, 2])\n\n# Sigmoid Function\nprint(activation_function(np.array([-1, 0, 1]), 'sigmoid'))\n# Output: array([0.26894142, 0.5         , 0.73105858])\n```", "solution": "import numpy as np\n\ndef activation_function(vector: np.ndarray, mode: str) -> np.ndarray:\n    \"\"\"\n    Returns the numpy array of the values after applying the specified activation function.\n    \"\"\"\n    if mode == 'binary_step':\n        return np.where(vector >= 0, 1, 0)\n    elif mode == 'relu':\n        return np.maximum(0, vector)\n    elif mode == 'sigmoid':\n        return 1 / (1 + np.exp(-vector))\n    else:\n        raise ValueError(\"Unknown activation mode: {}\".format(mode))", "test_code": "import numpy as np\nfrom scipy.special import expit  # Import the expit function for sigmoid\n\ndef test_activation_function():\n    # Binary Step Function\n    vector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])\n    expected = np.array([0, 1, 1, 1, 0, 1])\n    result = activation_function(vector, 'binary_step')\n    assert np.array_equal(result, expected)\n\n    # ReLU Function\n    vector = np.array([-1, 0, 1, -2, 2])\n    expected = np.array([0, 0, 1, 0, 2])\n    result = activation_function(vector, 'relu')\n    assert np.array_equal(result, expected)\n\n    # Sigmoid Function\n    vector = np.array([-1, 0, 1])\n    expected = expit(vector)  # Using scipy's expit for exact sigmoid implementation\n    result = activation_function(vector, 'sigmoid')\n    assert np.allclose(result, expected)\n\n    # Unknown activation mode\n    try:\n        activation_function(np.array([-1, 0, 1]), 'unknown')\n    except ValueError:\n        pass  # Test passes if it raises the expected ValueError\n\ntest_activation_function()", "test_info": [{"function_name": "activation_function", "parameter_list": "(vector, mode)", "function_declaration": "def activation_function(vector, mode):", "docstring": "Returns the numpy array of the values after applying the specified activation function."}], "gpt_pass_sequence": [0, 0, 1], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000068", "row_id": 68, "seed_ids": [910], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "**Scenario**: You are working on a project that involves processing text data in various languages, including those that use non-ASCII characters. You need a function to convert all uppercase letters to lowercase letters in a string, handling both ASCII and non-ASCII characters correctly.\n\n**Question**: Implement a function `enhanced_lower` that takes a string as input and returns a new string with all uppercase letters converted to lowercase. The function should handle both ASCII and non-ASCII characters and preserve the original order of characters in the string.\n\n**Input**: A string `text` (1 <= len(text) <= 10^5) consisting of alphanumeric characters, spaces, and punctuation marks. The string may contain non-ASCII characters.\n\n**Output**: A string where all uppercase letters in the input string are converted to lowercase.\n\n**Example**:\n```python\n>>> enhanced_lower(\"Hello, World!\")\n'hello, world!'\n>>> enhanced_lower(\"\u00a1Hola, MUNDO!\")\n'\u00a1hola, mundo!'\n>>> enhanced_lower(\"Python 3.8\")\n'python 3.8'\n>>> enhanced_lower(\"12345\")\n'12345'\n>>> enhanced_lower(\" caf\u00e9\")\n' caf\u00e9'\n```\n\n**Constraints**:\n- The input string will contain at least one character and at most 10^5 characters.\n- The string may contain non-ASCII characters.\n\n**Performance Requirement**: The function should handle large strings efficiently, aiming for a time complexity of O(n) and a space complexity of O(n)."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000070_I", "question": "**Scenario**: You are working on a project that involves processing text data in various languages, including those that use non-ASCII characters. You need a function to convert all uppercase letters to lowercase letters in a string, handling both ASCII and non-ASCII characters correctly.\n\n**Question**: Implement a function `enhanced_lower` that takes a string as input and returns a new string with all uppercase letters converted to lowercase. The function should handle both ASCII and non-ASCII characters and preserve the original order of characters in the string.\n\n**Input**: A string `text` (1 <= len(text) <= 10^5) consisting of alphanumeric characters, spaces, and punctuation marks. The string may contain non-ASCII characters.\n\n**Output**: A string where all uppercase letters in the input string are converted to lowercase.\n\n**Example**:\n```python\n>>> enhanced_lower(\"Hello, World!\")\n'hello, world!'\n>>> enhanced_lower(\"\u00a1Hola, MUNDO!\")\n'\u00a1hola, mundo!'\n>>> enhanced_lower(\"Python 3.8\")\n'python 3.8'\n>>> enhanced_lower(\"12345\")\n'12345'\n>>> enhanced_lower(\" caf\u00e9\")\n' caf\u00e9'\n```\n\n**Constraints**:\n- The input string will contain at least one character and at most 10^5 characters.\n- The string may contain non-ASCII characters.\n\n**Performance Requirement**: The function should handle large strings efficiently, aiming for a time complexity of O(n) and a space complexity of O(n).", "solution": "def enhanced_lower(text):\n    \"\"\"\n    Converts all uppercase letters in the input string to lowercase.\n    Handles both ASCII and non-ASCII characters.\n    \"\"\"\n    return text.lower()", "test_code": "import pytest\n\ndef test_enhanced_lower_ascii():\n    assert enhanced_lower(\"Hello, World!\") == 'hello, world!'\n    assert enhanced_lower(\"\u00a1Hola, MUNDO!\") == '\u00a1hola, mundo!'\n    assert enhanced_lower(\"Python 3.8\") == 'python 3.8'\n    assert enhanced_lower(\"12345\") == '12345'\n    assert enhanced_lower(\" caf\u00e9\") == ' caf\u00e9'\n\ndef test_enhanced_lower_non_ascii():\n    assert enhanced_lower(\"\u039a\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1\") == '\u03ba\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1'\n    assert enhanced_lower(\"\ud83d\ude00.prop\") == '\ud83d\ude00.prop'\n    assert enhanced_lower(\" teasers\") == ' teasers'\n    assert enhanced_lower(\"Teasers\") == 'teasers'\n    assert enhanced_lower(\"Teasers\ud83d\ude00\") == 'teasers\ud83d\ude00'", "test_info": [{"function_name": "enhanced_lower", "parameter_list": "(text)", "function_declaration": "def enhanced_lower(text):", "docstring": "Converts all uppercase letters in the input string to lowercase.\nHandles both ASCII and non-ASCII characters."}], "gpt_pass_sequence": [1, 0, 1], "gpt_pass_trial_num": 2, "gpt_difficulty": "easy", "gpt_pass_percentage": 0.667, "metadata": {"prompt_id": "00000070", "row_id": 70, "seed_ids": [286], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "You are given a function `bin_to_octal` that converts a binary string to its octal equivalent. The provided function already handles some edge cases and errors. Your task is to optimize the function to handle large binary strings more efficiently and to minimize the creation of intermediate data structures.\n\n**Function Signature**:\n```python\ndef bin_to_octal(bin_string: str) -> str:\n    # Your code here\n```\n\n**Input**:\n- `bin_string` (str): A binary string (composed of '0's and '1's).\n\n**Output**:\n- Return the octal equivalent of the binary string as a string.\n\n**Constraints**:\n- `1 <= len(bin_string) <= 10^6`\n\n**Performance Requirement**:\n- Optimize the function to handle large binary strings efficiently and minimize the use of additional data structures.\n\n**Example**:\n```python\n>>> bin_to_octal(\"1111\")\n'17'\n>>> bin_to_octal(\"101010101010011\")\n'52523'\n>>> bin_to_octal(\"\")\n''\n>>> bin_to_octal(\"a-1\")\nValueError: Non-binary value was passed to the function\n```\n\n**Note**: Ensure that your implementation handles all edge cases, including empty strings and non-binary strings, and performs optimally for large inputs."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000087_I", "question": "You are given a function `bin_to_octal` that converts a binary string to its octal equivalent. The provided function already handles some edge cases and errors. Your task is to optimize the function to handle large binary strings more efficiently and to minimize the creation of intermediate data structures.\n\n**Function Signature**:\n```python\ndef bin_to_octal(bin_string: str) -> str:\n    # Your code here\n```\n\n**Input**:\n- `bin_string` (str): A binary string (composed of '0's and '1's).\n\n**Output**:\n- Return the octal equivalent of the binary string as a string.\n\n**Constraints**:\n- `1 <= len(bin_string) <= 10^6`\n\n**Performance Requirement**:\n- Optimize the function to handle large binary strings efficiently and minimize the use of additional data structures.\n\n**Example**:\n```python\n>>> bin_to_octal(\"1111\")\n'17'\n>>> bin_to_octal(\"101010101010011\")\n'52523'\n>>> bin_to_octal(\"\")\n''\n>>> bin_to_octal(\"a-1\")\nValueError: Non-binary value was passed to the function\n```\n\n**Note**: Ensure that your implementation handles all edge cases, including empty strings and non-binary strings, and performs optimally for large inputs.", "solution": "def bin_to_octal(bin_string: str) -> str:\n    \"\"\"\n    Converts a binary string to its octal equivalent.\n    \"\"\"\n    if not all(c in '01' for c in bin_string):\n        raise ValueError(\"Non-binary value was passed to the function\")\n    if not bin_string:  # Handle empty string\n        return \"\"\n    \n    # Group binary string into chunks of 3, padding with leading zeros if necessary\n    padded_bin = bin_string.zfill((len(bin_string) + 2) // 3 * 3)\n    octal = \"\"\n    for i in range(0, len(padded_bin), 3):\n        chunk = padded_bin[i:i+3]\n        octal_digit = int(chunk, 2)\n        octal += str(octal_digit)\n    \n    return octal", "test_code": "import pytest\n\ndef test_bin_to_octal():\n    # Test with a valid binary string\n    assert bin_to_octal(\"1111\") == \"17\"\n    \n    # Test with a larger binary string\n    assert bin_to_octal(\"101010101010011\") == \"52523\"\n    \n    # Test with an empty string\n    assert bin_to_octal(\"\") == \"\"\n    \n    # Test with a non-binary string (should raise ValueError)\n    with pytest.raises(ValueError):\n        bin_to_octal(\"a-1\")\n    \n    # Test with a string that contains characters that are not '0' or '1'\n    with pytest.raises(ValueError):\n        bin_to_octal(\"1010x1010\")\n\ndef test_optimization():\n    # Test with a large binary string\n    large_bin = '1' * 1000000  # A large number of 1s\n    octal = bin_to_octal(large_bin)\n    assert len(octal) == 333334  # Since 1000000 / 3 = 333333 with a remainder of 1, we expect 333334 digits in octal", "test_info": [{"function_name": "bin_to_octal", "parameter_list": "(bin_string)", "function_declaration": "def bin_to_octal(bin_string):", "docstring": "Converts a binary string to its octal equivalent."}], "gpt_pass_sequence": [0, 0, 1], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000087", "row_id": 87, "seed_ids": [651], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "You are given a function `is_prime` that checks whether a number is prime. Your task is to implement a function `find_next_prime` that finds the next prime number greater than a given value. The function should handle edge cases and optimize performance for larger numbers.\n\n#### Function Signature\n```python\ndef find_next_prime(value: int) -> int:\n    pass\n```\n\n#### Constraints\n- `1 <= value <= 10^9`\n- The function should return the smallest prime number greater than the given value.\n\n#### Input and Output\n- **Input**: An integer `value`.\n- **Output**: The smallest prime number greater than `value`.\n\n#### Example\n```python\nassert find_next_prime(10) == 11\nassert find_next_prime(29) == 31\nassert find_next_prime(100) == 101\n```\n\n#### Performance Requirements\n- The function should be able to handle values up to `10^9` efficiently.\n\n#### Scenario\nYou are developing a secure messaging system that requires generating prime numbers for encryption keys. Your task is to ensure that the next prime number is found quickly and accurately."}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000089_I", "question": "You are given a function `is_prime` that checks whether a number is prime. Your task is to implement a function `find_next_prime` that finds the next prime number greater than a given value. The function should handle edge cases and optimize performance for larger numbers.\n\n#### Function Signature\n```python\ndef find_next_prime(value: int) -> int:\n    pass\n```\n\n#### Constraints\n- `1 <= value <= 10^9`\n- The function should return the smallest prime number greater than the given value.\n\n#### Input and Output\n- **Input**: An integer `value`.\n- **Output**: The smallest prime number greater than `value`.\n\n#### Example\n```python\nassert find_next_prime(10) == 11\nassert find_next_prime(29) == 31\nassert find_next_prime(100) == 101\n```\n\n#### Performance Requirements\n- The function should be able to handle values up to `10^9` efficiently.\n\n#### Scenario\nYou are developing a secure messaging system that requires generating prime numbers for encryption keys. Your task is to ensure that the next prime number is found quickly and accurately.", "solution": "from math import sqrt\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\"\"\"\n    while True:\n        value += 1\n        if is_prime(value):\n            return value", "test_code": "def test_find_next_prime():\n    assert find_next_prime(10) == 11\n    assert find_next_prime(29) == 31\n    assert find_next_prime(100) == 101\n    assert find_next_prime(131) == 137\n    assert find_next_prime(1) == 2\n    assert find_next_prime(2) == 3\n    assert find_next_prime(3) == 5\n\ntest_find_next_prime()", "test_info": [{"function_name": "is_prime", "parameter_list": "(n)", "function_declaration": "def is_prime(n):", "docstring": "Check if a number is prime."}, {"function_name": "find_next_prime", "parameter_list": "(value)", "function_declaration": "def find_next_prime(value):", "docstring": "Return the smallest prime number greater than the given value."}], "gpt_pass_sequence": [1, 1, 0], "gpt_pass_trial_num": 2, "gpt_difficulty": "easy", "gpt_pass_percentage": 0.667, "metadata": {"prompt_id": "00000089", "row_id": 89, "seed_ids": [326], "mode": "algorithm", "original_instruction": ""}}}
{"messages": [{"role": "user", "content": "def interleave_strings(first_str: str, second_str: str) -> str:\n    \"\"\"Interleave the characters from two strings and return the result.\n    >>> interleave_strings(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> interleave_strings(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> interleave_strings(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> interleave_strings(\"ABC\", \"\")\n    'ABC'\n    \"\"\""}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000003_C", "question": "def interleave_strings(first_str: str, second_str: str) -> str:\n    \"\"\"Interleave the characters from two strings and return the result.\n    >>> interleave_strings(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> interleave_strings(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> interleave_strings(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> interleave_strings(\"ABC\", \"\")\n    'ABC'\n    \"\"\"", "solution": "def interleave_strings(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Interleave the characters from two strings and return the result.\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(first_str) and j < len(second_str):\n        result.append(first_str[i])\n        result.append(second_str[j])\n        i += 1\n        j += 1\n    # Append remaining characters from first_str if any\n    result.extend(first_str[i:])\n    # Append remaining characters from second_str if any\n    result.extend(second_str[j:])\n    return ''.join(result)", "test_code": "from solution import interleave_strings\n\ndef test_interleave_strings():\n    assert interleave_strings(\"ABCD\", \"XY\") == \"AXBYCD\"\n    assert interleave_strings(\"XY\", \"ABCD\") == \"XAYBCD\"\n    assert interleave_strings(\"AB\", \"XYZ\") == \"AXBYZ\"\n    assert interleave_strings(\"ABC\", \"\") == \"ABC\"\n    assert interleave_strings(\"\", \"XYZ\") == \"XYZ\"\n    assert interleave_strings(\"a\" * 100000, \"b\" * 100000) == \"ab\" * 100000\n    assert interleave_strings(\"a\" * 100000, \"\") == \"a\" * 100000\n    assert interleave_strings(\"\", \"b\" * 100000) == \"b\" * 100000\n\ndef test_performance():\n    from timeit import timeit\n    # Check if the function can handle large input within 1 second\n    large_input = \"a\" * 100000\n    assert timeit(lambda: interleave_strings(large_input, large_input), number=1) < 1", "test_info": [{"function_name": "interleave_strings", "parameter_list": "(first_str, second_str)", "function_declaration": "def interleave_strings(first_str, second_str):", "docstring": "Interleave the characters from two strings and return the result."}], "gpt_pass_sequence": [1, 0, 0], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000003", "row_id": 3, "seed_ids": [289], "mode": "algorithm", "original_instruction": "Design a function `interleave_strings` that takes two strings `first_str` and `second_str` and returns a new string where the characters from `first_str` and `second_str` are interleaved. If one string is longer, the extra characters should be appended to the end of the result string.\n\n**Function Signature**: `def interleave_strings(first_str: str, second_str: str) -> str:`\n\n**Input**:\n- `first_str` (1 <= len(first_str) <= 10^5): A string consisting of lowercase English letters.\n- `second_str` (1 <= len(second_str) <= 10^5): A string consisting of lowercase English letters.\n\n**Output**:\n- Return a single string that is the result of interleaving `first_str` and `second_str`.\n\n**Examples**:\n```python\n>>> interleave_strings(\"ABCD\", \"XY\")\n'AXBYCD'\n>>> interleave_strings(\"XY\", \"ABCD\")\n'XAYBCD'\n>>> interleave_strings(\"AB\", \"XYZ\")\n'AXBYZ'\n>>> interleave_strings(\"ABC\", \"\")\n'ABC'\n```\n\n**Constraints**:\n- The input strings contain only lowercase English letters.\n- The lengths of the input strings are between 1 and 10^5.\n\n**Performance Requirement**:\n- The function should handle the largest input size (10^5 characters) within 1 second."}}}
{"messages": [{"role": "user", "content": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid\n        else:\n            upper_bound = mid - 1\n    \n    return result"}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000004_C", "question": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid\n        else:\n            upper_bound = mid - 1\n    \n    return result", "solution": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"\n    Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid\n        else:\n            upper_bound = mid - 1\n    \n    return result", "test_code": "import pytest\n\ndef test_optimized_integer_square_root():\n    assert optimized_integer_square_root(15) == 3\n    assert optimized_integer_square_root(31) == 5\n    assert optimized_integer_square_root(25) == 5\n    assert optimized_integer_square_root(1) == 1\n    assert optimized_integer_square_root(0) == 0\n    assert optimized_integer_square_root(2_147_483_647) == 46340\n    with pytest.raises(ValueError):\n        optimized_integer_square_root(-1)", "test_info": [{"function_name": "optimized_integer_square_root", "parameter_list": "(num)", "function_declaration": "def optimized_integer_square_root(num):", "docstring": "Returns the integer square root of a non-negative integer num.\nRaises ValueError for negative inputs."}], "gpt_pass_sequence": [1, 1, 1], "gpt_pass_trial_num": 3, "gpt_difficulty": "easy", "gpt_pass_percentage": 1.0, "metadata": {"prompt_id": "00000004", "row_id": 4, "seed_ids": [691], "mode": "algorithm", "original_instruction": "You are given a Python function `integer_square_root` that calculates the integer square root of a non-negative integer using a binary search approach. Your task is to implement a more efficient version of this function. Specifically, you need to optimize the current implementation to reduce the number of iterations in the binary search while handling edge cases properly.\n\n**Function Signature**:\n```python\ndef optimized_integer_square_root(num: int) -> int:\n    pass\n```\n\n**Requirements**:\n- The function must handle non-negative integers as input and raise a `ValueError` if the input is negative.\n- The function should return the integer square root of `num` rounded down to the nearest integer.\n- The optimized version should have a time complexity of \\(O(\\log(n))\\) and use \\(O(1)\\) space complexity.\n- Implement an early return for perfect squares and optimize the bounds checking in the binary search.\n\n**Test Cases**:\n```python\nassert optimized_integer_square_root(15) == 3\nassert optimized_integer_square_root(31) == 5\nassert optimized_integer_square_root(25) == 5\nassert optimized_integer_square_root(1) == 1\nassert optimized_integer_square_root(0) == 0\nassert optimized_integer_square_root(2_147_483_647) == 46340\nassert optimized_integer_square_root(-1) is None  # Should raise ValueError\n```\n\n**Note**:\nEnsure that the edge cases and performance are handled correctly. Optimize the bounds checking and early returns to improve the efficiency of the function."}}}
{"messages": [{"role": "user", "content": "def two_sum_indices(nums: List[int], target: int) -> List[int]:\n    \"\"\" Finds the indices of the two numbers in the list that add up to the target sum using the two-pointer technique.\n    >>> two_sum_indices([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum_indices([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum_indices([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_sum_indices([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum_indices([1, 3, 3], 6)\n    [1, 2]\n    >>> two_sum_indices([2, 7, 11, 15], 8)\n    []\n    >>> two_sum_indices([3 * i for i in range(10)], 19)\n    []\n    >>> two_sum_indices([1, 2, 3], 6)\n    []\n    \"\"\""}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000005_C", "question": "def two_sum_indices(nums: List[int], target: int) -> List[int]:\n    \"\"\" Finds the indices of the two numbers in the list that add up to the target sum using the two-pointer technique.\n    >>> two_sum_indices([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum_indices([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum_indices([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_sum_indices([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum_indices([1, 3, 3], 6)\n    [1, 2]\n    >>> two_sum_indices([2, 7, 11, 15], 8)\n    []\n    >>> two_sum_indices([3 * i for i in range(10)], 19)\n    []\n    >>> two_sum_indices([1, 2, 3], 6)\n    []\n    \"\"\"", "solution": "def two_sum_indices(nums, target):\n    \"\"\"\n    Returns the indices of the two numbers in nums that add up to target.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "test_code": "def test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()", "test_info": [{"function_name": "two_sum_indices", "parameter_list": "(nums, target)", "function_declaration": "def two_sum_indices(nums, target):", "docstring": "Returns the indices of the two numbers in nums that add up to target."}], "gpt_pass_sequence": [1, 0, 0], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000005", "row_id": 5, "seed_ids": [716], "mode": "algorithm", "original_instruction": "### Scenario\n\nYou are given a sorted list of integers and a target sum. Your task is to implement a function that finds the indices of the two numbers in the list that add up to the target sum using the two-pointer technique.\n\n### Requirements\n\n- **Function Name**: `two_sum_indices`\n- **Input**:\n  - A list of integers, `nums`, which is sorted in non-decreasing order.\n  - An integer, `target`, representing the target sum.\n- **Output**:\n  - Return a list of two integers, representing the indices of the two numbers in `nums` that add up to `target`. If no such pair exists, return an empty list.\n\n### Constraints\n\n- The length of `nums` will be in the range \\([2, 10^4]\\).\n- The elements of `nums` will be in the range \\([-10^9, 10^9]\\).\n- There will be exactly one solution, and you may not use the same element twice.\n- `nums` is sorted in non-decreasing order.\n\n### Example\n\n```python\ndef test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()\n```\n\n### Performance Requirements\n\nThe function should run efficiently, with a time complexity of \\(O(n)\\) and a space complexity of \\(O(1)\\).\n\n### Question\n\nImplement the `two_sum_indices` function."}}}
{"messages": [{"role": "user", "content": "def detect_cycle(linked_list: LinkedList) -> bool:\n    \"\"\"Returns True if a cycle exists in the linked list using Floyd's cycle detection algorithm.\n    >>> detect_cycle(LinkedList())\n    False\n    >>> detect_cycle_from_solution()\n    True\n    \"\"\""}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000008_C", "question": "def detect_cycle(linked_list: LinkedList) -> bool:\n    \"\"\"Returns True if a cycle exists in the linked list using Floyd's cycle detection algorithm.\n    >>> detect_cycle(LinkedList())\n    False\n    >>> detect_cycle_from_solution()\n    True\n    \"\"\"", "solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next_node = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def add_node(self, value):\n        if not self.head:\n            self.head = Node(value)\n        else:\n            current = self.head\n            while current.next_node:\n                current = current.next_node\n            current.next_node = Node(value)\n\ndef detect_cycle(linked_list: LinkedList) -> bool:\n    \"\"\"\n    Returns True if a cycle exists in the linked list using Floyd's cycle detection algorithm.\n    \"\"\"\n    if not linked_list.head:\n        return False\n\n    slow = linked_list.head\n    fast = linked_list.head\n\n    while fast and fast.next_node:\n        slow = slow.next_node\n        fast = fast.next_node.next_node\n        if slow == fast:\n            return True\n\n    return False", "test_code": "from solution import Node, LinkedList, detect_cycle\n\ndef test_detect_cycle_with_cycle():\n    linked_list = LinkedList()\n    linked_list.add_node(1)\n    linked_list.add_node(2)\n    linked_list.add_node(3)\n    linked_list.add_node(4)\n\n    # Create a cycle in the linked list\n    linked_list.head.next_node.next_node.next_node = linked_list.head.next_node\n\n    assert detect_cycle(linked_list) == True\n\ndef test_detect_cycle_with_no_cycle_one_node():\n    linked_list = LinkedList()\n    linked_list.add_node(1)\n\n    assert detect_cycle(linked_list) == False\n\ndef test_detect_cycle_with_no_cycle_two_nodes():\n    linked_list = LinkedList()\n    linked_list.add_node(1)\n    linked_list.add_node(2)\n    linked_list.head.next_node.next_node = None  # Break the cycle\n\n    assert detect_cycle(linked_list) == False\n\ndef test_detect_cycle_empty_list():\n    linked_list = LinkedList()\n\n    assert detect_cycle(linked_list) == False\n\ndef test_detect_cycle_with_cycle_in_middle():\n    linked_list = LinkedList()\n    linked_list.add_node(1)\n    linked_list.add_node(2)\n    linked_list.add_node(3)\n    linked_list.add_node(4)\n    linked_list.head.next_node.next_node.next_node.next_node = linked_list.head.next_node\n\n    assert detect_cycle(linked_list) == True\n\ndef test_detect_cycle_with_cycle_at_end():\n    linked_list = LinkedList()\n    linked_list.add_node(1)\n    linked_list.add_node(2)\n    linked_list.add_node(3)\n    linked_list.add_node(4)\n    linked_list.head.next_node.next_node.next_node.next_node = linked_list.head.next_node\n\n    assert detect_cycle(linked_list) == True", "test_info": null, "gpt_pass_sequence": [1, 1, 1], "gpt_pass_trial_num": 3, "gpt_difficulty": "easy", "gpt_pass_percentage": 1.0, "metadata": {"prompt_id": "00000008", "row_id": 8, "seed_ids": [327], "mode": "algorithm", "original_instruction": "You are given a singly linked list, and your task is to implement a function `detect_cycle` that detects whether a cycle exists in the linked list using Floyd's cycle detection algorithm.\n\n#### Function Signature\n\n```python\ndef detect_cycle(linked_list: LinkedList) -> bool:\n    pass\n```\n\n#### Input\n- `linked_list` (LinkedList): A singly linked list instance.\n\n#### Output\n- `bool`: `True` if a cycle exists in the linked list, otherwise `False`.\n\n#### Constraints\n- The linked list can contain up to \\(10^5\\) nodes.\n- Each node's data is an integer ranging from \\(-10^6\\) to \\(10^6\\).\n\n#### Performance Requirements\n- The function should run in \\(O(n)\\) time complexity.\n- The function should use \\(O(1)\\) space complexity.\n\n#### Example\n\n```python\nlinked_list = LinkedList()\nlinked_list.add_node(1)\nlinked_list.add_node(2)\nlinked_list.add_node(3)\nlinked_list.add_node(4)\n\n# Create a cycle in the linked list\nlinked_list.head.next_node.next_node.next_node = linked_list.head.next_node\n\nassert detect_cycle(linked_list) == True\n\nlinked_list2 = LinkedList()\nlinked_list2.add_node(1)\n\nassert detect_cycle(linked_list2) == False\n```\n\n### Additional Requirements\n\n- Ensure your implementation handles edge cases such as an empty list and a list with only one node.\n- Avoid any potential type errors by checking for `None` values before accessing `next_node`."}}}
{"messages": [{"role": "user", "content": "def fibonacci_iterative(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using iteration.\n    >>> fibonacci_iterative(0)\n    0\n    >>> fibonacci_iterative(1)\n    1\n    >>> fibonacci_iterative(2)\n    1\n    >>> fibonacci_iterative(10)\n    55\n    >>> fibonacci_iterative(20)\n    6765\n    \"\"\"\ndef fibonacci_recursive(n: int, memo={}) -> int:\n    \"\"\"Returns the n-th Fibonacci number using recursion with memoization.\n    >>> fibonacci_recursive(0)\n    0\n    >>> fibonacci_recursive(1)\n    1\n    >>> fibonacci_recursive(2)\n    1\n    >>> fibonacci_recursive(10)\n    55\n    >>> fibonacci_recursive(20)\n    6765\n    \"\"\"\ndef fibonacci_binets(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using Binet's formula.\n    >>> fibonacci_binets(0)\n    0\n    >>> fibonacci_binets(1)\n    1\n    >>> fibonacci_binets(2)\n    1\n    >>> fibonacci_binets(10)\n    55\n    >>> fibonacci_binets(20)\n    6765\n    \"\"\"\ndef fibonacci_matrix(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using matrix exponentiation.\n    >>> fibonacci_matrix(0)\n    0\n    >>> fibonacci_matrix(1)\n    1\n    >>> fibonacci_matrix(2)\n    1\n    >>> fibonacci_matrix(10)\n    55\n    >>> fibonacci_matrix(20)\n    6765\n    >>> fibonacci_matrix(50)\n    12586269025\n    \"\"\""}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000025_C", "question": "def fibonacci_iterative(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using iteration.\n    >>> fibonacci_iterative(0)\n    0\n    >>> fibonacci_iterative(1)\n    1\n    >>> fibonacci_iterative(2)\n    1\n    >>> fibonacci_iterative(10)\n    55\n    >>> fibonacci_iterative(20)\n    6765\n    \"\"\"\ndef fibonacci_recursive(n: int, memo={}) -> int:\n    \"\"\"Returns the n-th Fibonacci number using recursion with memoization.\n    >>> fibonacci_recursive(0)\n    0\n    >>> fibonacci_recursive(1)\n    1\n    >>> fibonacci_recursive(2)\n    1\n    >>> fibonacci_recursive(10)\n    55\n    >>> fibonacci_recursive(20)\n    6765\n    \"\"\"\ndef fibonacci_binets(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using Binet's formula.\n    >>> fibonacci_binets(0)\n    0\n    >>> fibonacci_binets(1)\n    1\n    >>> fibonacci_binets(2)\n    1\n    >>> fibonacci_binets(10)\n    55\n    >>> fibonacci_binets(20)\n    6765\n    \"\"\"\ndef fibonacci_matrix(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using matrix exponentiation.\n    >>> fibonacci_matrix(0)\n    0\n    >>> fibonacci_matrix(1)\n    1\n    >>> fibonacci_matrix(2)\n    1\n    >>> fibonacci_matrix(10)\n    55\n    >>> fibonacci_matrix(20)\n    6765\n    >>> fibonacci_matrix(50)\n    12586269025\n    \"\"\"", "solution": "def fibonacci_iterative(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using iteration.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\ndef fibonacci_recursive(n, memo={}):\n    \"\"\"\n    Returns the n-th Fibonacci number using recursion with memoization.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_recursive(n - 1, memo) + fibonacci_recursive(n - 2, memo)\n    return memo[n]\n\ndef fibonacci_binets(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using Binet's formula.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    phi = (1 + 5**0.5) / 2\n    return int((phi**n - (-phi)**(-n)) / 5**0.5)\n\ndef fibonacci_matrix(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using matrix exponentiation.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    if n == 0:\n        return 0\n    fib_matrix = [[1, 1], [1, 0]]\n    result = matrix_pow(fib_matrix, n - 1)\n    return result[0][0]\n\ndef matrix_pow(matrix, n):\n    \"\"\"\n    Raises a 2x2 matrix to the power of n using exponentiation by squaring.\n    \"\"\"\n    result = [[1, 0], [0, 1]]  # Identity matrix\n    base = matrix\n    while n:\n        if n % 2:\n            result = matrix_multiply(result, base)\n        base = matrix_multiply(base, base)\n        n //= 2\n    return result\ndef matrix_multiply(a, b):\n    \"\"\"\n    Multiplies two 2x2 matrices.\n    \"\"\"\n    return [[a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n            [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]]]", "test_code": "import pytest\nfrom solution import (\n    fibonacci_iterative, \n    fibonacci_recursive, \n    fibonacci_binets, \n    fibonacci_matrix\n)\n\ndef test_fibonacci_iterative():\n    assert fibonacci_iterative(0) == 0\n    assert fibonacci_iterative(1) == 1\n    assert fibonacci_iterative(2) == 1\n    assert fibonacci_iterative(10) == 55\n    assert fibonacci_iterative(20) == 6765\n\ndef test_fibonacci_recursive():\n    assert fibonacci_recursive(0) == 0\n    assert fibonacci_recursive(1) == 1\n    assert fibonacci_recursive(2) == 1\n    assert fibonacci_recursive(10) == 55\n    assert fibonacci_recursive(20) == 6765\n\ndef test_fibonacci_binets():\n    assert fibonacci_binets(0) == 0\n    assert fibonacci_binets(1) == 1\n    assert fibonacci_binets(2) == 1\n    assert fibonacci_binets(10) == 55\n    assert fibonacci_binets(20) == 6765\n\ndef test_fibonacci_matrix():\n    assert fibonacci_matrix(0) == 0\n    assert fibonacci_matrix(1) == 1\n    assert fibonacci_matrix(2) == 1\n    assert fibonacci_matrix(10) == 55\n    assert fibonacci_matrix(20) == 6765\n\ndef test_large_input_fibonacci_matrix():\n    assert fibonacci_matrix(50) == 12586269025\n\ndef test_negative_input():\n    with pytest.raises(ValueError):\n        fibonacci_iterative(-1)\n    with pytest.raises(ValueError):\n        fibonacci_recursive(-1)\n    with pytest.raises(ValueError):\n        fibonacci_binets(-1)\n    with pytest.raises(ValueError):\n        fibonacci_matrix(-1)", "test_info": [{"function_name": "fibonacci_iterative", "parameter_list": "(n)", "function_declaration": "def fibonacci_iterative(n):", "docstring": "Returns the n-th Fibonacci number using iteration."}, {"function_name": "fibonacci_recursive", "parameter_list": "(n, memo={})", "function_declaration": "def fibonacci_recursive(n, memo={}):", "docstring": "Returns the n-th Fibonacci number using recursion with memoization."}, {"function_name": "fibonacci_binets", "parameter_list": "(n)", "function_declaration": "def fibonacci_binets(n):", "docstring": "Returns the n-th Fibonacci number using Binet's formula."}, {"function_name": "fibonacci_matrix", "parameter_list": "(n)", "function_declaration": "def fibonacci_matrix(n):", "docstring": "Returns the n-th Fibonacci number using matrix exponentiation."}, {"function_name": "matrix_pow", "parameter_list": "(matrix, n)", "function_declaration": "def matrix_pow(matrix, n):", "docstring": "Raises a 2x2 matrix to the power of n using exponentiation by squaring."}, {"function_name": "matrix_multiply", "parameter_list": "(a, b)", "function_declaration": "def matrix_multiply(a, b):", "docstring": "Multiplies two 2x2 matrices."}], "gpt_pass_sequence": [0, 0, 1], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000025", "row_id": 25, "seed_ids": [699], "mode": "algorithm", "original_instruction": "<|Analysis Begin|>\n\n### Algorithm/Data Structure\n\n**Name and Type**: The provided code snippets demonstrate the calculation of Fibonacci numbers using several methods: iteration, recursion, memoization, and a simplified form of Binet's formula. Additionally, a matrix exponentiation method is used, which is a more advanced technique.\n\n**Core Operational Steps**:\n- **Iteration**: Uses a loop to iterate and calculate the Fibonacci sequence.\n- **Recursion**: Recursively calculates the Fibonacci sequence by dividing the problem into smaller subproblems.\n- **Memoization**: Stores the results of expensive function calls and reuses them when the same inputs occur again.\n- **Binet's Formula**: Uses mathematical formulas to calculate Fibonacci numbers, which is efficient but limited by floating-point precision.\n- **Matrix Exponentiation**: Utilizes matrix multiplication to compute the Fibonacci sequence, which is highly efficient for larger values of \\( n \\).\n\n**Time Complexity**:\n- **Iteration**: \\( O(n) \\)\n- **Recursion**: \\( O(2^n) \\) (without memoization), \\( O(n) \\) (with memoization)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(\\log n) \\)\n\n**Space Complexity**:\n- **Iteration**: \\( O(1) \\) (excluding the output list)\n- **Recursion**: \\( O(n) \\) (due to the call stack)\n- **Memoization**: \\( O(n) \\) (for storing intermediate results)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(1) \\) (excluding the output)\n\n### Characteristics & Applications\n\n**Properties**:\n- **Iteration**: Simple and easy to understand, but not efficient for large \\( n \\) due to its linear time complexity.\n- **Recursion**: Can lead to stack overflow for large \\( n \\) and is inefficient, but useful for teaching recursion.\n- **Memoization**: Efficient for large \\( n \\) and avoids redundant calculations, making it a good balance between speed and memory usage.\n- **Binet's Formula**: Efficient but limited by floating-point precision, making it less accurate for large values.\n- **Matrix Exponentiation**: Extremely efficient for very large \\( n \\) but requires understanding of matrix operations and logarithmic time complexity.\n\n**Common Use Cases**:\n- **Iteration**: Useful for small values of \\( n \\) where simplicity is preferred.\n- **Recursion**: Often used in teaching recursion, but not suitable for large \\( n \\).\n- **Memoization**: Good for practical applications where performance is critical and \\( n \\) is large.\n- **Binet's Formula**: Used in contexts where a quick, approximate solution is sufficient.\n- **Matrix Exponentiation**: Ideal for large \\( n \\) in performance-critical applications.\n\n**Strengths/Limitations**:\n- **Iteration**: Simple to implement, but inefficient for large \\( n \\).\n- **Recursion**: Elegant and easy to understand, but inefficient and prone to stack overflow.\n- **Memoization**: Efficient and avoids redundant calculations, but requires additional memory.\n- **Binet's Formula**: Fast but limited by floating-point precision, making it less accurate for large \\( n \\).\n- **Matrix Exponentiation**: Highly efficient with \\( O(\\log n) \\) time complexity but requires understanding of matrix operations.\n\n### Implementation Challenges\n\n**Edge Cases**:\n- **Negative Input**: All methods except the iterative yield version raise a `ValueError` for negative inputs.\n- **Large Input**: Binet's formula and matrix exponentiation have limitations for very large inputs due to floating-point precision and time complexity, respectively.\n\n**Performance Bottlenecks**:\n- **Recursion**: High stack usage and inefficiency, leading to stack overflow for large \\( n \\).\n- **Memoization**: Requires additional memory to"}}}
{"messages": [{"role": "user", "content": "def generate_all_subsequences(sequence: List[int]) -> None:\n    \"\"\"\n    Generates and prints all possible subsequences of the given sequence using a backtracking algorithm.\n    \n    :param sequence: A list of integers.\n    \"\"\"\n    def backtrack(start, current):\n        print(current)\n        for i in range(start, len(sequence)):\n            # Add the element at index i to the current subsequence\n            current.append(sequence[i])\n            # Recurse with the next element\n            backtrack(i + 1, current.copy())  # Use copy to avoid modifying the same subsequence\n            # Remove the last element to explore other subsequences\n            current.pop()\n    \n    backtrack(0, [])\n\nsequence = [1, 2, 3]\ngenerate_all_subsequences(sequence)"}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000038_C", "question": "def generate_all_subsequences(sequence: List[int]) -> None:\n    \"\"\"\n    Generates and prints all possible subsequences of the given sequence using a backtracking algorithm.\n    \n    :param sequence: A list of integers.\n    \"\"\"\n    def backtrack(start, current):\n        print(current)\n        for i in range(start, len(sequence)):\n            # Add the element at index i to the current subsequence\n            current.append(sequence[i])\n            # Recurse with the next element\n            backtrack(i + 1, current.copy())  # Use copy to avoid modifying the same subsequence\n            # Remove the last element to explore other subsequences\n            current.pop()\n    \n    backtrack(0, [])\n\nsequence = [1, 2, 3]\ngenerate_all_subsequences(sequence)", "solution": "from typing import List\n\ndef generate_all_subsequences(sequence: List[int]) -> None:\n    \"\"\"\n    Generates and prints all possible subsequences of the given sequence using a backtracking algorithm.\n    \n    :param sequence: A list of integers.\n    \"\"\"\n    def backtrack(start, current):\n        print(current)\n        for i in range(start, len(sequence)):\n            # Add the element at index i to the current subsequence\n            current.append(sequence[i])\n            # Recurse with the next element\n            backtrack(i + 1, current.copy())  # Use copy to avoid modifying the same subsequence\n            # Remove the last element to explore other subsequences\n            current.pop()\n    \n    backtrack(0, [])\n\nsequence = [1, 2, 3]\ngenerate_all_subsequences(sequence)", "test_code": "from solution import generate_all_subsequences\n\ndef test_generate_all_subsequences():\n    # Test with a single element\n    generate_all_subsequences([1])\n    assert True  # No assertion is needed, as the function should print the subsequence correctly\n\n    # Test with multiple elements\n    expected_output = ['[]', '[1]', '[1, 2]', '[1, 2, 3]', '[1, 3]', '[2]', '[2, 3]', '[3]']\n    sequence = [1, 2, 3]\n    captured_output = {}\n    import sys\n    original_stdout = sys.stdout\n    with open('output.txt', 'w') as f:\n        sys.stdout = f\n        generate_all_subsequences(sequence)\n    sys.stdout = original_stdout\n    with open('output.txt', 'r') as f:\n        lines = f.readlines()\n        captured_output = [line.strip() for line in lines]\n    assert captured_output == expected_output\n\ntest_generate_all_subsequences()", "test_info": [{"function_name": "generate_all_subsequences", "parameter_list": "(sequence)", "function_declaration": "def generate_all_subsequences(sequence):", "docstring": "Generates and prints all possible subsequences of the given sequence using a backtracking algorithm.\n\n:param sequence: A list of integers."}, {"function_name": "backtrack", "parameter_list": "(start, current)", "function_declaration": "def backtrack(start, current):", "docstring": null}], "gpt_pass_sequence": [1, 1, 1], "gpt_pass_trial_num": 3, "gpt_difficulty": "easy", "gpt_pass_percentage": 1.0, "metadata": {"prompt_id": "00000038", "row_id": 38, "seed_ids": [167], "mode": "algorithm", "original_instruction": "**Problem Statement**:\nYou are given a sequence of integers. Your task is to implement a function to generate all possible subsequences of the given sequence using a backtracking algorithm. The function should print each subsequence in a separate line.\n\n**Input**:\n- A non-empty list of integers, `sequence`, where the length of the list is between 1 and 10 (inclusive).\n\n**Output**:\n- Print all possible subsequences of the given sequence, each on a new line. Ensure that the subsequences are printed in lexicographical order.\n\n**Example**:\n```python\nsequence = [1, 2, 3]\nOutput:\n[]\n[1]\n[1, 2]\n[1, 2, 3]\n[1, 3]\n[2]\n[2, 3]\n[3]\n```\n\n**Constraints**:\n- The length of `sequence` is between 1 and 10.\n- The elements in `sequence` are integers between 1 and 100.\n\n**Performance Requirement**:\n- Your solution should run efficiently for sequences of length up to 10.\n\n**Implementation**:\nImplement the function to generate and print all possible subsequences of the given sequence.\n\n```python\ndef generate_all_subsequences(sequence: List[int]) -> None:\n    \"\"\"\n    Generates and prints all possible subsequences of the given sequence using a backtracking algorithm.\n    \n    :param sequence: A list of integers.\n    \"\"\"\n    # Your implementation here\n```"}}}
{"messages": [{"role": "user", "content": "def quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm.\n    \n    :param arr: A list of integers to be sorted.\n    \"\"\""}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000041_C", "question": "def quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm.\n    \n    :param arr: A list of integers to be sorted.\n    \"\"\"", "solution": "def quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm with an in-place median-of-three pivot selection.\n    \"\"\"\n    def partition(low, high):\n        # Choosing the median of the first, middle, and last elements as the pivot\n        mid = (low + high) // 2\n        pivot_candidates = [arr[low], arr[mid], arr[high]]\n        pivot_candidates.sort()\n        pivot_value = pivot_candidates[1]\n\n        # Move the pivot to the end for partitioning\n        pivot_index = arr.index(pivot_value)\n        arr[pivot_index], arr[high] = arr[high], arr[pivot_index]\n        pivot_index = high\n\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot_value:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[pivot_index] = arr[pivot_index], arr[i + 1]\n        return i + 1\n\n    def _quick_sort(low, high):\n        if low < high:\n            pi = partition(low, high)\n            _quick_sort(low, pi - 1)\n            _quick_sort(pi + 1, high)\n\n    _quick_sort(0, len(arr) - 1)", "test_code": "import random\n\ndef quick_sort_in_place(arr):\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm with an in-place median-of-three pivot selection.\n    \"\"\"\n    def partition(low, high):\n        mid = (low + high) // 2\n        pivot_candidates = [arr[low], arr[mid], arr[high]]\n        pivot_candidates.sort()\n        pivot_value = pivot_candidates[1]\n        pivot_index = arr.index(pivot_value)\n        arr[pivot_index], arr[high] = arr[high], arr[pivot_index]\n        pivot_index = high\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot_value:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[pivot_index] = arr[pivot_index], arr[i + 1]\n        return i + 1\n\n    def _quick_sort(low, high):\n        if low < high:\n            pi = partition(low, high)\n            _quick_sort(low, pi - 1)\n            _quick_sort(pi + 1, high)\n\n    _quick_sort(0, len(arr) - 1)\n\n# Test Cases\ndef test_quick_sort_in_place():\n    arr = [10, 5, 2, 3, 7, 6, 8, 4, 9, 1]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    arr = [1, 2, 3, 4, 5]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5]\n\n    arr = [5, 4, 3, 2, 1]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5]\n\n    arr = []\n    quick_sort_in_place(arr)\n    assert arr == []\n\n    arr = [random.randint(-1000, 1000) for _ in range(10000)]\n    quick_sort_in_place(arr)\n    assert arr == sorted(arr)\n\ntest_quick_sort_in_place()", "test_info": [{"function_name": "quick_sort_in_place", "parameter_list": "(arr)", "function_declaration": "def quick_sort_in_place(arr):", "docstring": "Sorts the given list arr in-place using the quick sort algorithm with an in-place median-of-three pivot selection."}, {"function_name": "partition", "parameter_list": "(low, high)", "function_declaration": "def partition(low, high):", "docstring": null}, {"function_name": "_quick_sort", "parameter_list": "(low, high)", "function_declaration": "def _quick_sort(low, high):", "docstring": null}], "gpt_pass_sequence": [1, 1, 0], "gpt_pass_trial_num": 2, "gpt_difficulty": "easy", "gpt_pass_percentage": 0.667, "metadata": {"prompt_id": "00000041", "row_id": 41, "seed_ids": [233], "mode": "algorithm", "original_instruction": "You are given a list of integers and are required to implement a quick sort algorithm. The provided code uses a simple random pivot selection and does not handle in-place sorting. Your task is to enhance the given implementation to achieve the following:\n\n1. Implement quick sort as an in-place sorting algorithm.\n2. Handle edge cases such as empty lists, single-element lists, and nearly sorted lists.\n3. Improve the pivot selection strategy to avoid worst-case performance.\n\n#### Function Signature\n\n```python\ndef quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm.\n\n    :param arr: A list of integers to be sorted.\n    \"\"\"\n```\n\n#### Constraints\n\n- \\(1 \\leq len(arr) \\leq 10^5\\)\n- Elements of `arr` are integers in the range \\([-10^3, 10^3]\\)\n\n#### Example\n\n```python\narr = [10, 5, 2, 3, 7, 6, 8, 4, 9, 1]\nquick_sort_in_place(arr)\nprint(arr)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n### Notes\n\n- You should modify the provided `quick_sort` function to work in-place.\n- Ensure that the function can handle edge cases such as already sorted or nearly sorted arrays.\n- Use a more sophisticated pivot selection strategy, such as the \"median-of-three\" pivot to improve performance.\n\n#### Performance Requirements\n\n- The algorithm should achieve an average-case time complexity of \\(O(n \\log n)\\)."}}}
{"messages": [{"role": "user", "content": "def enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result"}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000051_C", "question": "def enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result", "solution": "from typing import List, Optional\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result", "test_code": "import pytest\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n\ndef test_enhanced_inorder_traversal_single_node():\n    root = BinaryTreeNode(10)\n    assert enhanced_inorder_traversal(root) == [10]\n\ndef test_enhanced_inorder_traversal_empty_tree():\n    assert enhanced_inorder_traversal(None) == []\n\ndef test_enhanced_inorder_traversal_balanced_tree():\n    tree = make_tree()\n    assert enhanced_inorder_traversal(tree) == [6, 10, 14, 15, 20, 25, 60]\n\ndef test_enhanced_inorder_traversal_degenerate_tree():\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    assert enhanced_inorder_traversal(root) == [10, 15, 25]\n\ndef test_enhanced_inorder_traversal_negative_numbers():\n    root = BinaryTreeNode(-10)\n    root.left_child = BinaryTreeNode(-20)\n    root.right_child = BinaryTreeNode(-5)\n    root.left_child.left_child = BinaryTreeNode(-30)\n    root.left_child.right_child = BinaryTreeNode(-15)\n    assert enhanced_inorder_traversal(root) == [-30, -20, -15, -10, -5]", "test_info": null, "gpt_pass_sequence": [0, 1, 0], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000051", "row_id": 51, "seed_ids": [358], "mode": "algorithm", "original_instruction": "### Scenario\nYou are working on a project where you need to efficiently traverse a large Binary Search Tree (BST) and output the values in sorted order. Given the provided code snippet, you have been tasked with implementing an enhanced version of the inorder traversal.\n\n### Requirements\n1. **Function Specification**:\n    - Implement a function `enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]` that performs an inorder traversal on a given BST.\n    - The function should return a list of integers representing the values of the nodes in sorted order.\n2. **Input**:\n    - `root: BinaryTreeNode | None`: The root node of a BST. If `None`, the function should return an empty list.\n3. **Output**:\n    - A list of integers representing the values of the nodes in sorted order.\n4. **Constraints**:\n    - The maximum number of nodes in the tree is \\(10^5\\).\n    - The value of each node is an integer within the range \\([-10^9, 10^9]\\).\n5. **Optimization**:\n    - Use an iterative approach to avoid potential stack overflow issues with deep trees.\n    - Ensure the solution is efficient and handles edge cases properly.\n\n### Example\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\n# Function to test the solution\ndef check_solution(func):\n    tree = make_tree()\n    result = func(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n    print(\"Solution is correct.\")\n\n# Test the function\ncheck_solution(enhanced_inorder_traversal)\n```\n\n### Note\nEnsure your implementation is efficient and handles edge cases such as an empty tree or very deep trees. Use an iterative approach to avoid stack overflow issues."}}}
{"messages": [{"role": "user", "content": "def find_next_power_of_two(number: int) -> int:\n    \"\"\"\n    Returns the smallest power of two greater than the given non-negative integer.\n    If the input is 0, returns 1.\n    >>> find_next_power_of_two(0) == 1\n    >>> find_next_power_of_two(1) == 2\n    >>> find_next_power_of_two(15) == 16\n    >>> find_next_power_of_two(16) == 32\n    \"\"\""}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000052_C", "question": "def find_next_power_of_two(number: int) -> int:\n    \"\"\"\n    Returns the smallest power of two greater than the given non-negative integer.\n    If the input is 0, returns 1.\n    >>> find_next_power_of_two(0) == 1\n    >>> find_next_power_of_two(1) == 2\n    >>> find_next_power_of_two(15) == 16\n    >>> find_next_power_of_two(16) == 32\n    \"\"\"", "solution": "def find_next_power_of_two(number: int) -> int:\n    \"\"\"\n    Returns the smallest power of two greater than the given non-negative integer.\n    If the input is 0, returns 1.\n    \"\"\"\n    if number == 0:\n        return 1\n    power = 1\n    while power <= number:\n        power *= 2\n    return power", "test_code": "import pytest\n\ndef test_find_next_power_of_two():\n    assert find_next_power_of_two(0) == 1\n    assert find_next_power_of_two(1) == 2\n    assert find_next_power_of_two(15) == 16\n    assert find_next_power_of_two(16) == 32\n    assert find_next_power_of_two(1023) == 1024\n    assert find_next_power_of_two(1024) == 2048\n    assert find_next_power_of_two(1048575) == 1048576\n    assert find_next_power_of_two(1048576) == 2097152\n    pytest.approx(find_next_power_of_two(999999999), 2_000_000_000)", "test_info": [{"function_name": "find_next_power_of_two", "parameter_list": "(number)", "function_declaration": "def find_next_power_of_two(number):", "docstring": "Returns the smallest power of two greater than the given non-negative integer.\nIf the input is 0, returns 1."}], "gpt_pass_sequence": [0, 1, 0], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000052", "row_id": 52, "seed_ids": [1050], "mode": "algorithm", "original_instruction": "You are tasked with extending the functionality of a given function to not only find the largest power of two less than or equal to a given non-negative integer but also to handle an additional constraint: finding the smallest power of two greater than a given non-negative integer. This new function will be used in scenarios where binary allocations or specific power levels are required.\n\n**Function Signature**: `def find_next_power_of_two(number: int) -> int:`\n\n**Input and Output**:\n- **Input**: A single non-negative integer `number`.\n- **Output**: The smallest power of two greater than the given integer. If the input is 0, return 1.\n\n**Constraints**:\n- The input number will be in the range \\(0 \\leq \\text{number} \\leq 10^9\\).\n\n**Performance Requirements**:\n- The function should be efficient and handle the constraints within a reasonable time.\n\n**Scenario**:\nImagine you are working on a system where you need to allocate memory in the form of powers of two. You have a function to allocate memory based on the smallest power of two greater than a given request size. For example, if a request is for 5 units of memory, the system should allocate 8 units (2^3).\n\n**Example**:\n```python\nassert find_next_power_of_two(0) == 1\nassert find_next_power_of_two(1) == 2\nassert find_next_power_of_two(15) == 16\nassert find_next_power_of_two(16) == 32\n```\n\n**Note**:\n- You are not allowed to use any built-in functions or libraries for calculating powers of two.\n- The function should handle edge cases as described in the constraints."}}}
{"messages": [{"role": "user", "content": "from typing import List, Optional\n\ndef find_peak(lst: List[int]) -> Optional[int]:\n    \"\"\"\n    Returns the peak element in a unimodal list. If the list does not follow the unimodal pattern, returns None.\n    \"\"\""}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000054_C", "question": "from typing import List, Optional\n\ndef find_peak(lst: List[int]) -> Optional[int]:\n    \"\"\"\n    Returns the peak element in a unimodal list. If the list does not follow the unimodal pattern, returns None.\n    \"\"\"", "solution": "from typing import List, Optional\n\ndef find_peak(lst: List[int]) -> Optional[int]:\n    \"\"\"\n    Returns the peak element in a unimodal list. If the list does not follow the unimodal pattern, returns None.\n    \"\"\"\n    if not lst:\n        return None\n    \n    left, right = 0, len(lst) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if lst[mid] < lst[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return lst[left]", "test_code": "import pytest\n\ndef test_find_peak():\n    assert find_peak([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5\n    assert find_peak([1, 10, 9, 8, 7, 6, 5, 4]) == 10\n    assert find_peak([1, 9, 8, 7]) == 9\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 0]) == 7\n    assert find_peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2]) == 4\n    assert find_peak([1, 2, 2, 1, 0, -1, -2]) == 2\n    assert find_peak([1, 1]) == 1\n    assert find_peak([1]) == 1\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10]) == 12\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10, 9]) == 12\n    assert find_peak([]) is None\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 10\n    assert find_peak([1, 2, 2, 2, 2, 2, 1]) == 2\n\ndef test_edge_cases():\n    assert find_peak([1]) == 1\n    assert find_peak([1, 2]) == 2\n    assert find_peak([2, 1]) == 2\n    assert find_peak([1, 1]) == 1", "test_info": [{"function_name": "find_peak", "parameter_list": "(lst)", "function_declaration": "def find_peak(lst):", "docstring": "Returns the peak element in a unimodal list. If the list does not follow the unimodal pattern, returns None."}], "gpt_pass_sequence": [0, 0, 1], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000054", "row_id": 54, "seed_ids": [942], "mode": "algorithm", "original_instruction": "**Scenario**: You are given a list of integers, and you need to find the peak element in the list, which is the maximum value in a unimodal list. A unimodal list is defined as a list that increases to a point and then decreases. If the input list does not strictly follow this pattern, the function should return `None`.\n\n**Function Signature**:\n```python\ndef find_peak(lst: List[int]) -> Optional[int]:\n    pass\n```\n\n**Input**:\n- The function takes a list of integers `lst`.\n\n**Output**:\n- The function returns the peak element of the list as an integer. If the list does not follow the unimodal pattern, the function should return `None`.\n\n**Constraints**:\n- \\(1 \\leq \\text{len}(lst) \\leq 10^6\\)\n- The list can contain duplicate values.\n\n**Performance Requirement**:\n- The function should be efficient, aiming for a time complexity of \\(O(\\log n)\\) where \\(n\\) is the length of the list.\n\n**Example**:\n```python\n>>> find_peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n5\n>>> find_peak([1, 10, 9, 8, 7, 6, 5, 4])\n10\n>>> find_peak([1, 9, 8, 7])\n9\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 0])\n7\n>>> find_peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n4\n>>> find_peak([1, 2, 2, 1, 0, -1, -2])\n2\n>>> find_peak([1, 1])\n1\n>>> find_peak([1])\n1\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10])\n12\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10, 9])\n12\n```\n\n**Note**: Ensure that your implementation handles edge cases correctly and efficiently."}}}
{"messages": [{"role": "user", "content": "def generate_gray_code(bit_count: int) -> List[int]:\n    \"\"\"\n    Generates an n-bit Gray code sequence.\n    \"\"\""}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000056_C", "question": "def generate_gray_code(bit_count: int) -> List[int]:\n    \"\"\"\n    Generates an n-bit Gray code sequence.\n    \"\"\"", "solution": "from typing import List\n\ndef generate_gray_code(bit_count: int) -> List[int]:\n    \"\"\"\n    Generates an n-bit Gray code sequence.\n    \"\"\"\n    if not isinstance(bit_count, int) or bit_count <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    gray_code = [0]\n    for i in range(bit_count):\n        gray_code += [x + 2**i for x in reversed(gray_code)]\n    \n    return gray_code", "test_code": "import pytest\nfrom typing import List\n\ndef test_generate_gray_code():\n    assert generate_gray_code(2) == [0, 1, 3, 2]\n    assert generate_gray_code(1) == [0, 1]\n    assert generate_gray_code(3) == [0, 1, 3, 2, 6, 7, 5, 4]\n    assert generate_gray_code(4) == [0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8]\n\ndef test_invalid_input():\n    with pytest.raises(ValueError):\n        generate_gray_code(0)\n    with pytest.raises(ValueError):\n        generate_gray_code(-1)\n    with pytest.raises(ValueError):\n        generate_gray_code(3.5)", "test_info": [{"function_name": "generate_gray_code", "parameter_list": "(bit_count)", "function_declaration": "def generate_gray_code(bit_count):", "docstring": "Generates an n-bit Gray code sequence."}], "gpt_pass_sequence": [0, 0, 1], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000056", "row_id": 56, "seed_ids": [1055], "mode": "algorithm", "original_instruction": "**Scenario**: You are working on a project that requires generating Gray code sequences for various bit counts. The sequences are used in a digital communication system to ensure that only one bit changes between consecutive states.\n\n**Task**: Implement a function `generate_gray_code` that takes an integer \\( n \\) as input and returns a list of integers representing the \\( n \\)-bit Gray code sequence. The function should handle edge cases such as non-positive inputs and non-integer inputs.\n\n**Function Signature**: `def generate_gray_code(bit_count: int) -> List[int]:`\n\n**Input**:\n- \\( n \\) (1 \u2264 \\( n \\) \u2264 32): An integer representing the number of bits in the Gray code sequence.\n\n**Output**:\n- A list of integers representing the \\( n \\)-bit Gray code sequence.\n\n**Constraints**:\n- The function should handle inputs within the specified range.\n- The function should raise appropriate exceptions for invalid inputs.\n\n**Performance Requirements**:\n- The function should be efficient for \\( n \\leq 32 \\).\n\n**Example**:\n```python\n>>> generate_gray_code(2)\n[0, 1, 3, 2]\n>>> generate_gray_code(1)\n[0, 1]\n>>> generate_gray_code(3)\n[0, 1, 3, 2, 6, 7, 5, 4]\n```\n\n**Note**: You should not directly use the provided `gray_code` and `gray_code_sequence_string` functions. Implement your solution from scratch.\n\n**Hints**:\n- Consider the recursive nature of the problem and how you can build the sequence iteratively."}}}
{"messages": [{"role": "user", "content": "def activation_function(vector: np.ndarray, mode: str) -> np.ndarray:\n    \"\"\"\n    Returns the numpy array of the values after applying the specified activation function.\n    \"\"\"\n    pass\n\ndef test_activation_function():\n    vector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])\n    expected = np.array([0, 1, 1, 1, 0, 1])\n    result = activation_function(vector, 'binary_step')\n    assert np.array_equal(result, expected)\n\n    vector = np.array([-1, 0, 1, -2, 2])\n    expected = np.array([0, 0, 1, 0, 2])\n    result = activation_function(vector, 'relu')\n    assert np.array_equal(result, expected)\n\n    vector = np.array([-1, 0, 1])\n    expected = expit(vector)  # Using scipy's expit for exact sigmoid implementation\n    result = activation_function(vector, 'sigmoid')\n    assert np.allclose(result, expected)\n\n    try:\n        activation_function(np.array([-1, 0, 1]), 'unknown')\n    except ValueError:\n        pass  # Test passes if it raises the expected ValueError\n\nif __name__ == \"__main__\":\n    test_activation_function()"}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000068_C", "question": "def activation_function(vector: np.ndarray, mode: str) -> np.ndarray:\n    \"\"\"\n    Returns the numpy array of the values after applying the specified activation function.\n    \"\"\"\n    pass\n\ndef test_activation_function():\n    vector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])\n    expected = np.array([0, 1, 1, 1, 0, 1])\n    result = activation_function(vector, 'binary_step')\n    assert np.array_equal(result, expected)\n\n    vector = np.array([-1, 0, 1, -2, 2])\n    expected = np.array([0, 0, 1, 0, 2])\n    result = activation_function(vector, 'relu')\n    assert np.array_equal(result, expected)\n\n    vector = np.array([-1, 0, 1])\n    expected = expit(vector)  # Using scipy's expit for exact sigmoid implementation\n    result = activation_function(vector, 'sigmoid')\n    assert np.allclose(result, expected)\n\n    try:\n        activation_function(np.array([-1, 0, 1]), 'unknown')\n    except ValueError:\n        pass  # Test passes if it raises the expected ValueError\n\nif __name__ == \"__main__\":\n    test_activation_function()", "solution": "import numpy as np\n\ndef activation_function(vector: np.ndarray, mode: str) -> np.ndarray:\n    \"\"\"\n    Returns the numpy array of the values after applying the specified activation function.\n    \"\"\"\n    if mode == 'binary_step':\n        return np.where(vector >= 0, 1, 0)\n    elif mode == 'relu':\n        return np.maximum(0, vector)\n    elif mode == 'sigmoid':\n        return 1 / (1 + np.exp(-vector))\n    else:\n        raise ValueError(\"Unknown activation mode: {}\".format(mode))", "test_code": "import numpy as np\nfrom scipy.special import expit  # Import the expit function for sigmoid\n\ndef test_activation_function():\n    # Binary Step Function\n    vector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])\n    expected = np.array([0, 1, 1, 1, 0, 1])\n    result = activation_function(vector, 'binary_step')\n    assert np.array_equal(result, expected)\n\n    # ReLU Function\n    vector = np.array([-1, 0, 1, -2, 2])\n    expected = np.array([0, 0, 1, 0, 2])\n    result = activation_function(vector, 'relu')\n    assert np.array_equal(result, expected)\n\n    # Sigmoid Function\n    vector = np.array([-1, 0, 1])\n    expected = expit(vector)  # Using scipy's expit for exact sigmoid implementation\n    result = activation_function(vector, 'sigmoid')\n    assert np.allclose(result, expected)\n\n    # Unknown activation mode\n    try:\n        activation_function(np.array([-1, 0, 1]), 'unknown')\n    except ValueError:\n        pass  # Test passes if it raises the expected ValueError\n\ntest_activation_function()", "test_info": [{"function_name": "activation_function", "parameter_list": "(vector, mode)", "function_declaration": "def activation_function(vector, mode):", "docstring": "Returns the numpy array of the values after applying the specified activation function."}], "gpt_pass_sequence": [0, 0, 1], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000068", "row_id": 68, "seed_ids": [910], "mode": "algorithm", "original_instruction": "**Scenario**: You are working on a machine learning project that requires an activation function for a neural network layer. The Binary Step function is a simple yet effective choice for your needs. However, you want to extend its functionality to handle multiple activation functions for different layers.\n\n**Task**: Implement a more generalized version of the activation function that can switch between different activation functions based on a given input vector. Specifically, your task is to implement a function `activation_function` that takes an input vector and a mode as input and applies the corresponding activation function.\n\n**Function Signature**: `def activation_function(vector: np.ndarray, mode: str) -> np.ndarray`\n\n- **Input**:\n  - `vector` (ndarray): A numpy array of numeric values.\n  - `mode` (str): A string indicating the activation mode to be used. The possible values are:\n    - `'binary_step'`: Applies the binary step function.\n    - `'relu'`: Applies the Rectified Linear Unit (ReLU) activation function, which returns 0 for negative values and the input value for non-negative values.\n    - `'sigmoid'`: Applies the sigmoid activation function, which maps the input to a range between 0 and 1.\n\n- **Output**:\n  - A numpy array `vector` after applying the specified activation function.\n\n- **Constraints**:\n  - The input vector will always be a 1D numpy array.\n  - The mode will always be one of the specified strings.\n\n- **Performance Requirement**:\n  - The function should be optimized for performance, especially for large input vectors.\n\n**Examples**:\n```python\nimport numpy as np\n\n# Binary Step Function\nvector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])\nprint(activation_function(vector, 'binary_step'))\n# Output: array([0, 1, 1, 1, 0, 1])\n\n# ReLU Function\nprint(activation_function(np.array([-1, 0, 1, -2, 2]), 'relu'))\n# Output: array([0, 0, 1, 0, 2])\n\n# Sigmoid Function\nprint(activation_function(np.array([-1, 0, 1]), 'sigmoid'))\n# Output: array([0.26894142, 0.5         , 0.73105858])\n```"}}}
{"messages": [{"role": "user", "content": "def enhanced_lower(text: str) -> str:\n    \"\"\" Converts all uppercase letters in the input string to lowercase.\n    Handles both ASCII and non-ASCII characters.\n    \"\"\""}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000070_C", "question": "def enhanced_lower(text: str) -> str:\n    \"\"\" Converts all uppercase letters in the input string to lowercase.\n    Handles both ASCII and non-ASCII characters.\n    \"\"\"", "solution": "def enhanced_lower(text):\n    \"\"\"\n    Converts all uppercase letters in the input string to lowercase.\n    Handles both ASCII and non-ASCII characters.\n    \"\"\"\n    return text.lower()", "test_code": "import pytest\n\ndef test_enhanced_lower_ascii():\n    assert enhanced_lower(\"Hello, World!\") == 'hello, world!'\n    assert enhanced_lower(\"\u00a1Hola, MUNDO!\") == '\u00a1hola, mundo!'\n    assert enhanced_lower(\"Python 3.8\") == 'python 3.8'\n    assert enhanced_lower(\"12345\") == '12345'\n    assert enhanced_lower(\" caf\u00e9\") == ' caf\u00e9'\n\ndef test_enhanced_lower_non_ascii():\n    assert enhanced_lower(\"\u039a\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1\") == '\u03ba\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1'\n    assert enhanced_lower(\"\ud83d\ude00.prop\") == '\ud83d\ude00.prop'\n    assert enhanced_lower(\" teasers\") == ' teasers'\n    assert enhanced_lower(\"Teasers\") == 'teasers'\n    assert enhanced_lower(\"Teasers\ud83d\ude00\") == 'teasers\ud83d\ude00'", "test_info": [{"function_name": "enhanced_lower", "parameter_list": "(text)", "function_declaration": "def enhanced_lower(text):", "docstring": "Converts all uppercase letters in the input string to lowercase.\nHandles both ASCII and non-ASCII characters."}], "gpt_pass_sequence": [1, 0, 1], "gpt_pass_trial_num": 2, "gpt_difficulty": "easy", "gpt_pass_percentage": 0.667, "metadata": {"prompt_id": "00000070", "row_id": 70, "seed_ids": [286], "mode": "algorithm", "original_instruction": "**Scenario**: You are working on a project that involves processing text data in various languages, including those that use non-ASCII characters. You need a function to convert all uppercase letters to lowercase letters in a string, handling both ASCII and non-ASCII characters correctly.\n\n**Question**: Implement a function `enhanced_lower` that takes a string as input and returns a new string with all uppercase letters converted to lowercase. The function should handle both ASCII and non-ASCII characters and preserve the original order of characters in the string.\n\n**Input**: A string `text` (1 <= len(text) <= 10^5) consisting of alphanumeric characters, spaces, and punctuation marks. The string may contain non-ASCII characters.\n\n**Output**: A string where all uppercase letters in the input string are converted to lowercase.\n\n**Example**:\n```python\n>>> enhanced_lower(\"Hello, World!\")\n'hello, world!'\n>>> enhanced_lower(\"\u00a1Hola, MUNDO!\")\n'\u00a1hola, mundo!'\n>>> enhanced_lower(\"Python 3.8\")\n'python 3.8'\n>>> enhanced_lower(\"12345\")\n'12345'\n>>> enhanced_lower(\" caf\u00e9\")\n' caf\u00e9'\n```\n\n**Constraints**:\n- The input string will contain at least one character and at most 10^5 characters.\n- The string may contain non-ASCII characters.\n\n**Performance Requirement**: The function should handle large strings efficiently, aiming for a time complexity of O(n) and a space complexity of O(n)."}}}
{"messages": [{"role": "user", "content": "def bin_to_octal(bin_string: str) -> str:\n    \"\"\"\n    Converts a binary string to its octal equivalent.\n    \"\"\"\n    \"\"\"\n    Converts a binary string to its octal equivalent.\n    >>> bin_to_octal(\"1111\")\n    '17'\n    >>> bin_to_octal(\"101010101010011\")\n    '52523'\n    >>> bin_to_octal(\"\")\n    ''\n    >>> bin_to_octal(\"a-1\")\n    ValueError: Non-binary value was passed to the function\n    \"\"\""}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000087_C", "question": "def bin_to_octal(bin_string: str) -> str:\n    \"\"\"\n    Converts a binary string to its octal equivalent.\n    \"\"\"\n    \"\"\"\n    Converts a binary string to its octal equivalent.\n    >>> bin_to_octal(\"1111\")\n    '17'\n    >>> bin_to_octal(\"101010101010011\")\n    '52523'\n    >>> bin_to_octal(\"\")\n    ''\n    >>> bin_to_octal(\"a-1\")\n    ValueError: Non-binary value was passed to the function\n    \"\"\"", "solution": "def bin_to_octal(bin_string: str) -> str:\n    \"\"\"\n    Converts a binary string to its octal equivalent.\n    \"\"\"\n    if not all(c in '01' for c in bin_string):\n        raise ValueError(\"Non-binary value was passed to the function\")\n    if not bin_string:  # Handle empty string\n        return \"\"\n    \n    # Group binary string into chunks of 3, padding with leading zeros if necessary\n    padded_bin = bin_string.zfill((len(bin_string) + 2) // 3 * 3)\n    octal = \"\"\n    for i in range(0, len(padded_bin), 3):\n        chunk = padded_bin[i:i+3]\n        octal_digit = int(chunk, 2)\n        octal += str(octal_digit)\n    \n    return octal", "test_code": "import pytest\n\ndef test_bin_to_octal():\n    # Test with a valid binary string\n    assert bin_to_octal(\"1111\") == \"17\"\n    \n    # Test with a larger binary string\n    assert bin_to_octal(\"101010101010011\") == \"52523\"\n    \n    # Test with an empty string\n    assert bin_to_octal(\"\") == \"\"\n    \n    # Test with a non-binary string (should raise ValueError)\n    with pytest.raises(ValueError):\n        bin_to_octal(\"a-1\")\n    \n    # Test with a string that contains characters that are not '0' or '1'\n    with pytest.raises(ValueError):\n        bin_to_octal(\"1010x1010\")\n\ndef test_optimization():\n    # Test with a large binary string\n    large_bin = '1' * 1000000  # A large number of 1s\n    octal = bin_to_octal(large_bin)\n    assert len(octal) == 333334  # Since 1000000 / 3 = 333333 with a remainder of 1, we expect 333334 digits in octal", "test_info": [{"function_name": "bin_to_octal", "parameter_list": "(bin_string)", "function_declaration": "def bin_to_octal(bin_string):", "docstring": "Converts a binary string to its octal equivalent."}], "gpt_pass_sequence": [0, 0, 1], "gpt_pass_trial_num": 1, "gpt_difficulty": "medium", "gpt_pass_percentage": 0.333, "metadata": {"prompt_id": "00000087", "row_id": 87, "seed_ids": [651], "mode": "algorithm", "original_instruction": "You are given a function `bin_to_octal` that converts a binary string to its octal equivalent. The provided function already handles some edge cases and errors. Your task is to optimize the function to handle large binary strings more efficiently and to minimize the creation of intermediate data structures.\n\n**Function Signature**:\n```python\ndef bin_to_octal(bin_string: str) -> str:\n    # Your code here\n```\n\n**Input**:\n- `bin_string` (str): A binary string (composed of '0's and '1's).\n\n**Output**:\n- Return the octal equivalent of the binary string as a string.\n\n**Constraints**:\n- `1 <= len(bin_string) <= 10^6`\n\n**Performance Requirement**:\n- Optimize the function to handle large binary strings efficiently and minimize the use of additional data structures.\n\n**Example**:\n```python\n>>> bin_to_octal(\"1111\")\n'17'\n>>> bin_to_octal(\"101010101010011\")\n'52523'\n>>> bin_to_octal(\"\")\n''\n>>> bin_to_octal(\"a-1\")\nValueError: Non-binary value was passed to the function\n```\n\n**Note**: Ensure that your implementation handles all edge cases, including empty strings and non-binary strings, and performs optimally for large inputs."}}}
{"messages": [{"role": "user", "content": "def find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\n    >>> find_next_prime(10)\n    11\n    >>> find_next_prime(29)\n    31\n    >>> find_next_prime(100)\n    101\n    \"\"\""}], "metadata": {"style": "instruct", "subset": "Algorithm", "question_id": "Algorithm_00000089_C", "question": "def find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\n    >>> find_next_prime(10)\n    11\n    >>> find_next_prime(29)\n    31\n    >>> find_next_prime(100)\n    101\n    \"\"\"", "solution": "from math import sqrt\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\"\"\"\n    while True:\n        value += 1\n        if is_prime(value):\n            return value", "test_code": "def test_find_next_prime():\n    assert find_next_prime(10) == 11\n    assert find_next_prime(29) == 31\n    assert find_next_prime(100) == 101\n    assert find_next_prime(131) == 137\n    assert find_next_prime(1) == 2\n    assert find_next_prime(2) == 3\n    assert find_next_prime(3) == 5\n\ntest_find_next_prime()", "test_info": [{"function_name": "is_prime", "parameter_list": "(n)", "function_declaration": "def is_prime(n):", "docstring": "Check if a number is prime."}, {"function_name": "find_next_prime", "parameter_list": "(value)", "function_declaration": "def find_next_prime(value):", "docstring": "Return the smallest prime number greater than the given value."}], "gpt_pass_sequence": [1, 1, 0], "gpt_pass_trial_num": 2, "gpt_difficulty": "easy", "gpt_pass_percentage": 0.667, "metadata": {"prompt_id": "00000089", "row_id": 89, "seed_ids": [326], "mode": "algorithm", "original_instruction": "You are given a function `is_prime` that checks whether a number is prime. Your task is to implement a function `find_next_prime` that finds the next prime number greater than a given value. The function should handle edge cases and optimize performance for larger numbers.\n\n#### Function Signature\n```python\ndef find_next_prime(value: int) -> int:\n    pass\n```\n\n#### Constraints\n- `1 <= value <= 10^9`\n- The function should return the smallest prime number greater than the given value.\n\n#### Input and Output\n- **Input**: An integer `value`.\n- **Output**: The smallest prime number greater than `value`.\n\n#### Example\n```python\nassert find_next_prime(10) == 11\nassert find_next_prime(29) == 31\nassert find_next_prime(100) == 101\n```\n\n#### Performance Requirements\n- The function should be able to handle values up to `10^9` efficiently.\n\n#### Scenario\nYou are developing a secure messaging system that requires generating prime numbers for encryption keys. Your task is to ensure that the next prime number is found quickly and accurately."}}}
