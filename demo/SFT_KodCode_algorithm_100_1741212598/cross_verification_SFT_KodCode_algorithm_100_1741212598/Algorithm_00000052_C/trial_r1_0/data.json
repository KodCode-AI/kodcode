{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000052_C",
  "question": "def find_next_power_of_two(number: int) -> int:\n    \"\"\"\n    Returns the smallest power of two greater than the given non-negative integer.\n    If the input is 0, returns 1.\n    >>> find_next_power_of_two(0) == 1\n    >>> find_next_power_of_two(1) == 2\n    >>> find_next_power_of_two(15) == 16\n    >>> find_next_power_of_two(16) == 32\n    \"\"\"",
  "solution": "def find_next_power_of_two(number: int) -> int:\n    \"\"\"\n    Returns the smallest power of two greater than the given non-negative integer.\n    If the input is 0, returns 1.\n    \"\"\"\n    if number == 0:\n        return 1\n    power = 1\n    while power <= number:\n        power *= 2\n    return power",
  "test_code": "import pytest\n\ndef test_find_next_power_of_two():\n    assert find_next_power_of_two(0) == 1\n    assert find_next_power_of_two(1) == 2\n    assert find_next_power_of_two(15) == 16\n    assert find_next_power_of_two(16) == 32\n    assert find_next_power_of_two(1023) == 1024\n    assert find_next_power_of_two(1024) == 2048\n    assert find_next_power_of_two(1048575) == 1048576\n    assert find_next_power_of_two(1048576) == 2097152\n    pytest.approx(find_next_power_of_two(999999999), 2_000_000_000)",
  "test_info": [
    {
      "function_name": "find_next_power_of_two",
      "parameter_list": "(number)",
      "function_declaration": "def find_next_power_of_two(number):",
      "docstring": "Returns the smallest power of two greater than the given non-negative integer.\nIf the input is 0, returns 1."
    }
  ],
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I have to write a Python function called find_next_power_of_two that takes a non-negative integer and returns the smallest power of two that's bigger than it. Hmm, let's think about the examples given. For instance, if the input is 0, it returns 1 because 1 is 2^0 and the next power of two after that is 2. Wait, no, wait. Oh, no, wait\u2014if the input is 0, the function should return 1 because 1 is the next power. Oh right, the first example says find_next_power_of_two(0) ==1. Then, for 1 it returns 2, that makes sense. For 15, it returns 16 because 15 is 1111 in binary and the next power is 16 which is 10000. For 16, returns 32, because it's the next one.\n\nSo how to approach this in Python.\n\nFirst, what's a power of two? It's any number that's equal to 2 raised to some integer exponent. So, 1 is 2^0, 2 is 2^1, 4 is 2^2, etc.\n\nThe task is to find the smallest power of two greater than the given number. So even if the given number is a power of two, we need the next one. For example, 16 is a power of two, so the function returns 32.\n\nWait, looking back at the examples: For 16, it returns 32. So the next power, not the same as input if input is a power.\n\nSo the function should always find the next one that is strictly larger than the input.\n\nExcept for when the input is 0, but wait, in that case, 0 is not a power of two\u2014wait, 0 is not a positive integer, so 2^x can't be 0. So the function for 0 returns 1.\n\nSo the logic is: given a non-negative integer, find the smallest power of two that is strictly greater than the input.\n\nHmm, the question now is, how to compute that.\n\nLet me think of some approaches.\n\nApproach 1: Use logarithms.\n\nIf I can compute the exponent needed to reach the number, then add one and compute 2^exponent.\n\nBut that might have issues with numbers that are not exact powers.\n\nWait, another thought: for any number, the next power of two is 2 raised to the ceiling of the log base 2 of the number. But let's see:\n\nWait, let's take number =15. Log2(15) is about 3.906. The ceiling is 4, so 2^4=16. That's correct.\n\nIf number is 16: log2(16) is 4; ceiling is 4, 2^4 is 16. But the desired output is 32. Oh, wait, wait! So the formula would give 16, which is the same as the input. So to get the next, I need to compute 2^(ceil(log2(n)) +1), only if n is a power of two.\n\nSo perhaps:\n\nIf the number is 0, return 1.\n\nElse, compute the exponent. If the number is exactly a power of two, then next power is 2 * number.\n\nOtherwise, compute the next exponent as log2(n), take ceiling, exponent +1? Or perhaps just compute 2^{floor(log2(n)) +1}.\n\nWait, maybe a better way is to think in binary. For a non-power of two number, the next power is the number with only the next higher bit set.\n\nWait, for 15 (1111), the next is 16 (10000).\n\nSo, perhaps, for a number, we can find the position of the highest set bit, then create a number where only the next higher bit is set.\n\nLet's see: for 15, highest bit is 4th position (since 8 is 2^3), but wait, let me think in terms of exponents. The highest power less than or equal to n is 8 for 15. So the next power is 16.\n\nIf the number is exactly a power of two, say 16, then the next power is 32.\n\nHmm. So the way to compute is:\n\nCompute the position of the highest set bit for (number), then create a new number with the next higher bit set.\n\nBut how?\n\nAnother idea: for numbers that are not powers of two, the next power is 2^(floor(log2(n)) +1). For numbers that are powers of two, it's 2^(log2(n)+1).\n\nSo the formula is 2^(ceil(log2(n+1))). Wait, let me test.\n\nn=0: log2(0+1)=0, 2^0=1.\n\nn=1: log2(2)=1, 2^1=2.\n\nn=15: log2(16)=4, 2^4=16.\n\nn=16: log2(17) is ~4.09, ceil is 5? No, wait. Or wait, no\u2014what is 16+1? 17. Log2(17) is about 4.09, ceil is 5? No, 4.09's ceil is 5?\n\nWait, no: ceil(4.09) is 5, yes.\n\nSo 2^5 = 32. Which is correct.\n\nWait, but here's n=16. 16 is a power of two. Adding one makes it 17, which is not. So for the general case, number is n: taking n+1 in the log?\n\nWait, maybe the formula is 2 raised to the ceiling of log2(n+1). Let's test:\n\nn=0: log2(1) is 0. 2^0=1 \u2192 correct.\n\nn=1: log2(2) is 1 \u2192 2^1=2 \u2192 correct.\n\nn=15: log2(16) \u21924 \u21922^4=16 \u2192 correct.\n\nn=16: log2(17)\u22484.09 \u2192ceil=5 \u21922^5=32 \u2192 correct.\n\nn=32: log2(33)\u22485.04\u2192ceil=6\u21922^6=64 \u2192 correct.\n\nSeems to work.\n\nSo, perhaps the steps are:\n\nIf n is 0: return 1.\n\nElse: compute m = n + 1. Compute exponent = ceil(log2(m)). Then return 2^exponent.\n\nWait, no, wait\u2014n is the input, and we compute m =n+1? Or is it just log2(n) ?\n\nNo, in the earlier step I used n+1. Wait when I tried n=0, it's because n+1 was 1, and log is 0.\n\nWait no, let me think again.\n\nWait, in the case where n is a power of two, say n=2. Adding 1 gives 3. Log2(3) is about 1.58, ceiling is 2. So 2^2 =4. Which is correct, because the next power after 2 is 4. But wait no\u2014what is 2 being the input, it should return4. Or wait wait:\n\nWait, the function is supposed to return the next power AFTER the input. So if input is 2, which is 2^1, the next is 4 (2^2). So according to this formula with n=2:\n\nCompute log2(3) \u22481.58, ceiling is 2. 2^2=4. Correct.\n\nWait, let's think for the case when n is not a power.\n\nSuppose n=5.\n\nlog2(5+1)=log2(6)=2.58, ceiling is 3. So 2^3=8.\n\nWhich is correct because next power after 5 is 8.\n\nWait, 5 is less than 8, which is correct.\n\nSo yeah, using (n+1) inside the log seems to work.\n\nBut how to compute this in Python.\n\nFirst, handle the case when n=0: return 1.\n\nElse, compute m = n.\n\nWe can compute m = n, and compute the exponent as the ceiling of log2(m). But wait, when m is not a power of two, log2 returns something with decimal, which when ceiled gives the next power.\n\nWait, no. Because let's take m=15. log2(15) is ~3.906. Ceiling is 4. So 2^4=16, which is correct.\n\nIf m is 16, log2 is 4, ceiling is 4, 2^4=16, but we need 32. So using this method won't work for when m is a power of two.\n\nSo I need to differentiate between when the number is a power of two or not.\n\nWait, so perhaps the approach is:\n\nIf the number is zero, return 1.\n\nElse:\n\nCheck if the number is a power of two. If it is, the next power is 2*n.\n\nElse, find the next highest power, which is 2^(floor(log2(n)) + 1).\n\nSo let's see.\n\nFor example:\n\nn=15: check if power of two? 15 in binary is 1111, so no. Compute floor(log2(15))=3, add 1 to get 4, 2^4=16.\n\nn=16: is a power of two: next is 32.\n\nn=0: return 1.\n\nn=1: is 2^0, so next is 2.\n\nSo checking: how to check if a number is a power of two.\n\nA number is a power of two if it has exactly one bit set in binary.\n\nHow to check that.\n\nIn Python, a number is a power of two if n & (n-1) == 0, except for n=0.\n\nSo perhaps in code:\n\nif n ==0:\n\n    return 1\n\nelif (n & (n-1)) ==0: \n\n    return n*2\n\nelse:\n\n    # find exponents etc.\n\nWait, let's think about that.\n\nFor n=1: n&(n-1) is 1 & 0 =0: so it is a power. So returns 2. Correct.\n\nn=2: 2&1= 0: returns 4.\n\nBut what about n=0: handled.\n\nn=15: 15 & 14 is 14, which is not 0. So returns the next higher power.\n\nSo in code:\n\nif number ==0:\n\n    return 1\n\nelif (number & (number -1 )) ==0:\n\n    return number *2\n\nelse:\n\n    # compute floor(log2(n)) +1, multiply by 2.\n\nBut how to compute floor(log2(n)), but for that, in Python, I can use math.log2 and take the floor, but I have to be cautious about possible floating point approximations.\n\nAlternatively, since we're dealing with integers, perhaps another approach.\n\nLet me think about another way. For numbers that are not a power of two, there is a way to find the next highest power by manipulating the binary representation.\n\nHere's another approach: find the position of the highest set bit, and then set the next bit.\n\nBut how?\n\nWait, I can compute the highest power of two less than or equal to n, then double it.\n\nWait, but for n=16, which is a power of two, this would return 16, but we need 32.\n\nWait, perhaps:\n\nWhen n is not a power, compute the highest power less than n, then multiply by 2 to get next.\n\nWait:\n\nFor example, n=15: highest less than is 8, multiply by 2: 16.\n\nn=5: highest is4, multiply by 2:8.\n\nn=24 (16 is the highest, next is 32.\n\nWait, but for n=16, highest is16, multiply by 2:32.\n\nSo perhaps, the approach can be written as:\n\nNext power is 2 ** (bit_length of the number).\n\nWait, but what's the bit_length for 0.\n\nWait, in Python, 0's bit_length is 0. So 2**0 is 1.\n\nSo for n=0, it's handled.\n\nWait, let's test:\n\nFor any integer n>0, the bit_length() is the number of bits required to represent n, excluding the sign and leading zeros.\n\nSo for n=1: binary is 1 \u2192 bit_length =1 \u2192 2^1=2.\n\nn=2: binary 10 \u2192 bit_length=2 \u21922^2=4.\n\nn=3: binary 11 \u2192 bit_length=2 \u21922^2=4. Correct.\n\nn=4: binary100 \u2192 bit_length=3 \u21922^3=8. So 8 is the next power after 4, but 4*2 is 8. So works.\n\nWait, okay, so perhaps the function can be written as:\n\nif n ==0:\n\n    return 1\n\nelse:\n\n    return 1 << (n.bit_length())\n\nBecause 2^k is same as shifting 1 left by k bits.\n\nLet's test:\n\nn=0: return 1, correct.\n\nn=1:1. bit_length is 1. 1<<1 is 2. Correct.\n\nn=15: binary 1111, bit_length is 4. 1<<4=16. Correct.\n\nn=16: binary 10000, bit_length is5. 1<<5=32. Correct.\n\nYes! So this approach seems to handle all the cases correctly.\n\nBecause for numbers that are powers of two, their bit_length is log2(n)+1.\n\nWait, for 16, which is 2^4, but the bit_length is 5, because 16 is 10000 in binary, five bits.\n\nSo 1 << 5 is 32. Correct.\n\nSo the code can be written as:\n\ndef find_next_power_of_two(number: int) -> int:\n\n    if number ==0:\n\n        return 1\n\n    return 1 << (number.bit_length())\n\nWait, but let's test this with the cases.\n\nTest Case 1: number=0 \u2192 returns 1. Correct.\n\nTest Case 2: number=1 \u21921<<1 \u21922. Correct.\n\nTest Case 3: number=15 \u2192bit length is4 \u21921<<4=16. Correct.\n\nTest Case4: number=16 \u2192bit_length is5 \u21921<<5=32. Correct.\n\nAnother test case: number=5 \u2192 binary101\u2192bit_length is3\u21928.\n\nYes.\n\nWhat about number=7? binary111\u2192bit_length=3 \u21921<<3=8. Correct.\n\nnumber=8 \u2192 binary1000\u2192bit_length is4\u21921<<4=16. Correct.\n\nSo this seems to handle all the cases.\n\nBut wait: What about number=0? The shift is 1 <<0 \u21921, only if the code ran 1<<0 for 0, but because we have the if clause, it's handled. For example, if number=0, after the if condition, we return 1. So the code is correct.\n\nSo with this approach, the function can be written succinctly.\n\nSo to write the function, the code is:\n\nCheck if the number is 0, return 1.\n\nElse, compute 1 shifted left by the number's bit_length.\n\nSo the code is:\n\nreturn (1 << number.bit_length()) if number !=0 else 1\n\nBut in code:\n\ndef find_next_power_of_two(number: int) -> int:\n    if number == 0:\n        return 1\n    return 1 << number.bit_length()\n\nThis should work.\n\nTesting:\n\nLet's try number=0 \u21921.\n\nnumber=1\u21922.\n\nnumber=2\u21924.\n\nWait wait, wait\u2014if the function is designed to find the next power strictly larger than the input. Wait, for number=16, the next power is 32. So the function returns 32.\n\nYes, correct.\n\nSo the code works.\n</think>\n\nTo solve this problem, we need to determine the smallest power of two that is strictly greater than a given non-negative integer. If the input is zero, the function should return 1, as 1 is the smallest power of two.\n\n### Approach\nThe approach to solve this problem efficiently involves leveraging the properties of binary numbers and bitwise operations. Here\u2019s the step-by-step breakdown:\n\n1. **Handle the Special Case for Zero**: If the input number is zero, directly return 1, since 1 is the smallest power of two and the next power after zero.\n\n2. **Determine the Next Power of Two for Non-zero Numbers**:\n    - For any non-zero number, we can use the bit length of the number to find the next higher power of two. The bit length of a number is the number of bits required to represent it in binary, excluding leading zeros.\n    - The next power of two can be found by shifting the number 1 to the left by the bit length of the given number. This operation effectively creates a binary number with a 1 followed by the same number of zeros as the bit length, which is the next power of two.\n\n### Solution Code\n\n```python\ndef find_next_power_of_two(number: int) -> int:\n    if number == 0:\n        return 1\n    return 1 << number.bit_length()\n```\n\n### Explanation\n- **Special Case Handling**: The function first checks if the input number is zero. If it is, the function returns 1, as this is the smallest power of two.\n- **Bitwise Operation for Non-zero Numbers**: For non-zero numbers, the function calculates the bit length of the number. This bit length represents the number of bits needed to express the number in memory. By left-shifting the number 1 by this bit length, we obtain the next power of two. This is because shifting 1 left by `n` positions results in a binary 1 followed by `n` zeros, which is exactly the next power of two greater than the given number.\n\nThis approach efficiently computes the next power of two using bitwise operations, which are both fast and straightforward. The solution handles all edge cases, including the special case for zero, ensuring correct results across all non-negative integer inputs.",
  "r1_solution": "def find_next_power_of_two(number: int) -> int:\n    if number == 0:\n        return 1\n    return 1 << number.bit_length()",
  "metadata": {
    "prompt_id": "00000052",
    "row_id": 52,
    "seed_ids": [
      1050
    ],
    "mode": "algorithm",
    "original_instruction": "You are tasked with extending the functionality of a given function to not only find the largest power of two less than or equal to a given non-negative integer but also to handle an additional constraint: finding the smallest power of two greater than a given non-negative integer. This new function will be used in scenarios where binary allocations or specific power levels are required.\n\n**Function Signature**: `def find_next_power_of_two(number: int) -> int:`\n\n**Input and Output**:\n- **Input**: A single non-negative integer `number`.\n- **Output**: The smallest power of two greater than the given integer. If the input is 0, return 1.\n\n**Constraints**:\n- The input number will be in the range \\(0 \\leq \\text{number} \\leq 10^9\\).\n\n**Performance Requirements**:\n- The function should be efficient and handle the constraints within a reasonable time.\n\n**Scenario**:\nImagine you are working on a system where you need to allocate memory in the form of powers of two. You have a function to allocate memory based on the smallest power of two greater than a given request size. For example, if a request is for 5 units of memory, the system should allocate 8 units (2^3).\n\n**Example**:\n```python\nassert find_next_power_of_two(0) == 1\nassert find_next_power_of_two(1) == 2\nassert find_next_power_of_two(15) == 16\nassert find_next_power_of_two(16) == 32\n```\n\n**Note**:\n- You are not allowed to use any built-in functions or libraries for calculating powers of two.\n- The function should handle edge cases as described in the constraints."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results0.jsonl"
}