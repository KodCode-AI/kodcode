{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000052_C",
  "question": "def find_next_power_of_two(number: int) -> int:\n    \"\"\"\n    Returns the smallest power of two greater than the given non-negative integer.\n    If the input is 0, returns 1.\n    >>> find_next_power_of_two(0) == 1\n    >>> find_next_power_of_two(1) == 2\n    >>> find_next_power_of_two(15) == 16\n    >>> find_next_power_of_two(16) == 32\n    \"\"\"",
  "solution": "def find_next_power_of_two(number: int) -> int:\n    \"\"\"\n    Returns the smallest power of two greater than the given non-negative integer.\n    If the input is 0, returns 1.\n    \"\"\"\n    if number == 0:\n        return 1\n    power = 1\n    while power <= number:\n        power *= 2\n    return power",
  "test_code": "import pytest\n\ndef test_find_next_power_of_two():\n    assert find_next_power_of_two(0) == 1\n    assert find_next_power_of_two(1) == 2\n    assert find_next_power_of_two(15) == 16\n    assert find_next_power_of_two(16) == 32\n    assert find_next_power_of_two(1023) == 1024\n    assert find_next_power_of_two(1024) == 2048\n    assert find_next_power_of_two(1048575) == 1048576\n    assert find_next_power_of_two(1048576) == 2097152\n    pytest.approx(find_next_power_of_two(999999999), 2_000_000_000)",
  "test_info": [
    {
      "function_name": "find_next_power_of_two",
      "parameter_list": "(number)",
      "function_declaration": "def find_next_power_of_two(number):",
      "docstring": "Returns the smallest power of two greater than the given non-negative integer.\nIf the input is 0, returns 1."
    }
  ],
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function called find_next_power_of_two that takes an integer and returns the smallest power of two greater than that number. Hmm, let's think about the examples they gave. If the input is 0, it returns 1. Oh right, because 1 is 2^0, the next power of two after 0. For 1, it's 2. For 15, it's 16, which is 2^4. And for 16 itself, the next is 32, which is 2^5.\n\nSo, how do I approach this? I guess the key is to find the next power of two after the given number. Well, for a number that's itself a power of two, I just need to multiply it by two, right? But for numbers that aren't, like 15, I need to find the next one.\n\nWait, another example: if the number is 5, the next power is 8. Okay. What's the mathematical way to find the next power of two? Maybe I need to calculate 2 raised to the ceiling of the base-2 logarithm of the number, but wait, that doesn't work if the number is already a power of two because, for example, log2(16) is 4, and 2^4 is 16, but we need 32 in that case.\n\nAlternatively, maybe I can use bit manipulation. Since powers of two have exactly one bit set in their binary representation. For example, 2 is 10, 4 is 100, 8 is 1000, etc. So, when I add one to a number that is one less than a power of two, like 15 is 1111, adding one gives 10000, which is 16. Oh, but that's the same as the next power if the number is 15. What about when the number is like 17, which is 10001. Then the next power would be 32, which is 100000.\n\nHmm, but how to calculate that in Python.\n\nWait, I remember that for a non-zero number, the next power of two can be found by:\n\n1. Taking the binary representation of the number.\n2. Counting the number of bits, then creating a number with just the next higher bit set.\n\nWait, for example, number 5 is 101 in binary, which is 3 bits. But the next power is 8, which is 1000 in 4 bits. So, for any number, the next power is 2 raised to the ceiling of the log2(number + 1).\n\nWait no, because for 15 which is 4 bits (since it's 1111), adding one gives 16 which is 10000, 5 bits. So that approach might be tricky.\n\nAlternatively, perhaps I can compute the next power by using bitwise operations. Let's see: the next power of two after a number N can be calculated as 1 << (number of bits in N). For example, N=15 is 4 bits, so 1 << 4 is 16. For N=16, which is 5 bits (since 16 is 10000), that gives 32 (1<<5). But wait, what about when N is 0? 1 << 0 is 1, which is correct.\n\nWait no, the number of bits for N=0 is... Hmm, that's a problem. Because in Python, 0 doesn't have any bits except all zeros. So, maybe that's a special case.\n\nWait, perhaps I can use the bit_length() method. Let's see. For N=0, bit_length() is 0. So 1 << (0+1) is 1, which is correct. For N=1 (binary 1), bit_length is 1. 1 << 1 is 2, correct. For N=15 (1111), which is bit_length 4: 1<<4 is 16. For N=16 which is 10000, bit_length is 5: 1<<5 is 32. That seems to work.\n\nWait, testing with N=5 (101): bit_length is 3. 1<<3 is 8, correct. N=7 (111): 1<<3 is 8. Correct.\n\nSo maybe this method works. So the algorithm would be:\n\nIf the number is 0, return 1 (special case, but according to bit_length, 1<<0 is 1, so maybe it's handled). Wait, 0: compute 1 << (0's bit-length). 0 has bit_length 0: 1<<0 is 1, correct. So the function can be written as:\n\nreturn 1 << (number.bit_length())\n\nWait, let's test for N=15: 15.bit_length() is 4, 1<<4 is 16. Correct. N=16: bit_length is 5, 1<<5 is 32, correct. Yes, this seems to work.\n\nBut wait, what about when number is 0? Oh, 0's bit_length is 0, so 1<<0 is 1. Which is correct.\n\nSo that's it! So the function can be written as:\n\nreturn 1 << (number.bit_length())\n\nWait, trying for N=1: 1 has bit_length 1, 1<<1 is 2. Correct.\n\nWait, does this hold for all numbers? Let me see.\n\nAnother test case: N=2. 2 in binary is 10, bit_length is 2: 1<<2 is 4. Correct, as the next power after 2 is 4? Wait, no, wait the next power after 2 is 4? But according to the function, that's correct. Oh yes, because 2 is a power of two, and the next is 4. But in the examples, N=16 returns 32, which is correct.\n\nWait, according to the problem statement, for the input 1, the output is 2. Which is exactly what the function gives.\n\nWhat about for number=63? 63 is 111111, which is 6 bits. 1<<6 is 64, correct. 64 is the next power.\n\nYes, this seems like a solid solution.\n\nSo now the code can be written.\n\nWait, but zero case is handled. What if number is negative? But according to the problem statement, the input is a non-negative integer. So no problem. So the function is simply: return 1 << (number.bit_length()).\n\nSo writing the code:\n\ndef find_next_power_of_two(number: int) -> int:\n    if number == 0:\n        return 1  # though the required, but perhaps 1 <<0 is 1, so the same as number.bit_length(),\n        # so perhaps the next line would handle it without the condition.\n    return 1 << number.bit_length()\n\nWait, but is the condition necessary? For number=0, number.bit_length() returns 0, so 1<<0 is 1 which is correct. So the function can just be:\n\ndef find_next_power_of_two(number: int) -> int:\n    return 1 << number.bit_length()\n\nTesting that.\n\nYes, this should handle all cases correctly.\n</think>\n\nTo solve this problem, we need to determine the smallest power of two that is greater than a given non-negative integer. This can be achieved efficiently using bit manipulation techniques.\n\n### Approach\nThe approach leverages the properties of binary numbers, where each power of two is represented by a single bit set to 1 followed by zeros. For example, 16 is 10000 in binary, which is 2^4. The key insight is that the next power of two after a number can be found by determining the position of the highest set bit in the binary representation of the number and then setting the next higher bit.\n\n1. **Bit Length Calculation**: The bit length of a number is the number of bits required to represent it in binary. For example, the number 15 (binary 1111) has a bit length of 4.\n2. **Shift Operation**: By calculating 1 left-shifted by the bit length of the number, we effectively set the next higher bit, which corresponds to the next power of two.\n\nThis method works efficiently and handles all cases, including when the input number is zero.\n\n### Solution Code\n```python\ndef find_next_power_of_two(number: int) -> int:\n    return 1 << number.bit_length()\n```\n\n### Explanation\n- **Bit Length Calculation**: The `bit_length()` method returns the number of bits necessary to represent the number in binary. For zero, this returns 0.\n- **Shift Operation**: Shifting 1 to the left by the bit length of the number sets the next higher bit, which is the next power of two. For example, for the number 15 (binary 1111), `bit_length()` returns 4, and 1 << 4 equals 16, which is the next power of two.\n\nThis approach is efficient with a time complexity of O(1), as it involves only a few bitwise operations which are computed in constant time.",
  "r1_solution": "def find_next_power_of_two(number: int) -> int:\n    return 1 << number.bit_length()",
  "metadata": {
    "prompt_id": "00000052",
    "row_id": 52,
    "seed_ids": [
      1050
    ],
    "mode": "algorithm",
    "original_instruction": "You are tasked with extending the functionality of a given function to not only find the largest power of two less than or equal to a given non-negative integer but also to handle an additional constraint: finding the smallest power of two greater than a given non-negative integer. This new function will be used in scenarios where binary allocations or specific power levels are required.\n\n**Function Signature**: `def find_next_power_of_two(number: int) -> int:`\n\n**Input and Output**:\n- **Input**: A single non-negative integer `number`.\n- **Output**: The smallest power of two greater than the given integer. If the input is 0, return 1.\n\n**Constraints**:\n- The input number will be in the range \\(0 \\leq \\text{number} \\leq 10^9\\).\n\n**Performance Requirements**:\n- The function should be efficient and handle the constraints within a reasonable time.\n\n**Scenario**:\nImagine you are working on a system where you need to allocate memory in the form of powers of two. You have a function to allocate memory based on the smallest power of two greater than a given request size. For example, if a request is for 5 units of memory, the system should allocate 8 units (2^3).\n\n**Example**:\n```python\nassert find_next_power_of_two(0) == 1\nassert find_next_power_of_two(1) == 2\nassert find_next_power_of_two(15) == 16\nassert find_next_power_of_two(16) == 32\n```\n\n**Note**:\n- You are not allowed to use any built-in functions or libraries for calculating powers of two.\n- The function should handle edge cases as described in the constraints."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}