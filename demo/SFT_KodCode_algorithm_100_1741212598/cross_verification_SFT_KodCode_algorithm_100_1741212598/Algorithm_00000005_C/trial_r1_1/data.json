{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000005_C",
  "question": "def two_sum_indices(nums: List[int], target: int) -> List[int]:\n    \"\"\" Finds the indices of the two numbers in the list that add up to the target sum using the two-pointer technique.\n    >>> two_sum_indices([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum_indices([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum_indices([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_sum_indices([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum_indices([1, 3, 3], 6)\n    [1, 2]\n    >>> two_sum_indices([2, 7, 11, 15], 8)\n    []\n    >>> two_sum_indices([3 * i for i in range(10)], 19)\n    []\n    >>> two_sum_indices([1, 2, 3], 6)\n    []\n    \"\"\"",
  "solution": "def two_sum_indices(nums, target):\n    \"\"\"\n    Returns the indices of the two numbers in nums that add up to target.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
  "test_code": "def test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()",
  "test_info": [
    {
      "function_name": "two_sum_indices",
      "parameter_list": "(nums, target)",
      "function_declaration": "def two_sum_indices(nums, target):",
      "docstring": "Returns the indices of the two numbers in nums that add up to target."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function called two_sum_indices that finds the indices of two numbers in a list that add up to a target sum. The examples given show that for certain inputs, it returns specific pairs of indices. Hmm, the function is supposed to use the two-pointer technique. \n\nWait, so the two-pointer technique is typically used when the list is sorted because you can start from both ends and move towards the center. But wait, in the examples, the list isn't necessarily sorted. Or does it require the list to be modified or assumed to be sorted? Oh right, the examples like [1,3,3] and [2,7,11,15] are part of the test cases. So maybe the function expects the list to be sorted? Or is there another way to apply two-pointers here.\n\nWait, maybe not. Let's think. Alternatively, the problem might not require the list to be sorted, but using two pointers in some way. Hmm. Or perhaps the function is supposed to first sort the list alongside keeping track of their original indices, then use two pointers to find the target. Because with a sorted list and keeping track of original indices, you can then identify the pairs.\n\nSo the plan is maybe:\n\n1. Create a list of tuples where each tuple holds the value and its original index.\n2. Sort this list based on the values.\n3. Use two pointers, one at the start and one at the end of this sorted list.\n4. Sum the two values and check against the target.\n5. If the sum is equal to the target, then return the original indices.\n6. If the sum is less than target, move the left pointer forward to get a larger value.\n7. If sum is more than target, move right pointer backward to get a smaller value.\n8. Continue until a pair is found. If none is found, return an empty list.\n\nBut wait, what's the time complexity here? Sorting is O(n log n), which is acceptable for many cases. But if the input list is large, maybe we can have more optimal solutions. Although I think for the problem constraints, this should be fine.\n\nWait, but the standard two-sum problem expects a solution with O(n) time using a hash map. So why use two pointers here? Because maybe the problem specifically requires it. Let me re-examine the question: yes, it says to use the two-pointer technique. So the likely approach is to sort the list with their indices and then apply two pointers.\n\nWait, but in the first example, the input is [2,7,11,15], target 9: 2 and 7, which are at indices 0 and 1. When the list is sorted, it's already in order, so the two pointers would find it immediately.\n\nAnother example is [1,3,3], target 6: the two 3s are at indices 1 and 2. When we sort the list with indices, it becomes [(1,0), (3,1), (3,2)]. The two-pointer approach will consider 1 and 3 first, sum is 4 which is less than 6. Then move left to (3,1). Sum is 1+3 +? No, wait, wait. Wait, in the sorted list, the values are [1,3,3]. Left pointer at 1, right at 3. Sum is 4, less than 6. So move left pointer to next, which is index 1 (value 3). Then sum 3 +3 is 6, so the right pointer is at index 2, so indices are 1 and 2.\n\nBut wait, what if the list is being sorted but the original positions are being considered? So, the pointers in the sorted array have their original indices, and when a pair is found, their original indices are taken in the order of left pointer first or whatever.\n\nSo the steps are:\n\n- Sort the list of (value, original index) tuples by value.\n- Initialize left pointer at 0, right at len(nums) -1.\n- While left < right:\n   - current_sum = sorted_list[left][0] + sorted_list[right][0]\n   - if current_sum == target:\n      - return [sorted_list[left][1], sorted_list[right][1]]\n   - elif current_sum < target:\n      - increment left to increase sum\n   - else:\n      - decrement right to decrease sum\n- If no pair found, return empty list.\n\nBut wait, what about duplicates in the list? Like the [1,3,3] example. We need to ensure that the same element isn't used twice unless there are at least two distinct elements.\n\nBut in this approach, since the pointers are on different positions, duplicates in the sorted list won't be a problem as their original indices are different.\n\nBut let me think about another case like [2,2,3], target 5. The sorted list is [(2,0), (2,1), (3,2)]. The two-pointer approach would take left at (2,0) and right at (3,2), sum is 5. So returns [0,2].\n\nAnother test case in examples: [2,7,11,15], target 26. The sum is 11+15=26. In sorted list, the left is 2, right is 15, their sum is correct, indices are 2 and 3.\n\nBut in the test cases, [2,7,11,15], target 9 gives 0,1, and target 8 gives empty because 2+7 is 9, which is more than 8. Wait, in this list, the two smallest numbers are 2 and 7, which sum to 9, but target is 8, which is less than 9, so no pair possible.\n\nWait, but according to the last example, two_sum_indices([2,7,11,15],8) returns empty list.\n\nSo the approach works.\n\nBut some test cases:\n\nWhat about [3,0,3], target 6? Sorted would be [0,3,3], values 0+3=3, 3+3=6. So the two pointers would move as follows:\n\nleft is at 0 (value 0), right is at 3 (value 3). Sum is 3. Less than 6. So move left to next, which is 3. Now, current_sum is 3+3=6, so return. The original indices would be [1 and 2? Or depending on their positions.\n\nWait, in the original list [3,0,3], the indices are 0:3, 1:0, 2:3. The sorted list is [(0,1), (3,0), (3,2)]. So when sum reaches 6, left is at index 1 (value 3, original index 0), right is at index 2 (value 3, original index2). So the function returns [0,2].\n\nYes, that's correct.\n\nNow, in another scenario: what if the same value is needed but from the same element? Like [5,5], target 10: should return [0,1].\n\nYes, the function would handle that.\n\nAnother edge case: when the list is empty. Oh wait, the function expects a list of integers but for empty list, but the examples don't cover that. So we can assume that the list is non-empty with at least two elements.\n\nNow, considering that the function needs to return a list of the two indices, in the order they appeared in the original array. For example, [1,3,3], for target 6 returns [1,2], which are the two 3s' indices.\n\nIn our approach, when the two sorted elements come from the middle, their original indices may not be in the order they are in the array. Wait, once the sorted list is created, when a pair is found, they're added to the result. But the original indices are part of the sorted list. So when the pair is found at the left and right, which are in the middle, their order in the array is whatever it is.\n\nWait, in the function's examples, the outputs are given as the indices in the original order, e.g., for [2,7,11,15], sum 9 returns [0,1], 17 returns [0,3], 18 returns [1,2], and 26 returns [2,3].\n\nWait, when using two pointers on a sorted list of (value, index) tuples, when a pair is found, which indices do we pick? The pair's indices in the original array, which could be in any order.\n\nIn the example [2,7,11,15], target 17: 2+15 =17. When the sorted list is processed, 2 is at index 0, 15 at index 3. So the function returns [0,3], which matches the example.\n\nSo, in the function, once the two elements are found in the sorted list, their original indices are simply added in the order of left and right pointers. But what if the same number is considered from two different indices?\n\nWait, for the function, it doesn't matter because the two elements in the original array may be at any indices. The function returns the two indices found. So that order may not necessarily be sorted; the 0 and 3 are correctly added as per their occurrence.\n\nWait, but the function's return seems to have the indices in order as per their occurrence in the list. For example, in the example where target is 18, sum is 7+11. Their original indices are 1 and 2, so the function returns [1,2].\n\nSo in the two-pointer approach, when a sum is found, the indices are taken as the original indices. But what's the order? For example, in a case where right pointer's index is smaller than left's in the original list?\n\nLike, imagine a list like [5, 3, 4]. Sorted list is [3,4,5], indices 1,2,0.\n\nSuppose target is 9: 4+5 =9, which comes from the original indices 2 and 0.\n\nBut in two-pointer approach, the right is pointing to 5 (original index 0). So their sum is 3+5=8 <9, so move left. Then left is 4 (index 2), sum is4 +5=9, so return 2 and 0. The function would return [2,0]. But in the original array, the 4 is at 2 and 5 at 0. Wait, that's correct, because their sum is indeed 4+5=9.\n\nBut the returned list would have 2,0. However, I think whether the function expects any order? Like, whether the lower index comes first or not.\n\nWait, looking back at the examples, in the [2,7,11,15] for target 17, it returns [0,3], which is correct because 2 is at 0 and 15 at 3. For the [1,3,3] case, it returns [1,2], which are the correct indices.\n\nSo in the function, whether the indices are in order or not may not matter as long as they correctly represent a pair whose sum is target. Because for the problem statement, the function is to return the indices that add up to the target.\n\nThus, the order may not matter, but to match the examples, the function returns them as they are found by the two pointers.\n\nBut in the first example, after sorting, it's [2,7,11,15] in the tuple form. So in that case, the function returns the earliest possible pair. But what if we have multiple possible pairs?\n\nFor example, if the list is [3,1,4,2], target 5. The two possible pairs are 3 and 2 (indices 0 and 3) and 1 and4 (indices 1 and4's index in this hypothetical list.) Wait, wait in this example: (3,1,4,2), target 5. The correct pairs are (3,2) at indices 0 and 3, but also (1,4) but 4 is not in the list. Wait, in my hypothetical list, like [3,1,4,2], target 5.\n\nWait, no. The pairs that sum to 5 are (1 and4) but (4 isn't ... Wait, perhaps I should choose a better example for multiple pairs.\n\nBut for function refinement, the two-pointer approach may find the first possible pair but may not find all. Wait, but for the problem statement, you just need the indices of any two numbers that sum to target. But looking at the examples, the function seems to return the earliest possible pair.\n\nBut wait in the standard two-pointer approach for two-sum, once the list is sorted, it often returns nothing, but for the function to return as in the examples, regardless of the number of possible pairs.\n\nWait, perhaps in the function, when multiple pairs exist, any pair can be acceptable? Or is the function required to return all possible pairs? Well, the examples return a list of two elements, so I think it's looking for any one pair, as long as their sum is target.\n\nSo for the two-pointer approach, once the pair is found, return immediately.\n\nSo the function will proceed to find the pair and return.\n\nSo the steps are:\n\n1. Handle cases where the list is empty or smaller than two elements: return empty.\n\n2. Create a list of (value, original index) for each element.\n\n3. Sort this list based on the value.\n\n4. Initialize left and right pointers at start and end.\n\n5. While left < right:\n\n   a. calculate sum of current left and right.\n\n   b. if sum is target: return the indices in the order they are (left's index, then right's index).\n\n   c. if sum < target: move left +=1.\n\n   d. else: move right -=1.\n\n6. If no pair found, return empty.\n\nSo now let's think about the code.\n\nImplementing this in Python.\n\nWait, function signature is:\n\ndef two_sum_indices(nums: List[int], target: int) -> List[int]:\n\nSo first, check if the list is empty or has less than two elements: return empty.\n\nOtherwise, create a list of tuples sorted by value.\n\nWait, for example, for nums = [2,7,11,15], their sorted list would be [(2,0), (7,1), (11,2), (15,3)].\n\nThen left is 0, right is 3. Sum is 2+15=17. It depends on the target.\n\nWait. So the code steps:\n\nsorted_nums = sorted([(val, idx) for idx, val in enumerate(nums)], key=lambda x: x[0])\n\nThen, left =0, right = len(sorted_nums) -1.\n\nloop until left < right:\n\nsum_ = sorted_nums[left][0] + sorted_nums[right][0]\n\nif sum_ == target:\n\n   return [sorted_nums[left][1], sorted_nums[right][1]]\n\nelif sum_ < target:\n\n   left +=1\n\nelse:\n\n   right -=1\n\nIf no pair found, return [].\n\nWait, but looking at the example where the function is given [1,3,3], target 6: sorted list is [(1,0), (3,1), (3,2)]. So left is 0, right is 2.\n\nSum is 1+3=4: less than 6. So move left to 1. Now, sum is 3+3=6. So returns [1,2], which is correct.\n\nAnother test case: two_sum_indices([2,7,11,15], 17). Sorted list: same as before. left starts at 0 (2) and right at 3 (15). Sum 17, which is target. So returns [0,3], which matches.\n\nAnother example: target 26. The two largest: 11 and15, sum 26. When left is 2, right is3, their sum is 26, so return [2,3].\n\nWait, but in the code, how would it reach there?\n\nInitially, left is 0 and right is 3. Sum is 2+15=17. For target 26, which is larger, sum is less than target, move left.\n\nNext, left is 1. Sum is 7+15=22, still less than 26. Move left to 2 (value 11). 11 +15 =26: correct, returns [2,3].\n\nYes, correct.\n\nBut what about a case where the two numbers are adjacent in the original array but their sum is the target after moving through the pointers?\n\nLike nums = [4,5,6], target 11. Sorted list is [(4,0), (5,1), (6,2)]. So left starts at 0 and right at 2. Sum 10 <11: move left. Now left is1, right is2. Sum 5+6=11: correct. So indices are 1 and2, which is correct.\n\nAnother case: nums = [3,5,7,1], target 8. The sorted list would be [(1,3), (3,0), (5,1), (7,2)].\n\nLeft starts with 0 (1), right with3 (7). Sum is 8. So indices would be [3,2], but wait, indices 3 and 2 are 1 and7. But in the original list, indices 3 is 1, index 2 is7. Sum 8. So the function returns [3,2].\n\nBut wait, the original array is [3,5,7,1]. So 1 is at index3, and7 is at 2. So their sum is 8, but in the function, the sorted list is [1,3,5,7]. So the two would be found, and the indices are 3 and2, which are 1 and7. So function returns [3,2], which is correct.\n\nSo the code should handle these cases.\n\nNow, what about when the list has one element? Well, the function would return empty, as per the test case.\n\nAnother possible issue: when there are multiple possible pairs, the function returns the first found. But the function requires the earliest in the array? Or the earliest in the sorted list?\n\nNo, the function uses the two-pointer approach, which finds pairs in order of increasing left and decreasing right. So the first encountered pair is found.\n\nWait, but in sorted list, for a given sum, it may find a pair that is earliest possible or not.\n\nWait, perhaps the function would return the first possible pair in the order of the sorted list.\n\nBut since in the code, the function returns as soon as a pair is found, so it depends on where the two-pointer search finds it.\n\nBut looking at the examples, that's what happens. So the code is correct.\n\nThus, the steps for implementation are:\n\n- Check if the list has less than two elements: return empty.\n- Create a sorted list of (value, index) tuples, sorted by value.\n- Initialize left and right pointers.\n- Loop while left < right.\n   - Compute sum.\n   - Compare to target. On match, return the indices.\n   - Else, adjust pointers.\n- If no pair found, return empty.\n\nTesting:\n\nTest case 1: two_sum_indices([2,7,11,15],9) should return [0,1].\nThe sorted list is [(2,0), (7,1), ...]. Sum of 2+7=9: target found at initial step. So returns [0,1].\n\nTest case 2: two_sum_indices([2,7,11,15],8) returns []. Because 2 and7 sum to9, which is higher than8. Left increases, 2+11=13>8, so right moves, and 7 is 2 and15 adds to17, which is higher than8. So no pair found, empty returned.\n\nTest case 3: two_sum_indices([3*i for i in range(10)], 19) \u2192 []. Because the sum is 0+3=3, then 0+6=6, ..., but 19 is beyond.\n\nWait the list would be [0,3,6,9,12,15,18,21,24,27], target 19. Let's see:\n\nLooking for two elements that sum to19.\n\nIn the two-pointer approach: left is 0, right is9 (27). Sum 0+27=27>19: move right to 8 (24). 0+24=24>19. continue moving right down. When 0+18=18 <19: move left to 3 (3). Sum 3+18=21>19: move left to6 (6). sum 6+18=24>19. Left increases to9: sum 9+18=27>19. Left increases to 12: sum 12+18=30 >19. Left increases etc., until left < right condition fails.\n\nThus, no pair found.\n\nThus, function returns empty.\n\nSo the code should handle all these cases.\n\nNow, let's consider cases where the function returns multiple pairs, but the earliest is chosen.\n\nWait, for example: [1,1,1], target=2. Each pair of1s sums to 2. Sorted is [(1,0), (1,1), (1,2)]. left starts at0, right at2. sum is 2: so returns [0,2]. But is that the correct earliest pair? Well, in the original array, the indices 0 and1 are the earliest (sum 2). But the two-pointer approach returns 0 and2 in this case. Hmmm.\n\nSo this is a problem. Because the correct result could be [0,1], which are the first two elements.\n\nWait, in the two-pointer approach, for [1,1,1], target 2:\n\nsorted is [(1,0), (1,1), (1,2)].\n\nleft=0, right=2: sum 1+1=2: returns [0,2].\n\nBut the other possible pairs are 0 and1, 1 and2.\n\nThe function returns the pair found by the two pointer approach. But the problem description may expect [0,1], as the earliest pair.\n\nBut according to the function's test case like [1,3,3], it returns [1,2], which are the two 3s, perhaps because they are the first occurrence of the pair when moving the pointers.\n\nBut in the case where [1,1,1], target 2: in a function that uses the two-pointer approach, it would return [0,2], but the earliest possible is [0,1].\n\nThus, the function may not return the earliest possible pair when it's not the first that the two-pointer approach finds.\n\nBut according to the problem statement examples, perhaps in the cases of multiple pairs, any pair with the sum is acceptable, like the test cases only have one possible pair.\n\nThus, the function may proceed with the two-pointer approach, and for multiple pairs, the one found by the approach is returned.\n\nSo what's the correct output when both pairs exist?\n\nLooking at the example [1,3,3], the function returns [1,2]. So in that case, it's correct.\n\nBut in the case of [1,1,3,3], target 4: the sum can be 1+3, and the possible indices are [0,2], [0,3], [1,2], [1,3]. The two-pointer approach would find (1,3) when the sorted list is [(1,0), (1,1), (3,2), (3,3)].\n\nLeft is0 (1), right is3 (3): sum 4 \u2192 returns [0,3]. So the pair is 0 and3.\n\nBut another possible pair is 0 and2, but the function in two-pointer approach would find 0 and3 first. So it depends on the implementation.\n\nThis could be an issue if the function needs to return the earliest occurring pair.\n\nBut the problem statement does not specify this; it's unclear. However, given the examples given, it's likely that the function uses the two-pointer approach, returning the pair found.\n\nThus, the function should proceed as described.\n\nSo now, time to implement the code.\n\nBut let's also handle the case where the list is empty or has one element (like if len(nums) <2: return [].\n\nSo the code will look like this:\n\ndef two_sum_indices(nums: List[int], target: int) -> List[int]:\n    if len(nums) <2:\n        return []\n    sorted_nums = sorted([(val, idx) for idx, val in enumerate(nums)], key=lambda x: x[0])\n    left = 0\n    right = len(sorted_nums)-1\n    while left < right:\n        current_sum = sorted_nums[left][0] + sorted_nums[right][0]\n        if current_sum == target:\n            return [sorted_nums[left][1], sorted_nums[right][1]]\n        elif current_sum < target:\n            left +=1\n        else:\n            right -=1\n    return []\n\nTesting this against the examples:\n\nTesting with two_sum_indices([2,7,11,15], 9):\n\nSorted nums: [(2,0),(7,1), (11,2), (15,3)].\n\nleft=0, right=3. sum=2+15=17>9. So decrement right to 2.\n\nNow, left=0, right=2. sum 2+11=13>9. Decrement right to1.\n\nNow, left=0, right=1. sum 2+7=9: correct. Return [0,1]. Correct as per example.\n\nAnother example: two_sum_indices([2,7,11,15],17). left=0, right=3. sum is2+15=17. So return [0,3]. Correct.\n\nAnother example: two_sum_indices([2,7,11,15],18). Sum shall be 7+11=18. Sorted nums as before.\n\nleft starts with0, right 3: sum=17 <18. So left increases.\n\nNow sorted_nums[1][0] is7. sum 7+15=22>18: move right to2.\n\nsum 7+11=18: correct. return [1,2], as in example.\n\nTest case for [1,3,3],6:\n\nsorted_nums is [(1,0), (3,1), (3,2)].\n\nleft=0, right=2: sum 1+3=4 <6: left increases.\n\nNow left=1, sum3+3=6: return [1,2]. Correct.\n\nWhat about [3,0,3],6: sorted is [(0,1),(3,0), (3,2)].\n\nleft=0:0, right=2:3. sum 3. left increases to1: sum3+3=6: return [0,2]. Correct.\n\nBut if in the original array the function is [3,0,3], the possible pairs are (1 and0) and (1 and2), which are (0 and3's 0 is earlier than3's1 index). Hmm, wait I think that in the function, 0 is at index1 and 3 is at index0 and2. So when code runs, the sum of 3 (index0) and 3 (index2) is 6, so returns [0,2], which is correct.\n\nThus, the code works for the given test cases.\n</think>\n\nTo solve this problem, we need to find the indices of two numbers in a given list that add up to a specified target sum. We will use the two-pointer technique, which is efficient and works well when the list is sorted.\n\n### Approach\n1. **Sort the List with Indices**: First, we convert each element in the list into a tuple containing the element and its original index. We then sort this list of tuples based on the element values.\n2. **Two-Pointer Technique**: We initialize two pointers, one at the start (left) and one at the end (right) of the sorted list. We then iterate while the left pointer is less than the right pointer.\n3. **Check Sum**: For each iteration, we compute the sum of the elements at the left and right pointers. If the sum matches the target, we return the original indices. If the sum is less than the target, we move the left pointer to the right to increase the sum. If the sum is greater, we move the right pointer to the left to decrease the sum.\n4. **Return Result**: If no such pair is found after the iteration, we return an empty list.\n\n### Solution Code\n```python\nfrom typing import List\n\ndef two_sum_indices(nums: List[int], target: int) -> List[int]:\n    if len(nums) < 2:\n        return []\n    sorted_nums = sorted([(val, idx) for idx, val in enumerate(nums)], key=lambda x: x[0])\n    left = 0\n    right = len(sorted_nums) - 1\n    while left < right:\n        current_sum = sorted_nums[left][0] + sorted_nums[right][0]\n        if current_sum == target:\n            return [sorted_nums[left][1], sorted_nums[right][1]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n```\n\n### Explanation\n- **Sorting with Indices**: By sorting the list while keeping track of original indices, we ensure that we can correctly identify the positions of the numbers in the original list after finding a valid pair.\n- **Efficiency**: The two-pointer technique allows us to efficiently find the pair in O(n) time after sorting, which itself takes O(n log n) time. This combined approach ensures that we can handle even relatively large lists efficiently.\n- **Handling Edge Cases**: The function handles cases where no valid pairs exist by checking the length of the input list and returning an empty list when appropriate.\n\nThis approach ensures that we find the correct pair of indices efficiently and correctly, adhering to the problem constraints and requirements.",
  "r1_solution": "from typing import List\n\ndef two_sum_indices(nums: List[int], target: int) -> List[int]:\n    if len(nums) < 2:\n        return []\n    sorted_nums = sorted([(val, idx) for idx, val in enumerate(nums)], key=lambda x: x[0])\n    left = 0\n    right = len(sorted_nums) - 1\n    while left < right:\n        current_sum = sorted_nums[left][0] + sorted_nums[right][0]\n        if current_sum == target:\n            return [sorted_nums[left][1], sorted_nums[right][1]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
  "metadata": {
    "prompt_id": "00000005",
    "row_id": 5,
    "seed_ids": [
      716
    ],
    "mode": "algorithm",
    "original_instruction": "### Scenario\n\nYou are given a sorted list of integers and a target sum. Your task is to implement a function that finds the indices of the two numbers in the list that add up to the target sum using the two-pointer technique.\n\n### Requirements\n\n- **Function Name**: `two_sum_indices`\n- **Input**:\n  - A list of integers, `nums`, which is sorted in non-decreasing order.\n  - An integer, `target`, representing the target sum.\n- **Output**:\n  - Return a list of two integers, representing the indices of the two numbers in `nums` that add up to `target`. If no such pair exists, return an empty list.\n\n### Constraints\n\n- The length of `nums` will be in the range \\([2, 10^4]\\).\n- The elements of `nums` will be in the range \\([-10^9, 10^9]\\).\n- There will be exactly one solution, and you may not use the same element twice.\n- `nums` is sorted in non-decreasing order.\n\n### Example\n\n```python\ndef test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()\n```\n\n### Performance Requirements\n\nThe function should run efficiently, with a time complexity of \\(O(n)\\) and a space complexity of \\(O(1)\\).\n\n### Question\n\nImplement the `two_sum_indices` function."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}