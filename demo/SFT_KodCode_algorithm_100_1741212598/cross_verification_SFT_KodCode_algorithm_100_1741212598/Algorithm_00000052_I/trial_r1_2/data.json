{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000052_I",
  "question": "You are tasked with extending the functionality of a given function to not only find the largest power of two less than or equal to a given non-negative integer but also to handle an additional constraint: finding the smallest power of two greater than a given non-negative integer. This new function will be used in scenarios where binary allocations or specific power levels are required.\n\n**Function Signature**: `def find_next_power_of_two(number: int) -> int:`\n\n**Input and Output**:\n- **Input**: A single non-negative integer `number`.\n- **Output**: The smallest power of two greater than the given integer. If the input is 0, return 1.\n\n**Constraints**:\n- The input number will be in the range \\(0 \\leq \\text{number} \\leq 10^9\\).\n\n**Performance Requirements**:\n- The function should be efficient and handle the constraints within a reasonable time.\n\n**Scenario**:\nImagine you are working on a system where you need to allocate memory in the form of powers of two. You have a function to allocate memory based on the smallest power of two greater than a given request size. For example, if a request is for 5 units of memory, the system should allocate 8 units (2^3).\n\n**Example**:\n```python\nassert find_next_power_of_two(0) == 1\nassert find_next_power_of_two(1) == 2\nassert find_next_power_of_two(15) == 16\nassert find_next_power_of_two(16) == 32\n```\n\n**Note**:\n- You are not allowed to use any built-in functions or libraries for calculating powers of two.\n- The function should handle edge cases as described in the constraints.",
  "solution": "def find_next_power_of_two(number: int) -> int:\n    \"\"\"\n    Returns the smallest power of two greater than the given non-negative integer.\n    If the input is 0, returns 1.\n    \"\"\"\n    if number == 0:\n        return 1\n    power = 1\n    while power <= number:\n        power *= 2\n    return power",
  "test_code": "import pytest\n\ndef test_find_next_power_of_two():\n    assert find_next_power_of_two(0) == 1\n    assert find_next_power_of_two(1) == 2\n    assert find_next_power_of_two(15) == 16\n    assert find_next_power_of_two(16) == 32\n    assert find_next_power_of_two(1023) == 1024\n    assert find_next_power_of_two(1024) == 2048\n    assert find_next_power_of_two(1048575) == 1048576\n    assert find_next_power_of_two(1048576) == 2097152\n    pytest.approx(find_next_power_of_two(999999999), 2_000_000_000)",
  "test_info": [
    {
      "function_name": "find_next_power_of_two",
      "parameter_list": "(number)",
      "function_declaration": "def find_next_power_of_two(number):",
      "docstring": "Returns the smallest power of two greater than the given non-negative integer.\nIf the input is 0, returns 1."
    }
  ],
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function called find_next_power_of_two that takes a non-negative integer and returns the smallest power of two greater than that number. If the input is 0, I return 1. Hmm, let's think about how to approach this.\n\nWait, first, I remember that a power of two has exactly one bit set in its binary representation. So maybe I can find the next such number after the given number.\n\nWait, but if the given number is exactly a power of two, like 8, then I need to return the next one, which is 16. Except for the case where the number is zero, which should return 1.\n\nLet me see the examples. So for 0, return 1. For 1, return 2. For 15, return 16, and for 16, return 32. Right.\n\nSo the steps could be:\n1. Handle the case where number is 0. Just return 1.\n2. For other numbers, find the smallest power of two larger than the number.\n3. How to find that?\n\nOne way is to find the next power of two. But how? Let me think of binary operations.\n\nHmm, maybe I can calculate the position of the highest set bit and then shift 1 left by that position plus one.\n\nWait, but for numbers that are not exact powers, the next power is the next higher position.\n\nFor example, if the number is 5. Its binary is 101. The highest set bit is at position 2 (zero-based, since 2^2 =4 is the highest less than 5). So the next power is 2^(3) = 8.\n\nIf the number is 15 (1111), the next is 16 (10000). So yes, if the highest set bit is at position n, the next power is 2^(n+1).\n\nWait, but for a number that is exactly a power of two, say 8 (1000), let's think. Its highest set bit is position 3 (since 2^3=8). Next power is 2^4=16. So yes, same logic.\n\nSo, the approach is:\n- If number is 0, return 1.\n- Else, find the position of the highest set bit in the binary representation of the number.\n- The next power is 2^(position + 1).\n\nWait, but does that hold for all numbers?\n\nLet me test with 1. Binary is 1, highest set bit position is 0. So next is 2^1=2. Correct.\n\nFor 2: it's 10. Highest set bit is 1. Next is 4. Right.\n\nWait no, for 2: function should return 4, but according to the sample input, when input is 1, the output is 2. So yes, our logic fits.\n\nSo, the plan is:\n1. Check if number is 0, return 1.\n2. For other numbers, find the highest set bit position (the leftmost 1 in binary).\n3. Compute 2 raised to (highest position +1). That's the next power.\n\nNow, how to find the highest set bit in Python without built-in functions.\n\nHmm, but since I can't use built-in functions for calculating powers, but for this calculation, I think the bit length can be used.\n\nWait, the number's bit_length() gives the number of bits required to represent the number in binary, excluding the sign and leading zeroes. So for 8 (1000), it's 4 bits. So the highest bit is position 3 (since 0-based). So, subtracting 1 from the bit_length gives the exponent.\n\nWait, for example:\nnumber = 5 is 101, which has bit_length of 3. 2^(3-1) is 4, but 5 needs next power 8 which is 2^3. So yeah, 3 is log2(8). So in terms of exponents, it's (bit_length of number) gives the exponent of next power.\n\nWait, for number 5:\nnumber.bit_length() is 3. so next power is 2^(3) =8.\n\nFor number 8, number.bit_length() is 4. next power is 16=2^4.\n\nSo for number n >0, the next power is 1 << (n.bit_length()).\n\nAh, that's a neat formula.\n\nWait, 1 shifted left by the bit_length of the number.\n\nBecause:\n\nn=0: returns 1, which is special case.\n\nn=1: bit_length is 1, so 1<<1 is 2.\n\nn=2: bit_length is 2, 1<<2 is4.\n\nn=15: 1111, bit_length is4, so 1<<4 is 16.\n\nn=16: bit_length is5, 1<<5=32.\n\nYes, that works.\n\nSo, putting it all together, the function can be written as:\n\ndef find_next_power_of_two(number: int) -> int:\n    if number ==0:\n        return 1\n    return 1 << (number.bit_length())\n\nWait, does that handle all cases?\n\nTesting the sample inputs:\n\nSample 1: find_next_power_of_two(0) returns 1.\n\nSample 2: (1) 1<<1 is 2.\n\nSample3: for 15, 1<<4 is 16.\n\nFor 16: 1<<5=32.\n\nYes, matches the examples.\n\nWhat about numbers that are between two powers, like 3.\n\n3 is 11. bit_length is 2. 1<<2 is4, which is correct.\n\nWhat about 4: it is 100. bit_length is3. 1<<3=8.\n\nYep.\n\nWhat about the maximum input of 1e9.\n\nWhat's 1e9 in binary?\n\nWell, 1e9 is 1,000,000,000.\n\nlog2(1e9) is about 29.89. So, the next power is 2^30, which is 1,073,741,824.\n\nSo the function should return that.\n\nIt should be computed as 1<<30, which is correct.\n\nBut what about when number is 2^30-1? That is 1,073,741,823.\n\nbit_length is 30, so 1<<30 is 1,073,741,824.\n\nCorrect.\n\nSo, the function seems correct.\n\nWhat about when the input is 1? It's handled correctly.\n\nWhat about number 0: returns 1, correct.\n\nWhat about number 2^31-1: which has a bit_length of 31, so returns 2^31.\n\nSo, I think this approach works and is efficient because the bit_length() is a built-in operation and using shift is O(1) time.\n\nTherefore, the code seems solid.\n</think>\n\nTo solve this problem, we need to find the smallest power of two greater than a given non-negative integer. This is particularly useful in scenarios where memory allocation or specific power levels are required, such as in binary allocations.\n\n### Approach\nThe approach leverages the properties of binary numbers, where each power of two is represented by a 1 followed by zeros. The key insight is that the next power of two greater than a given number can be found using bit manipulation techniques.\n\n1. **Special Case Handling**: If the input number is 0, the function should return 1, as 1 is the smallest power of two.\n2. **Bit Length Calculation**: For any non-zero number, we determine the position of the highest set bit in its binary representation. This can efficiently be done using the `bit_length()` method, which returns the number of bits required to represent the number in binary.\n3. **Compute Next Power of Two**: Using the highest bit position, the next power of two is computed by left-shifting 1 by the bit length of the number. This effectively sets the next higher bit, resulting in the smallest power of two greater than the given number.\n\n### Solution Code\n```python\ndef find_next_power_of_two(number: int) -> int:\n    if number == 0:\n        return 1\n    return 1 << (number.bit_length())\n```\n\n### Explanation\n- **Special Case Handling**: The function first checks if the input number is 0 and returns 1 immediately, as 1 is the smallest power of two.\n- **Bit Length Calculation**: For non-zero numbers, the `bit_length()` method is used to find the number of bits required to represent the number. This gives the position of the highest set bit plus one (since `bit_length()` returns the count starting from 1).\n- **Compute Next Power of Two**: By left-shifting 1 by the bit length of the number, we effectively compute 2 raised to the power of the bit length, which is the next power of two greater than the input number.\n\nThis approach ensures that the function is both efficient and handles all edge cases, including the maximum input constraint of \\(10^9\\). The use of bit manipulation ensures that the solution is computed in constant time, making it highly performant.",
  "r1_solution": "def find_next_power_of_two(number: int) -> int:\n    if number == 0:\n        return 1\n    return 1 << (number.bit_length())",
  "metadata": {
    "prompt_id": "00000052",
    "row_id": 52,
    "seed_ids": [
      1050
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results2.jsonl"
}