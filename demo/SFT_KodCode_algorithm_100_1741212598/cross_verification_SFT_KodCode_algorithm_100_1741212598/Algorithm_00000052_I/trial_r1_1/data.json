{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000052_I",
  "question": "You are tasked with extending the functionality of a given function to not only find the largest power of two less than or equal to a given non-negative integer but also to handle an additional constraint: finding the smallest power of two greater than a given non-negative integer. This new function will be used in scenarios where binary allocations or specific power levels are required.\n\n**Function Signature**: `def find_next_power_of_two(number: int) -> int:`\n\n**Input and Output**:\n- **Input**: A single non-negative integer `number`.\n- **Output**: The smallest power of two greater than the given integer. If the input is 0, return 1.\n\n**Constraints**:\n- The input number will be in the range \\(0 \\leq \\text{number} \\leq 10^9\\).\n\n**Performance Requirements**:\n- The function should be efficient and handle the constraints within a reasonable time.\n\n**Scenario**:\nImagine you are working on a system where you need to allocate memory in the form of powers of two. You have a function to allocate memory based on the smallest power of two greater than a given request size. For example, if a request is for 5 units of memory, the system should allocate 8 units (2^3).\n\n**Example**:\n```python\nassert find_next_power_of_two(0) == 1\nassert find_next_power_of_two(1) == 2\nassert find_next_power_of_two(15) == 16\nassert find_next_power_of_two(16) == 32\n```\n\n**Note**:\n- You are not allowed to use any built-in functions or libraries for calculating powers of two.\n- The function should handle edge cases as described in the constraints.",
  "solution": "def find_next_power_of_two(number: int) -> int:\n    \"\"\"\n    Returns the smallest power of two greater than the given non-negative integer.\n    If the input is 0, returns 1.\n    \"\"\"\n    if number == 0:\n        return 1\n    power = 1\n    while power <= number:\n        power *= 2\n    return power",
  "test_code": "import pytest\n\ndef test_find_next_power_of_two():\n    assert find_next_power_of_two(0) == 1\n    assert find_next_power_of_two(1) == 2\n    assert find_next_power_of_two(15) == 16\n    assert find_next_power_of_two(16) == 32\n    assert find_next_power_of_two(1023) == 1024\n    assert find_next_power_of_two(1024) == 2048\n    assert find_next_power_of_two(1048575) == 1048576\n    assert find_next_power_of_two(1048576) == 2097152\n    pytest.approx(find_next_power_of_two(999999999), 2_000_000_000)",
  "test_info": [
    {
      "function_name": "find_next_power_of_two",
      "parameter_list": "(number)",
      "function_declaration": "def find_next_power_of_two(number):",
      "docstring": "Returns the smallest power of two greater than the given non-negative integer.\nIf the input is 0, returns 1."
    }
  ],
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function called find_next_power_of_two. It takes a non-negative integer and returns the smallest power of two greater than the given number. Oh, and if the input is 0, I return 1.\n\nLet me think about the examples given to understand the function better. For instance, when the input is 0, output is 1. When it's 1, output is 2. For 15, it's 16, and for 16, it's 32. So it seems like the function is finding the next power of two that's just bigger than the input.\n\nFirst, I need to find a way to calculate the next power of two without using built-in functions like pow or log, because the note says not to use them. Right, so I have to come up with an algorithm using bitwise operations or multiplication.\n\nHmm, let me think about how powers of two work. A power of two is any number like 1, 2, 4, 8, 16, etc. Each is 2 raised to some exponent. So the next power of two after N is 2 raised to the ceil of log2(N+1).\n\nBut since I can't use log, maybe I can find it using bitwise operations.\n\nSo, how can I find the next power of two of a given number?\n\nLet me consider the approach for numbers that are already powers of two. Like 16 is 2^4. The next should be 32, which is 2^5. So for a number that's a power of two, the next is multiplying by 2.\n\nWhat about numbers that are not powers of two? Like 5. It's between 4 (2^2) and 8 (2^3), so the next power is 8.\n\nWait, so the function could be rephrased as: find the smallest x=2^k such that x > number. So if number is 0, x is 1.\n\nHow can I compute that x?\n\nOne approach is to find the position of the highest set bit in the number, then shift 1 left by that position, and see.\n\nAlternatively, another approach: if the number is zero, return 1. Else, bitshift until we find the next power.\n\nWait, for a zero input, the output is 1, which is 2^0. For number 1, next is 2^1=2. For 2, next is 4, and so on.\n\nAnother way to think: The next power is equal to the current number rounded up to the nearest power of two.\n\nWait, let's think how rounded up is different. For number=5, rounded up would be 8. So how to compute that?\n\nI remember that for numbers greater than zero, the next power of two can be found by calculating 2 raised to the position of the highest set bit in (number) plus 1 if necessary.\n\nWait, or perhaps setting all the lower bits to 1 and then adding 1.\n\nWait, here's a method:\n\nTake the number, and find the position of the leading 1 bit. Then, the next power of two is 1 shifted left by that position plus 1? Wait, maybe not.\n\nWait, let's think about 3. Its binary is 11. The highest set bit is at position 1 (assuming 0-based from the right). So, the next power is 4, which is 1<<2.\n\nWait, for a number like 5, binary101, highest set bit is 2. So 1<<3 is 8.\n\nWait, yes. The highest set bit's position is the exponent's base. Wait, for 0, the highest bit is undefined, so we handle it as 0.\n\nHmm, so the steps could be:\n\n1. If the number is 0, return 1.\n\n2. Else, compute the position of the highest set bit. Let's call this position 'exp' (use 0-based from right, e.g., for 8=1000, exp=3).\n\n   So next_power = 2^(exp + 1).\n\nWait, not exactly. Wait, let's see:\n\nFor 1: 1 in binary is 1. Highest bit at position 0. Next power is 2, which is 2^(0+1) = 2.\n\nYes.\n\nFor 16 (exp is 4): next is 32 (2^(4+1) = 32). Correct.\n\nFor 15, which is 1111; highest bit is 3. So next is 16 (2^4): correct.\n\nYes, that formula seems to work.\n\nWait, but wait: 2 is 10; its highest bit is 1. Next power is 4, which is 2^(1+1) = 4. Correct.\n\nSo, how to find the highest set bit in the number.\n\nIn Python, for integers, we can use the bit_length() method. Oh right! Because for a number n, the bit_length is the number of bits required to represent it, which is one more than the highest bit's position.\n\nWait, let's see:\n\nn =0: bit_length is 0.\n\nn=1 (binary 1): bit_length 1. So the highest set bit position is 0.\n\nWait n=2: binary 10, bit_length is 2, highest bit at position 1.\n\nn=15: binary 1111, bit_length is 4, so position is 3.\n\nWait so, in general, the position of the highest set bit is (n.bit_length()-1). But what about when n is 0? Because 0 has a bit_length of 0. So for n !=0, the highest bit position is (n.bit_length() -1).\n\nSo the approach could be:\n\nif number ==0:\n\n    return 1\n\nelse:\n\n    highest_bit_position = (number.bit_length() -1)\n\n    next_power = 1 << (highest_bit_position + 1)\n\n    return next_power\n\nWait let's test with the examples.\n\nSample 1:\n\nn=0: output 1. Correct.\n\nSample 2:\n\nn=1: bit_length=1, highest_bit=0, next_power=1 <<1 =2. Correct.\n\nn=15: bit_length=4, highest_bit=3. 1<<4=16. Correct.\n\nn=16: bit_length=5, highest_bit=4. 1<<5=32. Correct.\n\nAnother test case: n=5. Binary 101. bit_length=3, highest_bit=2. 1<<3=8.\n\nYes, correct.\n\nWhat about n=6? Binary 110. same as above. 8.\n\nWhat about n=7? 8 is next.\n\nWait, then that approach seems to work.\n\nWait, but what about n=2, which is a power of two. Yes, the approach picks it up.\n\nWait, so I think the code can be written as follows:\n\ndef find_next_power_of_two(number: int) -> int:\n    if number == 0:\n        return 1\n    highest_bit = number.bit_length() -1\n    return 1 << (highest_bit + 1)\n\nWait, but is that correct?\n\nWait, let's test n=0. Returns 1, correct.\n\nBut what about n=2:\n\nbit_length of 2 is 2, so highest_bit is 1. 1 <<2 is 4. Correct.\n\nWhat about n=1? Correct, 2.\n\nWhat about numbers like 3,3:\n\nhighest_bit_position is 1, next_power is 4.\n\nYes, correct.\n\nSo this method seems to handle all cases.\n\nBut wait, wait\u2014 what's the bit_length of 0? Oh right, it's 0. So the code correctly handles n=0.\n\nAnother thing to consider is when number is 1. Oh, the code works.\n\nNow, handling very large numbers, since the constraints say up to 1e9. Well, in Python, integers can handle that.\n\nWait, but how about numbers like 1e9.\n\nn=1e9: binary is about, well, 1 followed by 30 bits or so. Let's see, 2^30 is about a billion. So, let's compute (1e9).bit_length().\n\nWait 2^30 is 1073741824. 1e9 is 1000000000. So 1e9 is less than 2^30, which is 1073741824.\n\n1e9 in binary is a number with 30 bits because 2^29 is 536870912 and 2^30 is larger. So 1e9 has bit_length() =30.\n\nSubtracting 1 gives 29. highest_bit_position is 29.\n\nThen, 1<<30 is 1073741824.\n\nWait, but that's correct because the next_pow after 1e9 is 2^30.\n\nYes.\n\nSo the code seems correct.\n\nWait, but what happens when number is already a power of two?\n\nLike, number=16, 16 is 10000. Its bit_length is 5, highest_bit_position is4. Then 1 shifted left by 5 is 32.\n\nWhich is correct.\n\nWait, for number=8 (1000), highest_bit is 3, next is 16.\n\nYes, correct.\n\nSo this seems to work.\n\nThus, the code seems correct.\n\nSo now, writing it as:\n\ndef find_next_power_of_two(number: int) -> int:\n    if number == 0:\n        return 1\n    highest_bit = number.bit_length() -1\n    return 1 << (highest_bit + 1)\n\nWait, let's test all the examples:\n\nSample 1: number=0 \u2192 returns 1. Correct.\n\nSample 2: number=1 \u2192 2. Correct.\n\nSample3: number=15 \u219216. Correct.\n\nSample4: number=16 \u2192 32. Correct.\n\nOther test cases:\n\nnumber=5 \u21928.\n\nnumber=2 \u21924.\n\nYes, all passing.\n\nBut wait, let me think about another edge case.\n\nWhat if the number is 1? Then next power is 2.\n\nSame as example.\n\nWhat if the number is 2^k -1? For example, 3 = 2^2-1. Next power is 4.\n\nThus code correctly returns 4.\n\nAnother case: number=31 \u2192 next power is 32.\n\nAll seems correct.\n\nI think that should work.\n</think>\n\nTo solve this problem, we need to find the smallest power of two that is greater than a given non-negative integer. This problem can be efficiently solved using bitwise operations to determine the highest set bit in the binary representation of the number.\n\n### Approach\n1. **Handle Special Case for Zero**: If the input number is zero, the function should return 1 because the smallest power of two greater than zero is 1.\n2. **Determine the Highest Set Bit**: For any non-zero number, the position of the highest set bit can be found using the `bit_length()` method. This method returns the number of bits necessary to represent the number, which gives us the position of the highest set bit when adjusted by subtracting 1.\n3. **Calculate the Next Power of Two**: Once we have the position of the highest set bit, the next power of two can be calculated by left-shifting 1 by one position more than the highest set bit position.\n\n### Solution Code\n\n```python\ndef find_next_power_of_two(number: int) -> int:\n    if number == 0:\n        return 1\n    highest_bit = number.bit_length() - 1\n    return 1 << (highest_bit + 1)\n```\n\n### Explanation\n1. **Special Case Handling**: The function first checks if the input number is zero. If it is, the function immediately returns 1, as the smallest power of two greater than zero is 1.\n2. **Finding the Highest Set Bit**: For non-zero numbers, the `bit_length()` method is used to determine the number of bits required to represent the number. Subtracting 1 from this value gives the position of the highest set bit.\n3. **Computing the Next Power of Two**: Using bitwise left-shift operation, the function calculates the next power of two by shifting 1 to the left by one position more than the highest set bit position. This effectively doubles the value of the highest found power of two, giving the next power of two.\n\nThis approach is efficient and handles the problem constraints within a reasonable time frame, even for large values up to \\(10^9\\).",
  "r1_solution": "def find_next_power_of_two(number: int) -> int:\n    if number == 0:\n        return 1\n    highest_bit = number.bit_length() - 1\n    return 1 << (highest_bit + 1)",
  "metadata": {
    "prompt_id": "00000052",
    "row_id": 52,
    "seed_ids": [
      1050
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}