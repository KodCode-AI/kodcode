{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000004_C",
  "question": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid\n        else:\n            upper_bound = mid - 1\n    \n    return result",
  "solution": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"\n    Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid\n        else:\n            upper_bound = mid - 1\n    \n    return result",
  "test_code": "import pytest\n\ndef test_optimized_integer_square_root():\n    assert optimized_integer_square_root(15) == 3\n    assert optimized_integer_square_root(31) == 5\n    assert optimized_integer_square_root(25) == 5\n    assert optimized_integer_square_root(1) == 1\n    assert optimized_integer_square_root(0) == 0\n    assert optimized_integer_square_root(2_147_483_647) == 46340\n    with pytest.raises(ValueError):\n        optimized_integer_square_root(-1)",
  "test_info": [
    {
      "function_name": "optimized_integer_square_root",
      "parameter_list": "(num)",
      "function_declaration": "def optimized_integer_square_root(num):",
      "docstring": "Returns the integer square root of a non-negative integer num.\nRaises ValueError for negative inputs."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, I need to implement an optimized integer square root function. The function should return the largest integer whose square is less than or equal to the input number. Also, it should handle non-negative integers and raise a ValueError for negatives.\n\nFirst, I should check if the input is negative. Yeah, so if num is less than 0, raise a ValueError. Got that part.\n\nWhat about when num is 0 or 1? Well, the square roots are themselves, so return num directly.\n\nFor numbers greater than 1, I think binary search would be efficient here. Binary search can quickly find the floor value without checking every number up to num.\n\nWait, what's a good range for binary search here? The square root can't be larger than half of num for numbers greater than 2. Or wait, no, that's not quite right. Actually, for any number, the square root is somewhere between 1 and num itself. But for optimization, maybe I can start with a tighter upper bound. Oh right, for numbers like 2, square root is about 1.4, so maybe starting with num//2 as the upper bound? Or sometimes, perhaps num is a perfect square, but that shouldn't matter.\n\nWait, wait, no: wait the square of (num//2) could be much smaller than num, especially for larger num. Wait, for example, 100: num//2 is 50, 50 squared is 2500 which is way bigger than 100. Oh right, so using num//2 as the upper bound is still okay because binary search will adjust. But maybe that's not the best upper bound. Oh, but maybe for the worst case, like when num is a perfect square just over (n)^2, it's okay.\n\nBut maybe a better approach is to start the lower bound at 1 and upper bound at num. Wait, no, for large num like 10^18, starting with upper as num is excessive, and binary search will take more steps. So perhaps, there's a better initial point for upper bound.\n\nWait, there's an often used method where we find the position in binary where the leading 1 is. For example, for 32-bit numbers, the square root is at most 2^16 (since (2^16)^2 is 2^32). So maybe we can find the upper bound by shifting bits or something. But perhaps for this problem, it's okay to keep the binary search between 1 and num//2.\n\nAlternatively, wait! The maximum possible square root for a number is when the number is between (n)^2 and (n+1)^2. So the integer square root is n, and the upper bound can be set to n+1. So when num is larger than 1, the square root is at least 2, maybe.\n\nAlternatively, we can handle it by setting upper bound to min(num, 1 << 32) or something, but perhaps that's overcomplicating.\n\nWait, perhaps for a general case, the initial upper bound can be calculated using bit operations. For example, a quick way to find an upper bound is to take the number and right-shift it by (bits//2). Wait, no, that's for specific algorithms. Hmm.\n\nAlternatively, for this function, since num can be any non-negative integer, perhaps using binary search between 1 and num is acceptable. But wait, when the number is large, say 1e30, the binary search from 1 to 1e30 would take, what, 100 steps? Because each step the range halves, so logarithmic time. That's manageable.\n\nBut perhaps the initial approach can be optimized by setting a smarter upper bound. Like for num in [2..4], upper bound could be 2, but in binary search, it would find it quickly either way.\n\nSo maybe setting the initial lower and upper bounds as 1 and num. Wait no: for example, if num is 8, the square root is 2. So lower is 1, upper is 8. But binary search would start mid at (1+8)//2=4, then realize that 4^2 is 16>8, so upper becomes 3, mid becomes 2, and check 2^2 is 4<8. Then lower becomes 3, mid is 5 (but wait upper is 3), so loop ends and returns. So perhaps that's correct.\n\nBut that approach works, but might take more steps. Using a tighter upper bound can reduce the number of steps, but perhaps not significantly for the problem's use case. So perhaps for simplicity, setting lower=1 and upper=num//2 as it's more efficient for numbers larger than 1.\n\nWait, but when num is 2, num//2 is 1, lower=1 so loop runs once: mid=1, 1^2=1<2, then lower becomes 2, loop ends. So the function returns 1, which is correct.\n\nLet's see. Let's walk through some examples to see how the algorithm works.\n\nExample 1: num=17.\n\nlower=1, upper=8.\n\nmid=(1+8)/2=4.5 -> 4, mid^2=16<17? Yes. So result is 4, lower becomes 5.\n\nNext, upper=8, mid=(5+8)//2=6. 6^2=36>17. So upper=5.\n\nNow, lower=5, upper=5. Mid=5, 5^2=25>17. So upper=4. Loop ends. So returns result which is 4, correct.\n\nAnother example: num=25.\n\nmid would eventually find 5, which is perfect.\n\nAnother example: num=2.\n\nlower=1, upper=1.\n\nLoop runs once, mid=1, 1^2=1<2. So lower=2. Now, upper is 1 so loop ends. Returns 1.\n\nWait, but what if num is 4?\n\nlower=1, upper=2.\n\nmid=1: 1^2=1<4, so result=1, lower=2.\n\nlower=2, upper=2: mid=2, 2^2=4 ==4, return 2.\n\nGood.\n\nWhat about num=30: square root is 5.\n\nLet's see:\n\nlower=1, upper=15.\n\nmid=(1+15)/2=8. 8^2=64>30, so upper=7.\n\nmid=(1+7)/2=4. 4^2=16<30, result=4, lower=5.\n\nlower=5, upper=7.\n\nmid=6: 6^2=36>30, so upper=5.\n\nNow lower=5, upper=5.\n\nmid=5, 5^2=25<30. So result=5, lower=6.\n\nLoop condition fails, returns 5. Correct.\n\nSo seems to work.\n\nWait, but in the code I was about to write, should I have the result variable? Because in the code I provided earlier, there's a line where if mid squared is less than num, update result and lower. Else, update upper.\n\nHmm, but I have to make sure that if the exact square is found, it returns mid directly. Otherwise, it should iterate and keep track of the highest mid where mid squared is less than num.\n\nWait, in the code I provided, the function starts with the case where num is 0 or 1, returning directly. Otherwise, lower starts at 1, upper at num//2.\n\nWait no, in the initial code, for numbers greater than 1, lower is 1 and upper is num//2. Hmm, is num//2 always larger than or equal to 1? Well for num>=2, yes. Because 2//2 is 1.\n\nWait, but for num=2, upper is 1, which is correct since mid starts at 1, which gives square 1<2, and the result is 1.\n\nIn code, when mid squared is equal to num, return mid immediately.\n\nOtherwise, if mid squared is less than num, update the result to mid and move lower to mid+1, else move upper to mid-1.\n\nWait, so in the case where we don't find an exact square, the result will hold the last mid where the square was less than num. But is that the correct floor value?\n\nWait, let's test with the earlier example of num=30: 30 has a floor sqrt of 5.\n\nIn the code:\n\nlower=1, upper=15.\n\nmid=8 \u2192 64>30 \u2192 upper=7.\n\nmid=4 (since (1+7)//2 is 4) \u2192 16<30 \u2192 result=4, lower=5.\n\nlower=5, upper=7.\n\nmid=6 \u219236>30 \u2192 upper=5.\n\nNow, lower is 5, upper is5. So mid=(5+5)/2=5.\n\nmid_squared=25<30 \u2192 so result is 5, and lower=6.\n\nThen, the loop condition is lower<=upper? Now, lower is 6 and upper is5: loop ends.\n\nSo the function returns the last result which is 5. Correct.\n\nAnother example: num=6.\n\nsqrt is 2.\n\nlower=1, upper=3.\n\nmid=2, 4<6 \u2192 result 2, lower=3.\n\nmid= (3+3)/2=3. 3 squared is 9>6: upper=2.\n\nLoop ends, returns 2. Correct.\n\nSo, the code seems to handle that.\n\nWait, but what about when num is a perfect square? Like 25:\n\nIn code: lower=1, upper=12.\n\nmid=6 \u219236>25\u2192upper=5.\n\nmid=(1+5)/2=3 \u21929<25\u2192 result=3, lower=4.\n\nmid=4 \u219216<25 \u2192 result=4, lower=5.\n\nNext, mid=5 \u219225=25\u2192 returns 5.\n\nPerfect.\n\nWait, but what if I have even mid where the square is exactly num?\n\nI think the code correctly handles it.\n\nWhat about when the function returns the result variable in the case where mid squared is less than num but it's the maximum floor value. That's why in the loop, whenever mid squared is less than num, the current mid is the best candidate so far, which is stored in result. Then, the lower bound is moved up to see if a higher mid can have a square less than num.\n\nBut wait, suppose in the case where mid squared is less than num, and then mid is 1, and the next mid is 2, which may be bigger than required, but perhaps upper bound would adjust.\n\nWait, perhaps the variable 'result' is being updated only when mid_squared is less than num. So the variable always holds the highest mid found so far whose square is less than or equal to num.\n\nWait, but in the else case when mid_squared > num, the upper is moved.\n\nSo perhaps the code is correctly capturing the integer square root.\n\nBut wait, I'm thinking about edge cases. What about when num is 1?\n\nWait, the initial condition handles num=0 and num=1, returning it. That's good.\n\nWhat about num=2?\n\nYes, as I saw earlier, returns 1.\n\nWhat about num=3?\n\nSame as 2? Yes, because lower=1, upper=1.\n\nmid=1, 1^2=1<3: result=1, lower=2.\n\nLoop ends, returns 1.\n\nWhich is correct.\n\nSo, now, let's think about the code structure.\n\nAlso, the code is returning 'result' at the end. So if the loop ends without finding an exact square, it returns the last best result.\n\nBut I should test what happens when the loop exits without the 'return mid' path being taken.\n\nWait, in the code, the 'return mid' is hit only when mid_square == num. Otherwise, it continues.\n\nSo, in such cases, after the loop, return the 'result' which was the last mid where mid_square < num.\n\nSo is this correct?\n\nWait, let me take num=7.\n\nLower=1, upper=3.\n\nMid=2: 2\u00b2=4 <7 \u2192 result=2, lower=3.\n\nMid= (3+3)/2=3: 9>7 \u2192 upper=2.\n\nLower is 3, upper is 2: loop ends. Return result=2.\n\nWhich is correct.\n\nSo the code seems to handle that.\n\nSo, the code seems to have it covered.\n\nAnother test case: num=5.\n\nlower=1, upper=2.\n\nMid=1.5\u2192 mid=1. Mid_squared=1<5, so result=1, lower=2.\n\nNext, mid= (2+2)/2=2. 2\u00b2=4<5 \u2192 result=2, lower=3.\n\nLoop ends, returns 2.\n\nWhich is correct.\n\nThus, the code handles all the test cases correctly.\n\nWait, but what about when the function is called with a very large number, say 10^18? The binary search would require about 60 steps, which is manageable.\n\nBut what about when num is 2? Let's see:\n\nlower=1, upper=1.\n\nMid=1, 1<2 \u2192 set result=1, lower=2. Loop ends.\n\nReturn 1.\n\nYes.\n\nWhat about when num is 1? Handled by initial condition.\n\nWait, the code is correct? Or is there a loop condition that may cause it to fail?\n\nAnother thought: in the code, what if num is 6:\n\nNum is 6.\n\nLower=1, upper=3.\n\nMid=2, 4 <6: result=2, lower=3.\n\nmid=3:9>6, so upper=2.\n\nLoop ends, returns 2.\n\nWhich is correct.\n\nYes.\n\nI think the code is correct.\n\nBut let's check for another case where num is between (n)^2 and (n+1)^2-1.\n\nLike, num=35 \u2192 5\u00b2=25, 6\u00b2=36. So sqrt(35) is 5.\n\nIn the code:\n\nlower=1, upper=17.\n\nWait, wait num is 35. upper is 35//2=17.\n\nWait, let me see:\n\nInitial loop:\n\nlower=1, upper=17.\n\nmid=(1+17)//2=9 \u21929^2=81>35 \u2192 upper=8.\n\nmid=(1+8)//2=4 \u219216<35 \u2192result=4, lower=5.\n\nmid=(5+8)//2=6 \u219236>35 \u2192 upper=5.\n\nNow, lower=5, upper=5.\n\nMid=5 \u219225 <35 \u2192 result=5, lower=6.\n\nLoop ends. Return 5.\n\nCorrect.\n\nSo yes, seems correct.\n\nThus, the code appears to handle all cases correctly, including the cases when the square is found exactly and when it's not.\n\nThus, the function should be correct.\n\nAnother corner case: num=0, should return 0. And the initial condition does that.\n\nYes.\n\nAnother case: num=1, returns 1.\n\nThus, the code handles that.\n\nSo the function seems to be correct.\n</think>\n\nTo solve this problem, we need to compute the integer square root of a non-negative integer. The integer square root is the largest integer whose square is less than or equal to the given number. This problem can be efficiently solved using a binary search approach, which provides an optimal solution with a time complexity of O(log n).\n\n### Approach\n1. **Initial Checks**: Handle edge cases where the input number is 0 or 1, returning the number itself as these are their own square roots.\n2. **Binary Search Setup**: Use two pointers, `lower_bound` and `upper_bound`, to bound the search space. Start with `lower_bound` at 1 and `upper_bound` at half of the input number to optimize the search range.\n3. **Binary Search Execution**: Continuously narrow down the search space by adjusting the `lower_bound` and `upper_bound` based on whether the square of the midpoint is less than or greater than the input number.\n4. **Track Result**: Keep track of the highest midpoint found whose square is less than the input number to ensure the correct result is returned when the exact square is not found.\n\n### Solution Code\n```python\ndef optimized_integer_square_root(num: int) -> int:\n    \"\"\"Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    result = 0  # Initialize result to store the highest valid value\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            result = mid\n            lower_bound = mid + 1\n        else:\n            upper_bound = mid - 1\n    \n    return result\n```\n\n### Explanation\n- **Edge Cases Handling**: The function immediately returns 0 or 1 if the input is 0 or 1, respectively, as these are straightforward cases.\n- **Binary Search**: The binary search is initiated with `lower_bound` at 1 and `upper_bound` at `num // 2`. This helps in reducing the search space significantly for larger numbers.\n- **Midpoint Calculation**: In each iteration, the midpoint is calculated, and its square is compared to the input number. If the square is exactly the input number, the midpoint is returned immediately.\n- **Adjusting Bounds**: If the midpoint square is less than the input number, it means the integer square root could be higher, so the `lower_bound` is updated. Otherwise, the `upper_bound` is adjusted to narrow down the search space.\n- **Tracking Result**: When the midpoint square is less than the input number, the midpoint is stored as the current highest valid result, ensuring the correct integer square root is returned when the loop exits.\n\nThis approach efficiently narrows down the possible values using binary search, ensuring optimal performance even for very large numbers.",
  "r1_solution": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    result = 0  # Initialize result to store the highest valid value\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            result = mid\n            lower_bound = mid + 1\n        else:\n            upper_bound = mid - 1\n    \n    return result",
  "metadata": {
    "prompt_id": "00000004",
    "row_id": 4,
    "seed_ids": [
      691
    ],
    "mode": "algorithm",
    "original_instruction": "You are given a Python function `integer_square_root` that calculates the integer square root of a non-negative integer using a binary search approach. Your task is to implement a more efficient version of this function. Specifically, you need to optimize the current implementation to reduce the number of iterations in the binary search while handling edge cases properly.\n\n**Function Signature**:\n```python\ndef optimized_integer_square_root(num: int) -> int:\n    pass\n```\n\n**Requirements**:\n- The function must handle non-negative integers as input and raise a `ValueError` if the input is negative.\n- The function should return the integer square root of `num` rounded down to the nearest integer.\n- The optimized version should have a time complexity of \\(O(\\log(n))\\) and use \\(O(1)\\) space complexity.\n- Implement an early return for perfect squares and optimize the bounds checking in the binary search.\n\n**Test Cases**:\n```python\nassert optimized_integer_square_root(15) == 3\nassert optimized_integer_square_root(31) == 5\nassert optimized_integer_square_root(25) == 5\nassert optimized_integer_square_root(1) == 1\nassert optimized_integer_square_root(0) == 0\nassert optimized_integer_square_root(2_147_483_647) == 46340\nassert optimized_integer_square_root(-1) is None  # Should raise ValueError\n```\n\n**Note**:\nEnsure that the edge cases and performance are handled correctly. Optimize the bounds checking and early returns to improve the efficiency of the function."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results0.jsonl"
}