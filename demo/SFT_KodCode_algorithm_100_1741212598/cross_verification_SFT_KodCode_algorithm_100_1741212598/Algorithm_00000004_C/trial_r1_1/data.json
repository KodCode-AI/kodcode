{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000004_C",
  "question": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid\n        else:\n            upper_bound = mid - 1\n    \n    return result",
  "solution": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"\n    Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid\n        else:\n            upper_bound = mid - 1\n    \n    return result",
  "test_code": "import pytest\n\ndef test_optimized_integer_square_root():\n    assert optimized_integer_square_root(15) == 3\n    assert optimized_integer_square_root(31) == 5\n    assert optimized_integer_square_root(25) == 5\n    assert optimized_integer_square_root(1) == 1\n    assert optimized_integer_square_root(0) == 0\n    assert optimized_integer_square_root(2_147_483_647) == 46340\n    with pytest.raises(ValueError):\n        optimized_integer_square_root(-1)",
  "test_info": [
    {
      "function_name": "optimized_integer_square_root",
      "parameter_list": "(num)",
      "function_declaration": "def optimized_integer_square_root(num):",
      "docstring": "Returns the integer square root of a non-negative integer num.\nRaises ValueError for negative inputs."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, I need to write an optimized integer square root function in Python. Hmm, I remember that the integer square root is the largest integer whose square is less than or equal to the input number. So for example, the square root of 8 is 2 because 2*2=4 which is less than 8, and 3*3=9 which is more than 8.\n\nThe function needs to take a non-negative integer. Oh right, I should first check if the input is negative. If it is, I raise a ValueError. What about zero or one? Those should return 0 and 1 respectively since their square roots are themselves.\n\nFor other numbers, how do I find the square root efficiently? Binary search comes to mind. That makes sense because the possible square roots are between 1 and num//2. Wait, wait, is it up to num or num//2? Well, if the number is a perfect square, the root could be as large as num//1, but the binary search can handle the range correctly. Oh right, for numbers like 4, the square root is 2, which is <= 4//2=2.\n\nSo I'll set the lower_bound to 1 and upper_bound to num//2. Wait, but wait, for num like 5, the upper bound is 2, which is correct because sqrt(5) is about 2.23. Hmm, so binary search between 1 and upper_bound.\n\nNow, I'll loop while lower_bound is less than or equal to upper_bound. In each iteration, calculate mid as the average of lower and upper, using integer division.\n\nCompute mid_squared as mid*mid. Compare that to num:\n\n- If mid_squared equals num, then mid is the exact square root, return it.\n- If mid_squared is less than num, then the result could be mid, but maybe there's a larger number that's still less than or equal to num. So I update result to mid and set lower_bound to mid+1.\n- Else, mid_squared is larger, so I set upper_bound to mid-1.\n\nWait, but how do I keep track of the closest result? Because in the case where mid_squared is less than num, I save that mid and then search higher. So the 'result' variable needs to be initialized once, outside the loop. Or maybe I can start it as 0. Oh, right, because in the loop, when I find mid_squared < num, I set result to mid. The lower_bound is increased to look for higher possible mids. So this should correctly capture the highest possible mid where mid*mid <= num.\n\nWait, but what about when the number is not a perfect square? Like 8, the loop should still correctly leave result as 2, which is correct. Let me see.\n\nLet's test this logic step by step with num=8.\n\nInitial: lower=1, upper=4.\n\nmid=(1+4)/2=2. mid_squared=4 < 8. So result=2, lower becomes 3.\n\nNext iteration, lower=3, upper=4. mid=(3+4)/2=3. mid_squared=9>8. So upper becomes 2.\n\nNow, loop condition: lower=3 > upper=2, exit loop.\n\nReturn result which is 2. Correct.\n\nAnother test case: num=9.\n\nlower=1, upper=4. mid=2.5, but integer division is 2.\n\nmid_squared=4 <9: result=2, lower=3.\n\nNext mid=(3+4)/2=3, 3^2=9: return 3.\n\nGood.\n\nWhat if num=10?\n\nlower=1, upper=5.\n\nmid=3, 9 <10: result=3, lower=4.\n\nmid=(4+5)/2=4, 16>10. So upper=3.\n\nLoop ends, return result=3 which is correct because 3^2=9<10 and 4^2=16>10.\n\nAnother test: num=2.\n\nlower=1, upper=1. mid=1, 1<2: result=1, lower=2.\n\nLoop ends as lower>upper. Return 1. Which is correct because sqrt(2) is ~1.414, so integer part is 1.\n\nWait, I'm thinking, what if num is 0? The code returns it. Yes.\n\nWhat about num=1? Returns 1.\n\nWhat about if num is a large number, like 1000000? sqrt(1000000) is 1000. Let's see. lower starts at 1, upper at 500000. It should quickly converge.\n\nI think this logic is correct. So I need to implement this.\n\nNow, in the code:\n\nFirst, handle the edge cases: if num is negative: raise ValueError. If num is 0 or 1, return num.\n\nElse, initialize lower as 1, upper as num//2.\n\nresult can be initialized as 0.\n\nThen, while lower <= upper:\n\nmid = (lower + upper) //2\n\nmid_sq = mid*mid\n\nif mid_sq == num: return mid\n\nelif mid_sq < num:\n\nresult = mid\n\nlower = mid +1\n\nelse:\n\nupper = mid-1\n\nAfter the loop, return result.\n\nYes, but what if num=2, after processing, the result is 1, which is correct.\n\nWhat about num=3?\n\nLoop:\n\nlower=1, upper=1.\n\nmid=1, 1 <3: result=1, lower=2. Loop ends, return 1.\n\nWhich is correct.\n\nHmm, looks solid.\n\nSo the code will work.\n</think>\n\nTo solve this problem, we need to compute the integer square root of a given non-negative integer. The integer square root is the largest integer whose square is less than or equal to the input number. \n\n### Approach\nThe approach to solve this problem efficiently involves using binary search. Binary search is chosen because it allows us to quickly narrow down the possible candidates for the integer square root by repeatedly dividing the search interval in half. Here is the detailed approach:\n\n1. **Handle Edge Cases**: If the input number is negative, raise a ValueError. If the input number is 0 or 1, return the number itself as these are straightforward cases.\n2. **Initialize Bounds**: Set the lower bound to 1 and the upper bound to half of the input number. This is because the square of any number larger than half of the input number will exceed the input number.\n3. **Binary Search**: Use a while loop to perform the binary search. In each iteration, compute the mid-point and its square. Adjust the search bounds based on whether the mid-point square is less than, equal to, or greater than the input number.\n4. **Track Result**: Keep track of the highest mid-point value that does not exceed the input number when squared. This ensures that even if the exact square root is not found, the closest lower integer is returned.\n\n### Solution Code\n```python\ndef optimized_integer_square_root(num: int) -> int:\n    \"\"\"Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    result = 0  # Initialize to 0 in case all mids are too high\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            result = mid\n            lower_bound = mid + 1\n        else:\n            upper_bound = mid - 1\n    \n    return result\n```\n\n### Explanation\n1. **Edge Cases Handling**: The function immediately handles the edge cases where the input is negative (raises ValueError), or the input is 0 or 1 (returns the input directly).\n2. **Initialization**: The lower bound is set to 1 and the upper bound to `num // 2` to start the binary search.\n3. **Binary Search Loop**: The loop continues adjusting the bounds until it finds the exact square root or until the bounds cross each other. The result is updated whenever a valid mid-point is found that does not exceed the input number when squared.\n4. **Efficiency**: The binary search approach ensures that the function runs in O(log n) time complexity, making it highly efficient even for very large numbers.\n\nThis approach efficiently finds the integer square root using binary search, ensuring optimal performance and correctness for all non-negative integers.",
  "r1_solution": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    result = 0  # Initialize to 0 in case all mids are too high\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            result = mid\n            lower_bound = mid + 1\n        else:\n            upper_bound = mid - 1\n    \n    return result",
  "metadata": {
    "prompt_id": "00000004",
    "row_id": 4,
    "seed_ids": [
      691
    ],
    "mode": "algorithm",
    "original_instruction": "You are given a Python function `integer_square_root` that calculates the integer square root of a non-negative integer using a binary search approach. Your task is to implement a more efficient version of this function. Specifically, you need to optimize the current implementation to reduce the number of iterations in the binary search while handling edge cases properly.\n\n**Function Signature**:\n```python\ndef optimized_integer_square_root(num: int) -> int:\n    pass\n```\n\n**Requirements**:\n- The function must handle non-negative integers as input and raise a `ValueError` if the input is negative.\n- The function should return the integer square root of `num` rounded down to the nearest integer.\n- The optimized version should have a time complexity of \\(O(\\log(n))\\) and use \\(O(1)\\) space complexity.\n- Implement an early return for perfect squares and optimize the bounds checking in the binary search.\n\n**Test Cases**:\n```python\nassert optimized_integer_square_root(15) == 3\nassert optimized_integer_square_root(31) == 5\nassert optimized_integer_square_root(25) == 5\nassert optimized_integer_square_root(1) == 1\nassert optimized_integer_square_root(0) == 0\nassert optimized_integer_square_root(2_147_483_647) == 46340\nassert optimized_integer_square_root(-1) is None  # Should raise ValueError\n```\n\n**Note**:\nEnsure that the edge cases and performance are handled correctly. Optimize the bounds checking and early returns to improve the efficiency of the function."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}