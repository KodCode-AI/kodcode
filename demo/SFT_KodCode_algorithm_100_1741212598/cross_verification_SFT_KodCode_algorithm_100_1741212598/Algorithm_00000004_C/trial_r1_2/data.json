{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000004_C",
  "question": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid\n        else:\n            upper_bound = mid - 1\n    \n    return result",
  "solution": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"\n    Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid\n        else:\n            upper_bound = mid - 1\n    \n    return result",
  "test_code": "import pytest\n\ndef test_optimized_integer_square_root():\n    assert optimized_integer_square_root(15) == 3\n    assert optimized_integer_square_root(31) == 5\n    assert optimized_integer_square_root(25) == 5\n    assert optimized_integer_square_root(1) == 1\n    assert optimized_integer_square_root(0) == 0\n    assert optimized_integer_square_root(2_147_483_647) == 46340\n    with pytest.raises(ValueError):\n        optimized_integer_square_root(-1)",
  "test_info": [
    {
      "function_name": "optimized_integer_square_root",
      "parameter_list": "(num)",
      "function_declaration": "def optimized_integer_square_root(num):",
      "docstring": "Returns the integer square root of a non-negative integer num.\nRaises ValueError for negative inputs."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, so I have this function called optimized_integer_square_root which is supposed to return the integer square root of a non-negative integer. Hmm, the integer square root is like, the largest integer whose square is less than or equal to the number. So for example, sqrt(25) would be 5, and sqrt(24) would be 4, right?\n\nThe function starts by checking if num is negative. That makes sense because square roots of negative numbers aren't real, so it raises a ValueError. Then, if num is 0 or 1, it returns num. Yeah, because sqrt(0) is 0 and sqrt(1) is 1.\n\nWait, the function then initializes lower_bound as 1. Oh, but wait, what if num is 0 or 1? Oh right, those cases are already handled before. So the function skips that part and initializes lower and upper bounds for numbers larger than 1.\n\nUpper_bound is set to num // 2. Hmm, why half? Oh right, because the square root of a number can't be larger than half of it once the number is bigger than 2. Because (n/2)^2 is n\u00b2/4, which is bigger than n when n>4. So for example, if n is 16, n//2 is 8, and sqrt(16) is 4, which is less than 8. So this upper_bound seems reasonable to reduce the search space.\n\nThen it enters a while loop which continues as long as lower_bound is less than or equal to upper_bound. Inside the loop, it calculates mid as the average of lower and upper bounds, using integer division. Then it squares mid and checks against num.\n\nIf mid squared equals num, it's a perfect square, so return mid. Otherwise, if mid squared is less than num, that means the actual square root is higher. So it sets the lower_bound to mid +1 and records mid as the current result. Because mid might still be the floor sqrt, but maybe not the final.\n\nWait, why is result set to mid here? Oh because if even after moving lower_bound up, the next mid might not square to something less than num, so the last valid mid is stored as result.\n\nOtherwise, if mid squared is larger than num, then we need to look lower. So upper_bound becomes mid -1.\n\nNow, the question: is this function correctly handling all cases?\n\nLet me think about a few examples.\n\nLet's try num=2. The function skips the initial checks. lower is 1, upper is 1. mid is 1. 1 squared is 1, which is less than 2. So lower becomes 2, upper is 1. Loop ends. Return result, which is 1. Correct.\n\nAnother example: num=6. sqrt(6) is 2.something, so return 2.\n\nlower=1, upper=3 (since 6//2 is 3). mid is 2. 2^2 is 4 <6: lower becomes 3, result=2.\n\nNow lower is 3, upper 3: mid is 3. 3^2 is 9>6. So upper becomes 2. Loop ends. Return result=2. Correct.\n\nAnother example: num=15. sqrt is 3.872... so should return 3.\n\nlower=1, upper=7 (15//2=7). mid=4. 16>15, so upper becomes 3.\n\nNow lower=1, upper=3: mid=2. 4<15: lower becomes 3, result=2.\n\nNext iteration: lower=3, upper=3. mid=3. 9<15: lower is 4, but upper is 3, so loop ends. Return result=3? No, wait, wait, no.\n\nWait, after mid=3, mid squared is 9 which is less than 15. So lower is set to 3+1=4. Upper is 3. Now lower is 4>upper 3: loop ends. So the last result was when mid was 3, which stored result as 3. So it returns 3? Wait no, wait. Let me walk through it step by step.\n\nWait, when num=15:\n\nStart: lower=1, upper=7.\n\nMid is 4, squared 16>15, so upper=3.\n\nNext, lower=1, upper=3: mid is 2, squared 4 <15. So lower becomes 3, result=2.\n\nThen mid is (3+3)//2 =3, squared 9 <15: so lower becomes 4, result=3.\n\nNow loop condition: lower (4) <= upper (3)? No. Loop ends. So return result which is 3. Correct.\n\nWhat if num is 17? real sqrt is 4.123, so floor is 4.\n\nFunction:\n\nlower=1, upper=8.\n\nmid=4.5~4 as integer (since 9//2=4). Mid is 4, squared 16 <17. So lower=5, result=4.\n\nNow mid is (5+8)//2=6.5~6. 6^2=36>17: upper becomes 5.\n\nNow lower is 5, upper 5: mid=5. 5^2=25>17: upper becomes4.\n\nLoop ends. So return result=4. Correct.\n\nAnother case: num is 0. returns 0. num=1 returns 1.\n\nWhat about a perfect square like 25:\n\nlower starts at1, upper=12.\n\nmid=6.5=6, 6^2=36>25: upper becomes 5.\n\nlower=1, upper=5: mid=3, 9<25: lower=4, result=3.\n\nmid=(4+5)/2=4. 16<25: lower=5, result=4.\n\nNow lower=5, upper=5: mid=5, 25=25. Return 5. Correct.\n\nWhat about num=2? Already tried, returns 1.\n\nWait, but what about num=3?\n\nSo during the run, it should return 1.\n\nLet's see.\n\nnum=3: lower=1, upper=1.\n\nmid=1, 1^2=1 <3: so lower=2, result=1.\n\nNow lower=2, upper=1: loop ends. return 1. Correct.\n\nWait, what about num=4?\n\nlower=1, upper=2.\n\nmid=1 (as (1+2)//2 is 1). 1 <4: lower becomes 2, result 1.\n\nThen mid is (2+2)//2=2. 2^2=4= num. Returns 2.\n\nSo all test cases seem handled correctly.\n\nWait, is there a problem with the initial cases for 0 and 1?\n\nYes, but how about when num is a very large number, like 1e18? Binary search should be efficient regardless.\n\nBut wait, I wonder if the initial value for upper_bound is correct. I mean, for numbers larger than 1, upper_bound is set to num // 2. But for num=2, it's 1, which is okay.\n\nBut wait, what about for num=5: sqrt(5) is about 2.236. So the function needs to return 2.\n\nLower starts at 1, upper is 2. Mid is 1: 1^2=1<5: lower becomes 2, result 1.\n\nThen, upper is 2, lower=2. Mid is 2, mid squared is 4<5: lower becomes3, making the loop end because lower>upper. So the result remains 2. So correct.\n\nSo everything seems to check out.\n\nWait, but I'm a bit confused about the 'result' variable. Because during the loop, every time mid_squared is less than num, it sets result to mid, regardless of whether it's higher or lower. But wait, that's correct because if mid^2 < num, then the sqrt could be higher, and we need to keep exploring higher midpoints. And we record mid as a possible result (floor). So any time a mid is found to be a lower value, it's saved, and if no higher mid satisfies, the last saved result is the floor.\n\nWait, actually, the function is correct because the binary search ensures that when mid_squared == num, it returns it immediately. If not, it's like whenever mid_squared < num, we move lower up but keep the mid as a possible result (since it's part of the floor sqrt). Otherwise, we decrease upper.\n\nSo for example, in the example of 6:\n\nAfter mid=2, which is 4<6: result is 2, lower becomes 3.\n\nNext mid is (3+3)=3: 9>6, so upper becomes 2. So the loop ends, and returns 2.\n\nYes, correct.\n\nI think this code should be correct. The only thing I'm concerned about is the initialization of upper_bound as num//2. But considering that any integer larger than num//1 would be a possible square root for numbers <= (num//1)^2. Wait, wait, no. Wait, the square of (num//2 +1) for even and some odd numbers:\n\nWait for example, let's take num=15, then num//2 is 7. The actual sqrt is 3, which is way less than 7. So is upper_bound of num//2 enough?\n\nYes, because the square of (num//2) could be as high as (num^2)/4, which for num >=4 is larger.\n\nWait, for any num >= 2, (num/2)^2 is num\u00b2/4. For num>4, num\u00b2/4 > num (since for num=5, 25/4=6.25>5. Wait, 5\u00b2 is 25, wait no. Oh wait, no: the number is num, and upper_bound is set to num//2.\n\nWait, no: the code computes the square of mid and compares to num. So for example, if upper_bound is num//2, that could be a very high upper bound, but the binary search reduces it quickly.\n\nSo for example, for num= 999999999999, upper_bound is ~500 million. The binary search will only take about 30 steps, as that's log2(5e8) is around 29 steps.\n\nSo this should be efficient.\n\nAnother possible case: num= (2^64) which is a huge number, but the code would still handle it quickly.\n\nOkay, so the code seems correct. But perhaps could it be optimized further?\n\nWait, wait, what's the maximum possible integer square root of a number? It's num itself in the case of perfect squares, but upper_bound is set to num//2, which is better.\n\nSo I think the function is correct. So I don't see any errors in this implementation.\n</think>\n\nThe function `optimized_integer_square_root` efficiently computes the integer square root of a non-negative integer using binary search. It handles edge cases appropriately and uses logical bounds to minimize the search space, ensuring optimal performance.\n\n**Step-by-Step Explanation:**\n\n1. **Input Validation:**\n   - The function first checks if the input is negative, raising a `ValueError` if true.\n   - For inputs 0 or 1, it directly returns the input as their square roots are themselves.\n\n2. **Initialization:**\n   - `lower_bound` is initialized to 1, as the square root of any number greater than 1 is at least 1.\n   - `upper_bound` is set to `num // 2`, which reduces the search space significantly. The square root of a number `num` is always less than or equal to `num // 2` for `num > 2`.\n\n3. **Binary Search Loop:**\n   - The loop continues until `lower_bound` exceeds `upper_bound`.\n   - In each iteration, `mid` is calculated as the average of `lower_bound` and `upper_bound`.\n   - `mid_squared` is computed to compare against `num`.\n\n4. **Condition Checks:**\n   - If `mid_squared` equals `num`, `mid` is the exact square root, and it is returned.\n   - If `mid_squared` is less than `num`, `lower_bound` is updated to `mid + 1` to search higher values, and `result` is updated to `mid`.\n   - If `mid_squared` exceeds `num`, `upper_bound` is adjusted to `mid - 1` to search lower values.\n\n5. **Result Handling:**\n   - If the loop completes without finding an exact square root, the last valid `mid` (stored in `result`) is returned as the integer square root.\n\n**Example Use Cases:**\n\n- `num = 25` \u2192 Returns 5 (exact square root).\n- `num = 24` \u2192 Returns 4 (floor value of sqrt(24)).\n- `num = 3` \u2192 Returns 1 (floor value of sqrt(3)).\n- `num = 0` \u2192 Returns 0 (edge case).\n- `num = 1` \u2192 Returns 1 (edge case).\n\n**Code:**\n\n```python\ndef optimized_integer_square_root(num: int) -> int:\n    \"\"\"Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    result = 0  # Initial result to store the floor value\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid  # Update result since mid^2 < num, and may be the floor\n        else:\n            upper_bound = mid - 1\n    \n    return result\n```\n\nThis approach efficiently finds the integer square root using binary search, ensuring the solution is both optimal and handles all edge cases appropriately.",
  "r1_solution": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    result = 0  # Initial result to store the floor value\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid  # Update result since mid^2 < num, and may be the floor\n        else:\n            upper_bound = mid - 1\n    \n    return result",
  "metadata": {
    "prompt_id": "00000004",
    "row_id": 4,
    "seed_ids": [
      691
    ],
    "mode": "algorithm",
    "original_instruction": "You are given a Python function `integer_square_root` that calculates the integer square root of a non-negative integer using a binary search approach. Your task is to implement a more efficient version of this function. Specifically, you need to optimize the current implementation to reduce the number of iterations in the binary search while handling edge cases properly.\n\n**Function Signature**:\n```python\ndef optimized_integer_square_root(num: int) -> int:\n    pass\n```\n\n**Requirements**:\n- The function must handle non-negative integers as input and raise a `ValueError` if the input is negative.\n- The function should return the integer square root of `num` rounded down to the nearest integer.\n- The optimized version should have a time complexity of \\(O(\\log(n))\\) and use \\(O(1)\\) space complexity.\n- Implement an early return for perfect squares and optimize the bounds checking in the binary search.\n\n**Test Cases**:\n```python\nassert optimized_integer_square_root(15) == 3\nassert optimized_integer_square_root(31) == 5\nassert optimized_integer_square_root(25) == 5\nassert optimized_integer_square_root(1) == 1\nassert optimized_integer_square_root(0) == 0\nassert optimized_integer_square_root(2_147_483_647) == 46340\nassert optimized_integer_square_root(-1) is None  # Should raise ValueError\n```\n\n**Note**:\nEnsure that the edge cases and performance are handled correctly. Optimize the bounds checking and early returns to improve the efficiency of the function."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results2.jsonl"
}