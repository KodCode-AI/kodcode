{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000089_C",
  "question": "def find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\n    >>> find_next_prime(10)\n    11\n    >>> find_next_prime(29)\n    31\n    >>> find_next_prime(100)\n    101\n    \"\"\"",
  "solution": "from math import sqrt\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\"\"\"\n    while True:\n        value += 1\n        if is_prime(value):\n            return value",
  "test_code": "def test_find_next_prime():\n    assert find_next_prime(10) == 11\n    assert find_next_prime(29) == 31\n    assert find_next_prime(100) == 101\n    assert find_next_prime(131) == 137\n    assert find_next_prime(1) == 2\n    assert find_next_prime(2) == 3\n    assert find_next_prime(3) == 5\n\ntest_find_next_prime()",
  "test_info": [
    {
      "function_name": "is_prime",
      "parameter_list": "(n)",
      "function_declaration": "def is_prime(n):",
      "docstring": "Check if a number is prime."
    },
    {
      "function_name": "find_next_prime",
      "parameter_list": "(value)",
      "function_declaration": "def find_next_prime(value):",
      "docstring": "Return the smallest prime number greater than the given value."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to write a function called find_next_prime that takes an integer value and returns the smallest prime number greater than it. Hmm, let's think about how to approach this.\n\nSo, the first thing that comes to mind is understanding what a prime number is. A prime is a number greater than 1 that has no divisors other than 1 and itself. So, for example, 11 is prime because it's only divisible by 1 and 11. Numbers like 4 or 6 aren't primes because they can be divided by other numbers besides 1 and themselves.\n\nNow, the task is to find the next prime after a given number. So if the input is 10, the output should be 11. If it's 29, the next is 31. For 100, it's 101, and so on.\n\nHow do I find primes algorithmically? Well, one straightforward method is to check each number greater than the given value and see if it's prime. But checking each number might be inefficient, especially for large numbers. But since this is a function and I don't know the constraints, I'll proceed with a basic approach that works and optimize later if needed.\n\nSo, the steps could be:\n\n1. Start from the given value + 1, and check each subsequent number.\n2. For each number, check if it's a prime.\n3. Once a prime is found, return it.\n\nSo I need a helper function to check if a number is prime. Oh wait, no, maybe I can implement that check within the main function or create a helper function. It might be cleaner to have a helper function.\n\nLet's think about writing an is_prime helper function.\n\nThe is_prime function will take a number and return True if it's prime, False otherwise.\n\nHow to implement is_prime:\n\n- If the number is less than or equal to 1, it's not prime.\n- If the number is 2, it's prime.\n- If the number is even, it's not prime.\n- Then, check divisors from 3 up to sqrt(n), stepping by 2. Because if a number has a factor larger than its square root, the pair factor would be smaller than the square root, so we can stop there.\n\nSo the helper function would look something like this:\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n ** 0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\nWait, but for checking up to sqrt(n), I can loop like this?\n\nYes. So implementing that is manageable.\n\nNow, back to the main function. So, for a given value, we start checking from value + 1 onwards. For each n in that sequence, we check is_prime(n). When is_prime returns True, we return that n as the next prime.\n\nSo the main function can be something like:\n\nn = value + 1\nwhile True:\n    if is_prime(n):\n        return n\n    else:\n        n += 1\n\nBut this could be a bit slow for very large numbers. But for the problem at hand, perhaps it's sufficient.\n\nSo putting it all together:\n\ndef find_next_prime(value: int) -> int:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        max_divisor = int(n ** 0.5) + 1\n        for d in range(3, max_divisor, 2):\n            if n % d == 0:\n                return False\n        return True\n\n    n = value + 1\n    while True:\n        if is_prime(n):\n            return n\n        n += 1\n\nBut wait, let me test this logic with the sample inputs.\n\nSample 1: find_next_prime(10) should return 11.\n\n10 +1 is 11, which is prime, so returns immediately.\n\nSample 2: find_next_prime(29) -> 31. Wait, but what about 30 and 31.\n\n30 is even, so no. 31 is prime, yes.\n\nSample 3: 100 -> check 101. 101 is prime, correct.\n\nWhat about an edge case, like when the value is 1? Then the next prime is 2.\n\nWait, in that case, value +1 is 2. So is_prime(2) is True, so returns 2.\n\nWhat if the value is 2? Then next is 3.\n\nLet me see another case. For value=3, next is 5? No, 4 is not prime, 5 is. So function returns 5.\n\nWait, let's see: the code would start at 4, check is_prime(4) (which is False because 4 is even), then 5. 5 is prime, so returns 5. Correct.\n\nAnother test case: value=7. Next prime is 11?\n\nWait, wait no: 7 is a prime. The next is 11? No, 8 is even, 9 is divisible by 3, 10 divisible by 2, 11 is prime. So yes, function would return 11.\n\nWait wait wait, wait: No! 7, next prime after 7 is 11? No, 7 is followed by 8,9,10, which are non-primes, but then 11 isn't the next. Oh wait no, 7 is prime, and the next is 11. Because 7 is the current, find next greater: yes.\n\nWait another thing, the function is called find_next_prime. So for 7, it returns 11?\n\nNo, wait after 7 comes 8, 9 (not primes), 10, then 11. So yes, function handles that correctly.\n\nHmm, but sometimes for some larger primes, this could be slow. But perhaps the test cases are manageable.\n\nWait another scenario: what is the next prime after 31? It's 37. Let me think, 32 is even, 33 divisible by 3, 34 even, 35 divisible by 5, 36 even, 37 is prime. So in that case, find_next_prime(31) is 37, which the code should find correctly.\n\nSo now, the code seems to correctly handle the examples given, including edge cases.\n\nBut wait, perhaps I can optimize the is_prime function a bit.\n\nWait, for numbers greater than 2 and even, we return False. So all other even numbers after 2 are handled quickly.\n\nBut perhaps for the next step, the code is okay.\n\nAlternatively, for the find_next_prime function, perhaps incrementing by 2 each time after value, but wait: if the value is 10, the next is 11. But if the value is 11, perhaps it's 13? Wait no, after 11 comes 12 (even), 13 prime. So is there a case where after an odd number, the next even isn't checked? Or perhaps it's better to increment correctly.\n\nWait, in the code we have:\n\nn = value +1, check if it's prime. If yes, return.\n\nElse, n += 1 and loop. So the code is handling all numbers, regardless of whether they are even or odd.\n\nWait, for example, let's take value = 7.\n\nn = 8, which is even. is_prime returns False, so loop continues, n=9, etc.\n\nSo the code is correct.\n\nWhat about a value of 2?\n\nn =3, which is prime, so returns 3, which is correct because the next after 2 is 3.\n\nAnother test: value=0: then next prime is 2.\n\nSo for find_next_prime(0): 1 is checked. Wait, no. Wait 0 + 1 =1, but is_prime(1) returns false. Then n +=1 becomes 2, which is prime, so returns 2. Correct.\n\nBut what about value=1?\n\nn =2 is computed, is prime, so returns 2. So that's correct.\n\nHmm.\n\nNow, I think the code should handle all cases.\n\nWait, but what if value is a negative number? Say value=-5.\n\nn=-5 +1=-4. But is_prime(-4) is less than 2, returns False. Then n increments: -3, which is not handled correctly? Wait no, because is_prime(-3) is n <=1, return False. So n keeps increasing until it reaches 2, which is prime, so it returns 2.\n\nYes, that seems correct.\n\nAnother test case: If the input is 100, next prime is 101.\n\nSo in code: value is 100, n=101. Check if is_prime: 101 is a prime. So returns immediately.\n\nYes.\n\nIs 101 a prime? Yes, because it is only divisible by 1 and 101.\n\nBut the is_prime function for 101:\n\nn is 101.\n\nmax_divisor is sqrt(101) ~10. So max_divisor +1 is 10+1=11.\n\nLoop d from 3 to 11 step 2: so 3,5,7,9.\n\nCheck 3: 101 %3 is not zero.\n\n5: 101%5 is 1.\n\n7: 101/7 is ~14.428, 7*14=98, 101-98=3, so not divisible by 7.\n\nCheck 9: but 9 is a divisor? Well, 9 is an odd number, but wait 101 /9 is about 11.222, so 9 doesn't divide 101.\n\nThus, the is_prime function would return True.\n\nSo it would correctly identify 101 as a prime.\n\nAnother test: 201 as the next prime after 200.\n\nn=201. Let's see:\n\nCheck if 201 is even: no. Then sqrt(201) is ~14.17, so max divisor is 15.\n\nCheck 3: 201 divided by 3 is 67. 3 *67=201. So is_prime(201) returns False. So n increases to 202 (even), then 203.\n\nWait n=201: is it prime?\n\nWell, 3 *67 is 201, so it's not. So function doesn't pick that. Next number is 202 even, not prime. Then 203: let's see.\n\nCheck if 203 is prime. sqrt(203) is ~14.24, check divisors up to 15.\n\nCheck 3: 203/3 is 67.666, so 3*67=201. 203-201=2, no.\n\n5: 203 ends with 3, not 0 or 5.\n\n7: 203 divided by 7: 7 * 29 is 203, so yes, so 203 is not prime.\n\nSo the code would continue to 204, 205, 206, then 207?\n\nWait but 207 is divisible by 3.\n\nWait perhaps another approach: step by step, but for code as is, it will correctly find the next primes.\n\nI think the code handles all scenarios correctly, though I should test for a larger value.\n\nBut in the context of an example for code submission, this approach should be acceptable.\n\nSo the function as written should work.\n\nOne potential optimization is that after the initial value, if that value is even, we could start the next step and then only check odd numbers. But I think it's beyond the scope for now, since the code as is works.\n\nSo to summarize, the function find_next_prime is implemented as follows:\n\n- It defines an inner helper function is_prime to check for primality.\n- The main function starts checking numbers greater than the input, returning the first prime it encounters.\n\nThus, the code should be:\n\n[The code as provided above]\n</think>\n\nTo solve this problem, we need to find the smallest prime number greater than a given integer. A prime number is defined as a number greater than 1 that has no divisors other than 1 and itself. \n\n### Approach\nThe approach to solve this problem involves the following steps:\n\n1. **Check for Primality**: We first need a helper function to determine if a given number is prime. This function will:\n   - Return `False` for numbers less than or equal to 1.\n   - Return `True` for the number 2, as it is the smallest prime number.\n   - Return `False` for even numbers greater than 2.\n   - Check divisibility from 3 up to the square root of the number, incrementing by 2 (to skip even numbers).\n\n2. **Find the Next Prime**: Starting from the given value plus 1, we check each subsequent number to see if it is prime using the helper function. The first prime number we encounter is returned as the result.\n\n### Solution Code\n\n```python\ndef find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        max_divisor = int(n ** 0.5) + 1\n        for d in range(3, max_divisor, 2):\n            if n % d == 0:\n                return False\n        return True\n\n    n = value + 1\n    while True:\n        if is_prime(n):\n            return n\n        n += 1\n```\n\n### Explanation\n1. **Prime Checking (is_prime Function)**:\n   - The function first handles edge cases for numbers less than 2 and even numbers.\n   - For odd numbers greater than 2, it checks divisibility up to the square root of the number, which optimizes the process by reducing the number of checks needed.\n\n2. **Finding the Next Prime (find_next_prime Function)**:\n   - Starting from the given value plus 1, the function iterates through each subsequent number.\n   - For each number, it uses the `is_prime` helper function to check if the number is prime.\n   - The first prime number found is returned immediately as the result.\n\nThis approach efficiently finds the next prime number by leveraging the mathematical properties of prime numbers and optimizing the number of checks needed to determine primality.",
  "r1_solution": "def find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        max_divisor = int(n ** 0.5) + 1\n        for d in range(3, max_divisor, 2):\n            if n % d == 0:\n                return False\n        return True\n\n    n = value + 1\n    while True:\n        if is_prime(n):\n            return n\n        n += 1",
  "metadata": {
    "prompt_id": "00000089",
    "row_id": 89,
    "seed_ids": [
      326
    ],
    "mode": "algorithm",
    "original_instruction": "You are given a function `is_prime` that checks whether a number is prime. Your task is to implement a function `find_next_prime` that finds the next prime number greater than a given value. The function should handle edge cases and optimize performance for larger numbers.\n\n#### Function Signature\n```python\ndef find_next_prime(value: int) -> int:\n    pass\n```\n\n#### Constraints\n- `1 <= value <= 10^9`\n- The function should return the smallest prime number greater than the given value.\n\n#### Input and Output\n- **Input**: An integer `value`.\n- **Output**: The smallest prime number greater than `value`.\n\n#### Example\n```python\nassert find_next_prime(10) == 11\nassert find_next_prime(29) == 31\nassert find_next_prime(100) == 101\n```\n\n#### Performance Requirements\n- The function should be able to handle values up to `10^9` efficiently.\n\n#### Scenario\nYou are developing a secure messaging system that requires generating prime numbers for encryption keys. Your task is to ensure that the next prime number is found quickly and accurately."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results0.jsonl"
}