{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000089_C",
  "question": "def find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\n    >>> find_next_prime(10)\n    11\n    >>> find_next_prime(29)\n    31\n    >>> find_next_prime(100)\n    101\n    \"\"\"",
  "solution": "from math import sqrt\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\"\"\"\n    while True:\n        value += 1\n        if is_prime(value):\n            return value",
  "test_code": "def test_find_next_prime():\n    assert find_next_prime(10) == 11\n    assert find_next_prime(29) == 31\n    assert find_next_prime(100) == 101\n    assert find_next_prime(131) == 137\n    assert find_next_prime(1) == 2\n    assert find_next_prime(2) == 3\n    assert find_next_prime(3) == 5\n\ntest_find_next_prime()",
  "test_info": [
    {
      "function_name": "is_prime",
      "parameter_list": "(n)",
      "function_declaration": "def is_prime(n):",
      "docstring": "Check if a number is prime."
    },
    {
      "function_name": "find_next_prime",
      "parameter_list": "(value)",
      "function_declaration": "def find_next_prime(value):",
      "docstring": "Return the smallest prime number greater than the given value."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, so I need to write a function called find_next_prime that takes an integer value and returns the smallest prime number that's bigger than this value. Hmm, right. Let's think about how primes work.\n\nFirst, I remember that a prime number is a number greater than 1 that has no divisors other than 1 and itself. So, for example, 11 is prime because its only divisors are 1 and 11.\n\nSo the function needs to find the next prime after a given value. Like if the input is 10, the next prime is 11. If it's 29, it's 31, and so on.\n\nI think the approach here would be to increment numbers starting from the given value + 1 and check each one to see if it's prime. Once I find a prime, I return it.\n\nBut how do I efficiently check if a number is prime? I remember that for a number n, to check if it's prime, I can try dividing it by all numbers from 2 up to the square root of n. If any of them divide n evenly, it's not prime. But calculating square roots and checking all numbers up to that could be slow for large numbers, but maybe for this problem, it's acceptable.\n\nWait, but the function doesn't have constraints on the size of 'value', so maybe for really big numbers, the check needs to be efficient. Hmm, but I think for the scope of this problem, sticking to the standard method should be fine.\n\nSo, steps:\n\n1. Start with the value + 1, call it n.\n2. For each n, check if it's prime.\n3. If it is, return n. If not, increment n by 1 and repeat.\n\nTo implement step 2, I'll need a helper function is_prime(num) that returns True if the number is prime.\n\nLet me think about how to write is_prime. It should take a number and return True or False.\n\nSo for is_prime:\n\n- If num is less than 2, return False.\n- For numbers 2 and 3, return True.\n- Check if num is even; if so, it's divisible by 2, so return False (unless num is 2).\n- Then, check divisors from 3 up to sqrt(num), stepping by 2 (since even numbers are already checked). For each divisor, if it divides num, then it's not a prime.\n- If none divide evenly, return True.\n\nThat makes sense.\n\nWait, but in the helper function, for even numbers, after checking 2 as a special case, maybe I should loop from 3 to sqrt(n), and only check odd numbers. That would save some time.\n\nNow, putting it all together.\n\nSo the main function:\n\ndef find_next_prime(value: int) -> int:\n\n    n = value + 1\n    while True:\n        if is_prime(n):\n            return n\n        n += 1\n\nAnd then the helper function.\n\nBut where is the helper function? I should define it inside find_next_prime, or make it a separate function. Well, for the purpose of this code, I'll define it inside as a nested function perhaps, but since Python allows for it, maybe it's clearer to write it as a helper.\n\nAlternatively, maybe just write the checking code inline, but that could make the code longer. It's better to have a helper function.\n\nWait, but how do I handle even numbers. For example, when I start checking n, if n is even, I can skip to n+1 because even numbers greater than 2 can't be primes.\n\nSo, in the main function, after n is incremented from value+1, perhaps I can increment to the next even/odd as needed.\n\nWait, for example, if the input is 10:\n\nvalue is 10, so n starts at 11, which is already odd. Check if 11 is prime (which it is). So return 11.\n\nBut what if value is 11? n becomes 12, which is even. So 12 is not prime. Then n becomes 13, which is checked.\n\nBut that's okay.\n\nAlternatively, maybe after setting n to value +1, if n is even, and greater than 2, then we can add 1 to make it odd. For example:\n\nn = value +1\nif n %2 ==0:\n    if n ==2:\n        return 2\n    else:\n        n +=1\n\nWait no, that's not right. If value is 2, value+1 is 3, which is odd. So, when n is value +1, if n is even, it can't be a prime unless it's 2.\n\nSo, maybe it's better to adjust n to the next odd number, as follows:\n\nstart with n = value +1\nif n is even:\n    if n is 2, return it.\n    else, n becomes n+1 to make it odd.\nthen, in the loop, each increment is by 2, checking only odd numbers.\n\nThat could be more efficient as it avoids checking even numbers.\n\nSo, the steps would be:\n\nn = value +1\nif n is even and n !=2:\n    n +=1\nthen, loop:\n    if n is prime, return n\n    else, n +=2\n\nWait, let's test this logic with some examples.\n\nCase 1: value =10\n\nn = 11, which is odd. So the code proceeds to check if 11 is prime (yes), return 11.\n\nCase 2: value=29\n\nn=30, which is even and not 2, so add 1 to make 31. Check if 31 is prime (yes), return 31.\n\nCase 3: value=100\n\nn=101, which is odd, check if prime. Yes.\n\nWhat about when value is 2?\n\nvalue=2, next prime would be 3.\n\nIn code: n=value+1 is 3, odd. Check, yes.\n\nWhat about value=4? Next prime is 5.\n\nn=5, which is odd and prime.\n\nHmm, that seems correct.\n\nAnother example: value=14.\n\nn=15, which is odd. But 15 is not prime, so we return 17. So, the loop would go 15, 17.\n\nWait: 15 is divisible by 3 and 5, so not prime. Next is 17, which is prime.\n\nTherefore, the helper function needs to be correct.\n\nWait, but what about when the next prime is 2 more than the even number. Like value=7, next is 11 is next? No. Value=7's next prime is 11, no wait: 7's next is 9? No, 9 is 3 squared. Then 11.\n\nWait, value=7, next prime is 11? No, 11 is after 7, but wait 8 is even, 9 is not prime, 10 is even, 11 is prime.\n\nWait, yes.\n\nSo for n after value+1, perhaps if n is even, it's skipped by making it the next odd number.\n\nWait let's try another approach.\n\nImplement the find_next_prime function as follows:\n\nInitialize n as value + 1.\n\nIf n is less than 2, then return 2.\n\nIf n is even, make it n+1 to be odd, unless n is 2.\n\nThen, in the loop, check each odd number to see if it's prime.\n\nEach iteration, add 2 to n.\n\nLet me outline the code.\n\ndef find_next_prime(value: int) -> int:\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        if num ==2:\n            return True\n        if num %2 ==0:\n            return False\n        for i in range(3, int(num**0.5) +1, 2):\n            if num %i ==0:\n                return False\n        return True\n\n    n = value +1\n\n    if n <=2:\n        return 2\n    elif n ==2:\n        return 2\n    elif n %2 ==0:\n        # if even, make it next odd\n        n +=1\n\n    while True:\n        if is_prime(n):\n            return n\n        n +=2 # only check odd numbers\n\nWait, but what if n is 3? For example, value=2 will make n=3, which is prime.\n\nBut let's see what happens in the code:\n\nn=value +1=3.\n\nn is not less than 2. Check if n is even? 3 is not even. So enter loop. Check if 3 is prime, which it is. So return 3.\n\nBut wait, what if value is 3, the next prime is 5. Let's see.\n\nn=4. Because 4 is even, it's incremented to 5. Then, is 5 prime? Yes, so returns 5.\n\nWait, but n was 4, then becomes 5.\n\nSo that seems correct.\n\nAnother example: what if value is 5?\n\nn =6, which is even. So incremented to 7.\n\nIs 7 prime? Yes. So returns 7.\n\nAnother test case is value=7, returns 11? Wait no, wait 7's next is 11? Wait after 7 is 11? No, wait 7, next primes are 7, 11. Wait, 7 is the prime given, the next is 11? Oh no, wait no, 7's next is 11, but wait, what about 8,9,10? Wait 8 is even, not a prime. 9 is divisible by 3. 10 even. So next prime is 11.\n\nSo yes, for value=7, returns 11.\n\nWait but wait, what about for value=13: next is 17? No, 13's next prime is 17? No, no, wait there's 14, 15, 16 which are even or divisible by something, but 17 is next. Wait, actually, I think I made a mistake there. Let's list primes after 13: 17 is the next. No, wait, 13 is followed by 17, no primes in between? No, wait 17 comes after 13, but numbers in between: 14 (even), 15 (divisible by 3,5), 16 (even), so yes, 17 is next.\n\nHmm, the code seems to be correct.\n\nBut wait, let's see another example.\n\nvalue=1. Next prime is 2.\n\nIn code: n=2. The code's condition is if n <=2, return 2. So it correctly returns 2.\n\nSo, function now has to implement this is_prime helper.\n\nWait, but in is_prime, for numbers like 9, sqrt(9) is 3. So, the loop checks 3, since range(3, 4, 2) which is [3]. 9 mod 3 is 0, so returns False.\n\nYes, correct.\n\nWhat about 25?\n\nsqrt(25) is 5. So, i will take 3 and 5.\n\n25 mod3 is 1, then check 5: 25 mod5=0: returns False.\n\nSo code is correct.\n\nAnother case: 49, which is 7^2. is_prime would check up to 7. 49 is at 7 in the loop, so returns false.\n\nSo, seems the helper function is correct.\n\nSo putting it all together: the code should work.\n\nWait, but let's think about the initial code. When n is calculated as value +1: if value is, say, 1, n becomes 2. So we return 2.\n\nAnother case: value is 0, function returns 2.\n\nWhat about when value is negative?\n\nWell, the function is called with 'value: int', so for value <2, the next prime is 2.\n\nSo if value is -5, n is -4: then n is even, but n is less than 2. Wait, in the code, in the first condition, it says if n<=2: return 2.\n\nSo yes, that's correct.\n\nWait, let's see: code starts by setting n=value+1. Then, if n <=2, returns 2.\n\nSo for any n<=2 (even if value was 1, n=2), returns 2.\n\nSo that's correct.\n\nThus, the code should handle all cases.\n\nSo I think this approach should work.\n</think>\n\nTo solve this problem, we need to find the smallest prime number greater than a given integer value. A prime number is a number greater than 1 that has no divisors other than 1 and itself. The approach involves checking each subsequent number starting from the given value incremented by 1 until we find a prime number.\n\n### Approach\n1. **Increment and Check:** Start with the given value incremented by 1. For each subsequent number, check if it is a prime number.\n2. **Prime Check Helper Function:** Use a helper function `is_prime` to determine if a number is prime. This function will:\n   - Return `False` for numbers less than 2.\n   - Return `True` for the number 2.\n   - Return `False` for even numbers greater than 2.\n   - Check divisibility from 3 up to the square root of the number, considering only odd numbers to optimize the check.\n3. **Optimization for Even Numbers:** If the starting number after incrementing is even and greater than 2, move to the next odd number immediately, as even numbers greater than 2 cannot be prime.\n\n### Solution Code\n```python\ndef find_next_prime(value: int) -> int:\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num ** 0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n\n    n = value + 1\n    if n <= 2:\n        return 2\n    elif n == 2:\n        return 2\n    elif n % 2 == 0:\n        n += 1\n\n    while True:\n        if is_prime(n):\n            return n\n        n += 2\n```\n\n### Explanation\n- **Helper Function `is_prime`:** This function efficiently checks if a number is prime by eliminating obvious non-prime cases and only checking up to the square root of the number, which reduces the number of checks needed.\n- **Main Function Logic:** The main function starts with the next number after the given value and checks each subsequent number for primality. If the next number is even and greater than 2, it skips to the next odd number to optimize the search.\n- **Loop Until Prime Found:** The loop continues checking each subsequent odd number using the helper function until a prime number is found, which is then returned.\n\nThis approach ensures that we efficiently find the next prime number by minimizing the number of checks and leveraging mathematical properties of prime numbers.",
  "r1_solution": "def find_next_prime(value: int) -> int:\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num ** 0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n\n    n = value + 1\n    if n <= 2:\n        return 2\n    elif n == 2:\n        return 2\n    elif n % 2 == 0:\n        n += 1\n\n    while True:\n        if is_prime(n):\n            return n\n        n += 2",
  "metadata": {
    "prompt_id": "00000089",
    "row_id": 89,
    "seed_ids": [
      326
    ],
    "mode": "algorithm",
    "original_instruction": "You are given a function `is_prime` that checks whether a number is prime. Your task is to implement a function `find_next_prime` that finds the next prime number greater than a given value. The function should handle edge cases and optimize performance for larger numbers.\n\n#### Function Signature\n```python\ndef find_next_prime(value: int) -> int:\n    pass\n```\n\n#### Constraints\n- `1 <= value <= 10^9`\n- The function should return the smallest prime number greater than the given value.\n\n#### Input and Output\n- **Input**: An integer `value`.\n- **Output**: The smallest prime number greater than `value`.\n\n#### Example\n```python\nassert find_next_prime(10) == 11\nassert find_next_prime(29) == 31\nassert find_next_prime(100) == 101\n```\n\n#### Performance Requirements\n- The function should be able to handle values up to `10^9` efficiently.\n\n#### Scenario\nYou are developing a secure messaging system that requires generating prime numbers for encryption keys. Your task is to ensure that the next prime number is found quickly and accurately."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}