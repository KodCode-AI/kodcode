{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000089_C",
  "question": "def find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\n    >>> find_next_prime(10)\n    11\n    >>> find_next_prime(29)\n    31\n    >>> find_next_prime(100)\n    101\n    \"\"\"",
  "solution": "from math import sqrt\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\"\"\"\n    while True:\n        value += 1\n        if is_prime(value):\n            return value",
  "test_code": "def test_find_next_prime():\n    assert find_next_prime(10) == 11\n    assert find_next_prime(29) == 31\n    assert find_next_prime(100) == 101\n    assert find_next_prime(131) == 137\n    assert find_next_prime(1) == 2\n    assert find_next_prime(2) == 3\n    assert find_next_prime(3) == 5\n\ntest_find_next_prime()",
  "test_info": [
    {
      "function_name": "is_prime",
      "parameter_list": "(n)",
      "function_declaration": "def is_prime(n):",
      "docstring": "Check if a number is prime."
    },
    {
      "function_name": "find_next_prime",
      "parameter_list": "(value)",
      "function_declaration": "def find_next_prime(value):",
      "docstring": "Return the smallest prime number greater than the given value."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to write a Python function called find_next_prime that takes an integer value and returns the smallest prime number greater than that value. Let me think about how to approach this.\n\nFirst, I remember that a prime number is a number greater than 1 that has no divisors other than 1 and itself. So, to find the next prime after a given value, I should start checking each number greater than the value to see if it's prime.\n\nWait, so the steps should be something like this: take the input value, start with value + 1, and then for each number, check if it's prime. If it is, return it. If not, move to the next number.\n\nBut how do I efficiently check if a number is prime? I recall that one common method is trial division. For a number n, I can check divisors from 2 up to the square root of n. If any divide n, then it's not prime. Otherwise, it's prime.\n\nSo here's the plan:\n\n1. Write a helper function to check if a number is prime. Let's call it is_prime(n).\n2. In find_next_prime, increment the input value by 1 to start checking for the next number.\n3. For each number starting from this, use the helper function to check if it's prime.\n4. When we find the first such prime, return it.\n\nLet me detail out the helper function. The is_prime function takes an integer n.\n\n- If n is less than 2, return False because primes are greater than 1.\n- For numbers 2 or 3, return True because they are primes.\n- If n is even, return False immediately since it's divisible by 2.\n- Then, check divisors from 3 up to sqrt(n), stepping by 2 (since even divisors are already handled). If any of them divides n, it's not prime.\n- Otherwise, return True.\n\nNow, implementing this, but wait, I should note that for efficiency, in the trial division, checking up to sqrt(n) is sufficient because a larger factor of n would be a multiple of smaller factor that has already been checked.\n\nIn the main function, find_next_prime(value), the process is:\n\n- Start checking from value + 1. Let's name the candidate number current.\n- Loop indefinitely, checking each current for being prime. Once a prime is found, return current.\n\nWait, but let's think about optimizations. Since we don't want to check numbers too far away, the loop should break once a prime is found. So, in the code, it's a while True loop, where in each iteration, we check current. If it's prime, return it; else, current +=1.\n\nThat makes sense.\n\nNow, test case examples:\n\n- find_next_prime(10) should return 11. 11 is prime, correct.\n- find_next_prime(29) returns 31, because 29 is prime but next is 31 since 30 is even.\n- find_next_prime(100) returns 101, which is the next prime.\n\nBut wait, what if value is a prime itself and larger than 2? Like find_next_prime(13) should return 17? No, after 13 comes 14 (not), 15 (15 is divisible by 3), 16 (even), so next is 17. So our code should correctly find 17.\n\nAnother test case: let's say the input is 2, the next prime is 3.\n\nSo, putting it all together.\n\nImplement the helper function is_prime:\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5)+1, 2):\n        if n % i == 0:\n            return False\n    return True\n\nYes, that should work.\n\nIn the find_next_prime function:\n\ndef find_next_prime(value):\n    current = value + 1\n    while True:\n        if is_prime(current):\n            return current\n        current +=1\n\nBut wait, perhaps we can make it slightly more efficient. For example, when current is even, increment only 1 to make it odd, or, better yet, set current to be value + 1 if value is even, then maybe step by 2. Wait, wait: no, perhaps my initial approach is sufficient. Because in is_prime, numbers even beyond 2 are quickly rejected. So checking even numbers beyond 2 in current is not a problem, but in terms of steps, perhaps we can optimize.\n\nWait, when value is even, adding 1 makes current odd. So in that case, to avoid checking even numbers beyond current (if current is even, in the next increment), perhaps better to step through numbers.\n\nAlternatively, in the loop, for current, after checking, we can increment by 1 each time. But in most cases, the is_prime function will return quickly for even numbers because they are checked right away. So the code is fine as is.\n\nTesting with the examples:\n\nCase 1: find_next_prime(10) starts checking 11. 11 is odd, is_prime(11) returns True because none of the divisors up to sqrt(11) (~3.316) divide it. 3 *3 is > 11? So, yes, returns 11.\n\nCase 2: find_next_prime(29) starts with 30. But 30 is even. is_prime(30) returns False (because 30 mod 2 is 0). So current increments to 31. Check is_prime(31). 31 is prime.\n\nCase 3: find_next_prime(100) starts with 101, which is a prime.\n\nAnother test: find_next_prime(13). Starts at 14: even -> no. 15: divisible by 3. 16: even. 17: is_prime returns true.\n\nAnother test: find_next_prime(2). Value is 2. So current is 3. 3 is prime.\n\nAnother edge case: find_next_prime(1). The next prime is 2.\n\nWhat about input 0 or negative numbers? Since the function is passed as value: int, but in code, the is_prime function returns False for n <2. So if value is 1: current is 2, which is prime. So the function returns 2.\n\nSo, I think the code will handle these cases correctly.\n\nWait, but what if the value is 2: current is 3. 3 is checked for being prime (yes), so return 3.\n\nYes.\n\nSo, code-wise, it should be fine.\n\nAnother point to consider: what about n being very large? For example, let's say we call find_next_prime with a very large number. The code may be slow because it's doing trial division each time, which can be computationally expensive. However, given that the problem likely doesn't require handling extremely large numbers, the code should be acceptable for the problem's constraints.\n\nI think that's a solid plan.\n</think>\n\nTo solve this problem, we need to find the smallest prime number greater than a given integer value. A prime number is a number greater than 1 that has no divisors other than 1 and itself. The approach involves checking each number greater than the given value until we find a prime number.\n\n### Approach\n1. **Prime Number Check:** Create a helper function `is_prime(n)` to determine if a number `n` is prime. This function will:\n   - Return `False` if `n` is less than 2.\n   - Return `True` if `n` is 2 or 3.\n   - Return `False` if `n` is even and greater than 2.\n   - Check divisibility from 3 up to the square root of `n`, stepping by 2 to skip even numbers, which are already handled.\n\n2. **Main Function:** The main function `find_next_prime(value)` will:\n   - Start checking from the number immediately greater than the given `value`.\n   - Use a loop to continuously check each subsequent number using the `is_prime` function until a prime number is found, which is then returned.\n\n### Solution Code\n```python\ndef find_next_prime(value: int) -> int:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    current = value + 1\n    while True:\n        if is_prime(current):\n            return current\n        current += 1\n```\n\n### Explanation\n1. **Helper Function `is_prime(n)`:** This function efficiently checks if a number is prime by eliminating even numbers early and only checking up to the square root for potential divisors. This reduces the number of checks needed, making the function more efficient.\n\n2. **Main Function `find_next_prime(value)`:** Starting from `value + 1`, this function checks each subsequent number to see if it is prime using the `is_prime` helper function. The loop continues until the first prime number is found and returned.\n\nThis approach ensures that we efficiently find the next prime number by minimizing unnecessary checks and leveraging mathematical properties of prime numbers.",
  "r1_solution": "def find_next_prime(value: int) -> int:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    current = value + 1\n    while True:\n        if is_prime(current):\n            return current\n        current += 1",
  "metadata": {
    "prompt_id": "00000089",
    "row_id": 89,
    "seed_ids": [
      326
    ],
    "mode": "algorithm",
    "original_instruction": "You are given a function `is_prime` that checks whether a number is prime. Your task is to implement a function `find_next_prime` that finds the next prime number greater than a given value. The function should handle edge cases and optimize performance for larger numbers.\n\n#### Function Signature\n```python\ndef find_next_prime(value: int) -> int:\n    pass\n```\n\n#### Constraints\n- `1 <= value <= 10^9`\n- The function should return the smallest prime number greater than the given value.\n\n#### Input and Output\n- **Input**: An integer `value`.\n- **Output**: The smallest prime number greater than `value`.\n\n#### Example\n```python\nassert find_next_prime(10) == 11\nassert find_next_prime(29) == 31\nassert find_next_prime(100) == 101\n```\n\n#### Performance Requirements\n- The function should be able to handle values up to `10^9` efficiently.\n\n#### Scenario\nYou are developing a secure messaging system that requires generating prime numbers for encryption keys. Your task is to ensure that the next prime number is found quickly and accurately."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results2.jsonl"
}