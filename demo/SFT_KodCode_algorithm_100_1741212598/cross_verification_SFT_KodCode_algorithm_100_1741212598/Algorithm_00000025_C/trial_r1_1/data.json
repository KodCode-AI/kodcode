{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000025_C",
  "question": "def fibonacci_iterative(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using iteration.\n    >>> fibonacci_iterative(0)\n    0\n    >>> fibonacci_iterative(1)\n    1\n    >>> fibonacci_iterative(2)\n    1\n    >>> fibonacci_iterative(10)\n    55\n    >>> fibonacci_iterative(20)\n    6765\n    \"\"\"\ndef fibonacci_recursive(n: int, memo={}) -> int:\n    \"\"\"Returns the n-th Fibonacci number using recursion with memoization.\n    >>> fibonacci_recursive(0)\n    0\n    >>> fibonacci_recursive(1)\n    1\n    >>> fibonacci_recursive(2)\n    1\n    >>> fibonacci_recursive(10)\n    55\n    >>> fibonacci_recursive(20)\n    6765\n    \"\"\"\ndef fibonacci_binets(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using Binet's formula.\n    >>> fibonacci_binets(0)\n    0\n    >>> fibonacci_binets(1)\n    1\n    >>> fibonacci_binets(2)\n    1\n    >>> fibonacci_binets(10)\n    55\n    >>> fibonacci_binets(20)\n    6765\n    \"\"\"\ndef fibonacci_matrix(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using matrix exponentiation.\n    >>> fibonacci_matrix(0)\n    0\n    >>> fibonacci_matrix(1)\n    1\n    >>> fibonacci_matrix(2)\n    1\n    >>> fibonacci_matrix(10)\n    55\n    >>> fibonacci_matrix(20)\n    6765\n    >>> fibonacci_matrix(50)\n    12586269025\n    \"\"\"",
  "solution": "def fibonacci_iterative(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using iteration.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\ndef fibonacci_recursive(n, memo={}):\n    \"\"\"\n    Returns the n-th Fibonacci number using recursion with memoization.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_recursive(n - 1, memo) + fibonacci_recursive(n - 2, memo)\n    return memo[n]\n\ndef fibonacci_binets(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using Binet's formula.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    phi = (1 + 5**0.5) / 2\n    return int((phi**n - (-phi)**(-n)) / 5**0.5)\n\ndef fibonacci_matrix(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using matrix exponentiation.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    if n == 0:\n        return 0\n    fib_matrix = [[1, 1], [1, 0]]\n    result = matrix_pow(fib_matrix, n - 1)\n    return result[0][0]\n\ndef matrix_pow(matrix, n):\n    \"\"\"\n    Raises a 2x2 matrix to the power of n using exponentiation by squaring.\n    \"\"\"\n    result = [[1, 0], [0, 1]]  # Identity matrix\n    base = matrix\n    while n:\n        if n % 2:\n            result = matrix_multiply(result, base)\n        base = matrix_multiply(base, base)\n        n //= 2\n    return result\ndef matrix_multiply(a, b):\n    \"\"\"\n    Multiplies two 2x2 matrices.\n    \"\"\"\n    return [[a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n            [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]]]",
  "test_code": "import pytest\nfrom solution import (\n    fibonacci_iterative, \n    fibonacci_recursive, \n    fibonacci_binets, \n    fibonacci_matrix\n)\n\ndef test_fibonacci_iterative():\n    assert fibonacci_iterative(0) == 0\n    assert fibonacci_iterative(1) == 1\n    assert fibonacci_iterative(2) == 1\n    assert fibonacci_iterative(10) == 55\n    assert fibonacci_iterative(20) == 6765\n\ndef test_fibonacci_recursive():\n    assert fibonacci_recursive(0) == 0\n    assert fibonacci_recursive(1) == 1\n    assert fibonacci_recursive(2) == 1\n    assert fibonacci_recursive(10) == 55\n    assert fibonacci_recursive(20) == 6765\n\ndef test_fibonacci_binets():\n    assert fibonacci_binets(0) == 0\n    assert fibonacci_binets(1) == 1\n    assert fibonacci_binets(2) == 1\n    assert fibonacci_binets(10) == 55\n    assert fibonacci_binets(20) == 6765\n\ndef test_fibonacci_matrix():\n    assert fibonacci_matrix(0) == 0\n    assert fibonacci_matrix(1) == 1\n    assert fibonacci_matrix(2) == 1\n    assert fibonacci_matrix(10) == 55\n    assert fibonacci_matrix(20) == 6765\n\ndef test_large_input_fibonacci_matrix():\n    assert fibonacci_matrix(50) == 12586269025\n\ndef test_negative_input():\n    with pytest.raises(ValueError):\n        fibonacci_iterative(-1)\n    with pytest.raises(ValueError):\n        fibonacci_recursive(-1)\n    with pytest.raises(ValueError):\n        fibonacci_binets(-1)\n    with pytest.raises(ValueError):\n        fibonacci_matrix(-1)",
  "test_info": [
    {
      "function_name": "fibonacci_iterative",
      "parameter_list": "(n)",
      "function_declaration": "def fibonacci_iterative(n):",
      "docstring": "Returns the n-th Fibonacci number using iteration."
    },
    {
      "function_name": "fibonacci_recursive",
      "parameter_list": "(n, memo={})",
      "function_declaration": "def fibonacci_recursive(n, memo={}):",
      "docstring": "Returns the n-th Fibonacci number using recursion with memoization."
    },
    {
      "function_name": "fibonacci_binets",
      "parameter_list": "(n)",
      "function_declaration": "def fibonacci_binets(n):",
      "docstring": "Returns the n-th Fibonacci number using Binet's formula."
    },
    {
      "function_name": "fibonacci_matrix",
      "parameter_list": "(n)",
      "function_declaration": "def fibonacci_matrix(n):",
      "docstring": "Returns the n-th Fibonacci number using matrix exponentiation."
    },
    {
      "function_name": "matrix_pow",
      "parameter_list": "(matrix, n)",
      "function_declaration": "def matrix_pow(matrix, n):",
      "docstring": "Raises a 2x2 matrix to the power of n using exponentiation by squaring."
    },
    {
      "function_name": "matrix_multiply",
      "parameter_list": "(a, b)",
      "function_declaration": "def matrix_multiply(a, b):",
      "docstring": "Multiplies two 2x2 matrices."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nAlright, I need to implement four different functions to compute the n-th Fibonacci number: iterative, recursive with memoization, using Binet's formula, and using matrix exponentiation. Hmm, okay. Let me think about each approach one by one.\n\nStarting with the iterative method. The Fibonacci sequence is 0, 1, 1, 2, 3, 5, etc. So the 0th term is 0, 1st is 1, 2nd is 1, and so on. In the iterative approach, I can compute each term step by step. I'll need two variables to keep track of the previous two numbers. For example, start with a=0, b=1. For each step from 0 to n, I'll update a and b by adding them together and shifting. Like, for n=0, return 0; for n=1, return 1. Then for higher n, loop from 2 to n, each time calculating the next number. That should be straightforward.\n\nNext, the recursive function with memoization. Wait, recursive without memoization would be too slow for large n because it recalculates the same Fibonacci numbers many times. So I need to store already computed values to avoid redundant calculations. Maybe I can use a dictionary as the memo. Each time the function is called, it checks if the value for n is already in the memo; if yes, return it. If not, compute it recursively. The base cases are when n is 0 or 1, return 0 or 1. Otherwise, return the sum of fib(n-1) and fib(n-2). But wait, how to handle the memo in the function? Maybe the memo is a default argument so that it's persisted between calls. Although, in Python, using mutable default arguments can be tricky, but for this problem, it should be manageable. So in the function definition, set memo as an optional argument with a default empty dictionary.\n\nOh wait, in each call, I can check if memo is empty, and if n is 0, store 0 in memo and return it. Similarly, if n is 1, memoize and return 1. Otherwise, proceed with fib(n-1) + fib(n-2), and store the result before returning. That should work.\n\nThird function is using Binet's formula. Binet's formula is a closed-form expression that allows calculating Fibonacci numbers without recursion or iteration. The formula is F(n) = (phi^n - psi^n)/sqrt(5), where phi is (1 + sqrt(5))/2 and psi is (1 - sqrt(5))/2. However, using this directly with floating-point numbers might lead to inaccuracies, especially for larger n because the difference between phi^n and psi^n becomes much smaller, and subtracting two large numbers can lose precision. Also, the formula only gives an approximation, so for integer results, rounding would be necessary.\n\nTo get precise results, perhaps I can calculate it and then round to the nearest integer. For example, once I compute the value using Binet's formula, I can add 0.5 and then cast it to an integer. Or maybe just use the math module's functions, but I need to handle cases where n is 0 and 1 correctly because the formula might not directly give 0 or 1 without calculation.\n\nWait, when n=0, F(0) is 0. Binet's formula at n=0 would give (1-1)/sqrt(5) = 0, which is correct. For n=1, it would be (phi - psi)/sqrt(5). Let's compute: phi is about 1.618, psi is about -0.618. So (1.618 - (-0.618)) / sqrt(5) is about 2.236 / 2.236 = approx 1, which is correct.\n\nBut when n increases, psi^n becomes very small, since the absolute value of psi is less than one. So for large n, the psi^n term becomes negligible, and F(n) ~ phi^n / sqrt(5). But for precise integer calculation, using Binet's formula directly may not be the best approach due to floating-point issues.\n\nHmm, is there a way to calculate this accurately? Another consideration: maybe using integer arithmetic with the square root, but that might get complicated. Alternatively, for n up to a certain size, say 20, Binet's formula is manageable, but for very large n, the iterative or matrix methods are better.\n\nWait, in the function, n can be as big as 50, as seen in the tests, which is manageable. So perhaps we can compute it using the formula, using math.pow or the exponentiation operator, then round and cast to integer.\n\nSo the steps would be:\n\n1. Import math.\n\n2. Calculate phi = (1 + math.sqrt(5)) / 2.\n\n3. Calculate psi = (1 - math.sqrt(5)) / 2.\n\n4. Compute result = (phi**n - psi**n) / math.sqrt(5).\n\n5. Round the result to the nearest integer, since for n\u22650, this should give F(n).\n\nBut wait, when n is even, would the subtraction cause any issues? Hmm, perhaps. I should test some values.\n\nFor example, n=10: F(10) is 55. Let's compute with the formula.\n\nphi^10 is approximately 122.991..., psi^10 is about 0.019... but since psi is negative, when n is even, psi^10 is positive. So (122.991 - 0.019)/sqrt(5) is ~122.972. Then sqrt(5) is ~2.236. So 122.972 / 2.236 is approx 55, which is correct.\n\nAnother example, n=20: F(20) is 6765.\n\nphi^20 is approximately (1.618)^20 \u2248 15126.999, psi^20 is a very small positive number (since even power), about 0.00015 perhaps. So subtraction gives 15126.999\u2026, and dividing by sqrt(5) (~2.236) gives 6765.\n\nSo, using the formula and rounding should work. Perhaps the best way is to compute the value, add 0.5, and convert to integer. Alternatively, use rounding functions.\n\nBut in Python, for numbers that are very close to an integer, sometimes floating point representations can be a little off. For example, (phi**n - psi**n)/sqrt(5) might be something like 55.0000000001, which would correctly round to 55. But maybe for some n, due to floating point precision, the calculation could be 54.9999999999, which when added 0.5 and int() would give 54 instead of 55.\n\nSo perhaps a safer approach is to use the round function. Then, cast to integer.\n\nWait, testing with n=0:\n\nresult = (phi^0 - psi^0)/sqrt(5) \u2192 (1 -1)/sqrt(5) = 0, so correct.\n\nn=1: (phi - psi)/sqrt(5) \u2192 (1.618... - (-0.618... )) / 2.236... = (2.236)/2.236 = 1.\n\nn=2: phi^2 is phi +1. Because phi^2 = phi + 1, since phi is the golden ratio.\n\nSo (phi^2 - psi^2)/sqrt(5) = [ (phi +1) - (psi +1) ] / ... Well, that seems accurate.\n\nAlternatively, perhaps using the decimal module for higher precision would give better accuracy, but that might complicate things. But given that n in the test cases is up to 50, perhaps the default float will be precise enough.\n\nSo the code for Binet's formula would involve:\n\nImport math.\n\nCompute phi and psi.\n\nCompute (phi**n - psi**n) / sqrt(5).\n\nUse round to get the integer.\n\nWait, perhaps directly converting to an integer would work via int(result + 0.5), or just rounding.\n\nAlternatively, since for Fibonacci numbers, the formula rounds to the correct integer if we add 0.5.\n\nAnother option is to use math.floor or math.ceil, but that's tricky because depending on the sign.\n\nBut perhaps rounding to nearest using the round function will suffice.\n\nSo in code:\n\nimport math\n\ndef fibonacci_binets(n: int) -> int:\n    if n == 0:\n        return 0\n    sqrt5 = math.sqrt(5)\n    phi = (1 + sqrt5) / 2\n    psi = (1 - sqrt5) / 2\n    result = (phi**n - psi**n) / sqrt5\n    return round(result)\n\nWait, need to test for n=0: in the formula, when n=0, (1 -1)/sqrt(5) is 0. So no problem. So perhaps the initial if is redundant.\n\nWait, let me test for n=0:\n\nphi^0 is 1, same as psi^0. So 1-1=0. sqrt(5) * (something zero) is zero. Correct. So maybe the function can be written without the if statement.\n\nThus, compute the formula for any n, include n=0. So:\n\ndef fibonacci_binets(n: int) -> int:\n    import math\n    sqrt5 = math.sqrt(5)\n    phi = (1 + sqrt5) / 2\n    psi = (1 - sqrt5) / 2\n    result = (phi**n - psi**n) / sqrt5\n    return int(result + 0.5)\n\nWait, but the round function is available, which for positive numbers would behave similarly. Let me think: for n=10, (55.0000001), adding 0.5 gives 55.5, int() truncates to 55.\n\nWait, int() in Python truncates towards zero. So adding 0.5 and using int() is equivalent to rounding?\n\nWait, let's see:\n\nx = 2.3 => x + 0.5 = 2.8 => int is 2.\n\nx=2.6 => 3.1 => int is 3. So yes, it's equivalent to rounding to the nearest integer for non-negative numbers.\n\nTherefore, the code can be written as:\n\nresult = round((phi**n - psi**n) / sqrt5)\n\nAlternatively, as:\n\nreturn int( (phi**n - psi**n)/sqrt5 + 0.5 )\n\nBut perhaps using the round function is more readable.\n\nWait, but let's test for a case where the calculation could be off. For example, n=5:\n\nF(5) is 5.\n\nphi = 1.618..., so phi^5 is approx 11.09017. psi^5 is approx -0.09017. Wait, wait: no, phi is (1+sqrt(5))/2, which is positive, psi is (1-sqrt(5))/2, which is negative and its absolute value is approximately 0.618...\n\nSo phi^5 is around 11.09, psi^5 is around -0.09017.\n\nThus, (phi^5 - psi^5) is about 11.09 - (-0.09017) = 11.18.\n\nDivide by sqrt(5) (~2.236) => 5.000. So in this case, no problem.\n\nAnother test, say n=2:\n\nphi^2 = (1.618)^2 \u2248 2.618. psi^2 is ( -0.618 )^2 \u2248 0.618.\n\nSo (2.618 - 0.618) / (2.236) = 2/2.236 \u2248 0.8944, but wait, sqrt(5) is approximately 2.236. Wait, 2/2.236 is 0.894, which when rounded would be 1? Wait, but F(2) is 1. So the calculation is (phi^2 - psi^2) is (2.618 - 0.618) = 2. So 2 / sqrt(5) is about 0.894, which when rounded gives 1, correct.\n\nWait, but the calculation was (phi^2 - psi^2)/sqrt(5) is equal to 2 / 2.236 which is approximately 0.894, which when rounded is 1. That's correct because F(2) is 1. Wait, no, F(2) is 1, yes. So rounding gives 1\u2014correct.\n\nAlternatively, perhaps adding 0.5 and then truncating works better. Because 0.894 +0.5=1.394 \u2192 int after is 1.\n\nWait, but when the result is 0.89, adding 0.5 gives 1.39, which is more accurate. Hmm, maybe not.\n\nAlternatively, perhaps to avoid confusion, use the int after adding 0.5. Because in cases where the fractional part is exactly 0.5, it will round up. But for most cases, this should work.\n\nAnother example: n=3.\n\nF(3) is 2.\n\nphi^3 \u2248 4.236, psi^3 \u2248 (-0.236). So (4.236 - (-0.236)) = 4.472. Divided by 2.236 is approximately 2.0. So correct.\n\nThus, the approach should work.\n\nSo the binets function is manageable.\n\nNow, the matrix exponentiation method. That's a bit more involved. The idea is that the nth Fibonacci number can be obtained by raising a transformation matrix to the (n-1)th power. Specifically, the matrix [[1, 1], [1, 0]] raised to the nth power gives us a matrix where the top left element is F(n+1). So, to get F(n), perhaps we can compute the matrix ^ (n-1) and take the top left element.\n\nSo, implementing matrix exponentiation requires functions to multiply matrices and to raise a matrix to a power using exponentiation by squaring.\n\nLet me outline the steps:\n\n1. Define a function to multiply two 2x2 matrices.\n\n2. Define a function to compute the power of a matrix, using exponentiation by squaring for efficiency.\n\n3. For a given n, compute the matrix [[1,1],[1,0]] raised to (n)th power, and get the element [0][0], which is F(n+1). So to get F(n), perhaps we need to compute the matrix to the (n-1)th power.\n\nWait, because matrix multiplication has the property that each exponent step increases the Fibonacci index by one step. So perhaps let's think about base cases:\n\nn=0: F(0) is 0. Matrix is M^(-1)?\n\nHmm, perhaps the approach is to represent the Fibonacci numbers as:\n\n| F(n+1)  F(n)  |   = M ^n, where M is [[1,1],[1,0]]\n| F(n)    F(n-1)|\n\nSo for n=1: M^1 = [[1,1],[1,0]] \u2192 F(2) =1, F(1)=1.\n\nThus, to get F(n), perhaps compute M^(n-1), and take the top right element.\n\nWait, or perhaps for n >=1, to get F(n), we can compute M^(n-1) and look at the element [0][0].\n\nWait no. Let me think again.\n\nM is [[1,1], [1,0]]\n\nM^0 is identity matrix [[1,0],[0,1]]\n\nM^1 is [[1,1],[1,0]]\n\nM^2 is [[2,1],[1,1]]\n\nSo:\n\nM^0: |1 0|   \u2192 F(1) F(0)=1 0? No, perhaps different.\n     |0 1|\n\nWait, perhaps it's better to think in terms of initial conditions.\n\nAnother approach is to see that:\n\nThe Fibonacci sequence can be represented as:\n\nF(n+1) = F(n) + F(n-1)\nF(n)   = F(n-1) + F(n-2)\n\nWhich is captured by the matrix multiplication.\n\nSo, when you multiply the vector [F(n), F(n-1)] by the matrix M, you get [F(n+1), F(n)].\n\nThus, to compute F(n), you can start with the initial vector and multiply by M^(n-1).\n\nWait, perhaps the initial vector for n=1 is [F(1), F(0)] = [1, 0]. Then, multiplying by M^(n-1) gives [F(n), F(n-1)].\n\nTherefore, for n >=1, M^(n-1) applied to [1, 0] gives [F(n), F(n-1)].\n\nHow does this relate to the matrix elements?\n\nThe resulting matrix M = [[a, b],[c, d]] when multiplied with [1,0] gives [a*1 + b*0, c*1 + d*0 ] \u2192 [a, c]. Wait, wait, no. Wait, matrix multiplication with a vector is:\n\nSuppose M is a 2x2 matrix, v is a 2x1 vector. Then, Mv is a 2x1 vector, where each row of M multiplied by the columns of v gives the elements.\n\nSo M = [[a, b], [c, d]], v = [x, y] \u2192 Mv = [a x + b y, c x + d y]\n\nSo, when I start with v = [F(2), F(1)] = [1, 1], then M * v would give [F(3), F(2)].\n\nBut perhaps the better way is to express the Fibonacci sequence as M^n * v, where v is the starting vector.\n\nWait, maybe need to think that M^n with n=0 is identity, so:\n\nM^0 * v = v.\n\nIf I start with v = [F(1), F(0)] = [1,0], then M = [[1,1],[1,0]]. So:\n\nM^1 * v = [[1,1],[1,0]] * [1,0] = [1,1]. Which is [F(2), F(1)].\n\nM^2 * v = M * (M * v) = M * [1,1] = [1+1, 1 + 0] = [2, 1].\n\nWhich is [F(3), F(2)].\n\nYes, so M^n * v = [F(n+1), F(n)].\n\nTherefore, if I want to compute F(n), for n >=1, I can compute M^(n-1) and multiply by v, and take the second element.\n\nWait, because:\n\nM^(n-1) * v = [F(n), F(n-1)]\n\nSo the vector is [F(n), F(n-1)], so the second element is F(n-1). That may not be directly helpful.\n\nAlternatively, perhaps I can express F(n) in terms of matrix elements.\n\nLet me see, the matrix M^(n) is [[a, b],[c, d]].\n\nIs there a closed-form relation between a, b, c, d and F(n)?\n\nUpon checking, after n multiplications, the element a in M^n is F(n+1), element b is F(n), c is also F(n), and d is F(n-1).\n\nWait, perhaps for M^n, a = F(n+1), b = F(n), c = F(n), d = F(n-1). So if I can compute M^(n-1), then a is F(n), b is F(n-1), etc. So perhaps F(n) is the a element of M^(n-1).\n\nWait, perhaps let me compute M^0:\n\na is 1, which F(0+1) is F(1) =1. So yes.\n\nM^1 is [[1,1],[1,0]] \u2192 a=1 = F(2) \u2192 yes, 1.\n\nM^2 is [[2,1],[1,1]] \u2192 a=2 = F(3) \u2192 2.\n\nSo, yes, M^n has a as F(n+1). So to get F(n), perhaps M^(n-1) has a= F(n).\n\nSo, the plan is:\n\n- For n=0: return 0.\n\n- For n>=1: compute M^(n-1), where M is [[1,1],[1,0]], and take the a (top-left element) which is F(n).\n\nBut how do I compute M^(n-1) efficiently? Using matrix exponentiation by squaring, which is O(log n) time.\n\nSo I'll need to implement matrix multiplication and matrix exponentiation.\n\nSo steps for the function:\n\n1. Handle the base case: n=0 \u2192 0, n=1 \u21921.\n\nWait, let's check:\n\nWait, for n=0, according to the problem statement, the function should return 0.\n\nFor n=1, return 1.\n\nSo the function needs to handle n=0 as a base case.\n\nOtherwise:\n\nCompute M^(n-1), where M is [[1,1],[1,0]], and return a, the top-left element of the matrix.\n\nSo code outline:\n\ndef fibonacci_matrix(n: int) -> int:\n\n    if n == 0:\n        return 0\n\n    def multiply(m1, m2):\n        # Multiply two 2x2 matrices\n        a = m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]\n        b = m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]\n        c = m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]\n        d = m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]\n        return [[a, b], [c, d]]\n\n    def matrix_power(matrix, power):\n        # Compute matrix^power using exponentiation by squaring\n        result = [[1,0], [0,1]]  # identity matrix\n        while power > 0:\n            if power % 2 == 1:\n                result = multiply(result, matrix)\n            matrix = multiply(matrix, matrix)\n            power = power // 2\n        return result\n\n    M = [[1,1], [1,0]]\n    powered = matrix_power(M, n-1)\n    return powered[0][0]\n\nWait, but the multiply function is for 2x2 matrices, right? Yes.\n\nBut let's see: What is M squared?\n\nM = [[1,1],[1,0]]\n\nM squared is [[1*1 +1*1, 1*1 +1*0], [1*1 +0*1, 1*1 + 0*0]] \u2192 [[2,1],[1,1]]\n\nWhich is correct, as before.\n\nWait, so for n=2, function calculates M^(1), which is M.\n\na is 1, which is F(2) \u2192 but wait, F(2) is 1.\n\nWait, but earlier I thought M^(n-1) gives a as F(n). So that would be correct.\n\nYes, M^(2-1) is M^1, which is [[1,1],[1,0]]. a is 1, which is F(2) \u2192 correct.\n\nSo the function seems correct.\n\nTesting for n=3:\n\nn-1=2 \u2192 M squared is [[2,1],[1,1]] \u2192 a=2 \u2192 F(3)=2.\n\nYes, correct.\n\nAnother test: n=10 -> returns 55.\n\nCompute M^9, which for function will return a matrix where a is F(10) =55.\n\nSo I think this should work.\n\nPutting it all together, for the function, we can define helper functions for matrix multiplication and exponentiation.\n\nBut since Python allows defining nested functions, they can be inside the fibonacci_matrix function.\n\nBut wait, for the purposes of writing code here, should I write helper functions inside?\n\nAlternatively, since the function is called once, perhaps writing helper functions is acceptable.\n\nPutting it all together, the code would have:\n\nImplement multiply and matrix_power as inner functions.\n\nNow, another potential issue: for n=1, n-1=0, so matrix_power returns the identity matrix. The a element is 1, which is correct, F(1)=1.\n\nn=0 returns 0, which is correctly handled.\n\nTesting for n=2: function returns 1, correct.\n\nn=5: F(5) is 5.\n\nM^4 is:\n\nM squared is [[2,1],[1,1]]\n\nM^4 is M squared squared: multiply [[2,1],[1,1]] by itself.\n\nCompute:\n\na = 2*2 + 1*1 =4+1=5\n\nb= 2*1 + 1*1=2+1=3\n\nc=1*2 +1*1=2+1=3\n\nd=1*1 +1*1=1+1=2.\n\nSo M^4 is [[5,3],[3,2]]. So a=5. Which is F(5), correct.\n\nThus, the function works.\n\nSo the code plan is:\n\nImplement the iterative function by maintaining two variables, a and b, starting with 0 and 1, then iterating up to n, updating a and b.\n\nImplement the recursive function with memoization, using a dictionary to store computed values.\n\nImplement Binet's formula using the formula, and returning the rounded value.\n\nImplement the matrix function as described.\n\nSo now, time to actually code each function.\n\nBut first, noting that for the Binet's function, we need to import math.\n\nSo putting it all together, the four functions would be implemented as:\n\nIterative:\n\ndef fibonacci_iterative(n: int) -> int:\n    if n == 0:\n        return 0\n    a, b = 0, 1\n    for _ in range(n-1):\n        a, b = b, a + b\n    return b\n\nWait, wait: for n=1, the function returns 1.\n\nTesting:\n\nn=0: returns 0.\nn=1: for _ in range(0), so loop doesn't run. return b=1.\nn=2: loop runs once: a=1, b=0+1=1. So after first iteration, a=1, b=1. So return b=1.\nn=10: i goes from 1 to 9, 9 iterations, correct.\n\nHmm, but when n is 0, the function returns 0.\n\nAlternative approach: something like:\n\ndef fibonacci_iterative(n):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\nThen:\n\nn=0: a is 0 after 0 steps \u2192 return 0.\nn=1: after 1 step \u2192 a becomes 1 \u2192 return 1?\nWait no: let's step through.\n\nWait initial a=0, b=1.\n\nn=1 \u2192 loop runs once:\n\nnew a = b \u2192 1.\n\nnew b = a + b \u2192 0+1=1.\n\nreturn a \u21921 \u2192 correct.\n\nn=2 \u2192 loop runs twice.\n\nLoop1: a=1, b=1.\n\nLoop2: a becomes 1, b=1+1=2.\n\nSo after two loops, a is 1, b=2.\n\nreturn a=1 \u2192 F(2) is 1, correct.\n\nn=3 \u2192 loop runs three times.\n\nAfter each iteration:\n\n1: a=1, b=1.\n\n2: a=1, b=2.\n\n3: a=2, b=3.\n\nreturn 2 \u2192 F(3)=2.\n\nWait, no. Because after loop iteration, a becomes previous b, which after the first step is 1, and so on. So for n=3, the function returns a=2, which is F(3). Correct.\n\nWait, F(0)=0, F(1)=1, F(2)=1, F(3)=2. Yes.\n\nSo for a function that returns F(n), starting from a=0, b=1, iterate n times, setting a = b and b = a + b (after previous a is set), and return a.\n\nYes, that might be the standard iterative approach.\n\nSo perhaps for the iterative function, that's the better approach.\n\nThus, the code would be:\n\ndef fibonacci_iterative(n: int) -> int:\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\nTesting:\n\nFor n=0: returns 0.\n\nn=1: return 1.\n\nn=2: returns 1.\n\nn=3: returns 2.\n\nCorrect.\n\nNow, the recursive function with memoization.\n\nAs discussed, we can have a memo in the function. As default argument. So:\n\ndef fibonacci_recursive(n: int, memo={}) -> int:\n    if n not in memo:\n        if n <= 0:\n            memo[n] = 0\n        elif n == 1:\n            memo[n] = 1\n        else:\n            memo[n] = fibonacci_recursive(n-1, memo) + fibonacci_recursive(n-2, memo)\n    return memo[n]\n\nWait, but wait, when n is 0, returns 0. If n is 1, returns 1. Else returns sum of n-1 and n-2.\n\nWait, but the initial code for recursive function needs to handle n=0 correctly.\n\nYes, as the test cases show. So the base case is if n <=0, return 0.\n\nWait, but no: according to the Fibonacci sequence, F(0)=0, F(1)=1, F(2)= F(1)+F(0)=1+0=1, etc. So the base cases are:\n\nn <=0 \u2192 return 0.\n\nn=1\u2192 return1.\n\nElse, return fib(n-1) + fib(n-2).\n\nWait, but in code, what about for n=2, where fib(2) is fib(1) + fib(0).\n\nWhich is 1+0=1. Correct.\n\nSo, recursive function should have base cases correctly handled.\n\nThus, the code:\n\ndef fibonacci_recursive(n: int, memo={} ) -> int:\n    if n in memo:\n        return memo[n]\n    if n <= 0:\n        memo[n] = 0\n    elif n == 1:\n        memo[n] = 1\n    else:\n        memo[n] = fibonacci_recursive(n-1, memo) + fibonacci_recursive(n-2, memo)\n    return memo[n]\n\nBut in Python, the default mutable argument (memo={}) can behave unexpectedly if not handled carefully. For example, if the function is called multiple times, the memo will retain previous values. But the test cases provided may not be affected if the functions are in a script and each call is separate. However, in a testing environment, it's better to reset the memo each time the function is called, which may not be desirable.\n\nAlternatively, perhaps the default argument can be set as None, and inside the function, the memo is created as a new dictionary each time the function is called when needed.\n\nAlternatively, perhaps using lru_cache decorator would be better, but I'm not sure if that is allowed here. Since the code provided in the problem doesn't have such a decorator, perhaps better to manage memo manually.\n\nSo, another approach: reset the memo each time, but no, that's not efficient.\n\nAlternatively, perhaps the function should not have a default memo, but create the memo each time. However, recursion needs the memo to accumulate the values for subproblems.\n\nWait, but all recursive calls would share the same memo instance.\n\nHmm.\n\nAlternatively, the function can be written as:\n\ndef fibonacci_recursive(n: int) -> int:\n\n    memo = {}\n\n    def helper(x):\n        if x in memo:\n            return memo[x]\n        if x <= 0:\n            return 0\n        elif x ==1:\n            return 1\n        else:\n            res = helper(x-1) + helper(x-2)\n            memo[x] = res\n            return res\n\n    return helper(n)\n\nBut this is for a helper with a nested memo.\n\nBut then, if the function is called multiple times, the memo is reinitialized each time. Which might be less efficient, but for small n, it's acceptable.\n\nAlternatively, in the initial code, setting the memo with a default argument would preserve it between function calls, which is more efficient but can lead to unexpected behavior if the function is called with varying n in different test cases. So perhaps the nested helper approach is better for this case.\n\nBut let's see: the problem provides doctests that call each function separately. So the functions will be tested in isolation.\n\nThus, perhaps using a helper with memo is acceptable.\n\nAlternatively, for now, the initial approach uses a default memo.\n\nBut what if someone calls the function with n=5 and then with n=3. The memo would have all the computed values up to 5. So for the second call, it can retrieve 3 from the memo. So the code seems correct.\n\nThus, perhaps the initial code is acceptable.\n\nAnother way to handle this is to use the functools.lru_cache decorator, but the problem code probably expects the approach with memoization done manually.\n\nPutting it all together, the four functions are as follows.\n</think>\n\nTo solve this problem, we need to compute the n-th Fibonacci number using four different methods: iterative approach, recursive approach with memoization, Binet's formula, and matrix exponentiation. Each method offers a unique perspective and efficiency in calculating Fibonacci numbers.\n\n### Approach\n\n1. **Iterative Method**: This approach uses a loop to compute Fibonacci numbers iteratively. Starting with the first two numbers (0 and 1), each subsequent number is the sum of the previous two, which makes this method straightforward and efficient.\n\n2. **Recursive Method with Memoization**: This approach uses recursion to compute Fibonacci numbers. To avoid redundant calculations and improve efficiency, memoization is used to store previously computed values, ensuring each Fibonacci number is calculated only once.\n\n3. **Binet's Formula**: This closed-form formula uses mathematical properties to compute Fibonacci numbers directly without recursion or iteration. It involves the golden ratio and is efficient for small values of n but may face precision issues for larger values due to floating-point arithmetic.\n\n4. **Matrix Exponentiation**: This method leverages matrix multiplication to compute Fibonacci numbers in logarithmic time. By raising a transformation matrix to the power of (n-1), we can efficiently compute the n-th Fibonacci number.\n\n### Solution Code\n\n```python\ndef fibonacci_iterative(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using iteration.\"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\n\ndef fibonacci_recursive(n: int, memo={}) -> int:\n    \"\"\"Returns the n-th Fibonacci number using recursion with memoization.\"\"\"\n    if n in memo:\n        return memo[n]\n    if n <= 0:\n        memo[n] = 0\n    elif n == 1:\n        memo[n] = 1\n    else:\n        memo[n] = fibonacci_recursive(n - 1, memo) + fibonacci_recursive(n - 2, memo)\n    return memo[n]\n\n\ndef fibonacci_binets(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using Binet's formula.\"\"\"\n    import math\n    sqrt5 = math.sqrt(5)\n    phi = (1 + sqrt5) / 2\n    psi = (1 - sqrt5) / 2\n    result = (phi ** n - psi ** n) / sqrt5\n    return round(result)\n\n\ndef fibonacci_matrix(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using matrix exponentiation.\"\"\"\n    if n == 0:\n        return 0\n\n    def multiply(m1, m2):\n        a = m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]\n        b = m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]\n        c = m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]\n        d = m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]\n        return [[a, b], [c, d]]\n\n    def matrix_power(matrix, power):\n        result = [[1, 0], [0, 1]]  # Identity matrix\n        while power > 0:\n            if power % 2 == 1:\n                result = multiply(result, matrix)\n            matrix = multiply(matrix, matrix)\n            power //= 2\n        return result\n\n    M = [[1, 1], [1, 0]]\n    powered_matrix = matrix_power(M, n - 1)\n    return powered_matrix[0][0]\n```\n\n### Explanation\n\n1. **Iterative Method**: This approach initializes two variables `a` and `b` to 0 and 1, respectively. It then iterates `n` times, updating these variables to hold the next Fibonacci numbers. This method is efficient and runs in O(n) time.\n\n2. **Recursive Method with Memoization**: This method uses a dictionary (`memo`) to store previously computed Fibonacci numbers. For each recursive call, it checks if the value is already computed and stored, avoiding redundant calculations. This reduces the time complexity to O(n) from the exponential time complexity of a naive recursive approach.\n\n3. **Binet's Formula**: This method uses the mathematical formula involving the golden ratio to compute Fibonacci numbers directly. It leverages floating-point arithmetic and rounding to handle precision issues. The time complexity is O(1) for calculations, making it efficient for small values of `n`.\n\n4. **Matrix Exponentiation**: This method uses matrix multiplication to compute the n-th Fibonacci number efficiently. By exponentiating a transformation matrix using exponentiation by squaring, the time complexity is reduced to O(log n), making it suitable for large values of `n`.\n\nEach method provides a unique solution to the problem, with varying efficiency and complexity trade-offs depending on the value of `n`.",
  "r1_solution": "def fibonacci_iterative(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using iteration.\"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\n\ndef fibonacci_recursive(n: int, memo={}) -> int:\n    \"\"\"Returns the n-th Fibonacci number using recursion with memoization.\"\"\"\n    if n in memo:\n        return memo[n]\n    if n <= 0:\n        memo[n] = 0\n    elif n == 1:\n        memo[n] = 1\n    else:\n        memo[n] = fibonacci_recursive(n - 1, memo) + fibonacci_recursive(n - 2, memo)\n    return memo[n]\n\n\ndef fibonacci_binets(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using Binet's formula.\"\"\"\n    import math\n    sqrt5 = math.sqrt(5)\n    phi = (1 + sqrt5) / 2\n    psi = (1 - sqrt5) / 2\n    result = (phi ** n - psi ** n) / sqrt5\n    return round(result)\n\n\ndef fibonacci_matrix(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using matrix exponentiation.\"\"\"\n    if n == 0:\n        return 0\n\n    def multiply(m1, m2):\n        a = m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]\n        b = m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]\n        c = m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]\n        d = m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]\n        return [[a, b], [c, d]]\n\n    def matrix_power(matrix, power):\n        result = [[1, 0], [0, 1]]  # Identity matrix\n        while power > 0:\n            if power % 2 == 1:\n                result = multiply(result, matrix)\n            matrix = multiply(matrix, matrix)\n            power //= 2\n        return result\n\n    M = [[1, 1], [1, 0]]\n    powered_matrix = matrix_power(M, n - 1)\n    return powered_matrix[0][0]",
  "metadata": {
    "prompt_id": "00000025",
    "row_id": 25,
    "seed_ids": [
      699
    ],
    "mode": "algorithm",
    "original_instruction": "<|Analysis Begin|>\n\n### Algorithm/Data Structure\n\n**Name and Type**: The provided code snippets demonstrate the calculation of Fibonacci numbers using several methods: iteration, recursion, memoization, and a simplified form of Binet's formula. Additionally, a matrix exponentiation method is used, which is a more advanced technique.\n\n**Core Operational Steps**:\n- **Iteration**: Uses a loop to iterate and calculate the Fibonacci sequence.\n- **Recursion**: Recursively calculates the Fibonacci sequence by dividing the problem into smaller subproblems.\n- **Memoization**: Stores the results of expensive function calls and reuses them when the same inputs occur again.\n- **Binet's Formula**: Uses mathematical formulas to calculate Fibonacci numbers, which is efficient but limited by floating-point precision.\n- **Matrix Exponentiation**: Utilizes matrix multiplication to compute the Fibonacci sequence, which is highly efficient for larger values of \\( n \\).\n\n**Time Complexity**:\n- **Iteration**: \\( O(n) \\)\n- **Recursion**: \\( O(2^n) \\) (without memoization), \\( O(n) \\) (with memoization)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(\\log n) \\)\n\n**Space Complexity**:\n- **Iteration**: \\( O(1) \\) (excluding the output list)\n- **Recursion**: \\( O(n) \\) (due to the call stack)\n- **Memoization**: \\( O(n) \\) (for storing intermediate results)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(1) \\) (excluding the output)\n\n### Characteristics & Applications\n\n**Properties**:\n- **Iteration**: Simple and easy to understand, but not efficient for large \\( n \\) due to its linear time complexity.\n- **Recursion**: Can lead to stack overflow for large \\( n \\) and is inefficient, but useful for teaching recursion.\n- **Memoization**: Efficient for large \\( n \\) and avoids redundant calculations, making it a good balance between speed and memory usage.\n- **Binet's Formula**: Efficient but limited by floating-point precision, making it less accurate for large values.\n- **Matrix Exponentiation**: Extremely efficient for very large \\( n \\) but requires understanding of matrix operations and logarithmic time complexity.\n\n**Common Use Cases**:\n- **Iteration**: Useful for small values of \\( n \\) where simplicity is preferred.\n- **Recursion**: Often used in teaching recursion, but not suitable for large \\( n \\).\n- **Memoization**: Good for practical applications where performance is critical and \\( n \\) is large.\n- **Binet's Formula**: Used in contexts where a quick, approximate solution is sufficient.\n- **Matrix Exponentiation**: Ideal for large \\( n \\) in performance-critical applications.\n\n**Strengths/Limitations**:\n- **Iteration**: Simple to implement, but inefficient for large \\( n \\).\n- **Recursion**: Elegant and easy to understand, but inefficient and prone to stack overflow.\n- **Memoization**: Efficient and avoids redundant calculations, but requires additional memory.\n- **Binet's Formula**: Fast but limited by floating-point precision, making it less accurate for large \\( n \\).\n- **Matrix Exponentiation**: Highly efficient with \\( O(\\log n) \\) time complexity but requires understanding of matrix operations.\n\n### Implementation Challenges\n\n**Edge Cases**:\n- **Negative Input**: All methods except the iterative yield version raise a `ValueError` for negative inputs.\n- **Large Input**: Binet's formula and matrix exponentiation have limitations for very large inputs due to floating-point precision and time complexity, respectively.\n\n**Performance Bottlenecks**:\n- **Recursion**: High stack usage and inefficiency, leading to stack overflow for large \\( n \\).\n- **Memoization**: Requires additional memory to"
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}