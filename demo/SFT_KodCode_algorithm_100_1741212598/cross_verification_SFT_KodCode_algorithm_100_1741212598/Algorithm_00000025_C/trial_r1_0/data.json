{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000025_C",
  "question": "def fibonacci_iterative(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using iteration.\n    >>> fibonacci_iterative(0)\n    0\n    >>> fibonacci_iterative(1)\n    1\n    >>> fibonacci_iterative(2)\n    1\n    >>> fibonacci_iterative(10)\n    55\n    >>> fibonacci_iterative(20)\n    6765\n    \"\"\"\ndef fibonacci_recursive(n: int, memo={}) -> int:\n    \"\"\"Returns the n-th Fibonacci number using recursion with memoization.\n    >>> fibonacci_recursive(0)\n    0\n    >>> fibonacci_recursive(1)\n    1\n    >>> fibonacci_recursive(2)\n    1\n    >>> fibonacci_recursive(10)\n    55\n    >>> fibonacci_recursive(20)\n    6765\n    \"\"\"\ndef fibonacci_binets(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using Binet's formula.\n    >>> fibonacci_binets(0)\n    0\n    >>> fibonacci_binets(1)\n    1\n    >>> fibonacci_binets(2)\n    1\n    >>> fibonacci_binets(10)\n    55\n    >>> fibonacci_binets(20)\n    6765\n    \"\"\"\ndef fibonacci_matrix(n: int) -> int:\n    \"\"\"Returns the n-th Fibonacci number using matrix exponentiation.\n    >>> fibonacci_matrix(0)\n    0\n    >>> fibonacci_matrix(1)\n    1\n    >>> fibonacci_matrix(2)\n    1\n    >>> fibonacci_matrix(10)\n    55\n    >>> fibonacci_matrix(20)\n    6765\n    >>> fibonacci_matrix(50)\n    12586269025\n    \"\"\"",
  "solution": "def fibonacci_iterative(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using iteration.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\ndef fibonacci_recursive(n, memo={}):\n    \"\"\"\n    Returns the n-th Fibonacci number using recursion with memoization.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_recursive(n - 1, memo) + fibonacci_recursive(n - 2, memo)\n    return memo[n]\n\ndef fibonacci_binets(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using Binet's formula.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    phi = (1 + 5**0.5) / 2\n    return int((phi**n - (-phi)**(-n)) / 5**0.5)\n\ndef fibonacci_matrix(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using matrix exponentiation.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    if n == 0:\n        return 0\n    fib_matrix = [[1, 1], [1, 0]]\n    result = matrix_pow(fib_matrix, n - 1)\n    return result[0][0]\n\ndef matrix_pow(matrix, n):\n    \"\"\"\n    Raises a 2x2 matrix to the power of n using exponentiation by squaring.\n    \"\"\"\n    result = [[1, 0], [0, 1]]  # Identity matrix\n    base = matrix\n    while n:\n        if n % 2:\n            result = matrix_multiply(result, base)\n        base = matrix_multiply(base, base)\n        n //= 2\n    return result\ndef matrix_multiply(a, b):\n    \"\"\"\n    Multiplies two 2x2 matrices.\n    \"\"\"\n    return [[a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n            [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]]]",
  "test_code": "import pytest\nfrom solution import (\n    fibonacci_iterative, \n    fibonacci_recursive, \n    fibonacci_binets, \n    fibonacci_matrix\n)\n\ndef test_fibonacci_iterative():\n    assert fibonacci_iterative(0) == 0\n    assert fibonacci_iterative(1) == 1\n    assert fibonacci_iterative(2) == 1\n    assert fibonacci_iterative(10) == 55\n    assert fibonacci_iterative(20) == 6765\n\ndef test_fibonacci_recursive():\n    assert fibonacci_recursive(0) == 0\n    assert fibonacci_recursive(1) == 1\n    assert fibonacci_recursive(2) == 1\n    assert fibonacci_recursive(10) == 55\n    assert fibonacci_recursive(20) == 6765\n\ndef test_fibonacci_binets():\n    assert fibonacci_binets(0) == 0\n    assert fibonacci_binets(1) == 1\n    assert fibonacci_binets(2) == 1\n    assert fibonacci_binets(10) == 55\n    assert fibonacci_binets(20) == 6765\n\ndef test_fibonacci_matrix():\n    assert fibonacci_matrix(0) == 0\n    assert fibonacci_matrix(1) == 1\n    assert fibonacci_matrix(2) == 1\n    assert fibonacci_matrix(10) == 55\n    assert fibonacci_matrix(20) == 6765\n\ndef test_large_input_fibonacci_matrix():\n    assert fibonacci_matrix(50) == 12586269025\n\ndef test_negative_input():\n    with pytest.raises(ValueError):\n        fibonacci_iterative(-1)\n    with pytest.raises(ValueError):\n        fibonacci_recursive(-1)\n    with pytest.raises(ValueError):\n        fibonacci_binets(-1)\n    with pytest.raises(ValueError):\n        fibonacci_matrix(-1)",
  "test_info": [
    {
      "function_name": "fibonacci_iterative",
      "parameter_list": "(n)",
      "function_declaration": "def fibonacci_iterative(n):",
      "docstring": "Returns the n-th Fibonacci number using iteration."
    },
    {
      "function_name": "fibonacci_recursive",
      "parameter_list": "(n, memo={})",
      "function_declaration": "def fibonacci_recursive(n, memo={}):",
      "docstring": "Returns the n-th Fibonacci number using recursion with memoization."
    },
    {
      "function_name": "fibonacci_binets",
      "parameter_list": "(n)",
      "function_declaration": "def fibonacci_binets(n):",
      "docstring": "Returns the n-th Fibonacci number using Binet's formula."
    },
    {
      "function_name": "fibonacci_matrix",
      "parameter_list": "(n)",
      "function_declaration": "def fibonacci_matrix(n):",
      "docstring": "Returns the n-th Fibonacci number using matrix exponentiation."
    },
    {
      "function_name": "matrix_pow",
      "parameter_list": "(matrix, n)",
      "function_declaration": "def matrix_pow(matrix, n):",
      "docstring": "Raises a 2x2 matrix to the power of n using exponentiation by squaring."
    },
    {
      "function_name": "matrix_multiply",
      "parameter_list": "(a, b)",
      "function_declaration": "def matrix_multiply(a, b):",
      "docstring": "Multiplies two 2x2 matrices."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write four functions that calculate the nth Fibonacci number. Each function uses a different method: iterative, recursive with memoization, Binet's formula, and matrix exponentiation. Let me think about each method step by step.\n\nStarting with the iterative approach. I remember that the iterative method simply uses a loop to calculate each Fibonacci number from the bottom up. So for n=0, it's 0; n=1, it's 1. For higher n, each number is the sum of the two preceding ones. So I can initialize two variables, a and b, to 0 and 1. Then, for each step up to n, calculate the next as a + b and update a and b accordingly. Wait, but I have to be careful about the loop's stopping condition and the cases when n is 0 or 1.\n\nNext, the recursive function with memoization. Recursive Fibonacci is straightforward but highly inefficient without memoization. So I'll use memoization to store already computed values. The memo can be a dictionary that the function uses to check if n is already a key. For each call, if n is 0, return 0; if n is 1, return 1. Otherwise, compute fibonacci(n-1) + fibonacci(n-2), and store this result in the memo before returning. Oh, but memoization in Python, especially with default arguments, can lead to some issues if not handled correctly. I need to make sure the memo doesn't grow too large or interfere with multiple function calls, but for the purposes of this problem, it's manageable.\n\nMoving on to Binet's formula. Binet's formula uses the closed-form expression involving the golden ratio. The formula is (phi^n - psi^n)/sqrt(5), where phi is (1 + sqrt(5))/2 and psi is (1 - sqrt(5))/2. Since this involves floating point operations, I'll need to cast the final result to an integer because for integer n, the result is an integer. However, for large n, this might introduce some precision errors. So adding a rounding step before converting to int could help. Let me also note that for n=0, it should return 0, and for n=1, it should return 1, which fits the formula as well.\n\nThe matrix exponentiation method is a bit more complex. The idea is to represent the Fibonacci sequence as the power of a transformation matrix. The matrix [[1,1],[1,0]] raised to the (n-1)th power gives a matrix where the top left element is fib(n). So, I'll need to implement matrix exponentiation. To do this efficiently, I can use exponentiation by squaring, which reduces the time complexity to O(log n). Let's outline the steps: define a helper function to multiply two 2x2 matrices and another function to compute the power of a matrix using exponentiation by squaring. Then, the final result is matrix_power(matrix, n-1)[0][0].\n\nWait, for n=0, the function should return 0, so I need to handle that case before computing the matrix. For n=1, it should return 1, so maybe handle n=0 and n=1 as base cases before proceeding.\n\nLet me outline each function:\n\nFor iterative:\n- Initialize a and b as 0 and 1.\n- If n is 0, return 0.\n- Else, loop from 2 to n, updating a and b as a becomes b, and b becomes a + new a.\n\nFor recursive:\n- Use a memoization dictionary.\n- Base cases: if n is 0, return 0; if n is 1, return 1.\n- Otherwise, return fib(n-1) + fib(n-2), storing the result in memo.\n\nFor Binet:\n- Compute phi and psi.\n- Calculate (phi^n - psi^n) divided by sqrt(5).\n- Round to the nearest integer to avoid floating point errors.\n\nWait, but for n >= 0, is Binet's formula applicable? Let me test for small n. For n=0: (phi^0 - psi^0)/sqrt(5) = (1 -1)/... =0. Correct. n=1: (phi - psi)/sqrt(5). Let's compute phi = (1+sqrt(5))/2 \u22481.618, psi=(1-sqrt(5))/2\u2248-0.618. phi - psi = 2 sqrt(5)/2 = sqrt(5). So (phi - psi)/sqrt(5) = (sqrt(5)) / sqrt(5) =1. Correct. So yes, it works for n=1. But when using this with integer exponentiation, for very large exponents, the floating point precision might cause issues. Also, for n=2, phi^2 is approx 2.618, psi^2 is approx 0.618, so difference is 2, divided by sqrt(5) is about 0.894? Wait wait no, maybe I'm miscalculating. Wait phi^2 is ((1+sqrt5)/2)^2 = (1 + 2 sqrt5 +5)/4 = (6 + 2 sqrt5)/4 = (3 + sqrt5)/2 \u2248 (3+2.236)/2=2.618. Similarly, psi^2 is ((1-sqrt5)/2)^2 = same as phi^2 but with minus sqrt5, so (3 - sqrt5)/2\u2248(3-2.236)/2=0.382. So phi^2 - psi^2 is (3 + sqrt5 -3 + sqrt5)/2 = (2 sqrt5)/2 = sqrt5. So (phi^2 - psi^2)/sqrt5 =1, which is correct for fib(2)=1. So yes, formula works but calculating this with floating points for large n may lead to inaccuracies. So perhaps using rounding is sufficient.\n\nFor matrix exponentiation:\n- When n is 0, return 0.\n- When n is 1, return 1.\n- Otherwise, compute the matrix [[1,1],[1,0]] raised to (n-1)th power.\n- The [0][0] element of the resulting matrix is fib(n).\n\nSo the helper functions I need are matrix multiplication and matrix exponentiation.\n\nWait, matrices are 2x2, so each multiplication involves specific steps, calculating each element. Maybe represent the matrix as a list of lists, like [[a, b], [c, d]]. Then, multiply two matrices m1 and m2 as follows:\n- new_a = m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]\n- new_b = m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]\n- new_c = m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]\n- new_d = m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]\nReturn [[new_a, new_b], [new_c, new_d]]\n\nThe exponentiation can be done by initializing the result as the identity matrix and then performing exponentiation by squaring. For even exponents, square the matrix and halve the exponent. For odd, multiply by the matrix once, then proceed.\n\nAlternatively, to compute the exponent, handle it recursively: matrix_power(m, n) is m multiplied by matrix_power(m, n-1). But for large n, that's inefficient. So exponentiation by squaring is better.\n\nPutting it all together.\n\nI think I need to code each function with the base cases handled.\n\nTesting iterative function:\nn=0 \u21920, yes.\nn=1\u21921.\nn=2: a=0, b=1.\nAfter first iteration (i=2), temp = a + b = 0+1=1, a becomes 1, b becomes 1. So now, return b=1.\nYes.\n\nTesting recursive function with memo:\nThe memo starts empty, but each call adds n to the memo. Wait, the initial function definition has memo={} as a default argument. But in Python, default arguments are evaluated once, so this could lead to the memo being preserved between function calls. Which is good for multiple calls, but perhaps for the problem's usage, it's acceptable.\n\nTesting with n=2:\nfibonacci_recursive(2) \u2192 fib(1)+fib(0)=1+0=1. Correct.\n\nNow for Binets' function, using floating points. For larger n, say n=20, 6765. Let me see:\n\nphi = (1+sqrt(5))/2 \u22481.618033988749895\npsi = (1-sqrt(5))/2 \u2248-0.6180339887498949\n\nphi^20 is approximately 6765.0 exactly? Or close enough that after subtracting psi^20 and dividing by sqrt(5), it becomes 6765. So in code, compute pow(phi, n) - pow(psi, n), divide by sqrt(5), add 0.5 and then cast to int to round correctly.\n\nWait, because (phi^n - psi^n) is always an integer, but due to floating point inaccuracies, the computed value might be something like 6764.99999999 or 6765.00000002. So adding 0.5 and converting to int would correctly round it to 6765.\n\nSo the formula in code would be:\n\nimport math\nsqrt5 = math.sqrt(5)\nphi = (1 + sqrt5) / 2\npsi = (1 - sqrt5) / 2\nresult = (phi**n - psi**n) / sqrt5\nrounded_result = int(result + 0.5)\nreturn rounded_result\n\nBut wait for n=0, phi^0 is 1, psi^0 is 1. 1-1=0, divided by sqrt5 is 0. Correct.\n\nn=1: (phi - psi)/sqrt5 \u2192 (sqrt(5)) / sqrt5=1.\n\nn=2: (phi^2 - psi^2)/sqrt5 \u2192 which we saw is 1. Correct.\n\nBut for very large n, say 50, fib(50) is 12586269025. Using Binet's formula, does it compute correctly without losing precision? Floating point precision can be an issue for large exponents.\n\nSo perhaps we need to adjust something here, but for the purposes of the problem, I think this approach is acceptable as it's one of the standard methods.\n\nThe matrix approach:\n\nDefine the initial matrix as [[1,1],[1,0]]. The idea is that when you raise this matrix to the (n)th power, the top left element is fib(n+1). So maybe for n, it's better to compute the matrix to the (n-1)th power, because fib(2)=1 = [[1,1],[1,0]]^1.\n\nSo, for n=2, the matrix is [[1,1],[1,0]], and its top-left is 1, which matches fib(2)=1. For n=3, the matrix squared is [[2,1],[1,1]], top-left 2, which is fib(3)=2.\n\nWait perhaps it's the case that matrix^(n) gives fib(n+1). So in code, for the function, if n=0, return 0; if n=1, return 1; else, compute the matrix^(n-1) and return top-left element.\n\nSo the base cases are important. So for n=2, matrix^1 is [[1,1],[1,0]], so fib(2) is 1. Correct.\n\nImplementing matrix multiplication and exponentiation.\n\nFor the helper function, I need to write functions that can multiply two 2x2 matrices, and a function to raise a matrix to a power using exponentiation by squaring.\n\nSo in code, within the fibonacci_matrix function, perhaps implement matrix multiplication and power as nested functions or just compute inline.\n\nBut writing the helper functions within the main function to avoid polluting the namespace.\n\nPutting it all together, I can now outline each function with their respective approaches.\n\nBut wait, for Fibonacci_iterative, what's the loop structure?\n\nIn code:\n\ndef fibonacci_iterative(n: int) -> int:\n    if n == 0:\n        return 0\n    a, b = 0, 1\n    for i in range(2, n+1):\n        a, b = b, a + b\n    return b\n\nWait, let me test with n=0: returns 0.\nn=1: loop doesn't run, returns b=1.\nn=2: loop runs for i=2, a becomes 1, b becomes 0+1=1? Wait wait, initial a=0, b=1. For i=2, temp = a + b =0 +1=1. Then a becomes b (1), b becomes temp (1). So returns b=1. Correct.\nn=3: a=1, b=1 for i=2; then i=3: a becomes 1, b becomes 1+1=2. Return 2. Correct.\n\nSo that's correct.\n\nFor the recursive function with memoization:\n\ndef fibonacci_recursive(n: int, memo={}) -> int:\n    if n in memo:\n        return memo[n]\n    if n <= 0:\n        result = 0\n    elif n == 1:\n        result = 1\n    else:\n        result = fibonacci_recursive(n-1, memo) + fibonacci_recursive(n-2, memo)\n    memo[n] = result\n    return result\n\nWait, but in the initial definition, the memo is passed as a default argument. That could cause problems if the function is called multiple times because the memo will accumulate all previous results. But for testing purposes where each function is called with a specific n, it's fine. Let me test:\n\nfibonacci_recursive(0) would first check if 0 is in memo, which it is not, but in the if n <=0 condition, returns 0. So correct.\n\nSimilarly for n=1 and higher. But perhaps it's better to use a function attribute instead of mutable default argument for memo, but for the sake of the problem, this should suffice.\n\nTesting n=2: fib(2) calls fib(1) and fib(0). So memo is filled correctly.\n\nBinets function:\n\nimport math\n\ndef fibonacci_binets(n: int) -> int:\n    if n == 0:\n        return 0\n    sqrt5 = math.sqrt(5)\n    phi = (1 + sqrt5) / 2\n    psi = (1 - sqrt5) / 2\n    return int( (phi**n - psi**n) / sqrt5 + 0.5 )\n\nTesting this with n=0 returns 0. n=1: returns 1. n=2: returns 1. n=10: 55. Correct.\n\nBut as mentioned earlier, for very large n (like 50), the floating-point imprecision may cause errors. But perhaps using the round function or adding 0.5 and casting to int is enough.\n\nWait, let me test for n=20. Let me compute phi^20 and psi^20 numerically.\n\nphi^20 is approx 6765.999999999999, so subtracting psi^20 (which is very small, negative) would make it 6765.999999999... Then divide by sqrt(5), which is about 2.236. So 6765.9999 / 2.236 is approximately 3025. So wait, no. Wait sorry, perhaps I'm miscalculating.\n\nWait phi^20 is approximately 6765.0, which is fib(20). Because (phi^20) is about 6765.0. So (phi^20 - psi^20) / sqrt(5) should give 6765 correct.\n\nBut let me compute it with actual numbers.\n\nLet me compute 20th Fibonacci number using Binet's formula.\n\nsqrt5 = 2.2360679775\nphi = 1.618033988749895\npsi = -0.618033988749895\n\nphi^20 = 1.618033988749895^20.\nLet me compute that:\n\n1.618033988749895^2 = approx 2.618\n^4: ~6.854\n^8: ~46.9787\n^16: around 2795.0\n^20: (phi^16)*(phi^4) = 2795 *6.854 \u2192 ~19,178. Not sure. Wait but perhaps it's easier to compute in code.\n\nWait, perhaps it's better to test with the function.\n\nAlternatively, I can look up the 20th Fibonacci number, which is 6765. Using the function:\n\nphi^20 = 1.618033988749895^20 \u2192 let me compute using Python.\n\nBut in any case, the function seems logically correct.\n\nFinally, the matrix exponentiation.\n\nImplementing the matrix exponentiation is a bit more involved, so let me outline the steps.\n\nThe function:\n\ndef fibonacci_matrix(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    # Initialize the transformation matrix [[1,1],[1,0]]\n    def multiply(m1, m2):\n        a = m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]\n        b = m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]\n        c = m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]\n        d = m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]\n        return [[a, b], [c, d]]\n    \n    def power(mat, exponent):\n        # Initialize result as identity matrix\n        result = [[1, 0], [0, 1]]\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = multiply(result, mat)\n            mat = multiply(mat, mat)\n            exponent = exponent // 2\n        return result\n    \n    mat = [[1,1], [1,0]]\n    mat_power = power(mat, n-1)\n    return mat_power[0][0]\n\nTesting with n=2, returns 1. For n=3: mat^(2) is [[2,1],[1,1]], so return 2. Correct.\n\nn=10: mat^9, top-left element should be 55. Correct.\n\nSo this should handle all cases.\n\nNow, considering all functions, yes, I think this should work.\n</think>\n\nTo solve this problem, we need to compute the n-th Fibonacci number using four different methods: iterative approach, recursive approach with memoization, Binet's formula, and matrix exponentiation. Each method has its own strengths and weaknesses, and understanding them helps in choosing the most appropriate one based on the problem constraints.\n\n### Approach\n\n1. **Iterative Approach**: This method uses a loop to compute Fibonacci numbers from the bottom up. It is efficient and has a time complexity of O(n).\n\n2. **Recursive Approach with Memoization**: This method uses recursion with memoization to store already computed values, thus avoiding redundant calculations and improving efficiency. The time complexity is O(n).\n\n3. **Binet's Formula**: This closed-form formula uses the golden ratio to compute the Fibonacci number directly. It is efficient for computations but can suffer from floating-point precision errors for large n.\n\n4. **Matrix Exponentiation**: This method uses matrix exponentiation to compute Fibonacci numbers efficiently, with a time complexity of O(log n). It is particularly useful for very large n.\n\n### Solution Code\n\n```python\nimport math\n\ndef fibonacci_iterative(n: int) -> int:\n    if n == 0:\n        return 0\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\ndef fibonacci_recursive(n: int, memo={}) -> int:\n    if n in memo:\n        return memo[n]\n    if n <= 0:\n        result = 0\n    elif n == 1:\n        result = 1\n    else:\n        result = fibonacci_recursive(n - 1, memo) + fibonacci_recursive(n - 2, memo)\n    memo[n] = result\n    return result\n\ndef fibonacci_binets(n: int) -> int:\n    if n == 0:\n        return 0\n    sqrt5 = math.sqrt(5)\n    phi = (1 + sqrt5) / 2\n    psi = (1 - sqrt5) / 2\n    return int((phi ** n - psi ** n) / sqrt5 + 0.5)\n\ndef fibonacci_matrix(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    def multiply(m1, m2):\n        a = m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]\n        b = m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]\n        c = m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]\n        d = m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]\n        return [[a, b], [c, d]]\n    \n    def power(mat, exponent):\n        result = [[1, 0], [0, 1]]  # Identity matrix\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = multiply(result, mat)\n            mat = multiply(mat, mat)\n            exponent = exponent // 2\n        return result\n    \n    mat = [[1, 1], [1, 0]]\n    mat_power = power(mat, n - 1)\n    return mat_power[0][0]\n```\n\n### Explanation\n\n1. **Iterative Approach**: The function `fibonacci_iterative` initializes two variables `a` and `b` to 0 and 1, respectively. It then iterates from 2 to n, updating `a` and `b` to the next Fibonacci number in each iteration. This approach is efficient and straightforward.\n\n2. **Recursive Approach with Memoization**: The function `fibonacci_recursive` uses a dictionary `memo` to store computed Fibonacci numbers. For each call, it checks if the number is already in the memo, computes it recursively if not, and stores the result before returning. This avoids redundant calculations and significantly improves performance.\n\n3. **Binet's Formula**: The function `fibonacci_binets` computes the Fibonacci number using the closed-form formula involving the golden ratio. It calculates the values of phi and psi, then uses these to compute the result. The result is adjusted to handle floating-point precision issues.\n\n4. **Matrix Exponentiation**: The function `fibonacci_matrix` uses matrix exponentiation to compute the Fibonacci number efficiently. It defines helper functions for matrix multiplication and exponentiation by squaring, which allows it to compute the result in logarithmic time. The transformation matrix `[[1, 1], [1, 0]]` is raised to the power of (n-1), and the top-left element of the resulting matrix gives the n-th Fibonacci number.",
  "r1_solution": "import math\n\ndef fibonacci_iterative(n: int) -> int:\n    if n == 0:\n        return 0\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\ndef fibonacci_recursive(n: int, memo={}) -> int:\n    if n in memo:\n        return memo[n]\n    if n <= 0:\n        result = 0\n    elif n == 1:\n        result = 1\n    else:\n        result = fibonacci_recursive(n - 1, memo) + fibonacci_recursive(n - 2, memo)\n    memo[n] = result\n    return result\n\ndef fibonacci_binets(n: int) -> int:\n    if n == 0:\n        return 0\n    sqrt5 = math.sqrt(5)\n    phi = (1 + sqrt5) / 2\n    psi = (1 - sqrt5) / 2\n    return int((phi ** n - psi ** n) / sqrt5 + 0.5)\n\ndef fibonacci_matrix(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    def multiply(m1, m2):\n        a = m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]\n        b = m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]\n        c = m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]\n        d = m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]\n        return [[a, b], [c, d]]\n    \n    def power(mat, exponent):\n        result = [[1, 0], [0, 1]]  # Identity matrix\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = multiply(result, mat)\n            mat = multiply(mat, mat)\n            exponent = exponent // 2\n        return result\n    \n    mat = [[1, 1], [1, 0]]\n    mat_power = power(mat, n - 1)\n    return mat_power[0][0]",
  "metadata": {
    "prompt_id": "00000025",
    "row_id": 25,
    "seed_ids": [
      699
    ],
    "mode": "algorithm",
    "original_instruction": "<|Analysis Begin|>\n\n### Algorithm/Data Structure\n\n**Name and Type**: The provided code snippets demonstrate the calculation of Fibonacci numbers using several methods: iteration, recursion, memoization, and a simplified form of Binet's formula. Additionally, a matrix exponentiation method is used, which is a more advanced technique.\n\n**Core Operational Steps**:\n- **Iteration**: Uses a loop to iterate and calculate the Fibonacci sequence.\n- **Recursion**: Recursively calculates the Fibonacci sequence by dividing the problem into smaller subproblems.\n- **Memoization**: Stores the results of expensive function calls and reuses them when the same inputs occur again.\n- **Binet's Formula**: Uses mathematical formulas to calculate Fibonacci numbers, which is efficient but limited by floating-point precision.\n- **Matrix Exponentiation**: Utilizes matrix multiplication to compute the Fibonacci sequence, which is highly efficient for larger values of \\( n \\).\n\n**Time Complexity**:\n- **Iteration**: \\( O(n) \\)\n- **Recursion**: \\( O(2^n) \\) (without memoization), \\( O(n) \\) (with memoization)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(\\log n) \\)\n\n**Space Complexity**:\n- **Iteration**: \\( O(1) \\) (excluding the output list)\n- **Recursion**: \\( O(n) \\) (due to the call stack)\n- **Memoization**: \\( O(n) \\) (for storing intermediate results)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(1) \\) (excluding the output)\n\n### Characteristics & Applications\n\n**Properties**:\n- **Iteration**: Simple and easy to understand, but not efficient for large \\( n \\) due to its linear time complexity.\n- **Recursion**: Can lead to stack overflow for large \\( n \\) and is inefficient, but useful for teaching recursion.\n- **Memoization**: Efficient for large \\( n \\) and avoids redundant calculations, making it a good balance between speed and memory usage.\n- **Binet's Formula**: Efficient but limited by floating-point precision, making it less accurate for large values.\n- **Matrix Exponentiation**: Extremely efficient for very large \\( n \\) but requires understanding of matrix operations and logarithmic time complexity.\n\n**Common Use Cases**:\n- **Iteration**: Useful for small values of \\( n \\) where simplicity is preferred.\n- **Recursion**: Often used in teaching recursion, but not suitable for large \\( n \\).\n- **Memoization**: Good for practical applications where performance is critical and \\( n \\) is large.\n- **Binet's Formula**: Used in contexts where a quick, approximate solution is sufficient.\n- **Matrix Exponentiation**: Ideal for large \\( n \\) in performance-critical applications.\n\n**Strengths/Limitations**:\n- **Iteration**: Simple to implement, but inefficient for large \\( n \\).\n- **Recursion**: Elegant and easy to understand, but inefficient and prone to stack overflow.\n- **Memoization**: Efficient and avoids redundant calculations, but requires additional memory.\n- **Binet's Formula**: Fast but limited by floating-point precision, making it less accurate for large \\( n \\).\n- **Matrix Exponentiation**: Highly efficient with \\( O(\\log n) \\) time complexity but requires understanding of matrix operations.\n\n### Implementation Challenges\n\n**Edge Cases**:\n- **Negative Input**: All methods except the iterative yield version raise a `ValueError` for negative inputs.\n- **Large Input**: Binet's formula and matrix exponentiation have limitations for very large inputs due to floating-point precision and time complexity, respectively.\n\n**Performance Bottlenecks**:\n- **Recursion**: High stack usage and inefficiency, leading to stack overflow for large \\( n \\).\n- **Memoization**: Requires additional memory to"
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results0.jsonl"
}