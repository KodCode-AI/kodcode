{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000055_I",
  "question": "You are given a 2x2 grid, and you are required to calculate the number of unique paths from the top-left corner to the bottom-right corner, where you can only move right or down. The general solution extends to an \\(n \\times n\\) grid.\n\nWrite a Python function `calculate_paths(n: int) -> int` that returns the number of unique paths in an \\(n \\times n\\) grid.\n\n**Function Signature**: `def calculate_paths(n: int) -> int:`\n\n**Input**\n- `n` (1 <= n <= 100): An integer representing the size of the grid.\n\n**Output**\n- An integer representing the number of unique paths in the \\(n \\times n\\) grid.\n\n**Constraints**\n- The input `n` will be a positive integer.\n\n**Example**\n```python\nprint(calculate_paths(2))  # Output: 6\nprint(calculate_paths(20))  # Output: 137846528820\n```\n\n**Note**\n- Use combinatorial mathematics to solve the problem efficiently.\n- Ensure your function handles edge cases correctly.",
  "solution": "def calculate_paths(n: int) -> int:\n    \"\"\"\n    Returns the number of unique paths in an n x n grid.\n    \"\"\"\n    from math import comb\n    return comb(2 * n, n)",
  "test_code": "import pytest\n\ndef test_calculate_paths():\n    assert calculate_paths(2) == 6\n    assert calculate_paths(3) == 20\n    assert calculate_paths(1) == 2\n    assert calculate_paths(20) == 137846528820\n\ndef test_calculate_paths_edge_cases():\n    assert calculate_paths(0) == 1  # Edge case: 0x0 grid\n    assert calculate_paths(1) == 2  # Edge case: 1x1 grid",
  "test_info": [
    {
      "function_name": "calculate_paths",
      "parameter_list": "(n)",
      "function_declaration": "def calculate_paths(n):",
      "docstring": "Returns the number of unique paths in an n x n grid."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I have to write a Python function called calculate_paths that takes an integer n and returns the number of unique paths from the top-left to the bottom-right corner of an n x n grid. The movement is only allowed right or down. Hmm.\n\nWait, wait. Wait, the problem says n x n grid. So for a 2x2 grid, the output is 6. How does that work?\n\nLet me think about smaller grids. Maybe I should visualize.\n\nFor a 1x1 grid, that's just a single cell. So the number of paths is 1, right? Because you're already at the destination.\n\nFor a 2x2 grid. Let's see: you can move right then down then down? Or no, because the grid is 2x2, meaning it's 2 rows and 2 columns. So the starting point is (0,0), and end is (1,1). Because moving right takes you from (0,0) to (0,1), then down to (1,1). Or moving down then right.\n\nWait, actually, to go from top-left to bottom-right in a 2x2 grid, the number of steps would be 2 right and 2 down? Or wait no. Because if the grid has n+1 points, like for n=2 the grid has 3 points along each side. Oh right, maybe that's a confusion point.\n\nAh, right. So for a grid that is n squares on each side, you have (n+1) horizontal lines. So moving from the top-left to the bottom-right requires moving right n times and down n times, in any order. Oh, wait, yes. Because each move takes you across a grid line. So for n=2, the grid is 2x2 squares, which is 3x3 points. So to move from (0,0) to (2,2), you need 2 right and 2 down moves, but wait no, that would only be 4 steps. Wait, wait, no.\n\nWait, no. Moving from the top-left (0,0) to the bottom-right (2,2) requires moving right twice (to go from x=0 to x=2) and down twice (to go from y=0 to y=2). So in total, 4 moves, 2 in each direction. So the number of unique paths is the number of ways to arrange these moves. Which is the combination C(4, 2) = 6, which matches the sample input where calculate_paths(2) returns 6.\n\nSo in general, the number of moves for an n x n grid is  make a total of 2n moves, with n rights and n downs. So the formula would be (2n choose n).\n\nWait, but wait\u2014the grid is n x n, which as in, for example, the sample input says 2x2 grid, which they consider as returning 6. Which is 4 choose 2, yes. So 2n choose n when the grid is n x n.\n\nSo for a general solution, for n steps right and n steps down, the number of unique paths is (2n)!/( n! n! ) which is the combination of 2n things taken n at a time.\n\nSo the formula is (2n choose n), which can be computed as binomial(2n, n).\n\nSo to compute this in Python, we need to calculate the binomial coefficient for (2n, n). But how?\n\nHmm. But for n up to 100, 2n can be up to 200. So (200 choose 100) is a very big number, but Python can handle big integers, so we don't have to worry about overflow.\n\nSo the problem reduces to computing the binomial coefficient C(2n, n), which is the number of ways to choose n steps (either right or down) out of 2n total steps.\n\nHow to calculate this in Python?\n\nWell, one approach is to use the math.comb function, which gives the binomial coefficient. Because math.comb(2n, n) would directly give us the desired value.\n\nWait, was math.comb added in Python 3.10? I think so. But if that's the case, then it's okay to use it because the problem likely expects it.\n\nBut what if for older versions? Or maybe for n up to 100, maybe precalculating or using a dynamic programming approach is possible. But in any case, the most efficient way is to compute the combination.\n\nSo the plan is: compute the binomial coefficient C(2n, n).\n\nTesting the example:\n\nFor n=2, 2n=4. So C(4,2)=6. Which matches the sample.\n\nAnother sample: when n=20, output is 137846528820. Let's see: math.comb(40,20) is 137846528820, correct.\n\nSo yes.\n\nSo the function can be as simple as importing math.comb(2n, n).\n\nSo the code would be:\n\nimport math\n\ndef calculate_paths(n: int) -> int:\n    return math.comb(2 * n, n)\n\nWait, that's it?\n\nBut wait\u2014the note says to use combinatorial mathematics. So yes, this solves it.\n\nNow, test with the sample:\n\nprint(calculate_paths(2)) should print 6. Correct.\n\nPrint(calculate_paths(20)) gives that big number. Correct.\n\nOther test cases:\n\nn=1: steps 2, so C(2,1) is 2. But wait, the grid is 1x1\u2014so how?\n\nWait, no, wait. For a 1x1 grid, how many paths? Let's see: to go from start to the end in a 1x1 grid. Because it's one square, so you have to move right once and down once. So steps are R and D, in any order: 2 steps, which is 2 choose 1 which is 2. So the function would return 2 for n=1.\n\nYes.\n\nSo the code should handle all these cases.\n\nTherefore, the function is correct.\n</think>\n\nTo solve this problem, we need to determine the number of unique paths from the top-left corner to the bottom-right corner of an \\(n \\times n\\) grid, where movement is restricted to only right or down directions. This problem can be efficiently solved using combinatorial mathematics.\n\n### Approach\nThe problem can be approached by recognizing that each path from the top-left to the bottom-right corner consists of exactly \\(2n\\) moves: \\(n\\) moves to the right and \\(n\\) moves down. The number of unique paths is therefore the number of ways to choose \\(n\\) right moves (or equivalently \\(n\\) down moves) out of \\(2n\\) total moves. This is a combinatorial problem that can be solved using the binomial coefficient, which calculates the number of ways to choose \\(k\\) successes in \\(n\\) trials without regard to order.\n\nThe binomial coefficient \\(C(2n, n)\\) gives the number of ways to arrange \\(n\\) right moves and \\(n\\) down moves, which directly gives the number of unique paths in the grid. This value can be efficiently computed using Python's `math.comb` function.\n\n### Solution Code\n```python\nimport math\n\ndef calculate_paths(n: int) -> int:\n    return math.comb(2 * n, n)\n```\n\n### Explanation\n1. **Problem Analysis**: The task is to find the number of paths in an \\(n \\times n\\) grid where movement is restricted to right and down directions. Each path requires exactly \\(n\\) right moves and \\(n\\) down moves.\n2. **Combinatorial Insight**: The problem reduces to finding the number of ways to arrange \\(n\\) right moves and \\(n\\) down moves, which is given by the binomial coefficient \\(C(2n, n)\\).\n3. **Efficient Calculation**: Using Python's `math.comb` function allows us to compute the binomial coefficient efficiently, even for larger values of \\(n\\) up to 100.\n\nThis approach ensures that the solution is both optimal and efficient, leveraging mathematical properties to avoid unnecessary computations.",
  "r1_solution": "import math\n\ndef calculate_paths(n: int) -> int:\n    return math.comb(2 * n, n)",
  "metadata": {
    "prompt_id": "00000055",
    "row_id": 55,
    "seed_ids": [
      474
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}