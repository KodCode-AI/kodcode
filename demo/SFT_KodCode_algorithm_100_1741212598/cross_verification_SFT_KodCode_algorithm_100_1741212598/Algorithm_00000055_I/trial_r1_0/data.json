{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000055_I",
  "question": "You are given a 2x2 grid, and you are required to calculate the number of unique paths from the top-left corner to the bottom-right corner, where you can only move right or down. The general solution extends to an \\(n \\times n\\) grid.\n\nWrite a Python function `calculate_paths(n: int) -> int` that returns the number of unique paths in an \\(n \\times n\\) grid.\n\n**Function Signature**: `def calculate_paths(n: int) -> int:`\n\n**Input**\n- `n` (1 <= n <= 100): An integer representing the size of the grid.\n\n**Output**\n- An integer representing the number of unique paths in the \\(n \\times n\\) grid.\n\n**Constraints**\n- The input `n` will be a positive integer.\n\n**Example**\n```python\nprint(calculate_paths(2))  # Output: 6\nprint(calculate_paths(20))  # Output: 137846528820\n```\n\n**Note**\n- Use combinatorial mathematics to solve the problem efficiently.\n- Ensure your function handles edge cases correctly.",
  "solution": "def calculate_paths(n: int) -> int:\n    \"\"\"\n    Returns the number of unique paths in an n x n grid.\n    \"\"\"\n    from math import comb\n    return comb(2 * n, n)",
  "test_code": "import pytest\n\ndef test_calculate_paths():\n    assert calculate_paths(2) == 6\n    assert calculate_paths(3) == 20\n    assert calculate_paths(1) == 2\n    assert calculate_paths(20) == 137846528820\n\ndef test_calculate_paths_edge_cases():\n    assert calculate_paths(0) == 1  # Edge case: 0x0 grid\n    assert calculate_paths(1) == 2  # Edge case: 1x1 grid",
  "test_info": [
    {
      "function_name": "calculate_paths",
      "parameter_list": "(n)",
      "function_declaration": "def calculate_paths(n):",
      "docstring": "Returns the number of unique paths in an n x n grid."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, so I need to write a Python function called calculate_paths that takes an integer n and returns the number of unique paths in an n x n grid. The movement is only allowed right or down. Hmm.\n\nWait, I remember that this is a classic combinatorial problem. Like, the number of paths from the top-left to the bottom-right corner of a grid. But wait, wait, let's think.\n\nSo for a 2x2 grid, like the example, the answer is 6. Hmm. Oh wait, wait no, wait. I might be mixing up something. Or maybe wait, no: in the example, calculate_paths(2) returns 6. But wait, I feel like a 2x2 grid should have 2 choices each time, right?\n\nWait, no, let's think. Wait, maybe it's because in a grid that's represented by 2x2 squares, the number of steps you take is more. Or perhaps I'm misunderstanding the grid's size.\n\nWait, in a standard grid path problem, moving from (0,0) to (n,n), right? Because the 2x2 grid would require steps: from the top-left corner, to go to the bottom-right, you have to move right once and down once each in 2 steps, perhaps. Or maybe I'm getting the grid size wrong.\n\nWait, let's clarify the problem. For an n x n grid, meaning that there are n rows and n columns. So the number of grid lines is n+1 in each direction, right? So for example, a 2x2 grid, actually has 3x3 intersections. So to move from top-left to bottom-right, which is (0,0) to (2,2) if the grid is 2x2.\n\nSo in that case, you have to take 2 right steps and 2 down steps, in any order. The number of unique paths is the combination of 4 steps taken 2 at a time for right (or down). So that would be C(4, 2) = 6, which matches the example.\n\nSo for a general n, the total steps required are 2n steps: n right and n down. So the number of unique paths is (2n choose n) or 2n!/(n!n!), yeah.\n\nSo the formula for calculate_paths(n) is (2n)!/(n! * n!). Oh right, because we have 2n steps, where n are right and n are down. So the number of ways to arrange the steps is the combination of 2n things taken n at a time.\n\nSo the function needs to compute binomial(2n, n). Or also known as the central binomial coefficient.\n\nBut how to calculate this efficiently in Python, especially for n up to 100. Because 2*100 is 200, factorial of 200 is a very big number. But even then, in Python, handling large integers is manageable.\n\nBut computing factorials for 200 is possible but perhaps could be optimized using a multiplicative approach, or using combatorial functions from math libraries.\n\nWait, but for n=0, it's 1, but that's not part of the input constraints since n is at least 1.\n\nWait, but the constraints say 1<=n<=100.\n\nWait, so in code, I could compute this using the math.comb function in Python 3.10+, because math.comb(n, k) returns the number of ways to choose k items from n without repetition.\n\nWait, for n=2, it would be math.comb(4, 2) = 6. Which it does. And for n=20, the result is 137846528820, which matches the example.\n\nSo the function can be simplified to math.comb(2n, n).\n\nWait, so the plan is: the function calculate_paths(n) returns C(2n, n).\n\nSo the code.\n\nBut wait, what about when n is 0? But in constraints, it's given that n is at least 1, so 0 is not an input.\n\nSo let's write code that first calculates 2n, and then computes the combination of 2n choose n.\n\nLet's see: for n=1, it's C(2,1)=2, which is correct (right then down, or down then right).\n\nSo the function can be:\n\nimport math\n\ndef calculate_paths(n: int) -> int:\n    return math.comb(2 * n, n)\n\nWait, but wait, which version of Python is this for? The problem states that I should write the Python function. So assuming that I can use math.comb, which is available from Python 3.10 onwards.\n\nBut what if the user is using an older version? Hmm. The problem doesn't specify, but perhaps implementing it with a helper function that calculates the combination, but that's probably overcomplicating.\n\nBut given that math.comb is the correct and efficient way, and that the examples are correct with this approach, I'll proceed.\n\nWait, but let me think again about the grid size. The problem says that for a 2x2 grid, the result is 6, which is C(4,2) as 4 choose 2 is indeed 6, so that's correct.\n\nYes, so the function can indeed be written as returning math.comb(2*n, n).\n\nSo to write the function, I need to import math and return the combination.\n\nSo that's the approach.\n</think>\n\nTo solve this problem, we need to determine the number of unique paths from the top-left corner to the bottom-right corner of an \\(n \\times n\\) grid, where movement is restricted to only right or down directions. \n\n### Approach\nThe problem can be efficiently solved using combinatorial mathematics. The key insight is recognizing that each unique path from the top-left to the bottom-right corner of an \\(n \\times n\\) grid consists of exactly \\(2n\\) moves: \\(n\\) right moves and \\(n\\) down moves. The number of unique paths corresponds to the number of ways to arrange these moves, which can be computed using the binomial coefficient.\n\nThe binomial coefficient, also known as \"n choose k\", is given by the formula:\n\\[\nC(n, k) = \\frac{n!}{k!(n-k)!}\n\\]\nIn our problem, we need to compute the binomial coefficient \\(C(2n, n)\\), which represents the number of ways to choose \\(n\\) right moves (or equivalently \\(n\\) down moves) out of \\(2n\\) total moves.\n\n### Solution Code\n```python\nimport math\n\ndef calculate_paths(n: int) -> int:\n    return math.comb(2 * n, n)\n```\n\n### Explanation\n1. **Combinatorial Insight**: The problem is reduced to finding the number of ways to arrange \\(n\\) right moves and \\(n\\) down moves, which is a combinatorial problem.\n2. **Binomial Coefficient**: The solution uses the binomial coefficient \\(C(2n, n)\\) which efficiently calculates the number of unique paths without explicitly enumerating all possible paths.\n3. **Efficiency**: Using Python's `math.comb` function ensures that we compute the result efficiently, even for larger values of \\(n\\) up to 100, by leveraging optimized underlying routines for factorial and combination calculations.\n\nThis approach ensures that we handle up to \\(n = 100\\) efficiently, providing the correct result as a large integer which Python can manage seamlessly.",
  "r1_solution": "import math\n\ndef calculate_paths(n: int) -> int:\n    return math.comb(2 * n, n)",
  "metadata": {
    "prompt_id": "00000055",
    "row_id": 55,
    "seed_ids": [
      474
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results0.jsonl"
}