{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000055_I",
  "question": "You are given a 2x2 grid, and you are required to calculate the number of unique paths from the top-left corner to the bottom-right corner, where you can only move right or down. The general solution extends to an \\(n \\times n\\) grid.\n\nWrite a Python function `calculate_paths(n: int) -> int` that returns the number of unique paths in an \\(n \\times n\\) grid.\n\n**Function Signature**: `def calculate_paths(n: int) -> int:`\n\n**Input**\n- `n` (1 <= n <= 100): An integer representing the size of the grid.\n\n**Output**\n- An integer representing the number of unique paths in the \\(n \\times n\\) grid.\n\n**Constraints**\n- The input `n` will be a positive integer.\n\n**Example**\n```python\nprint(calculate_paths(2))  # Output: 6\nprint(calculate_paths(20))  # Output: 137846528820\n```\n\n**Note**\n- Use combinatorial mathematics to solve the problem efficiently.\n- Ensure your function handles edge cases correctly.",
  "solution": "def calculate_paths(n: int) -> int:\n    \"\"\"\n    Returns the number of unique paths in an n x n grid.\n    \"\"\"\n    from math import comb\n    return comb(2 * n, n)",
  "test_code": "import pytest\n\ndef test_calculate_paths():\n    assert calculate_paths(2) == 6\n    assert calculate_paths(3) == 20\n    assert calculate_paths(1) == 2\n    assert calculate_paths(20) == 137846528820\n\ndef test_calculate_paths_edge_cases():\n    assert calculate_paths(0) == 1  # Edge case: 0x0 grid\n    assert calculate_paths(1) == 2  # Edge case: 1x1 grid",
  "test_info": [
    {
      "function_name": "calculate_paths",
      "parameter_list": "(n)",
      "function_declaration": "def calculate_paths(n):",
      "docstring": "Returns the number of unique paths in an n x n grid."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function called calculate_paths that takes an integer n and returns the number of unique paths in an n x n grid. The movement is only allowed to the right or down. Hmm, I remember this is a classic combinatorics problem.\n\nSo, for a 2x2 grid, the example says there are 6 paths. Wait, wait\u2014no, wait. Oh wait no, wait\u2014 wait, let me think again. In a 2x2 grid, how do you move from top-left to bottom-right? Oh right, you have to make exactly 2 right moves and 2 down moves in some order.\n\nWait, what's the correct way to model this? For a grid of size n x n, the path requires (n) right moves and (n) down moves, right? Because for example, in a 2x2 grid, moving from (0,0) to (2,2) requires two rights and two downs. So the total number of steps is 2n, with n rights and n downs.\n\nSo the problem reduces to finding the number of distinct permutations of these steps. That number is given by the combination formula C(2n, n), which is (2n choose n).\n\nWait, let's double-check for the sample provided. For n=2, calculate_paths(2) should return 6. Let's see: C(4,2) = 6. Yes, that's correct.\n\nAnother sample is n=20, which outputs 137846528820. That's 40 choose 20, right? Yes.\n\nSo the general formula is (2n)! / (n! * n!). That makes sense.\n\nBut calculating factorials for large n could be computationally intensive. However, since n is up to 100, 2n is 200, which is manageable.\n\nWait, but calculating 200! might result in very large numbers, but Python can handle big integers, so that's not a problem.\n\nSo, the plan is to compute (2n choose n) and return it as the number of paths.\n\nNow, how to compute this in Python efficiently.\n\nPossible approach:\n\n1. Use the math.comb function if available. Oh right, because in Python 3.10+, math.comb(n, k) calculates the number of ways to choose k items from n without regard to the order. So for n=2, math.comb(4,2) is 6.\n\nWait: but when n is given, like for the 2x2 grid, the number should be (2+n) choose n, wait no. Wait wait: Wait, no, in a 2x2 grid, the path requires moving right 2 times and down 2 times. So the formula is (2n choose n), in this case 4 choose 2 is 6. So when n is the parameter, it's (2n choose n).\n\nSo the function is (2n choose n).\n\nSo the approach is to compute the binomial coefficient (2n choose n).\n\nSo the steps are:\n\n1. Take the input n as a parameter.\n\n2. Compute 2n and n.\n\n3. Calculate the binomial coefficient C(2n, n).\n\n4. Return that value as an integer.\n\nTesting with sample inputs:\n\nn=2: 4 choose 2 =6.\n\nn=20: 40 choose 20 is 137846528820. As given.\n\nSo that should work.\n\nNow, handling the calculation: In Python, for n=100, 200 choose 100 is a very big number, but Python can handle big integers.\n\nThe question is, how to compute this binomial coefficient.\n\nI can use the math.comb function, which is straightforward.\n\nLooking up the Python math.comb function: It was introduced in Python 3.10, which should be compatible for most purposes now.\n\nSo the function can be written as:\n\nCompute math.comb(2n, n).\n\nWait, but in the 2x2 example, when n=2, math.comb(4, 2) is 6. So yes.\n\nSo putting it all together:\n\nImport math\n\nDefine calculate_paths(n: int) -> int:\n\nreturn math.comb(2n, n)\n\nWait, but in Python, the multiplication operator is *, not n. So it's (2 * n).\n\nWait wait wait no: in code, it's 2*n, right? So inside math.comb, it's (2*n, n).\n\nSo the code would be:\n\nimport math\n\ndef calculate_paths(n: int) -> int:\n    return math.comb(2 * n, n)\n\nHmm, but perhaps for n=1? Let's test. For a 1x1 grid, you need to move right once and down once, so two steps, one right, one down. The number of paths is 2 choose 1, which is 2. So math.comb(2,1)=2. That's correct.\n\nAnother test case: n=1 returns 2.\n\nWait, the sample has n=2 returning 6.\n\nYes.\n\nSo this should cover all cases.\n\nBut let's think about possible alternatives. What if the function needs to handle n=0, but the input constraints say n is a positive integer, so n=0 is not allowed. So no problem.\n\nSo the function is straightforward.\n\nWait, except that for very large n, calculating 2n choose n may take time. But for n=100, 200 choose100 is manageable for Python.\n\nThus, this approach should be efficient.\n\nSo I'll proceed to code it accordingly.\n</think>\n\nTo solve this problem, we need to calculate the number of unique paths from the top-left corner to the bottom-right corner of an \\(n \\times n\\) grid, where movement is restricted to only right or down directions.\n\n### Approach\nThe problem can be efficiently solved using combinatorial mathematics. The key insight is that any path from the top-left to the bottom-right corner of an \\(n \\times n\\) grid requires exactly \\(n\\) right moves and \\(n\\) down moves, totaling \\(2n\\) moves. The number of unique paths is then equivalent to the number of ways to choose \\(n\\) right moves out of \\(2n\\) total moves, which is given by the binomial coefficient \\(C(2n, n)\\). This can be computed using Python's `math.comb` function, which efficiently calculates the binomial coefficient.\n\n### Solution Code\n```python\nimport math\n\ndef calculate_paths(n: int) -> int:\n    return math.comb(2 * n, n)\n```\n\n### Explanation\n1. **Problem Analysis**: We need to find the number of unique paths in an \\(n \\times n\\) grid where movement is restricted to right or down. This reduces to finding the number of ways to arrange \\(n\\) right moves and \\(n\\) down moves.\n2. **Combinatorial Insight**: The number of unique paths is given by the binomial coefficient \\(C(2n, n)\\), which represents the number of ways to choose \\(n\\) positions (for right moves) out of \\(2n\\) total positions.\n3. **Efficient Calculation**: The `math.comb` function is used to compute the binomial coefficient efficiently, even for large values of \\(n\\), up to 100, ensuring the solution is both optimal and easy to implement.\n\nThis approach ensures that we handle large values efficiently and correctly, providing the correct number of paths for any given \\(n\\).",
  "r1_solution": "import math\n\ndef calculate_paths(n: int) -> int:\n    return math.comb(2 * n, n)",
  "metadata": {
    "prompt_id": "00000055",
    "row_id": 55,
    "seed_ids": [
      474
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results2.jsonl"
}