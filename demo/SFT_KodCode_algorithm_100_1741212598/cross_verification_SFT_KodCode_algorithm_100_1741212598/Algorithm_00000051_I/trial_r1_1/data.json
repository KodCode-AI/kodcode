{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000051_I",
  "question": "### Scenario\nYou are working on a project where you need to efficiently traverse a large Binary Search Tree (BST) and output the values in sorted order. Given the provided code snippet, you have been tasked with implementing an enhanced version of the inorder traversal.\n\n### Requirements\n1. **Function Specification**:\n    - Implement a function `enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]` that performs an inorder traversal on a given BST.\n    - The function should return a list of integers representing the values of the nodes in sorted order.\n2. **Input**:\n    - `root: BinaryTreeNode | None`: The root node of a BST. If `None`, the function should return an empty list.\n3. **Output**:\n    - A list of integers representing the values of the nodes in sorted order.\n4. **Constraints**:\n    - The maximum number of nodes in the tree is \\(10^5\\).\n    - The value of each node is an integer within the range \\([-10^9, 10^9]\\).\n5. **Optimization**:\n    - Use an iterative approach to avoid potential stack overflow issues with deep trees.\n    - Ensure the solution is efficient and handles edge cases properly.\n\n### Example\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\n# Function to test the solution\ndef check_solution(func):\n    tree = make_tree()\n    result = func(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n    print(\"Solution is correct.\")\n\n# Test the function\ncheck_solution(enhanced_inorder_traversal)\n```\n\n### Note\nEnsure your implementation is efficient and handles edge cases such as an empty tree or very deep trees. Use an iterative approach to avoid stack overflow issues.",
  "solution": "from typing import List, Optional\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result",
  "test_code": "import pytest\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n\ndef test_enhanced_inorder_traversal_single_node():\n    root = BinaryTreeNode(10)\n    assert enhanced_inorder_traversal(root) == [10]\n\ndef test_enhanced_inorder_traversal_empty_tree():\n    assert enhanced_inorder_traversal(None) == []\n\ndef test_enhanced_inorder_traversal_balanced_tree():\n    tree = make_tree()\n    assert enhanced_inorder_traversal(tree) == [6, 10, 14, 15, 20, 25, 60]\n\ndef test_enhanced_inorder_traversal_degenerate_tree():\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    assert enhanced_inorder_traversal(root) == [10, 15, 25]\n\ndef test_enhanced_inorder_traversal_negative_numbers():\n    root = BinaryTreeNode(-10)\n    root.left_child = BinaryTreeNode(-20)\n    root.right_child = BinaryTreeNode(-5)\n    root.left_child.left_child = BinaryTreeNode(-30)\n    root.left_child.right_child = BinaryTreeNode(-15)\n    assert enhanced_inorder_traversal(root) == [-30, -20, -15, -10, -5]",
  "test_info": null,
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to implement an enhanced inorder traversal for a binary search tree. Hmm, the function is called enhanced_inorder_traversal and it takes a root node which can be None. I remember that inorder traversal visits the left subtree, then the current node, and then the right subtree. And since it's a BST, the result should be a sorted list of the node values.\n\nWait, the example given in the code shows that after making the tree, the expected output is [6,10,14,15,20,25,60]. So when the tree is built correctly, the inorder traversal gives that list. That's a good test case.\n\nThe function needs to return a list of integers. Also, if the root is None, we return an empty list.\n\nThe user mentioned that we should use an iterative approach to avoid stack overflow from deep recursion. Oh right, because if the tree is very deep, a recursive approach might hit the recursion depth limit and cause a stack overflow. So yeah, I should think iteratively.\n\nSo how does iterative inorder traversal work? I recall that it uses a stack to keep track of the nodes. Let me think: the process involves going as far left as possible, pushing nodes onto the stack until there are no more left children. Then pop the top node, add it to the result, and then move to the right child, repeating the process.\n\nWait, let me outline the steps. The iterative method typically involves:\n\n1. Initialize a stack and a result list.\n2. Set current node to the root.\n3. While current is not null, keep pushing current to stack and move current to current's left child.\n4. When current is null, pop from stack, add to result, then set current to the popped node's right child.\n5. Repeat until stack is empty.\n\nYes, that's the standard approach.\n\nSo applying this logic to our function:\n\nFirst, handle the case where root is None. If it is, return an empty list.\n\nOtherwise, initialize stack, current = root, result = [].\n\nThen, proceed with the iterative steps.\n\nLet's think about the code structure. So in Python, the function will look like this:\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]:\n    result = []\n    stack = []\n    current = root\n    while True:\n        # Go to the leftmost child\n        while current is not None:\n            stack.append(current)\n            current = current.left_child\n        # If stack is empty, break the loop\n        if not stack:\n            break\n        # Pop from stack\n        current = stack.pop()\n        result.append(current.data)\n        # Move to right child\n        current = current.right_child\n    return result\n\nWait, does this correctly handle all cases? I think so.\n\nBut wait, what if the tree is completely empty? Well, the root is None, so the function returns empty list, which is correct.\n\nWhat about single-node trees? Then current is not None, pushed to stack. Then stack is not empty, popped, added to result. Then current is the right child, which is None, breaking the loop. So it's correct.\n\nEdge case tests: how about a tree that's a straight line (like a linked list)? For example, all left children. Like nodes 4, 3, 2, 1. Then the stack will have 4,3,2,1. Then 1 is popped, added, then right is null. So current is none. Stack is now [4,3,2]. So process continues popping and adding 4, 3, 2, etc., but wait, no. Wait, wait, in the case where the tree is like 4's left is 3, 3's left is 2, 2's left is 1. So the stack starts with 4,3,2,1. Then current becomes None. So the inner loop breaks. So stack is [4,3,2,1], stack not empty. Pop 1, add to result. current is set to 1's right, which is None. Next, the outer loop continues. Since current is None, inner loop does nothing. Pop next node: 2. Add to result. Then current is 2's right, which is None. No. Wait no: wait, after popping 1, current is set to its right (which is None). So the while current loop doesn't run. So we pop the next node from the stack, which is 2. But wait, no: when current is set to 2's right, and then loop continues.\n\nWait, maybe I should re-examine the algorithm.\n\nLet me walk through a sample case.\n\nFor the example tree, the root is 15.\n\nLet me see the traversal in steps:\n\nInitialize stack = [], current = 15.\n\nFirst, enter the while current is not None loop:\n\n- current is 15, which is not null. So append to stack (stack becomes [15]). Then current becomes 10.\n\nStack is now [15,10]. Then, current becomes 6.\n\nStack is [15,10,6]. current becomes 6's left, which is null.\n\nSo inner loop breaks. Then, check if stack is empty? No, so pop 6, add 6 to result. Then current becomes 6's right, which is null.\n\nWait, no. Wait, in the stack after popping 6, the current for the right is 6's right.\n\nWait let me correct the steps. Let me redo:\n\nInitial state: stack empty, current is 15.\n\nStep 1: current is not null, so push 15, current becomes left (10).\n\nStep 2: current is 10, push to stack, current becomes left (6).\n\nStep 3: current is 6, push to stack. current becomes 6.left_child = null.\n\nSo inner loop ends, stack has [15,10,6].\n\nNow, stack is not empty, so current = stack.pop() \u2192 6. Add 6 to result.\n\nThen, current becomes 6.right_child = null.\n\nNow, enter the outer loop again.\n\nCurrent is null, so inner loop doesn't run. Stack is now [15, 10].\n\nIs stack empty? No. So pop 10, add to result. Now result is [6,10]. current becomes 10's right, which is 14.\n\nNow, set current to 14. Enter the inner loop.\n\nNow, current is 14. Push to stack. current becomes 14's left, which is null.\n\nSo stack is [15,10,14]. current becomes null. break inner loop.\n\nPop 14, add to result. Now [6,10,14]. current is 14's right \u2192 null.\n\nSet current to null. Next iteration: stack is [15,10]. So pop 10's right? No, wait, wait:\n\nWait, I think I might be confusing the steps.\n\nWait, I'm supposed to add the current node after popping, then set current to the right child of that node.\n\nSo when current is popped (10), current.right-child is 14, which was processed when we pushed it into the inner loop.\n\nWait, maybe I'm overcomplicating.\n\nI think the algorithm correctly handles all steps, but perhaps it's better to try writing it with induction.\n\nSo the code should work.\n\nWhat about very large trees, like 1e5 nodes? Well, using an iterative approach avoids stack overflow because it doesn't rely on recursion, so the function should handle it.\n\nSo the code should be correct.\n\nNow, the BinaryTreeNode class has attributes like data, left_child, right_child. So in Python, when we access current.left_child, it's fine as long as the node is not None.\n\nWait, but in Python, you can access .left_child even if the current is None, but that would cause an error. But, in our loops, we have a check that current is not None before pushing to stack. So the stack only contains non-None nodes. So when we pop, current is a valid node, so current.left_child is safe.\n\nYes.\n\nSo in the function, the initial case where root is null returns [], that's correct.\n\nI think this should handle all cases correctly.\n</think>\n\nTo solve this problem, we need to perform an inorder traversal on a Binary Search Tree (BST) and return the node values in sorted order. The solution should be efficient and handle large trees without causing stack overflow issues.\n\n### Approach\nThe solution uses an iterative approach to perform the inorder traversal. This approach is preferable over recursion because it avoids potential stack overflow issues with deep trees. Here\u2019s a step-by-step breakdown of the approach:\n\n1. **Initialization**: Use a stack to keep track of nodes and a list to store the result.\n2. **Traversal**: Start at the root and move to the leftmost child, pushing each node onto the stack as we go.\n3. **Backtracking**: Once there are no more left children, pop nodes from the stack, add their values to the result list, and move to their right child.\n4. **Termination**: The process continues until the stack is empty, ensuring all nodes are visited in inorder sequence.\n\n### Solution Code\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]:\n    result = []\n    stack = []\n    current = root\n    \n    while True:\n        # Traverse to the leftmost node\n        while current is not None:\n            stack.append(current)\n            current = current.left_child\n        \n        # If the stack is empty, break the loop\n        if not stack:\n            break\n        \n        # Pop the node from the stack\n        current = stack.pop()\n        result.append(current.data)\n        \n        # Move to the right child\n        current = current.right_child\n    \n    return result\n```\n\n### Explanation\n- **Initialization**: We start by initializing an empty result list and an empty stack. The current node is set to the root of the BST.\n- **Leftmost Traversal**: We traverse to the leftmost node by continuously moving to the left child of the current node and pushing each node onto the stack.\n- **Stack Processing**: When there are no more left children (current becomes None), we pop nodes from the stack, add their values to the result list, and move to their right child.\n- **Termination**: The loop continues until the stack is empty, ensuring all nodes are processed and the result is a list of node values in sorted order.\n\nThis approach efficiently handles large trees by avoiding recursion and using an iterative method with a time complexity of O(n), where n is the number of nodes in the tree.",
  "r1_solution": "class BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]:\n    result = []\n    stack = []\n    current = root\n    \n    while True:\n        # Traverse to the leftmost node\n        while current is not None:\n            stack.append(current)\n            current = current.left_child\n        \n        # If the stack is empty, break the loop\n        if not stack:\n            break\n        \n        # Pop the node from the stack\n        current = stack.pop()\n        result.append(current.data)\n        \n        # Move to the right child\n        current = current.right_child\n    \n    return result",
  "metadata": {
    "prompt_id": "00000051",
    "row_id": 51,
    "seed_ids": [
      358
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}