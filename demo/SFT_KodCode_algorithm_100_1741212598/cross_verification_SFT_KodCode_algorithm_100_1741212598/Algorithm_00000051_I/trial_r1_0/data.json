{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000051_I",
  "question": "### Scenario\nYou are working on a project where you need to efficiently traverse a large Binary Search Tree (BST) and output the values in sorted order. Given the provided code snippet, you have been tasked with implementing an enhanced version of the inorder traversal.\n\n### Requirements\n1. **Function Specification**:\n    - Implement a function `enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]` that performs an inorder traversal on a given BST.\n    - The function should return a list of integers representing the values of the nodes in sorted order.\n2. **Input**:\n    - `root: BinaryTreeNode | None`: The root node of a BST. If `None`, the function should return an empty list.\n3. **Output**:\n    - A list of integers representing the values of the nodes in sorted order.\n4. **Constraints**:\n    - The maximum number of nodes in the tree is \\(10^5\\).\n    - The value of each node is an integer within the range \\([-10^9, 10^9]\\).\n5. **Optimization**:\n    - Use an iterative approach to avoid potential stack overflow issues with deep trees.\n    - Ensure the solution is efficient and handles edge cases properly.\n\n### Example\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\n# Function to test the solution\ndef check_solution(func):\n    tree = make_tree()\n    result = func(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n    print(\"Solution is correct.\")\n\n# Test the function\ncheck_solution(enhanced_inorder_traversal)\n```\n\n### Note\nEnsure your implementation is efficient and handles edge cases such as an empty tree or very deep trees. Use an iterative approach to avoid stack overflow issues.",
  "solution": "from typing import List, Optional\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result",
  "test_code": "import pytest\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n\ndef test_enhanced_inorder_traversal_single_node():\n    root = BinaryTreeNode(10)\n    assert enhanced_inorder_traversal(root) == [10]\n\ndef test_enhanced_inorder_traversal_empty_tree():\n    assert enhanced_inorder_traversal(None) == []\n\ndef test_enhanced_inorder_traversal_balanced_tree():\n    tree = make_tree()\n    assert enhanced_inorder_traversal(tree) == [6, 10, 14, 15, 20, 25, 60]\n\ndef test_enhanced_inorder_traversal_degenerate_tree():\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    assert enhanced_inorder_traversal(root) == [10, 15, 25]\n\ndef test_enhanced_inorder_traversal_negative_numbers():\n    root = BinaryTreeNode(-10)\n    root.left_child = BinaryTreeNode(-20)\n    root.right_child = BinaryTreeNode(-5)\n    root.left_child.left_child = BinaryTreeNode(-30)\n    root.left_child.right_child = BinaryTreeNode(-15)\n    assert enhanced_inorder_traversal(root) == [-30, -20, -15, -10, -5]",
  "test_info": null,
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, so I need to implement an enhanced inorder traversal for a binary search tree. The goal is to output the nodes' values in sorted order, which makes sense because BSTs are structured so that in-order traversal gives elements in order. \n\nFirst, I should think about the function specifications. The function is called enhanced_inorder_traversal and takes a root node as input, which can be None. It returns a list of integers. Oh right, because the tree might be empty, so the output could be an empty list.\n\nThe constraints say that the tree can have up to 1e5 nodes, which is a hundred thousand. That's a lot, so I need to make sure my solution is efficient. Oh, wait, recursion might hit stack overflow for very deep trees. Python has a recursion depth limit, and for 1e5 nodes, recursive traversal would definitely hit that. So, the note says to use an iterative approach. Right, I must avoid recursion and go with a stack-based or some other iterative method.\n\nIn-order traversal means left, root, right. So for each node, I process the left subtree, then the node itself, then the right subtree.\n\nAn iterative approach to in-order traversal usually uses a stack. The standard method is to traverse all the way to the left, pushing nodes onto the stack along the way. Then, pop the top node, add it to the result, then move to its right child, and repeat the process.\n\nBut wait, sometimes people get this algorithm slightly wrong. Let me think about how to set it up.\n\nHere's how it goes:\n\n1. Initialize an empty stack.\n2. Initialize a result list.\n3. Initialize a current pointer as the root.\n\nThen, while the current is not null or the stack is not empty:\n\n4. While current is not null (meaning we're moving to the left as much as possible), push each node onto the stack and move to the left child.\n5. Once we hit a null current, pop a node from the stack, add it to the result.\n6. Then, set current to the popped node's right child.\n\nYes, that's the way. So applying this strategy should correctly give an in-order traversal.\n\nBut wait, in Python, popping from a stack is done with pop() which by default pops the last element, so it's correct because we process from left to right.\n\nNow, how do I translate this into code.\n\nThe function will take the root as a parameter. First, handle if root is None: return empty list.\n\nElse, create a stack, a result list. Current is root.\n\nWait, better to handle with stack correctly. Wait, I think the step-wise processing is right.\n\nLet's write some pseudocode.\n\nInitialize stack as empty, result as empty.\ncurrent = root\n\nwhile True:\n\n    While current is not None:\n        push current to stack\n        current = current.left_child\n\n    if stack is empty:\n        break\n\n    current = stack.pop()\n    result.append(current.data)\n\n    current = current.right_child\n\nWait, but in the code, the while loop is while current is not None. So for the leftmost child, it keeps pushing all lefts onto the stack. Then, when it can't go left anymore (current is None), pop the rightmost node (since we added lefts as we went left). Then, append that to result. Then, set current to the right child. But then, again, if current is not None, we enter the inner while loop again, pushing nodes and going left.\n\nThis should correctly process all nodes in in-order.\n\nWait for example, let's take the sample tree.\n\nSample tree during in-order traversal:\n\nFor root=15, left child is 10, right is25.\n\nGoing to 10, left is 6, right 14. Then 6 is a left, no children.\n\nLet's see the stack operations:\n\ncurrent is 15. Push 15. current becomes 15's left, 10. Push 10. current becomes 6. Push 6. current becomes 6's left, which is None. So now, inner loop stops. Stack is [15,10,6].\n\nPop 6, add 6 to result. Then set current to 6's right, which is None. So current is None. Next, in the while True loop:\n\nif stack is empty? Well, after pop, stack has [15,10]. Not empty. So we go into the inner loop? Wait, no.\n\nWait, let's get this right.\n\nAfter popping 6, current is set to right (null). Then, in the next iteration of the while True loop, check while current is not null, but current is null, so that inner loop doesn't run. Then, we pop the next node from the stack, which is 10. Append 10 to result. Then set current to 10's right, which is 14.\n\nNow, the stack is [15], result is [6,10]. Now, current is 14, which is not null. Push 14. current is set to left of 14, which is null. So inner loop stops. Pop 14, add to result. Then, set current to its right, which may be null, if 14 is a leaf. So current is null.\n\nThen in the while True loop, check if current is not null (no). So stack is popped next, which is 15.\n\nSo, pop 15, add, current becomes 15's right, 25.\n\nAgain, push 25? Let's see: current is 25, enter inner loop. push 25, current is 20 (which is 25's left, perhaps). Then push 20. Its left is, say, 20 has a left? No, in the sample 20 is the left of 25. Wait, 25's left is 20. 20's left is none or another node?\n\nLooking back at the make_tree function:\n\nRoot 15:\n\nleft_child 10:\n\nleft_child 6, right_child 14.\n\nright_child 25:\n\nleft_child 20, right_child 60.\n\n20's left is null? Or in sample, 20 has any children? Let me check make_tree function:\n\nYes, 25's left is 20, right is 60.\n\n20's left is not set, I think. Similarly, 20's right?\n\nSo when current is 20, after being added, current is set to left_child (None). So the inner loop stops, pop 20, add to result, set current to 20's right. Which is None.\n\nThen, in the outer loop, pop next which is 25.\n\nProcessing 25, then checking its right.\n\nSo, the result after all pops would be [6,10,14,15,20,25,60].\n\nWhich is the expected output.\n\nSo the algorithm seems correct.\n\nNow, what about edge cases.\n\nTest case 1: empty tree. So root is None. The function returns empty list.\n\nTest case 2: a tree with one node. Returns a list with that node's value.\n\nTest case 3: a tree that is entirely a left chain, e.g., each node only has a left child. The stack will push all left nodes, then pop them in reverse order, appends each. Wait, the traversal would visit all the leftmost nodes in the correct order.\n\nWait, no. Let's think about a tree like 5 -> 4 ->3 -> 2 ->1.\n\nIn the in-order traversal, it's 1,2,3,4,5.\n\nWait, no. Wait, in in-order traversal, that's left, root, right. So for this tree, which is a right-skewed tree (if the left children are all the way down), the in-order would be left to right, so the traversal would be 1,2,3,4,5.\n\nWait no. Because 5 is the root, 5 -> left is 4, 4-> left is 3, etc. So in in-order traversal:\n\nWe first process 5's left all the way to 1, then 1, then go up to 2, 3, 4, 5.\n\nWait no, no. Let's see, from 5:\n\nprocess left subtree of 5: 4's entire inorder.\n\nWhich is processing left subtree of 4: 3's entire inorder.\n\nAnd so on until 1, which has no left nor right.\n\nSo in the traversal:\n\nleft subtree of 5 (4,3,2,1) is entirely processed (in their left, then root, then right). Wait, 1 is a leaf. It has no children. So processing inorder for 1 would just return [1]. Then, processing 2's left subtree is 1's in-order. So 2's is [1], then 2's value, then its right (null). Then 3's left is [1,2], then 3, then right (4). Wait, wait this is getting complicated.\n\nAlternatively, for the tree 5's left is 4, 4's left is3, 3's left is 2, 2's left is1. All nodes have no right children.\n\nIn-order traversal would visit all the left nodes and then the root, so the order is 1,2,3,4,5.\n\nSo our algorithm should correctly process that.\n\nLet's see how the iterative approach handles this.\n\nProcessing the root, 5:\n\ncurrent is 5. Push 5. Then current = left (4).\n\nPush 4, current =3, push... until push 1, current is None.\n\nSo the stack is [5,4,3,2,1].\n\nPop 1, add to result. current set to right. which is None.\n\nThen pop 2, because current is None, and stack is not empty, so next iteration. No. Wait, no.\n\nWait, the code step is:\n\nAfter popping 1:\n\ncurrent is set to 1's right, which is None.\n\nThen the outer while True loop checks if the stack is not empty.\n\nWait, the stack is [5,4,3,2].\n\nThis is because after popping 1, the stack is [5,4,3,2]. Then, in the next step, because current is None, the inner while loop is skipped.\n\nBut the next part is, because after we popped, current is set to None, so the outer loop's while True goes:\n\nCheck if current is not None or stack is not empty? No, but wait, the outer loop just is a 'while True' which is broken only when the stack is empty.\n\nWait, no. The code's structure is:\n\nwhile True:\n\n    while current is not None:\n        push to stack\n        current = current.left\n\n    if stack is empty:\n        break\n\n    current = stack.pop()\n    add to result\n    current = current.right\n\nThen, the loop continues.\n\nSo after processing 1 (popping from stack and appending to result), current is set to 1's right (None). Then, the stack is not empty ([5,4,3,2]), so in the next step, the code pops the next node, which is 2.\n\nWait wait, let's step through:\n\nAfter popping 1, stack is [5,4,3,2]. current is 1's right (None). Then, the outer loop runs:\n\n- Inner loop: current is None, so no pushing.\n- Stack is not empty, do we proceed? Because stack is not empty, the code checks, but actually, whether stack is empty is in the condition to break, so in this case, it's not empty, so the code continues.\n\nWait, no. Let me rewrite the exact code steps.\n\nAfter processing 1:\n\ncurrent is None.\n\nThen, the next iteration of the while True:\n\ncurrent is None.\n\nSo the inner loop doesn't run.\n\nThen, check if stack is empty. The stack is not empty (has 5,4,3,2). So, not empty, so code proceeds.\n\nThen, current is popped from stack: which is 2.\n\nresult becomes [1, 2]\n\ncurrent = 2's right (None).\n\nThen, the loop continues. current is None, inner loop doesn't run.\n\nNext iteration, stack is popped, giving 3.\n\nAdd 3 to result.\n\ncurrent is 3's right (None).\n\nStack now has 5,4.\n\nWait, but I'm a bit confused here. Let me imagine the stack after all the pushing and popping.\n\nWait, wait. The stack is a list, so when we push to it, we append. So when 1 is processed, before that, all the left nodes are pushed.\n\nInitially, when we process the tree:\n\n- push 5,4,3,2,1.\n\nThen, pop 1, and set current to 1.right (None). So stack is [5,4,3,2].\n\nNext, since current is None, no more pushing.\n\nBut we pop 2 from stack:\n\nresult appends 2.\n\ncurrent becomes 2's right. Let's see, 2's right is None.\n\nThen, back to the loop. Stack is [5,4,3], and current is None. So we pop next, which is 3.\n\nresult appends 3. current is 3's right (which is 4? Wait no, 3's right? I thought the tree was 1,2,3,4,5, but actually, initially, it's left only. So 3's left is 2, 2's left is 1.\n\nWait, no. Let me clarify.\n\nThe tree structure is:\n\n5 is root.\n\nleft child is 4.\n\n4's left is 3.\n\n3's left is 2.\n\n2's left is 1.\n\nNo right children.\n\nSo in order traversal is 1,2,3,4,5.\n\nSo the stack after pushing all left of 5 would be [5,4,3,2,1]. So Y pop 1, then the stack becomes [5,4,3,2], current is None.\n\nNext iteration, since current is None and stack isn't empty, we pop 2.\n\nBut wait, no. Because current is None, the code tries to pop from stack.\n\nAh, right, because the stack isn't empty. So in the next step after popping 1, the code is:\n\nif stack is empty: break.\n\nSince the stack isn't empty, we pop 2 and add it to result.\n\nSo after 2 is added, result is [1,2].\n\ncurrent is set to 2.right, which is None.\n\nNext iteration: current is None, stack is [5,4,3].\n\nWe pop 3, add to result ([1,2,3]).\n\ncurrent is 3.right (4?), no, because in the tree 3's right is None because it's only left.\n\nWait no, in the tree, 3's left is 2. 3's right is None.\n\nSo then, current is set to None. Next iteration, current is None, pop 4.\n\nAdd 4 to result.\n\nThen current is 4's right (which is None, because 4's left is 3, and right is none).\n\nPop 4. So stack now is [5]. Then stack is not empty.\n\nAdd 4, current is None. Then loop again.\n\nPop 5, add to result.\n\ncurrent is 5's right. Which could be null as per tree, but maybe 5 has a right child? Hmm, in this specific test case, no. So current is set to null.\n\nNow, the stack is empty.\n\nSo next iteration, in the outer loop, the inner loop runs because current is null.\n\nThen, in the inner loop, since current is none, the loop doesn't add anything. Then, the code checks if the stack is empty. It is, so the outer loop breaks.\n\nThus, the result is [1,2,3,4,5], which is correct.\n\nSo the algorithm works for this case.\n\nAnother test case: a right-heavy tree.\n\nE.g., 1's right is 2, whose right is 3, etc.\n\nIn this case, the in-order traversal is 1,2,3,4,...n.\n\nWait no. Wait, in a right-heavy tree where each node's right is a bigger value. So for example:\n\nroot is 1, right is 2, right is 3, right is4, and so on.\n\nIn-order traversal would process the root's left (null), then root, then root's right.\n\nSo for 1, the in-order is [1,2,3,4,...], which is correct.\n\nLet me see how the algorithm handles this.\n\nInitially, current is 1.\n\nWe push 1 and move to its left. Which is null. So stack has [1].\n\nPop 1, add to result. current is set to 1's right, which is 2.\n\nNow, in the next outer iteration, current is 2 (not null). Push 2, then move to left (null). So stack is [1,2].\n\nPop 2, add to result. current is 2's right, which is3.\n\nLoop continues, stack now is [1]. Then, push 3, current is null.\n\nAfter popping, add 3 to result, current is 3's right 4.\n\nAgain, stack is [1]. So for each node, it's pushed, then processed.\n\nEventually, the result will be [1,2,3,4,...n], as expected.\n\nSo the code is correct.\n\nNow, other edge cases.\n\nWhat if a node has only a right child? For example:\n\nroot is 5, right is 10, which has right child 15.\n\n_root = 5, right=10, right right=15.\n\nIn-order traversal is 5,10,15.\n\nLet's see:\n\ncurrent =5.\n\npush 5, then current =5.left (null). So stack has [5]. pop and add to result.\n\ncurrent becomes 5.right=10.\n\nInner loop runs: push 10, current=10.left (null). stack is [5,10]. Pop 10, add to result. current becomes10's right=15.\n\nPush 15, current=15.left (null). stack is [5,10,15]. pop 15, add. current=15's right (null). Then, loop continues.\n\nSo result is correct.\n\nNow, the node structure: I need to make sure that the code correctly accesses left_child and right_child.\n\nWait, in the code, the BinaryTreeNode has left_child and right_child, which are of type BinaryTreeNode or None.\n\nSo in the function, when accessing nodes, I have to make sure that, for example, when current is a node, current.left_child is checked.\n\nYes.\n\nSo the code will process:\n\nInitialize stack = [], result=[].\n\ncurrent = root.\n\nif root is None, return empty.\n\nElse:\n\nenter the while True loop.\n\nWhat about if the root is None? The function returns an empty list. So that's solved.\n\nNow, for the code.\n\nIn Python.\n\nImplementing the iterative approach.\n\nSo, in the function enhanced_inorder_traversal:\n\n- Check if root is None: return []\n\n- Else:\n\n    stack = []\n    result = []\n    current = root\n\n    while True:\n\n        while current is not None:\n            stack.append(current)\n            current = current.left_child\n\n        if not stack:\n            break\n\n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n\n    return result\n\nWait, is this sufficient?\n\nWait, let's simulate for the sample tree.\n\nSample tree structure:\n\n15 is root.\n\nLeft child 10:\n\nleft 6, right 14.\n\nRight child 25:\n\nleft 20, right 60.\n\nSo the traversal order is 6,10,14,15,20,25,60.\n\nLet's see:\n\ncurrent =15. push, move to 15's left (10). push, move to 6. push, move to 6's left (None). So stack is [15,10,6]. Pop 6, add to result. current is 6's right (null). Stack is now [15,10].\n\nThen, the loop continues:\n\ncurrent is none, so inner loop doesn't run. Pop 10, add to result. current is 10's right (14). Push to stack: 14. current is 14's left (none), so pop 14, add to result. current is 14's right (none).\n\nPop next, which is 15. Add to result. current is 15's right (25).\n\nPush 25, then its left (20). Push 20, then its left (none). Pop 20, add to result. current is 20's right (none). Stack now is [25].\n\nPop 25, add to result. current is 25's right (60). Push 60, then left is none. Pop 60, add to result. current is 60's right (none). Stack is empty. So loop breaks.\n\nThus, result is [6,10,14,15,20,25,60], as expected.\n\nThus, the code seems correct.\n\nNow, testing the code with make_tree function.\n\nIn make_tree:\n\nroot =15.\n\nThe left and rights are correctly assigned.\n\nThus, the code should produce the expected output.\n\nAnother thing to think about: the BinaryTreeNode class. Does it have left_child and right_child as attributes? In the example, the code assigns root.left_child, etc. So the code should access those correctly.\n\nThus, the function should be implemented as such.\n\nTesting edge cases:\n\nTest empty tree: returns empty.\n\nTest single node: returns list with node's data.\n\nTest all left chain: returns the list in correct order.\n\nNow, let's write the code.\n\nWait, in Python, we have to be careful about checking for None. So when current is None, we don't enter the while loop. Stack is managed correctly.\n\nSo the function is:\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]:\n    if root is None:\n        return []\n    stack = []\n    result = []\n    current = root\n    while True:\n        while current is not None:\n            stack.append(current)\n            current = current.left_child  # move to left child\n        if not stack:\n            break\n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    return result\n\nThat should do it.\n\nTesting with the sample:\n\nmake_tree() returns the root 15. The code should produce the expected list.\n\nThus, the function should pass the provided test and handle all cases.\n\nI think that's all. So the code written should satisfy all the problem's requirements.\n</think>\n\nTo solve this problem, we need to perform an efficient inorder traversal of a Binary Search Tree (BST) and return the node values in sorted order. The solution should handle large trees efficiently and avoid potential stack overflow issues by using an iterative approach.\n\n### Approach\nThe goal is to traverse the BST in such a way that outputs the node values in ascending order. Inorder traversal of a BST ensures this because it visits nodes in the order of left subtree, root, and right subtree.\n\nAn iterative approach using a stack is chosen to avoid recursion depth issues. Here's the step-by-step approach:\n\n1. **Initialize Data Structures**: Use a stack to keep track of nodes and a list to store the result.\n2. **Traverse Left Subtree**: Start from the root and traverse to the leftmost node, pushing each node onto the stack along the way.\n3. **Pop and Process Nodes**: Once the leftmost node is reached (current becomes None), pop nodes from the stack, add their values to the result list, and move to the right subtree.\n4. **Repeat until Complete**: Continue this process until all nodes have been processed and the stack is empty.\n\n### Solution Code\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]:\n    if root is None:\n        return []\n    \n    stack = []\n    result = []\n    current = root\n    \n    while True:\n        # Traverse all the way to the left\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        if not stack:\n            break\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    def make_tree() -> BinaryTreeNode | None:\n        root = BinaryTreeNode(15)\n        root.left_child = BinaryTreeNode(10)\n        root.right_child = BinaryTreeNode(25)\n        root.left_child.left_child = BinaryTreeNode(6)\n        root.left_child.right_child = BinaryTreeNode(14)\n        root.right_child.left_child = BinaryTreeNode(20)\n        root.right_child.right_child = BinaryTreeNode(60)\n        return root\n\n    tree = make_tree()\n    result = enhanced_inorder_traversal(tree)\n    print(result)  # Expected output: [6, 10, 14, 15, 20, 25, 60]\n```\n\n### Explanation\n- **Tree Structure**: The solution assumes a BST where each node has `left_child` and `right_child` attributes.\n- **Traversal Logic**: The iterative approach uses a stack to simulate the recursion stack, ensuring we handle deep trees without stack overflow.\n- **Efficiency**: The algorithm efficiently processes each node exactly once, making it suitable for large trees with up to \\(10^5\\) nodes.\n\nThis approach ensures that the BST is traversed in-order, producing a sorted list of node values efficiently and safely.",
  "r1_solution": "class BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]:\n    if root is None:\n        return []\n    \n    stack = []\n    result = []\n    current = root\n    \n    while True:\n        # Traverse all the way to the left\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        if not stack:\n            break\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    def make_tree() -> BinaryTreeNode | None:\n        root = BinaryTreeNode(15)\n        root.left_child = BinaryTreeNode(10)\n        root.right_child = BinaryTreeNode(25)\n        root.left_child.left_child = BinaryTreeNode(6)\n        root.left_child.right_child = BinaryTreeNode(14)\n        root.right_child.left_child = BinaryTreeNode(20)\n        root.right_child.right_child = BinaryTreeNode(60)\n        return root\n\n    tree = make_tree()\n    result = enhanced_inorder_traversal(tree)\n    print(result)  # Expected output: [6, 10, 14, 15, 20, 25, 60]",
  "metadata": {
    "prompt_id": "00000051",
    "row_id": 51,
    "seed_ids": [
      358
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results0.jsonl"
}