{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000051_I",
  "question": "### Scenario\nYou are working on a project where you need to efficiently traverse a large Binary Search Tree (BST) and output the values in sorted order. Given the provided code snippet, you have been tasked with implementing an enhanced version of the inorder traversal.\n\n### Requirements\n1. **Function Specification**:\n    - Implement a function `enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]` that performs an inorder traversal on a given BST.\n    - The function should return a list of integers representing the values of the nodes in sorted order.\n2. **Input**:\n    - `root: BinaryTreeNode | None`: The root node of a BST. If `None`, the function should return an empty list.\n3. **Output**:\n    - A list of integers representing the values of the nodes in sorted order.\n4. **Constraints**:\n    - The maximum number of nodes in the tree is \\(10^5\\).\n    - The value of each node is an integer within the range \\([-10^9, 10^9]\\).\n5. **Optimization**:\n    - Use an iterative approach to avoid potential stack overflow issues with deep trees.\n    - Ensure the solution is efficient and handles edge cases properly.\n\n### Example\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\n# Function to test the solution\ndef check_solution(func):\n    tree = make_tree()\n    result = func(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n    print(\"Solution is correct.\")\n\n# Test the function\ncheck_solution(enhanced_inorder_traversal)\n```\n\n### Note\nEnsure your implementation is efficient and handles edge cases such as an empty tree or very deep trees. Use an iterative approach to avoid stack overflow issues.",
  "solution": "from typing import List, Optional\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result",
  "test_code": "import pytest\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n\ndef test_enhanced_inorder_traversal_single_node():\n    root = BinaryTreeNode(10)\n    assert enhanced_inorder_traversal(root) == [10]\n\ndef test_enhanced_inorder_traversal_empty_tree():\n    assert enhanced_inorder_traversal(None) == []\n\ndef test_enhanced_inorder_traversal_balanced_tree():\n    tree = make_tree()\n    assert enhanced_inorder_traversal(tree) == [6, 10, 14, 15, 20, 25, 60]\n\ndef test_enhanced_inorder_traversal_degenerate_tree():\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    assert enhanced_inorder_traversal(root) == [10, 15, 25]\n\ndef test_enhanced_inorder_traversal_negative_numbers():\n    root = BinaryTreeNode(-10)\n    root.left_child = BinaryTreeNode(-20)\n    root.right_child = BinaryTreeNode(-5)\n    root.left_child.left_child = BinaryTreeNode(-30)\n    root.left_child.right_child = BinaryTreeNode(-15)\n    assert enhanced_inorder_traversal(root) == [-30, -20, -15, -10, -5]",
  "test_info": null,
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write an enhanced_inorder_traversal function for a Binary Search Tree. The function has to return a list of integers in sorted order. The requirements mention using an iterative approach to avoid stack overflow because the tree can be deep. Hmm, right, recursion can hit the stack limit for large trees, so iteratively is the way to go.\n\nSo, first, I remember that in an inorder traversal, we visit the left subtree, then the root, then the right subtree. For an iterative approach, I think we can use a stack. The classic way is to keep track of the nodes as we go left until we can't anymore, then pop from the stack and visit, then go right.\n\nWait, the algorithm goes something like this: initialize a stack and a while loop. Start by pushing the root node onto the stack. Then, in each iteration, go as far left as possible from the top of the stack, pushing nodes along the way. Once you hit a null left, pop the node, add to the result. Then move to the right child of the popped node, and repeat.\n\nWait, actually, no, I think I got that a bit wrong. Let me think again. I believe the correct approach is to have the stack keep track of the nodes to visit. We start by pushing the root onto the stack. Then, each time, we check if the root exists. If it does, we push root to stack, and then set root to root.left. Or wait, perhaps I'm overcomplicating.\n\nAlternatively, I remember an approach where we use a stack, and for each node, we move to the leftmost child while pushing each node into the stack. Once we can't go further left (the left is null), we pop the node from the stack, process it, and then set current to the right child of the popped node, pushing that into the stack as we go right, and so on.\n\nWait no, maybe I should structure it as follows. We initialize stack as empty, current to root, result as empty list. Then, while current is not null or the stack is not empty, we process: while current is not null, push it to stack, and current = current.left. Then, pop from stack, add to result, set current to popped node's right.\n\nYes, that makes sense. So, step by step:\n\n1. If root is None, return empty list immediately.\n\n2. Else, initialize stack = [] and current = root.\n\n3. While current is not None or stack is not empty:\n   a. Traverse all the way to the leftmost node, pushing each node into the stack.\n   b. Pop the top node, add its data to result.\n   c. Move current to the popped node's right child.\n\nWait, but in the while loop condition, as long as current is not null, we push nodes onto the stack by going left. Then when current becomes null, we pop from stack.\n\nWait, perhaps the standard iterative approach is something like this:\n\ncurrent = root\nstack = []\nresult = []\n\nwhile True:\n    # Go to the leftmost child, pushing nodes on the stack\n    while current is not None:\n        stack.append(current)\n        current = current.left\n\n    if not stack:\n        break\n\n    # Pop from stack\n    node = stack.pop()\n    result.append(node.data)\n\n    current = node.right\n\nSo this loop will run until stack is empty. This correctly processes left, then root, then right.\n\nYes, that's the way to go. So implementing this in Python.\n\nNow, edge cases to handle: what if tree is empty (root is None), in which case return empty list. Also, tree with one node, only left children, only right children, etc. Need to ensure that the traversal captures all nodes correctly.\n\nSo for the function, first I'll check if the root is None, and if so, return empty list.\n\nOtherwise, proceed with the iterative approach.\n\nLet's think about the example in the problem. The make_tree function constructs a tree as follows:\n\n          15\n        /    \\\n       10    25\n      /  \\  /  \\\n     6  14 20  60\n\nInorder traversal should visit 6, 10, 14, 15, 20, 25, 60. So the function should return [6,10,14,15,20,25,60].\n\nTesting with the given tree, the code should correctly capture this.\n\nNow, in terms of implementation:\n\nThe function is called enhanced_inorder_traversal and takes root as argument.\n\nSo code outline:\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]:\n    result = []\n    if not root:\n        return result\n    stack = []\n    current = root\n    while True:\n        # Traverse to the leftmost node\n        while current:\n            stack.append(current)\n            current = current.left_child\n        if not stack:\n            break\n        node = stack.pop()\n        result.append(node.data)\n        current = node.right_child\n    return result\n\nWait, in the BinaryTreeNode class, left_child and right_child are the attributes. So yes, correct.\n\nWait, let me check. In the BinaryTreeNode __init__, self.left_child is set to None initially, so yes.\n\nSo the condition in the while loop for traversal is correct.\n\nTesting this approach:\n\nFor the sample tree:\n\n- First, current is 15.\n- Push 15 to stack, current becomes its left child 10.\n- Push 10, current becomes 6. Enter left child.\n- Push 6, current is None. Exit inner loop.\n- Pop 6, add to result. current is its right (which is None).\n- Wait, node is 6, right child is None. So current becomes None.\n- Since stack is not empty now (has 10 and 15), the outer loop continues.\n- Again, enter the first inner while loop which is while current: but current is None, so do not execute.\n- Check if stack is empty? No. Pop 10, add to result.\n- current is now 10's right child, which is 14.\n- Now, go into the inner loop again: current is 14 not null, so push it.\n- current becomes 14's left, which is None. So popped 14, added to result. Current becomes 14's right which is None.\n- Stack now has 15. Next iteration, inner while current is 15? No.\n- Pop 15 from stack, add to result. Current becomes 15's right, which is 25.\n- Enter inner loop: current is 25, push to stack. Then current becomes 25's left, 20.\n- Push 20 to stack, current becomes 20's left, which is None.\n- Pop 20, add to result. Current becomes 20's right, which is None?\nWait, in the sample tree, 25 has left child 20 and right child 60. So 20's right is None?\n\nWait, in the make_tree function, the 25's right is 60. So 20's right child is None, because 20 is the left of 25, which has right 60. So yes.\n\nSo after adding 20:\n\n- stack after popping 25's left handling is: 25. Then in next step, current is 25. Its right is 60.\n\nSo processing:\n\nAfter popping 20, current becomes 20's right, which is None.\nSo stack is now [15, 25]. Wait no, initially stack was:\n\nLet me retrace. Wait when 15 is the current root, stack is built by pushing 15, then 10, then 6. After popping 6, current=6's right which is None. Then, in the while loop:\n\nstack is [15,10]. So we pop 10, add to result. Its right is 14. Then:\n\n- Inner loop: current=14, pushed to stack. current becomes 14.left = None. Pop it, add to result. current becomes 14.right = None.\n- Now, stack is [15]. Pop 15, add to result. current becomes 15's right which is 25.\n\nSo handle right subtree:\n\ncurrent is 25. Push to stack. current becomes 25's left, which is 20. Push 20. current becomes 20.left=None. Pop 20, add to result. current is 20.right=None? Or, no, wait: 20 has no right child, because in make_tree(), 25's left is 20, and 20's right_child is None. So 20's right is none.\n\nSo after popping 20, current is None? Or no, wait:\n\nWait, in the code, after popping 20, current is set to 20's right, which is None.\n\nIn the next iteration of the while loop: current is None. So in the outer loop:\n\nWe enter: since stack is not empty (has 15 and 25?), wait no, after popping 15, stack was empty? Wait, let me walk through the steps more carefully.\n\nAfter processing 15's right, which is 25:\n\n- Current was set to 25.\n- Since the outer loop is still active (the stack is empty? No, because processing 25 is inside the loop).\n\nWait, perhaps I need to reevaluate:\n\nInitially, when stack is [15,10,6]. Pop 6, add to result. Current is 6.right (None). So inner while current's loop doesn't run. Check stack is empty? No, pop 10. process, current is 10's right (14). Stack is [15].\n\nThen, in the while loop, since current is 14, which is not none, inner loop runs: stack appends 14, then current becomes 14.left which is None. So pop 14 \u2192 add to result. current becomes 14's right (None). So stack is [15].\n\nNext, in the outer loop:\n\nCheck if current is None or stack is not empty.\n\nWait, the outer condition is a while True loop, which checks each iteration. So:\n\n- After processing 14, current is None. Stack is [15]. So in the outer loop, 'current is not None or stack is not empty' is True because stack is not empty.\n\nSo enter the outer loop.\n\nFirst inner loop: current is None \u2192 don't execute.\n\nSo pop 15.\n\nAdd 15 to result. current is set to 15.right_child, which is 25.\n\nNow, in the next iteration of the outer loop:\n\nAt the start of the while (which is True), do:\n\nWhile current is not null: push to stack and go left.\n\nSo current is 25, which is not null. Push 25 to stack. current becomes 25.left \u2192 20. Push 20 to stack. current becomes 20.left (null). So inner loop ends.\n\nStack is [15,25,20]. Wait no, let's see:\n\nWait no, after popping 15, we set current to 25.\n\nThen, the next outer loop iteration: inner loop starts:\n\ncurrent is 25 \u2192 push to stack \u2192 stack becomes [15, 25]. current becomes 25.left \u2192 20 \u2192 push, current becomes 20.left \u2192 None. So then stack has [15,25,20].\n\nPop 20 \u2192 add to result (6,10,14,15,20). current now is 20.right \u2192 None.\n\nNext iteration: current is None. So in inner loop, don't push anything. So, pop from stack. What's left?\n\nStack now has 25. Pop it \u2192 add to result. Current becomes 25.right \u2192 60.\n\nAt this point, inner loop:\n\ncurrent is 60. Push to stack. current becomes 60's left, which is None. Then, pop 60, add to result. current becomes 60's right, None.\n\nStack is now empty. So the next iteration of the outer loop:\n\nEnter the inner loop \u2192 current is None. So pop stack (now empty? Let me think: After popping 60, current is None. Then, the next pass through the outer loop: inner loop doesn't add anything. So if stack is empty, break.\n\nSo the while True loop ends when the stack is empty.\n\nWait, no: in the outer loop, 'break' is called if stack is empty. But in the code I wrote earlier, the outer loop is a 'while True:' which runs indefinitely until the 'break' condition is met.\n\nSo the code has:\n\nwhile True:\n    while current ... \n    if not stack: break\n\nSo when the stack is empty after popping, the next loop will break.\n\nSo in this step:\n\nAfter adding 60 to result (after popping 60), current is set to its right child (None). Then, in the while loop:\n\nInner loop runs, current is None, so no pushing. Then, check if stack is empty? Yes. So break.\n\nNow, let's list the result array:\n\n6 (from 6), 10 (10), 14 (14), 15 (15), 20 (20), 25 (25), 60 (60). Correct.\n\nSo the code seems to handle this.\n\nWhat about a tree with a single node? Say, root is BinaryTreeNode(5). Then, current is 5.\n\nInner loop: push 5, current becomes 5's left (None). So stack has [5]. Pop \u2192 add 5 to result. Then current set to 5's right (None). Next iteration of outer loop: check stack for emptiness. It's empty, so break. Correct.\n\nAnother test case: all nodes to the left. For example, root is 5, left is 4, left is 3, etc. The in-order traversal should list them in order.\n\nThe code should handle it.\n\nAnother case: root is None. So returns empty array.\n\nWhat about a tree with 1, right child 2, right child 3, etc. So the in-order traversal would be 1,2,3. The code should handle this as well.\n\nI think this approach covers all cases.\n\nNow, implementing that.\n\nWait, in the iterative approach:\n\nWe have a while True loop that runs until stack is empty and current is not null.\n\nWait, no: the condition is to break when stack is empty.\n\nWait, for example:\n\nIn the initial steps, when current is not null, the inner loop fills the stack. Then, after processing, when the stack is empty, the loop breaks.\n\nSo the code is correct.\n\nSo the function enhanced_inorder_traversal is as outlined.\n\nNow, handling edge cases.\n\nAnother point: the problem says that the BST can have up to 1e5 nodes, which is 10^5. So the code needs to handle that. But an iterative approach should handle that without stack overflow since Python's default stack is for function calls.\n\nIterative approach is O(n) time and space.\n\nSo yes.\n\nSo the code should be as above.\n\nTesting the sample case with make_tree, I think the function returns [6,10,14,15,20,25,60], which is correct.\n\nThus, this should solve the problem.\n</think>\n\nTo solve this problem, we need to perform an efficient inorder traversal of a Binary Search Tree (BST) using an iterative approach. This approach ensures that we avoid potential stack overflow issues that can arise with deep recursion in a tree with a large number of nodes.\n\n### Approach\nThe inorder traversal of a BST visits nodes in the following order: left subtree, root, and then right subtree. To achieve this iteratively, we use a stack to keep track of nodes as we traverse the tree.\n\n1. **Initialization**: Start by checking if the tree is empty. If it is, return an empty list.\n2. **Traversal**: Use a stack to push nodes as we traverse to the leftmost child of each node. Once we can no longer go further left, pop nodes from the stack, process them, and then move to the right subtree.\n3. **Termination**: The process continues until the stack is empty, ensuring all nodes are visited in the correct order.\n\n### Solution Code\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]:\n    result = []\n    if not root:\n        return result\n    \n    stack = []\n    current = root\n    \n    while True:\n        # Traverse to the leftmost node\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        if not stack:\n            break\n        \n        # Visit the node\n        node = stack.pop()\n        result.append(node.data)\n        \n        # Move to the right child\n        current = node.right_child\n    \n    return result\n```\n\n### Explanation\n- **Initialization**: The function starts by initializing an empty result list and checking if the root is `None`. If so, it returns the empty list immediately.\n- **Stack Usage**: The stack is used to keep track of nodes as we traverse deeper into the tree. We start with the root and push each left child onto the stack until we reach the leftmost node.\n- **Processing Nodes**: Once we encounter a `None` left child, we pop nodes from the stack, add their values to the result list, and then move to the right child of the popped node.\n- **Efficiency**: This approach ensures that each node is processed exactly once, resulting in a time complexity of O(n), where n is the number of nodes in the tree. The space complexity is also O(n) in the worst case due to the stack storage.\n\nThis method efficiently handles large trees by avoiding recursion and ensures that nodes are processed in the correct inorder sequence.",
  "r1_solution": "class BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]:\n    result = []\n    if not root:\n        return result\n    \n    stack = []\n    current = root\n    \n    while True:\n        # Traverse to the leftmost node\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        if not stack:\n            break\n        \n        # Visit the node\n        node = stack.pop()\n        result.append(node.data)\n        \n        # Move to the right child\n        current = node.right_child\n    \n    return result",
  "metadata": {
    "prompt_id": "00000051",
    "row_id": 51,
    "seed_ids": [
      358
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results2.jsonl"
}