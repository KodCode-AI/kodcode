{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000089_I",
  "question": "You are given a function `is_prime` that checks whether a number is prime. Your task is to implement a function `find_next_prime` that finds the next prime number greater than a given value. The function should handle edge cases and optimize performance for larger numbers.\n\n#### Function Signature\n```python\ndef find_next_prime(value: int) -> int:\n    pass\n```\n\n#### Constraints\n- `1 <= value <= 10^9`\n- The function should return the smallest prime number greater than the given value.\n\n#### Input and Output\n- **Input**: An integer `value`.\n- **Output**: The smallest prime number greater than `value`.\n\n#### Example\n```python\nassert find_next_prime(10) == 11\nassert find_next_prime(29) == 31\nassert find_next_prime(100) == 101\n```\n\n#### Performance Requirements\n- The function should be able to handle values up to `10^9` efficiently.\n\n#### Scenario\nYou are developing a secure messaging system that requires generating prime numbers for encryption keys. Your task is to ensure that the next prime number is found quickly and accurately.",
  "solution": "from math import sqrt\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\"\"\"\n    while True:\n        value += 1\n        if is_prime(value):\n            return value",
  "test_code": "def test_find_next_prime():\n    assert find_next_prime(10) == 11\n    assert find_next_prime(29) == 31\n    assert find_next_prime(100) == 101\n    assert find_next_prime(131) == 137\n    assert find_next_prime(1) == 2\n    assert find_next_prime(2) == 3\n    assert find_next_prime(3) == 5\n\ntest_find_next_prime()",
  "test_info": [
    {
      "function_name": "is_prime",
      "parameter_list": "(n)",
      "function_declaration": "def is_prime(n):",
      "docstring": "Check if a number is prime."
    },
    {
      "function_name": "find_next_prime",
      "parameter_list": "(value)",
      "function_declaration": "def find_next_prime(value):",
      "docstring": "Return the smallest prime number greater than the given value."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to implement a function called find_next_prime that returns the smallest prime larger than a given value. Hmm, I remember that my function will use the is_prime function provided, which checks if a number is prime.\n\nWait, but I should think about how to efficiently find the next prime, especially since the input can be as large as 1e9. That means the function needs to handle big numbers without being too slow. So performance is a concern here.\n\nSo the plan is, given a starting point 'value', I need to search for the next prime. Let's see, I'll start checking numbers one by one, but I need to make this as efficient as possible.\n\nWait, but how do I start? Let's think: if the input 'value' is even, maybe I can increment it to the next odd number since even numbers larger than 2 can't be primes. Wait, but wait\u2014the next prime might be 2 if the input is less than 2? Oh, but looking at the constraints: value is at least 1. So for value=1, the next prime is 2. But looking at the function signature, it says that the next prime needs to be greater than the given value. So for example, if value is 10, the next prime is 11. If value is 11, the next is 13.\n\nWait, wait, no: for example, in the sample input, when value is 10, which is even, the function returns 11. So perhaps the approach is to check the numbers in order starting from value+1, and for each, check if it's prime.\n\nBut checking each number sequentially could be slow for large values. Let me think: the is_prime function\u2014how efficient is it? Well, I don't know its implementation, but in the worst case, if it's a simple trial division method, it might not be very efficient for very large numbers. So if value is 1e9, we might end up checking many numbers.\n\nBut perhaps the given is_prime is optimized in some way, so the find_next_prime function's efficiency relies on how often it calls is_prime.\n\nSo let's think about the algorithm:\n\n1. Start with the number after 'value'\u2014let's call it candidate = value + 1.\n\n2. Check if candidate is prime using is_prime. If yes, return it.\n\n3. If not, increment candidate. But wait, perhaps we can skip some numbers. For example, even numbers can be skipped because the only even prime is 2. So if candidate is even, and it's greater than 2, it's not a prime.\n\nSo for efficiency, after checking if candidate is 2, we can set candidate to be the next odd number if the current one is even and not 2.\n\nWait but more specifically: suppose value is even and greater than 2, then the next candidate should be value+1 (which is odd). And then we check each subsequent odd number. For example, if the next candidate is even, like after 10, we have 11 (which is odd, perhaps is a prime). If 11 is prime, return it. But if value is 11, the next is 13.\n\nBut wait, the initial approach is to start at value+1 and check each number sequentially, but that can be improved by skipping even numbers beyond even candidate.\n\nLet me outline the steps more clearly:\n\n- Start with candidate = value + 1.\n- If candidate is 2, return 2.\n- Otherwise, check if candidate is even. If it is, then move to the next odd number (candidate += 1) as even numbers beyond 2 are not primes.\n- Then, for each candidate, check if it's a prime using is_prime.\n- If it's prime, return it. Else, move to the next odd number (+2).\n- Also, need to handle the case where the initial candidate is even (like when value is odd). For example, value = 29, which is 29. So the next candidate would be 30 (even, but 30 is even but the first to check in loop). But wait, in that case, perhaps immediately the candidate after 29 is 30, which is even\u2014so why not first check 30, see that it's not a prime, then increment by 1 to make it 31, which is prime.\n\nWait no, perhaps a better approach is: if the current candidate is even, then check if it's 2. If it is, return it. Otherwise, add 1 to make it odd, then increment by 2 each time. Wait no, perhaps doing something like:\n\ncandidate = value + 1\nif candidate is even and candidate != 2:\n    if candidate > 2:\n        candidate += 1  # make it odd\n\nthen, while True:\n    if is_prime(candidate):\n        return candidate\n    else:\n        candidate += 2  # check next odd\n\nWait, that might not capture 2? Let's see: If value is 1, then candidate is 2. Let's see, in code. For value=1:\n\ncandidate = 1 +1 = 2\ncheck if candidate is even and not 2: it is even but is 2. So no, proceed to check if it's prime. So return 2.\n\nIf value is 2, then candidate is 3 (2+1). 3 is odd, check if prime (yes), return 3.\n\nWait, the next prime after 2 is 3 which is correct.\n\nWait, but what if value is 3? Then candidate is 4, which is even and not 2. So code would add 1, making it 5, then check if 5 is prime, which is yes. So returns 5, correct.\n\nBut wait, no. Let me see: value=3, the next prime is 5? Or wait, no: 3 is a prime. The function should find the next prime after 'value', meaning a prime greater than 'value'. So, for value=3, the function should return 5? Or wait, no\u2014what is the next prime after 3. The primes are 2,3,5,7,... So next after 3 is 5. That's correct.\n\nSo the approach seems to handle the cases.\n\nWait, but for value=29: the next prime is 31. So the code: candidate starts at 30. Since it's even (and >2), then it's made odd by adding 1: becomes 31. Then check if 31 is prime. It is, so return 31.\n\nAnd for the example with value=10: 10 is even. Candidate=11, which is odd. It's prime, so returns 11. Correct.\n\nWhat about value=1: next prime is 2.\n\nWhat about value=2: returns 3.\n\nWhat about value=0: the function's initial constraints say 1 <= value, so no need to handle that.\n\nSo the steps would be:\n\n1. If value < 2, return 2.\n\nWait no, because the function's parameter is value >= 1. So let me think: what's the return for value=0? Well, according to function's prompt, the constraints for value are 1 <= value \u2264 1e9, so not needed.\n\nBut for value=1, the function should return 2.\n\nWait, when value=1, candidate = 2. That's correct.\n\nSo the code:\n\ncandidate = value + 1\n\nif candidate % 2 == 0 and candidate != 2:\n\n    candidate += 1\n\nThen, we enter a loop, where in each step:\n\nif is_prime(candidate):\n\n    return candidate\n\nelse:\n\n    candidate +=2\n\nWait wait, what about when candidate is odd but not a prime. For example, value=100: 101 is next prime, but maybe 103, etc.\n\nSo in code, for value=100, candidate=101, which is prime, so returns.\n\nBut wait, let me see for value=7: candidate is 8, which is even, so add 1 to get 9. 9 is 3^2, not a prime. So code moves to 11, which is the next prime.\n\nWait, but wait: once candidate is odd, the code increments by 2 each time, so 9 \u2192 11, etc.\n\nYes.\n\nSo the algorithm is:\n\nStart with candidate = value + 1.\n\nIf candidate is 2, return it.\n\nIf candidate is even and greater than 2, then we make it the next odd by adding 1.\n\nThen, enter a loop where we check each odd candidate.\n\nSo in code:\n\ndef find_next_prime(value: int) -> int:\n    candidate = value + 1\n    if candidate == 2:\n        return candidate\n    if candidate % 2 == 0:\n        candidate += 1\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 2\n\nWait, but what about the case when value is even, and candidate is not. For example, value is 4: candidate is 5. 5 is prime, so returns 5.\n\nBut let's test: value is 5. Then candidate is 6, which is even, so add 1 to make 7. 7 is prime, return 7.\n\nWhat if value is 6: then candidate is 7, which is prime and returned.\n\nWhat about when value is 7: candidate is 8, even. Add 1 to make 9, which is not prime (9=3*3), so code adds 2 \u2192 11, returns 11.\n\nThat's correct because 11 is the next prime after 7.\n\nThis seems to handle the cases correctly.\n\nBut wait, what about value is 13: candidate is 14. Even and not 2. Add 1 \u2192 15 (is it prime? 15 is not, 3*5=15. So next candidate 17, which is prime.)\n\nSo code would correctly return 17.\n\nSimilarly for value=1, candidate is 2, which is correctly returned.\n\nNow, the issue is performance. For larger numbers, the code must not take too long. How can we ensure that?\n\nWell, the given is_prime function's performance will greatly affect this. The is_prime function must be optimized for large numbers. But since I'm to write only find_next_prime, I can't change is_prime. So I must rely on it being efficient.\n\nBut for find_next_prime, the approach is correct in terms of checking only a minimal number of candidates.\n\nAlternatively, perhaps the code can be optimized further by pre-checking for small primes and then using some sieving or other methods, but given that the function is for a single next prime, sieve would not be efficient for very large numbers.\n\nSo the approach of checking each odd after a certain point is efficient.\n\nAnother point: the function might need to handle cases where value is non-integer, but according to the signature, it's an integer, so no.\n\nWait, but what about when candidate is 1? For example, when value is 1, candidate is 2\u2014so no problem.\n\nYes, seems safe.\n\nNow let's test the examples:\n\nExample 1: find_next_prime(10) \u2192 should return 11.\n\nAs in the sample, 10 +1 =11, which is prime. So returns 11.\n\nExample 2: find_next_prime(29) \u219231.\n\n29 \u2192 next is 30, which is even. So add 1 \u219231, which is prime.\n\nSample expects 31. Correct.\n\nExample 3: find_next_prime(100) \u2192101.\n\n100+1=101, which is prime.\n\nSample expects 101.\n\nWhat about a case where the next prime is two steps away? Like when value is 7: next is 11.\n\nIn code, candidate=8\u21929\u2192 checks 9 (non-prime), then 11.\n\nAnother test case: value=8.\n\nNext prime is 11.\n\nIn code:\n\ncandidate=9 (8+1=9? Wait, no.\n\nWait, code for value=8: candidate =9. Even?\n\nNo, 8 is even, so value+1 is 9, which is odd.\n\nCheck if 9 is prime? 9 is 3*3, so no. So the loop adds 2, candidate becomes 11, which is prime. So function returns 11.\n\nWhich is correct.\n\nAnother test: value=20.\n\nCandidate is 21, which is 3*7 \u2192 not prime. Next is 23, which is prime.\n\nSo correct.\n\nNow, the code seems to handle all these cases.\n\nOne edge case is when value=2, which would return 3.\n\nYes, code: candidate=3, which is odd. is_prime(3) returns True, so returns 3.\n\nAnother case: value=3: returns 5?\n\nWait no\u20143 is a prime. Next prime after 3 is 5.\n\nWait no: wait, the function is to find the next prime greater than value, so 3\u2192 next is 5? Or is 5 the next prime after 3?\n\nActually, 5 comes after 3, but between them, there's no primes except 5.\n\nYes, 3 is prime, so the function returns the next prime which is 5? No! Wait, no.\n\nWait, no. Wait the primes are 2, 3, 5, 7...\n\nSo the next prime after 3 is 5. So function should return 5.\n\nIn code: value=3 \u2192 candidate=4. 4 is even, so add 1 \u21925.\n\nCheck if 5 is prime \u2192 yes, returns 5.\n\nSo correct.\n\nWait, but what about if value itself is a prime, but not the largest? For example, value=5. The next prime is 7.\n\nSo candidate=6 \u2192 6 is even, add 1\u21927 (is prime, return). Correct.\n\nAnother point: what if value is 1? candidate=2, returned.\n\nWhat about value=0. Well, according to the constraints, 1<=value.\n\nSo the code is correct.\n\nIn terms of performance, the is_prime function should handle even large numbers quickly. For numbers around 1e9, checking is_prime on pairs would be manageable as the next prime after 1e9 is 1000000007, which is 1e9+7.\n\nBut again, the code can iterate through each odd number starting from 0 after 1e9.\n\nI think the code is correct and meets the requirements. So now, time to write it.\n\nBut wait, wait: when value+1 is even, in code, the code adds 1. But what if value+1 is a prime? For example, value is 10: value+1=11, which is prime. The code will find it.\n\nYes.\n\nAnother example: value=1000000. value+1=1000001. If that's a prime, return it else check 1000003 etc.\u2014so code handles it.\n\nSo I think the code handles all cases correctly.\n</think>\n\nTo solve this problem, we need to find the smallest prime number that is greater than a given value. This function should efficiently handle large numbers up to \\(10^9\\).\n\n### Approach\n1. **Initial Check for Small Values**: Start by checking if the given value is less than 2. If it is, the next prime number is 2.\n2. **Increment and Adjust Candidate**: Begin with the candidate number as the next integer after the given value. If this candidate is even and greater than 2, adjust it to the next odd number since even numbers greater than 2 cannot be prime.\n3. **Check for Primality**: Use a loop to check each candidate number for primality using the provided `is_prime` function. If a candidate is prime, return it. If not, move to the next odd number and repeat the check.\n\n### Solution Code\n```python\ndef find_next_prime(value: int) -> int:\n    candidate = value + 1\n    if candidate == 2:\n        return candidate\n    if candidate % 2 == 0:\n        candidate += 1\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 2\n```\n\n### Explanation\n1. **Initialization**: Start with `candidate` set to `value + 1`. This ensures we begin checking the next number after the given value.\n2. **Adjust for Even Numbers**: If `candidate` is even and greater than 2, increment it by 1 to make it odd, as even numbers greater than 2 cannot be prime.\n3. **Primality Check Loop**: Continuously check each odd number starting from the adjusted candidate. If `is_prime` returns true for any candidate, return that candidate as the next prime number. If not, increment the candidate by 2 (to skip even numbers) and continue the loop.\n\nThis approach efficiently skips unnecessary checks on even numbers, significantly reducing the number of candidates to be checked, especially for large values. The use of the provided `is_prime` function ensures that each candidate is checked efficiently, even for very large numbers.",
  "r1_solution": "def find_next_prime(value: int) -> int:\n    candidate = value + 1\n    if candidate == 2:\n        return candidate\n    if candidate % 2 == 0:\n        candidate += 1\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 2",
  "metadata": {
    "prompt_id": "00000089",
    "row_id": 89,
    "seed_ids": [
      326
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results2.jsonl"
}