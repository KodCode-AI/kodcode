{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000089_I",
  "question": "You are given a function `is_prime` that checks whether a number is prime. Your task is to implement a function `find_next_prime` that finds the next prime number greater than a given value. The function should handle edge cases and optimize performance for larger numbers.\n\n#### Function Signature\n```python\ndef find_next_prime(value: int) -> int:\n    pass\n```\n\n#### Constraints\n- `1 <= value <= 10^9`\n- The function should return the smallest prime number greater than the given value.\n\n#### Input and Output\n- **Input**: An integer `value`.\n- **Output**: The smallest prime number greater than `value`.\n\n#### Example\n```python\nassert find_next_prime(10) == 11\nassert find_next_prime(29) == 31\nassert find_next_prime(100) == 101\n```\n\n#### Performance Requirements\n- The function should be able to handle values up to `10^9` efficiently.\n\n#### Scenario\nYou are developing a secure messaging system that requires generating prime numbers for encryption keys. Your task is to ensure that the next prime number is found quickly and accurately.",
  "solution": "from math import sqrt\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\"\"\"\n    while True:\n        value += 1\n        if is_prime(value):\n            return value",
  "test_code": "def test_find_next_prime():\n    assert find_next_prime(10) == 11\n    assert find_next_prime(29) == 31\n    assert find_next_prime(100) == 101\n    assert find_next_prime(131) == 137\n    assert find_next_prime(1) == 2\n    assert find_next_prime(2) == 3\n    assert find_next_prime(3) == 5\n\ntest_find_next_prime()",
  "test_info": [
    {
      "function_name": "is_prime",
      "parameter_list": "(n)",
      "function_declaration": "def is_prime(n):",
      "docstring": "Check if a number is prime."
    },
    {
      "function_name": "find_next_prime",
      "parameter_list": "(value)",
      "function_declaration": "def find_next_prime(value):",
      "docstring": "Return the smallest prime number greater than the given value."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to implement a Python function called find_next_prime, which finds the smallest prime number greater than a given value. The function is given a starting point, 'value', and I need to find the next prime after that. The function should handle edge cases and be efficient, especially for large values up to 1e9.\n\nFirst, let me understand the problem. The next prime after a number can be found by checking each number greater than the given value until a prime is found. However, since the value can be very large, this approach might not be efficient enough. So, I need to think about how to make this process efficient.\n\nThe is_prime function is given, which checks if a number is prime. I should probably use that function, since it's already implemented and assumed to be correct.\n\nWait, but I don't know what algorithm is_prime uses. If it's not efficient, that could be a problem, especially for large numbers. But the problem says that is_prime is given, so I have to use it. Therefore, the efficiency of find_next_prime depends a lot on how efficiently is_prime works, especially for checking large numbers.\n\nAssuming that is_prime is efficient, I need to think about the steps to find the next prime.\n\nThe straightforward approach would be: starting from value + 1, check each integer in increasing order until I find a prime. But for very large values, this could be slow. For example, if the value is just below a large gap between primes, this could take a lot of checks.\n\nSo, how can I optimize this? Let me think about the distribution of primes. Primes are more common when numbers are small, but as numbers get larger, primes become less frequent. However, the exact distribution is random but follows certain patterns, like the prime number theorem which tells us about the density of primes.\n\nBut for the purpose of this function, perhaps the straightforward approach is acceptable because, while the gaps can be large for some numbers, on average the next prime is not too far away.\n\nWait, for example, according to some facts, the average gap between primes near a large number n is about log(n). So, for n=1e9, log(n) is about 20.7. So, it's expected that the next prime is within 20 steps or so on average. That seems manageable.\n\nBut in the worst case, there are prime gaps larger than that. For instance, it's known that there are infinitely many pairs of primes that differ by at least any given even number, but I'm not sure. So, for the worst case, the function might have to check many numbers, but perhaps in practice for programming challenges, the straightforward approach is manageable.\n\nWait, but let's take an example. Suppose the input is 10, the next prime is 11. Then next after 11 is 13, then 17, etc. So the function just increments by 1 or 2 each time and checks.\n\nBut wait, maybe I can optimize the checking. For numbers greater than 2, even numbers are not primes. So, instead of checking every number, I could check numbers that are potentially primes. So, for example, if the starting number is even, I could increment it to the next odd number and then proceed checking odds.\n\nWait, but after the initial check: the next candidate after 'value' can be determined. Let's see:\n\nIf the value is even, the next number could be value + 1 (if it's 2, which is prime). Otherwise, if the value is even and not 2, then the next candidate should be the next odd after value, then every even step after that.\n\nHmm, perhaps the following approach can be done:\n\n- If value is less than 2, return 2.\n- Otherwise, start at the first number greater than 'value', then for each candidate, check if it's prime. If not, move to the next number.\n- But moving one by one could be slow for large numbers. So perhaps, I can increment by 1 until I hit the next number, but I can also have steps by moving in even increments, e.g., after checking 2, if the starting value is 2 or more, just check the next even or alternately the next odd.\n\nWait, maybe even more efficient: if the 'value' is even, then the next candidate should be value + 1 (since even numbers are not prime except 2). If that's not a prime, then the next candidates can be incremented by 2 each time to avoid checking even numbers.\n\nWait, but if the value is even, the next number after is value + 1. So:\n\nstep 1: if value is even, start checking from value + 1. Then, for each next step, add 2, because even numbers are skipped.\n\nBut if the value is odd, then the next number after that is even (so can't be a prime, except 2), so for example, if the starting value is 3, next is 4 (not a prime, so we check 5, which is the next step.\n\nSo, for the function:\n\nFirst, check if the initial 'value' is less than 2. Then, the next prime is 2.\n\nOtherwise, set the next_candidate to be the next number after value. If the value is even, next_candidate is value +1. If it is odd, next_candidate is value + 2, because value is odd, next is even (so not a prime except 2). Wait, no: for example, if the value is 3 (which is odd and a prime), the next number would be 4. 4 is even, not a prime. So, the candidate after value =3 is 4: so in that case, we need to check for 4, which is even, not a prime, and then proceed. So perhaps the function should handle that.\n\nWait no: perhaps the more efficient way is:\n\nIf the value is even, then the next candidate is value +1.\n\nIf the value is odd, the next candidate is value + 2.\n\nWait, is that right? Let me see.\n\nSuppose value is 2: it is even. The next candidate is 3.\n\nIf value is 3 (odd and prime): next candidate is 5.\n\nWait wait, but 4 is not a prime, but in that case, when value is 3, adding 2 gives 5. So, perhaps, when the value is even, the next candidate is value +1. If it's odd, then:\n\nif the next_candidate to check is value+2 if value is odd? That skips even numbers. \n\nWait, no: for an odd value, say 7, the next number is 8 (even, not prime), which is skipped. So the next candidate would be 9, which is also not a prime, but this approach would jump from 7 to 9, etc. So perhaps, the idea is to increment by 2 every time, after checking the first number.\n\nBut what about when the starting value is even. For example:\n\nvalue = 10: next is 11. That's correct.\n\nIf value is 11 (a prime, odd), next is 12 (not a prime, so in the function, we need to find 13 which is the next prime). So, after value=11, the next_candidate is 12.\n\nWait, no, the function is supposed to find the next prime greater than 'value'. So the function should look for the next number after (value) which is prime, regardless of whether value is prime.\n\nWait: because 'value' could be a non-prime. For example, if value is 4, the next prime is 5. If value is 5 (a prime), the next is 7.\n\nWait, the function should find the smallest prime that is strictly greater than 'value'. So regardless of whether 'value' is prime or not, the next prime after 'value' needs to be found.\n\nSo, in the case where value is a prime (like 29 in the example), the next prime is 31, which is correct.\n\nThus, the steps would be:\n\n1. If value is less than 2, return 2.\n\nElse:\n\n2. Start checking from value + 1.\n\n3. For each candidate:\n   a. if it is prime, return it.\n   b. otherwise, proceed to next candidate.\n\nBut checking every single number may be inefficient for large candidate steps.\n\nSo, the goal is to minimize the number of candidates we need to check.\n\nAlternative approach:\n\n- Increment by 1 if the next number is even (like, value is even), because otherwise you'd be checking even numbers.\n\nWait, for example, if the current candidate is even, and it's not 2, it's not a prime. So, it's better to avoid checking even numbers after that.\n\nSo, perhaps:\n\nstart = value + 1\n\nif start is even:\n    start +=1\n\nthen, check in steps of 2 (check odd numbers only).\n\nBecause even numbers are not primes except 2, after considering start = value+1, if it's even, we can skip all even numbers beyond that.\n\nWait, but what if value is 2. Then value+1=3, which is odd. Then 3 is considered, and so on.\n\nWait, but 2 is the only even prime. So, if the start is even, but if start is 2, it's valid. So in the code, perhaps the function should first check the starting number.\n\nOk, let's outline the function:\n\ndef find_next_prime(value: int) -> int:\n    if value < 2:\n        return 2\n\n    candidate = value + 1\n    if candidate % 2 == 0:\n        # if the candidate is even, then if it's 2, it's fine. else, make it next odd.\n        if candidate == 2:\n            return 2\n        # else, make it the next odd\n        candidate += 1\n\n    while True:\n        if is_prime(candidate):\n            return candidate\n        # move to the next odd\n        candidate += 2\n        # but wait, after adding 2, could that number be even again? No, because 2 added to odd gives another odd.\n\nWait, but why not handle the 2 case at the beginning?\n\nAlternative approach:\n\nIf the candidate is even, but it's equal to 2, return it. Otherwise, if it's 0 is even, then make the candidate the next odd, as even numbers can't be primes except 2.\n\nSo, let's adjust:\n\ncandidate = value + 1\nif candidate > 2 and candidate % 2 == 0:\n    candidate +=1\n\nBut wait, candidate can be 2 even after that. So, perhaps in code:\n\nif value < 2:\n    return 2\n\ncandidate = value + 1\n\nif candidate == 2:\n    return 2\n\nif candidate % 2 == 0:\n    candidate +=1\n\nthen, while True:\n\ncheck if candidate is prime. if yes, return. else, add 2, repeat.\n\nBut wait, in the case where candidate is 2, we can return it. So perhaps the initial condition is:\n\nif value < 2:\n    return 2\n\ncandidate = value + 1\n\nif candidate == 2:\n    return 2\n\n# else, make sure candidate is odd.\n\nif candidate % 2 ==0:\n    candidate +=1\n\nThen, for each candidate afterward, add 2 each time.\n\nWait, let's test some examples.\n\nExample 1: value = 10\n\ncandidate = 11.\n\n11 is odd and >2. check is_prime(11) => yes. return 11.\n\nWhich is correct.\n\nExample 2: value = 29\n\ncandidate is 30. 30 is even and greater than 2.\n\nso, candidate +=1 \u219231.\n\nIs 31 a prime? yes. return 31.\n\nWhich is correct.\n\nExample 3: value is 100.\n\ncandidate is 101, which is odd. is it a prime? Yes, so function returns 101.\n\nAnother test case: value is 2. Then, candidate is 3. No, wait, value=2 is handled before. Because value+1=3.\n\nWait, when value=2, the code will:\n\ncandidate = 3.\n\nsince 3 is odd, and not equal to 2.\n\nWait, the code after the initial check for candidate == 2 is not in the code.\n\nWait, let's think about the function's flow for value=2:\n\nvalue is 2, which is >=2.\n\ncandidate is 3.\n\n3 is not equal to 2, so proceed.\n\nif 3 is even? No. So the code enters the loop.\n\ncheck if 3 is prime. yes, return 3.\n\nYes, correct.\n\nWhat about value = 3:\n\ncandidate =4. Then, since even, candidate is increased by 1 \u21925.\n\nis_prime(5) \u2192 yes. returns 5. Correct.\n\nAnother example: value=5: candidate=6. even, so increase by 1\u21927, which is prime.\n\nYes, correct.\n\nAnother case: value=1:\n\nfunction returns 2.\n\nValue=0: same, returns 2.\n\nWhat about value=7: candidate is 8, even, increase by 1\u21929. Is 9 a prime? No. So, we check 9, not a prime. Then next is 9+2=11. Which is a prime. So function returns 11.\n\nYes.\n\nWhat about a case where the next_prime is after several steps, like value=14.\n\ncandidate =15. is 15 prime? No. Then 17, which is a prime.\n\nSo, the function returns 17.\n\nWait, but wait: 14 \u219215 is not prime, function adds 2 to get 15+2=17 and returns.\n\nAnother example: value=2 \u2192 next prime is 3.\n\nSo, seems the logic holds.\n\nSo the function would look something like this:\n\nStart at value +1. Check if that candidate is 2, return. Else, if it's even, add 1 to make it odd. Then while True, check for primality, and if not, add 2.\n\nBut let's think about the starting condition.\n\nWait, what if the value is 1e9, which is the upper limit.\n\nAssuming that the is_prime function can handle that efficiently, but the find_next_prime function will proceed to find the next prime, which may be 1e9+ (some steps).\n\nIn terms of code:\n\nInside the function, the steps are:\n\n1. Handle the case where value is less than 2.\n\n2. Else, set candidate to value+1.\n\n3. If candidate is 2, return it.\n\n4. Else, check if candidate is even: if so, add 1 to make it odd.\n\n5. Then, loop: check if the candidate is prime. If yes, return. If not, add 2.\n\nWait, but after step 3, if candidate is even but not 2, making it odd by adding 1 is correct because even numbers >2 are not primes.\n\nFor example, value=4 \u2192 next candidate is 5, which is correct.\n\nBut for value=5: next candidate is 6 (even), add 1\u21927, which is prime.\n\nYes.\n\nSo the code outline is:\n\ndef find_next_prime(value: int) -> int:\n    if value < 2:\n        return 2\n\n    candidate = value + 1\n\n    if candidate == 2:\n        return 2\n\n    if candidate % 2 == 0:\n        candidate +=1\n\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 2\n\nBut wait, after step 2, the code may have a candidate that's even, greater than 2, so makes it odd.\n\nBut what about when the candidate is already odd?\n\nLike: if value is even, then candidate is value+1, which is odd. For example, value=4 is even, candidate=5 is odd. Proceeds to check.\n\nIf the candidate were already odd (because value is even, candidate is odd, e.g., value=5 is odd, candidate=6 even \u2192 add 1 \u21927, which is odd.\n\nYes.\n\nWait, suppose the candidate is already odd.\n\nWait, for value=3: candidate is 4, even. Makes it 5, odd.\n\nvalue=5: candidate is 6, even. becomes 7.\n\nYes.\n\nBut what about when the value is even: for example, value=6. candidate is 7. which is odd.\n\nSo, no problem.\n\nBut wait, the code after the initial step may miss some corner cases.\n\nLet's test value=2: candidate is 3, which is handled correctly.\n\nAnother case: value=1 \u2192 returns 2.\n\nWhat about value=13: next prime is 17. How would the code handle that.\n\ncandidate =14 \u2192 even \u2192 15.\n\nCheck if 15 is prime: 3*5=15\u2192 no.\n\nAdd 2: 17 \u2192 yes.\n\nSo returns 17.\n\nAnother test case: find_next_prime(7) should return 11.\n\ncandidate=8 \u2192 even, add 1\u21929 \u2192 not prime.\n\n9 \u2192 add2\u219211 \u2192 prime.\n\nYes.\n\nAnother case: find_next_prime(29)=31.\n\nvalue=29 is even? No, it's odd. So candidate =30 \u2192 even \u2192 add 1 \u219231, which is a prime, returns.\n\nYes.\n\nSo the logic seems correct.\n\nNow, what about the performance aspects.\n\nIn the worst case, for a large 'value' where the next prime is much larger, the function might take a lot of steps.\n\nBut as discussed earlier, the average gap between primes near large n is about log(n), so for 1e9, log2(n) is around 30, so in that case, about 60 checks (since each check skips even numbers, so on average half the numbers are being checked).\n\nBut even within that, the is_prime function must be optimized as much as possible.\n\nSuppose the is_prime function is implemented with trial division. Then, for very large numbers, this might be slow because trial division is O(sqrt(n)). So, for numbers up to 1e18, each is_prime call could take a long time.\n\nBut given that the 'is_prime' function is given as a black box, I have to assume it is optimized (perhaps using probabilistic methods).\n\nIn that case, the function's performance is acceptable.\n\nSo now, writing the code accordingly.\n\nBut wait, wait: what about the case where the candidate is 2?\n\nBecause, in the initial code, if the 'value' is 1, candidate is 2; since in the first if condition (value<2 checks), which returns 2 if the value is 1 or less. So for value=2?\n\nWait no: when value=2, candidate is 3 \u2192 step 3: If candidate ==2? No. Then, step4: check if even. 3 is not even, so nothing is done. Then in the loop: check is_prime(3). 3 is a prime, so returns 3, which is correct.\n\nBut wait: When value=1, candidate is 2.\n\nYes, correct.\n\nHmm, but for value=2, the function returns 3.\n\nWhich is correct, since 3 is the next prime after 2.\n\nBut wait, what about if value is exactly a prime? Like value=5. Function returns 7, which is correct.\n\nAnother edge case: what if the value is 0: the function returns 2.\n\nYes.\n\nAnother edge case: what if the value is 999999937 (a large known prime). The next prime is 1000000003.\n\nSo, the next function, when given value=999999937, will first compute candidate=999999938 (even) \u2192 add 1 (since even) to get 999999939. Check if it is a prime.\n\nNo, it is 999999939 \u00f73: because 999 is divisible by 3.\n\nSo, then the function proceeds to 999999941, etc., until it finds 1000000003.\n\nSo the code would correctly find it.\n\nNow, the only thing is to make sure that when the candidate starts as an even number, it's properly incremented to an odd.\n\nBut according to the code, the candidate is incremented to make it odd only if it's even and not 2.\n\nYes.\n\nThus, the code should work for all cases.\n\nI think that's the correct approach. Now, translate that logic into code.\n\nWait, the code step is as follows:\n\ndef find_next_prime(value: int) -> int:\n    if value < 2:\n        return 2\n\n    candidate = value + 1\n\n    if candidate == 2:\n        return candidate\n\n    if candidate % 2 == 0:\n        candidate += 1\n\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 2\n\nYes.\n\nNow, test another case: value=4.\n\ncandidate =5.\n\n5 is odd. Is_prime(5) is yes. Return 5.\n\nWhich is correct, because next prime after 4 is 5.\n\nAnother example: value=6 \u2192 candidate=7 \u2192 returns 7.\n\nYes.\n\nValue=7 \u2192 candidate=8 (even, add 1 \u21929. Not a prime, add 2 \u219211. Returns 11.\n\nYes.\n\nAnother test: value=9: candidate is 10, even \u2192 add1=11. Is prime. returns.\n\nYes.\n\nSo, seems all correct.\n\nWait, what if value=31 (a prime). The next prime is 37. So:\n\ncandidate=32 \u2192 even \u219233. is_prime(33)=3*11\u2192 no. 35 \u21925*7. 37 \u2192 yes.\n\nSo function correctly returns 37.\n\nI think that's correct.\n\nThus, the code is written.\n</think>\n\nTo solve this problem, we need to find the smallest prime number greater than a given value. The function should handle edge cases and be efficient, especially for large values up to \\(10^9\\).\n\n### Approach\n1. **Initial Check for Small Values**: If the given value is less than 2, the function immediately returns 2, as 2 is the smallest prime number.\n2. **Candidate Initialization**: Start from the next number greater than the given value.\n3. **Even Number Handling**: If the next candidate number is even and greater than 2, it is incremented by 1 to make it odd. This step leverages the fact that even numbers greater than 2 are not prime.\n4. **Prime Check Loop**: Iterate through each candidate number, checking if it is a prime using the provided `is_prime` function. If a prime is found, return it. Otherwise, continue checking subsequent odd numbers.\n\nThis approach ensures that we efficiently skip even numbers after the initial check, reducing the number of candidates we need to evaluate for primality.\n\n### Solution Code\n```python\ndef find_next_prime(value: int) -> int:\n    if value < 2:\n        return 2\n\n    candidate = value + 1\n\n    if candidate == 2:\n        return candidate\n\n    if candidate % 2 == 0:\n        candidate += 1\n\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 2\n```\n\n### Explanation\n1. **Handling Small Values**: The function first checks if the input value is less than 2. If so, it directly returns 2, the smallest prime number.\n2. **Starting Point**: The candidate number starts at `value + 1` to ensure we look for the next number greater than the given value.\n3. **Even Check**: If the candidate is even and greater than 2, it is converted to the next odd number by incrementing by 1.\n4. **Prime Check Loop**: The loop continues to check each subsequent odd number for primality. When a prime is found, it is returned immediately.\n\nThis approach efficiently narrows down the candidates to only odd numbers, reducing the number of checks needed and ensuring the solution is optimal even for large values.",
  "r1_solution": "def find_next_prime(value: int) -> int:\n    if value < 2:\n        return 2\n\n    candidate = value + 1\n\n    if candidate == 2:\n        return candidate\n\n    if candidate % 2 == 0:\n        candidate += 1\n\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 2",
  "metadata": {
    "prompt_id": "00000089",
    "row_id": 89,
    "seed_ids": [
      326
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results0.jsonl"
}