{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000089_I",
  "question": "You are given a function `is_prime` that checks whether a number is prime. Your task is to implement a function `find_next_prime` that finds the next prime number greater than a given value. The function should handle edge cases and optimize performance for larger numbers.\n\n#### Function Signature\n```python\ndef find_next_prime(value: int) -> int:\n    pass\n```\n\n#### Constraints\n- `1 <= value <= 10^9`\n- The function should return the smallest prime number greater than the given value.\n\n#### Input and Output\n- **Input**: An integer `value`.\n- **Output**: The smallest prime number greater than `value`.\n\n#### Example\n```python\nassert find_next_prime(10) == 11\nassert find_next_prime(29) == 31\nassert find_next_prime(100) == 101\n```\n\n#### Performance Requirements\n- The function should be able to handle values up to `10^9` efficiently.\n\n#### Scenario\nYou are developing a secure messaging system that requires generating prime numbers for encryption keys. Your task is to ensure that the next prime number is found quickly and accurately.",
  "solution": "from math import sqrt\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_next_prime(value: int) -> int:\n    \"\"\"Return the smallest prime number greater than the given value.\"\"\"\n    while True:\n        value += 1\n        if is_prime(value):\n            return value",
  "test_code": "def test_find_next_prime():\n    assert find_next_prime(10) == 11\n    assert find_next_prime(29) == 31\n    assert find_next_prime(100) == 101\n    assert find_next_prime(131) == 137\n    assert find_next_prime(1) == 2\n    assert find_next_prime(2) == 3\n    assert find_next_prime(3) == 5\n\ntest_find_next_prime()",
  "test_info": [
    {
      "function_name": "is_prime",
      "parameter_list": "(n)",
      "function_declaration": "def is_prime(n):",
      "docstring": "Check if a number is prime."
    },
    {
      "function_name": "find_next_prime",
      "parameter_list": "(value)",
      "function_declaration": "def find_next_prime(value):",
      "docstring": "Return the smallest prime number greater than the given value."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to write a Python function called find_next_prime which takes a value as input and returns the smallest prime number greater than that value. The function should handle edge cases and perform efficiently even for large numbers up to 10^9.\n\nFirst, let's think about what a prime number is. A prime number is a number greater than 1 that has no divisors other than 1 and itself. So, the task is to find the next number after 'value' that satisfies this condition.\n\nBut wait, how do I efficiently check if a number is prime? Oh right, the function is_prime is given. So I don't have to implement that part; I just need to use it properly.\n\nSo the main steps for my function find_next_prime would be:\n\n1. Start checking numbers starting from value + 1, then value +2, and so on.\n2. For each number, use the is_prime function to check if it's prime.\n3. The first number for which is_prime returns True is the one we need to return.\n\nBut wait, checking each number sequentially could be slow, especially for large values. Oh but the problem states that the function needs to handle larger numbers efficiently. Hmm, but since is_prime is already given, perhaps I should leave the optimization to it. Or are there ways I can optimize the search process?\n\nAlternatively, are there patterns to primes that I can exploit? Like checking numbers of certain forms. For example, except for 2, all primes are odd. So if the value is even and higher than 2, the next number could be odd and then increment by 2 each time. If the value is odd, we can start from value +2, then +2, etc.\n\nWait, that's a good point. For example, for even numbers greater than 2, adding 1 to get the next candidate (to make it odd) is the first step. For odd numbers, we can add 2 each time to skip even numbers. This can reduce the number of checks by half.\n\nLet me outline a possible approach:\n\nStart from n = value + 1 if value is even, else n = value + 2. Then, for each n, if it's even, skip it except when n is 2.\n\nWait, but 2 is the only even prime. So for example, if value is 1, the next prime is 2. So perhaps handling that edge case is important.\n\nSo in my function, first, check if value is less than 2. Then return 2. Because the next prime after 0, 1, etc. is 2.\n\nWait, maybe:\n\nIf value < 2, return 2.\n\nElse:\n\nStart checking from the next number after value, but optimize by checking only odd numbers.\n\nSo, if the value is even, then value +1 is odd, then increment by 2. For example, if value is 10, which is even, next is 11 (odd), which is a prime.\n\nWait, but what if the next prime is larger and even? No, because other than 2, primes are all odd. So for numbers greater than 2, the next candidate is the next odd number.\n\nSo the logic can be:\n\n- If the current value is even, check if it +1 is prime. If not, check +3, etc.\nBut perhaps it's better to start from the correct parity.\n\nAlternatively, here's a step-by-step approach for the function:\n\n- If the value is less than 2, return 2.\n\nOtherwise:\n\n- Compute n as the next number to check. If value is even, start at value +1. If value is odd, then the next possible candidate is the value + 2, except when value is a prime itself.\n\nWait, no. Because the function is to find the next prime greater than the given value, not just the next number. So, for example, if the value is 29, which is a prime, the function should return 31.\n\nSo perhaps the function needs to find the next number after the given value, regardless of whether it's prime or not, starting from the next odd.\n\nWait, but more precisely: for a given value, we need to check whether the next number (value+1) is prime. If not, check the next, and so on.\n\nBut to optimize, if the value is even, then value+1 is odd, and primes after that can only be odd numbers (except 2). So from value +1, we can check in steps of 2.\n\nSimilarly, if the value is odd, then we can start from value +2, check if it's prime, and increment by 2 each time.\n\nLet me think in terms of code.\n\nHere's a rough outline:\n\ndef find_next_prime(value: int) -> int:\n    if value < 2:\n        return 2\n    candidate = value + 1 if value % 2 == 0 else value + 2\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 2\n\nWait, but wait: For value =2, which is even. Then candidate is 3. If 3 is prime? Yes. So for value =2, returns 3, which is correct.\n\nWait, let me test some examples:\n\nExample 1: value=10\n\n- 10 is even, candidate =11. is_prime(11) is True. So return 11. Correct.\n\nExample 2: value=29, which is odd. So candidate=31. is_prime(31) is True. Wait, but wait. What about 30? Wait, no, because after 29 comes 30 (even, ignored) and then 31 is next candidate.\n\nWait, but 29 is the input. So the next number is 30, but it's even. Since 29 is odd, we start candidate at 31.\n\nWhich is correct because the next prime after 29 is 31.\n\nAnother example: value=14 is even, so candidate starts at 15. 15 is not prime, so next is 17. 17 is some prime?\n\nWait, no. 15 is not prime, next is 17. 17 is a prime. So function would return 17 for value=14.\n\nWait, but wait. What about value=1?\n\nfunction returns 2, which is correct.\n\nNow, what about a case where the next candidate is 2?\n\nFor example, supposed value is 3. Wait, function would go wrong in that case.\n\nWait no.\n\nWait value =3 is odd. So candidate starts at 3 +2=5. But if 3 is the input, then the next prime is 5, which is correct. But wait, what about if value=2? 2 is even. Candidate is 3, which is prime.\n\nYes.\n\nBut what about when value is 1? The function returns 2, which is correct.\n\nWhat about when value is 0? Returns 2.\n\nWhat if the function is called with value=5 (a prime)? It should return the next prime, which is 7.\n\nYes.\n\nAnother test case: value=100.\n\n100 is even, so candidate is 101. 101 is a prime. So function returns 101, which matches the sample.\n\nAnother test case: value=30. It's even, candidate is 31. 31 is prime. Correct.\n\nOkay, so the algorithm seems to cover these cases.\n\nBut what about when the given number itself is 2? Let's see.\n\nvalue=2: even, so candidate is 3. 3 is prime, so function returns 3. Correct.\n\nSo, code logic seems OK.\n\nBut wait, what about when value is even and the next candidate is even?\n\nNo, because candidate is value +1 if even, which could be even only when value is even and adding 1 makes it odd.\n\nWait, for example, value=5 is odd, candidate is 7. But 5 is already a prime.\n\nWhat about when is_prime isn't correctly implemented. But the function is_prime is provided, so we can assume it works.\n\nWait, perhaps another edge case: value is 1, and nothing, returns 2.\n\nWhat about value=7, which is a prime. So function starts at 9. 9 is not a prime, next is 11, which is.\n\nSo function returns 11 for value=7, which is correct.\n\nHmm.\n\nWait, but wait: what about in the case of value=25. Value is odd. So candidate is 27, which is 3^3. Not a prime. Next: 29, which is a prime. So function returns 29. Correct.\n\nSo the approach of checking candidates with step 2, starting at next odd number, seems solid.\n\nBut what about when the given value is very large, like 1e9? Then, the is_prime function needs to be efficient.\n\nAssuming that the provided is_prime function is robust and efficient for large numbers, perhaps using probabilistic methods like the Miller-Rabin test, this should not be a problem.\n\nBut if the function is_prime is not efficient, say, if it checks for divisibility up to sqrt(n), then for large numbers, it could be very slow.\n\nWait, but that's a limitation of the is_prime function, not our code. But the problem statement mentions that the find_next_prime function should handle large numbers efficiently. So I think that the is_prime function is assumed to be efficient.\n\nBut since the code is given, perhaps I should proceed.\n\nSo the code outline is as I wrote before.\n\nBut wait, what about when value is 1? The code correctly returns 2.\n\nBut what about when the value is 0?\n\nWhat about when the value is a prime number?\n\nThe function correctly finds the next prime.\n\nNow, what about when the next candidate is even?\n\nWait, the candidate is always odd except when value is 1, for example.\n\nBecause the code is designed to start at value +1 (if even) which would be odd, or value +2 (if odd) which adds 2, keeping the parity.\n\nSo in all cases except when value is 2, the candidate is odd.\n\nSo the code starts at an odd candidate and increments by 2.\n\nWait, but let me test when value=3 (which is 3, a prime). The function starts looking at 5 (3 + 2), which is correct because 5 is the next prime.\n\nBut wait, what about value=4 which is even. Then candidate is 5, which is a prime.\n\nAnother test: value=5, which is odd. Next candidate is 7 (5+2=7), which is correct.\n\nSo all cases seem to be handled.\n\nNow, what about when is_prime for 2 returns True.\n\nWait, the function would return 3 for value=2.\n\nDoes the function correctly handle other even numbers? Yes.\n\nSo the code seems solid.\n\nWait, but in the function, the candidate for even value is value +1, which could be even. No: wait, for value even, value+1 is always odd.\n\nBecause adding 1 to an even number is odd, and adding 1 to an odd number is even.\n\nWait, for value =2:\n\nvalue is even, so candidate is 3, which is correct.\n\nYes.\n\nNow, thinking about the increments: for each step, we add 2, so it checks all the odd numbers.\n\nNow, coding.\n\nBut in the code, after the candidate is calculated, it's better to sort of loop: keep checking if candidate is prime, return it. Else, add 2 and repeat.\n\nBut maybe we need to handle the candidate if it's even. Or not.\n\nWait, let's think: when the candidate is 2 (when value is 1, e.g.), which is correctly handled.\n\nWait, code:\n\nif value <2: return 2.\n\nBut for other cases:\n\nvalue=even, candidate = value +1, which is odd.\n\nBut perhaps not the next prime. So increment by 2 each time.\n\nWait, okay.\n\nBut in code:\n\nBut for value=7 (odd), the candidate is 9, which is not a prime. So function will check 9, 11. 11 is a prime, returns that.\n\nSo it's correct.\n\nNow, perhaps the code should first check if value+1 is greater than 2 and even, but that's not required since function starts at an odd candidate.\n\nWait, because all even numbers beyond 2 are not primes. So the function is correct in only checking the candidates in an odd sequence.\n\nWait, unless the function starts at 2.\n\nWait, for value=1:\n\nfunction returns 2, correct.\n\nBut for value=0, same. Returns 2.\n\nOther examples:\n\nvalue=1: returns 2.\n\nvalue=2: returns 3.\n\nWait, but wait: 2 is a prime, but the function's code actually starts at 3, because 2 is even, so candidate is 3. Then checks if 3 is prime, yes. So function returns 3, which is correct as the next prime after 2.\n\nSo, code is correct.\n\nI think this approach is correct.\n\nSo to implement this:\n\ndef find_next_prime(value: int) -> int:\n    if value < 2:\n        return 2\n    # Determine the next candidate\n    if value % 2 == 0:\n        candidate = value + 1\n    else:\n        candidate = value + 2\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 2\n\nWait, but what about the number 2? Let's see.\n\nvalue=2 is even, candidate is 3, is_prime(3)=True, returns 3.\n\nYes.\n\nWhat about value=3? It's odd, so candidate is 5. Is 3 a prime? Yes, but the function returns 5 as next.\n\nWait, no, 3 is already a prime. So the next number after 3 is 4, but is that a prime? No. 5 is next.\n\nWhich is handled correctly.\n\nOkay.\n\nSo I think this logic covers all cases, including edge cases.\n\nOne more test case:\n\nvalue=6: even, so candidate is 7. 7 is a prime, return 7.\n\nYes.\n\nAnother test case: value=29, as per the sample, should return 31. Our code does that.\n\nWhat about value is a very large prime, say 41? Next prime is 43.\n\nYes, code would return that.\n\nSo now, the code should be correct.\n\nWait, but what about the next prime number could be 2 in some case?\n\nOnly when the value is less than 2, then it's correct.\n\nOther than that, 2 can't be the next prime, because the function is looking for primes greater than value.\n\nSo if the value is 1, next prime is 2. Correct.\n\nOkay, I think the code is correct.\n\nSo now, the function should be implemented as follows.\n\nBut wait, what about when the candidate is 2?\n\nBecause in the case where value is 1, it's handled in the initial check. Otherwise, the candidate will always be \u22653.\n\nSo the code should be correct.\n</think>\n\nTo solve this problem, we need to find the next prime number greater than a given value. The solution should efficiently handle large numbers up to \\(10^9\\).\n\n### Approach\n1. **Initial Check for Small Values**: If the given value is less than 2, the next prime number is 2, as 2 is the smallest and only even prime number.\n2. **Determine Starting Candidate**: \n   - If the given value is even, the starting candidate is the next odd number (i.e., value + 1).\n   - If the given value is odd, the starting candidate is the next odd number greater than the given value (i.e., value + 2).\n3. **Prime Check and Increment**: Starting from the determined candidate, check each subsequent odd number to see if it is a prime. If it is, return it; otherwise, increment by 2 and continue checking.\n\nThis approach optimizes the search by skipping even numbers after the initial check, reducing the number of candidates to check by half.\n\n### Solution Code\n```python\ndef find_next_prime(value: int) -> int:\n    if value < 2:\n        return 2\n    if value % 2 == 0:\n        candidate = value + 1\n    else:\n        candidate = value + 2\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 2\n```\n\n### Explanation\n- **Initial Check**: For values less than 2, return 2 immediately.\n- **Starting Candidate**: For even values, start with the next odd number; for odd values, start with the next odd number after the given value.\n- **Prime Check Loop**: Incrementally check each subsequent odd number using the provided `is_prime` function until a prime is found, ensuring efficient search by skipping even numbers.\n\nThis method ensures that we efficiently find the next prime number by leveraging the properties of primes and minimizing the number of checks needed.",
  "r1_solution": "def find_next_prime(value: int) -> int:\n    if value < 2:\n        return 2\n    if value % 2 == 0:\n        candidate = value + 1\n    else:\n        candidate = value + 2\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 2",
  "metadata": {
    "prompt_id": "00000089",
    "row_id": 89,
    "seed_ids": [
      326
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}