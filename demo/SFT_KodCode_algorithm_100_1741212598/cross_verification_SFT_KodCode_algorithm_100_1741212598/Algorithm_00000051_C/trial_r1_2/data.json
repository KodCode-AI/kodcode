{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000051_C",
  "question": "def enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result",
  "solution": "from typing import List, Optional\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result",
  "test_code": "import pytest\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n\ndef test_enhanced_inorder_traversal_single_node():\n    root = BinaryTreeNode(10)\n    assert enhanced_inorder_traversal(root) == [10]\n\ndef test_enhanced_inorder_traversal_empty_tree():\n    assert enhanced_inorder_traversal(None) == []\n\ndef test_enhanced_inorder_traversal_balanced_tree():\n    tree = make_tree()\n    assert enhanced_inorder_traversal(tree) == [6, 10, 14, 15, 20, 25, 60]\n\ndef test_enhanced_inorder_traversal_degenerate_tree():\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    assert enhanced_inorder_traversal(root) == [10, 15, 25]\n\ndef test_enhanced_inorder_traversal_negative_numbers():\n    root = BinaryTreeNode(-10)\n    root.left_child = BinaryTreeNode(-20)\n    root.right_child = BinaryTreeNode(-5)\n    root.left_child.left_child = BinaryTreeNode(-30)\n    root.left_child.right_child = BinaryTreeNode(-15)\n    assert enhanced_inorder_traversal(root) == [-30, -20, -15, -10, -5]",
  "test_info": null,
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write an enhanced in-order traversal for a binary search tree. The function is called enhanced_inorder_traversal and it takes a root node which could be None, and returns a list of integers. Hmm, right, because an empty tree would just return an empty list.\n\nSo, in-order traversal means we visit the left subtree first, then the root, then the right subtree. But wait, the question says it's a BST, so the in-order traversal should return the nodes in sorted order. So the function should be correct in that aspect.\n\nWait, the code given seems to have some structure. Let's see: if the root is None, return an empty list. That makes sense. Then it initializes stack and result as empty lists, and current as root. So the plan is to use an iterative approach with a stack, right?\n\nOkay, so the while loop runs as long as the stack isn't empty or current isn't null. In the loop, it first tries to traverse as far left as possible, pushing nodes onto the stack. Then when current is null, it pops the top node from the stack, adds its data to result, and then sets current to the right child. That seems correct for in-order traversal.\n\nWait, let's step through this. Suppose we have a tree where root is 5, with 3 as left child and 7 as right. The left subtree of 3 is 2, and right is 4. The right subtree of 7 has 6 and 8.\n\nSo the in-order traversal should be 2,3,4,5,6,7,8. Let's see what the code does.\n\nInitially, stack is empty, current is 5. The outer loop runs because current is not null. Then the inner while loop runs, pushing 5 onto the stack and moving to 3. Then push 3, then move to 2, push, then move to null. So stack has 5,3,2.\n\nNow current is null, so we pop 2 from the stack. Add 2 to results. Then set current to 2's right child, which is null. So the outer loop checks again: stack not empty. So enter the outer loop again. current is null, so it doesn't do the inner while. Pop 3 from stack, add 3 to list. Then current becomes 3's right child, which is 4.\n\nNow, current isn't null, so enter inner while loop: push 4, current =4's left which is null. So stack is now [5,4]. Pop 4, add to result, now result is [2,3,4]. Current becomes 4's right, which is null.\n\nSo stack is now [5]. So pop 5, add to result, now [2,3,4,5]. Then current is set to 5's right child, which is 7.\n\nNow stack is empty, current is 7. So the outer loop runs again. Enter the while loop: push 7, then move to its left child 6. Push 6, current is 6's left which is null. So stack is [7,6].\n\nPop 6, add to results: [2,3,4,5,6]. Current becomes 6's right, which is null. Stack now has [7]. Pop 7, add, then current is 7's right, which is 8.\n\nCurrent is 8, non-null. Push 8, then move to its left which is null. Pop 8, add to results, current becomes 8's right which is null.\n\nNow, stack is empty and current is null. So the loop ends. The result is as expected.\n\nWait, but why is it called 'enhanced'? Oh, maybe because it's iterative, which is more efficient than the recursive approach for large trees?\n\nWait, the code seems correct. But perhaps I should think about any edge cases. What if the tree is just a single node? Like root has no children. So current is that node. It pushes it into the stack. Then when popped, adds to result. Then the right is null, stack is empty. So returns [root.data], correct.\n\nWhat if the tree is a right-skewed tree? Like 1's right is 2, whose right is 3, etc. So in-order traversal should be 1,2,3,4...\n\nLet's see: starting with current=1. push 1, then current=1's left which is null. So pop 1, add to result. Then current becomes 1's right, which is 2. Then the loop continues.\n\nWait, maybe the code is correct. So the function should work as intended.\n\nWait, but in Python, I need to define the BinaryTreeNode class, but since the function doesn't include import statements, perhaps it's assumed that the class is already defined somewhere else, with attributes left_child and right_child, and data. So no problem for the function itself.\n\nSo the function seems to implement iterative in-order traversal correctly. So perhaps the code is correct.\n\nBut wait, in the while loop condition: while stack or current. So when current is not null, we proceed. But once inside, after adding the right child, the loop will run again because current could be non-null, or stack could have elements.\n\nYes, that's correct. Because after processing a node, it's possible that the right child has a subtree that needs to be processed, perhaps pushing more nodes. So the condition makes sense.\n\nSo I think the code is correct. It's an iterative approach for in-order traversal, efficient with O(n) time and O(n) space in the worst case (like a skewed tree). That should be fine.\n</think>\n\nTo solve this problem, we need to perform an in-order traversal of a given binary search tree (BST) and return the values in sorted order. The in-order traversal visits the left subtree, then the root node, and finally the right subtree. This traversal ensures that the values are returned in ascending order, which is a property of BSTs.\n\n### Approach\nThe approach to solve this problem involves using an iterative method with a stack to perform the in-order traversal. This method is efficient and avoids the potential stack overflow issues that can arise with recursive solutions for very large trees. Here's a step-by-step breakdown of the approach:\n\n1. **Initialization**: Start by checking if the root is `None`. If it is, return an empty list. Otherwise, initialize an empty stack to keep track of nodes and an empty list to store the result of the traversal.\n\n2. **Traversal Loop**: Use a while loop that continues as long as there are nodes in the stack or the current node is not `None`.\n\n3. **Inner Loop for Left Subtree**: Traverse to the leftmost node of the current subtree, pushing each node onto the stack along the way.\n\n4. **Process Node**: Once the leftmost node is reached (i.e., `current` becomes `None`), pop the top node from the stack, add its value to the result list, and set the current node to its right child.\n\n5. **Repeat**: The process continues, visiting nodes in the left subtree, then the root, and then moving to the right subtree until all nodes are processed.\n\nThis method ensures that each node is visited exactly once, leading to an efficient traversal with a time complexity of O(n) and a space complexity of O(n) in the worst case.\n\n### Solution Code\n```python\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        # Traverse to the leftmost node\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        # Visit the node\n        current = stack.pop()\n        result.append(current.data)\n        # Move to the right subtree\n        current = current.right_child\n    \n    return result\n```\n\n### Explanation\n- **Initialization**: The function starts by checking if the root is `None` and initializes the necessary data structures (stack and result list).\n- **Traversal Loop**: The outer loop ensures that nodes are processed as long as there are nodes in the stack or the current node is not `None`.\n- **Inner Loop for Left Subtree**: This loop traverses all the way to the leftmost node of the current subtree, pushing each encountered node onto the stack.\n- **Process Node**: After reaching the leftmost node, the top node is popped from the stack, its value is added to the result list, and the current node is set to its right child to continue the traversal.\n- **Efficiency**: The algorithm efficiently handles each node exactly once, making the time complexity O(n) and space complexity O(n) in the worst case, which is optimal for this problem.",
  "r1_solution": "def enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        # Traverse to the leftmost node\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        # Visit the node\n        current = stack.pop()\n        result.append(current.data)\n        # Move to the right subtree\n        current = current.right_child\n    \n    return result",
  "metadata": {
    "prompt_id": "00000051",
    "row_id": 51,
    "seed_ids": [
      358
    ],
    "mode": "algorithm",
    "original_instruction": "### Scenario\nYou are working on a project where you need to efficiently traverse a large Binary Search Tree (BST) and output the values in sorted order. Given the provided code snippet, you have been tasked with implementing an enhanced version of the inorder traversal.\n\n### Requirements\n1. **Function Specification**:\n    - Implement a function `enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]` that performs an inorder traversal on a given BST.\n    - The function should return a list of integers representing the values of the nodes in sorted order.\n2. **Input**:\n    - `root: BinaryTreeNode | None`: The root node of a BST. If `None`, the function should return an empty list.\n3. **Output**:\n    - A list of integers representing the values of the nodes in sorted order.\n4. **Constraints**:\n    - The maximum number of nodes in the tree is \\(10^5\\).\n    - The value of each node is an integer within the range \\([-10^9, 10^9]\\).\n5. **Optimization**:\n    - Use an iterative approach to avoid potential stack overflow issues with deep trees.\n    - Ensure the solution is efficient and handles edge cases properly.\n\n### Example\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\n# Function to test the solution\ndef check_solution(func):\n    tree = make_tree()\n    result = func(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n    print(\"Solution is correct.\")\n\n# Test the function\ncheck_solution(enhanced_inorder_traversal)\n```\n\n### Note\nEnsure your implementation is efficient and handles edge cases such as an empty tree or very deep trees. Use an iterative approach to avoid stack overflow issues."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results2.jsonl"
}