{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000051_C",
  "question": "def enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result",
  "solution": "from typing import List, Optional\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result",
  "test_code": "import pytest\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n\ndef test_enhanced_inorder_traversal_single_node():\n    root = BinaryTreeNode(10)\n    assert enhanced_inorder_traversal(root) == [10]\n\ndef test_enhanced_inorder_traversal_empty_tree():\n    assert enhanced_inorder_traversal(None) == []\n\ndef test_enhanced_inorder_traversal_balanced_tree():\n    tree = make_tree()\n    assert enhanced_inorder_traversal(tree) == [6, 10, 14, 15, 20, 25, 60]\n\ndef test_enhanced_inorder_traversal_degenerate_tree():\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    assert enhanced_inorder_traversal(root) == [10, 15, 25]\n\ndef test_enhanced_inorder_traversal_negative_numbers():\n    root = BinaryTreeNode(-10)\n    root.left_child = BinaryTreeNode(-20)\n    root.right_child = BinaryTreeNode(-5)\n    root.left_child.left_child = BinaryTreeNode(-30)\n    root.left_child.right_child = BinaryTreeNode(-15)\n    assert enhanced_inorder_traversal(root) == [-30, -20, -15, -10, -5]",
  "test_info": null,
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write an enhanced in-order traversal for a binary search tree (BST) and return the elements in sorted order. Let's think about how to approach this.\n\nWait, but wait\u2014what is in-order traversal exactly? From what I remember, in-order traversal visits the tree by first going as far left as possible, then visiting the root, and then proceeding to the right. This should naturally give elements in sorted order since it's a BST, right?\n\nSo the input is the root node. I need to handle if the root is None, in which case I return an empty list. Otherwise, I proceed with traversal.\n\nTrue, so the function is called enhanced_inorder_traversal, taking the root as an argument. Let me sketch the steps.\n\nI think using an iterative approach is better here to avoid recursion depth issues, especially if the tree is large. So I'll use a stack to help with the traversal.\n\nInitialize a stack and a result list. Also, a current pointer starting at root.\n\nThe algorithm goes like this: while the stack is not empty or current is not null, we enter the loop. Inside, we first traverse all the way to the left, pushing each node onto the stack. Once current becomes null (no more left children), we pop from the stack, add that node's data to the result, and then move to the right child. Repeat the process.\n\nWait, let me think through that again. So first, if current is not null, it means there's a left to explore. We push all the nodes on the path to the left onto the stack. When current becomes null (current.left is exhausted), we pop the stack top, which should be the leftmost node, add it to the result, then check its right child. \n\nThis way, the nodes are visited in the correct in-order sequence. For a BST, this should give the elements in ascending order.\n\nLet me think about a sample case. Suppose the BST is:\n\n   5\n  / \\\n3    7\n \\ \n  4\n\nIn-order traversal should be 3,4,5,7.\n\nLet me test it step by step.\n\nInitialize stack empty, result empty, current =5.\n\nIn loop:\n\nSince current is non-null, enter the while current loop.\n\nPush 5 to stack, current =5.left=3.\n\n3 is non-null, push it, current=3.left=null (assuming 3's left is none).\n\nCurrent is now null, so break inner loop. Pop 3 from stack, add to result. Now result is [3]. current =3.right=4.\n\nNow current is non-null. Again, enter inner loop: check current (4). current is non-null, but while current in the outer loop runs stack or current? Wait, after setting current=4, in the outer loop, since stack is now empty after pop, but current is non-null, so the loop continues.\n\nSo again, current is non-null. Let me re-examine. The outer while loop condition is stack or current. So when stack is empty but current is not null, the loop runs. So now, current is 4. We check inner loop: yes, current is non-null, so push it, then current becomes 4.left, which is null.\n\nSo stack has [5,4]. Wait, no, in the initial steps, when we first entered the while stack or current:\n\nWait, the initial step:\n\n- stack is empty, current is 5.\n\nSo enter outer loop because current is non-null.\n\nThen, in the inner loop: while current is not null, we push 5 to stack, set current to 5's left (3).\n\nAgain, inner loop: current is 3. Pushed, current becomes 3.left (null).\n\nInner loop exits because current is null.\n\nPop 3. Result becomes [3].\n\nSet current to 3.right=4.\n\nNow, current is 4.\n\nSo the outer loop continues because current is non-null.\n\nIn outer loop, stack is now [5]. Because we popped 3, stack is [5].\n\nWait no, initial steps:\n\nWait, when current was 5: pushed into stack. So stack is [5].\n\nThen current is 3: pushed, stack [5,3].\n\nCurrent becomes null.\n\nThen we pop 3 (count 1). Stack becomes [5].\n\nThen, current is set to 3.right=4.\n\nNow, in outer loop: stack is [5], and current is 4, so yes.\n\nWe check the inner loop: current is 4 (non-null), so push 4 into stack (stack [5,4]). current becomes 4.left, which is null.\n\nInner loop ends, now pop 4. Add to result, [3,4]. Set current to 4.right, which is null.\n\nSo now stack is back to [5], current is null.\n\nNext, outer loop continues since stack is not empty.\n\nPop 5 from stack, add to result. [3,4,5]. Current becomes 5.right=7.\n\nCurrent is 7, so stack becomes empty.\n\nNow, outer loop runs again because current is non-null.\n\nPush 7 into stack. Then current is 7's left (null). Inner loop ends.\n\nPop 7, add to result. [3,4,5,7]. set current to 7.right which is null.\n\nSo stack is empty, current is null. Outer loop exits.\n\nSo the final result is [3,4,5,7], which is correct.\n\nLooks like the logic works.\n\nNow what about edge cases? For example, a tree with only left children.\n\nTest case 2:\n\nTree is:\n\n1\n\n/\n\n2\n\n/\n\n3\n\nIn-order should be 1,2,3.\n\nLet's see:\n\ncurrent is 1, stack is empty.\n\nIn inner loop: current is non-null, push 1, current=left (which is 2).\n\nkeep going until current is 3 (all lefts), but let me simulate more carefully.\n\nInitially, current is 1.\n\nouter loop: stack is empty, current is 1. enter outer.\n\ninner: push 1, current becomes 1.left='2'.\n\ncurrent 2 is non-null, push, current=2.left=3.\n\ncurrent 3 is non-null, push, current=3.left=null.\n\nNow inner loop ends, stack is [1,2,3].\n\npop 3, add to result. result is [3]. current=3.right=null.\n\nWait no. Wait, this is in-order, so nodes are processed after left children.\n\nWait wait, maybe I wrote the simulation wrong.\n\nWait no\u2014the in-order should be 1, then 2, then 3. But in this simulation, the nodes would be popped in reverse order.\n\nWait wait a minute, here's a mistake in the simulation.\n\nWait, the stack will push node 1, then 2, then 3.\n\nBut in the stack, nodes are popped starting from 3.\n\nWait when we process the inner loop for current=1:\n\nTrue, so push 1, then current=1's left=2. again, push 2, then 2's left=3. push 3, current=3's left=null. inner loop exits. pop 3, add to result. So result starts with 3. Then current is 3's right (null).\n\nSo outer loop repeats: stack is [1,2].\n\nNow, current is null.\n\nWe enter outer loop again (because stack not empty). Pop 2, add to result (now [3,2]). current is 2's right (null).\n\nThen, in outer loop: stack is [1]. Pop 1, add to result. So [3,2,1]. That's not correct. Oh wait\u2014that can't be.\n\nWait this indicates a problem. In this case, the algorithm returns [3,2,1], but in-order should be [1,2,3], meaning this is incorrect.\n\nWait wait\u2014so what's wrong here?\n\nWait no, perhaps I messed up the case.\n\nWait, the tree in the test is 1 as root, 2 is left, and 3 is left of 2. So in in-order, you visit left, then root, then right. So for tree 1's left is 2, whose left is 3. So in-order should be 3,2,1? Or 1,2,3? Wait no, wait in-order traversal of a BST goes to the left, then root, then right. \n\nWait, in in-order traversal, for a BST that's a-linked list to the left, you go as far as possible, which in this case is the leftmost node. So when the tree is all to the left, the in-order traversal will first go to the farthest left, which is 3, then back to 2, then to 1. So the traversal is 3,2,1. Which is correct for in-order traversal, but wait, in a BST composed like this, in-order traversal will visit 3,2,1, right? Because it's a left-linear tree.\n\nSo in that case, perhaps the algorithm is correct. Because for this tree, in-order is indeed 3,2,1. But wait, no\u2014wait, the in-order traversal visits nodes in the order left, root, right. So for this left-skewed tree, let's see:\n\nStart with root (1). We go left to 2, then left to 3. No more left, so we add 3 to result. Then, backtrack to 2, add to result. Then backtrack to root 1, add it. So the result is [3,2,1], which is what the algorithm does.\n\nBut wait, if it's a BST, then 1's left is 2, which is larger than 1. But this isn't a valid BST. In a BST, the left node must be smaller than the parent. So this case might not be a BST but merely a binary tree. So perhaps the problem, since it's dealing with BST, this case is invalid.\n\nWait, the function is for a BST. So in a valid BST, if 1 is the root, the left child must have value less than 1. So in a BST, this case can't happen. Therefore, the test case I considered is not a valid BST. So perhaps the function is correct, given that the tree is a BST.\n\nSo the function works as expected for a BST.\n\nAnother test case: a single node. It should return a list with just that node's data.\n\nAnother test case: a tree where the left subtree is a chain to the left, and the right subtree is a chain to the right. In this case, the in-order traversal should correctly collect all the nodes in order.\n\nI think the logic works. So the code should be correct.\n\nNow, in the code, for each current, we first go as far left as possible, pushing to the stack. Then pop, add to result, move to right, and repeat.\n\nSo the function initializes stack and result as empty lists. current is set to root.\n\nIn Python, the code will be:\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n\nWait, but this uses a BinaryTreeNode, which I assume has attributes like left_child and data. I should make sure that the code correctly references these.\n\nWait, but in the problem statement, it's given as:\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n\nSo I assume that the BinaryTreeNode class has attributes left_child, right_child, and data.\n\nHmm. So, in the code, it's important that the stack stores the nodes, and each time we process the node after popping. Then, we point to the right child.\n\nYes, the code looks correct.\n\nTesting the earlier case where the tree is 5, I think it worked.\n\nSo, I think the code is correct.\n</think>\n\nTo solve this problem, we need to perform an in-order traversal on a given Binary Search Tree (BST) and return the elements in ascending order. The in-order traversal of a BST naturally visits nodes in ascending order, which makes it suitable for this task.\n\n### Approach\nThe approach involves using an iterative method with a stack to simulate the recursion stack and avoid potential issues with recursion depth limits in large trees. Here's a step-by-step breakdown of the approach:\n\n1. **Initialization**: Start with an empty stack to keep track of nodes and an empty result list to store the values in the order they are visited.\n2. **Traversal**: Use a while loop that continues as long as there are nodes in the stack or the current node is not null.\n3. **Left Subtree Exploration**: For each node, traverse all the way to the leftmost child, pushing each encountered node onto the stack.\n4. **Node Processing**: Once the leftmost child is reached (current becomes null), pop the top node from the stack, add its value to the result list, and move to its right child.\n5. **Repeat**: Continue this process until all nodes are processed.\n\nThis method ensures that nodes are visited in the correct in-order sequence: left subtree, root, right subtree.\n\n### Solution Code\n```python\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        # Traverse to the farthest left node, pushing each encountered node onto the stack\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        # Pop the stack to get the farthest left node and add it to the result\n        current = stack.pop()\n        result.append(current.data)\n        \n        # Proceed to the right child\n        current = current.right_child\n    \n    return result\n```\n\n### Explanation\n- **Initialization**: The function starts by checking if the root is null. If it is, it returns an empty list. Otherwise, it initializes the stack, result list, and current node.\n- **Traversal Loop**: The outer while loop ensures that we process nodes as long as there are nodes in the stack or the current node is non-null.\n- **Left Subtree Exploration**: The inner while loop pushes all nodes from the current node to the leftmost child onto the stack.\n- **Node Processing**: Once the inner loop exits (current is null), the top node from the stack is popped, its value is added to the result list, and we move to the right child of this node.\n- **Repeat**: This process continues until all nodes are processed, ensuring that each node is visited in the correct in-order sequence.\n\nThis approach efficiently handles the in-order traversal using an iterative method with a stack, making it suitable for large trees where recursion depth could be a concern.",
  "r1_solution": "def enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        # Traverse to the farthest left node, pushing each encountered node onto the stack\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        # Pop the stack to get the farthest left node and add it to the result\n        current = stack.pop()\n        result.append(current.data)\n        \n        # Proceed to the right child\n        current = current.right_child\n    \n    return result",
  "metadata": {
    "prompt_id": "00000051",
    "row_id": 51,
    "seed_ids": [
      358
    ],
    "mode": "algorithm",
    "original_instruction": "### Scenario\nYou are working on a project where you need to efficiently traverse a large Binary Search Tree (BST) and output the values in sorted order. Given the provided code snippet, you have been tasked with implementing an enhanced version of the inorder traversal.\n\n### Requirements\n1. **Function Specification**:\n    - Implement a function `enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]` that performs an inorder traversal on a given BST.\n    - The function should return a list of integers representing the values of the nodes in sorted order.\n2. **Input**:\n    - `root: BinaryTreeNode | None`: The root node of a BST. If `None`, the function should return an empty list.\n3. **Output**:\n    - A list of integers representing the values of the nodes in sorted order.\n4. **Constraints**:\n    - The maximum number of nodes in the tree is \\(10^5\\).\n    - The value of each node is an integer within the range \\([-10^9, 10^9]\\).\n5. **Optimization**:\n    - Use an iterative approach to avoid potential stack overflow issues with deep trees.\n    - Ensure the solution is efficient and handles edge cases properly.\n\n### Example\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\n# Function to test the solution\ndef check_solution(func):\n    tree = make_tree()\n    result = func(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n    print(\"Solution is correct.\")\n\n# Test the function\ncheck_solution(enhanced_inorder_traversal)\n```\n\n### Note\nEnsure your implementation is efficient and handles edge cases such as an empty tree or very deep trees. Use an iterative approach to avoid stack overflow issues."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results0.jsonl"
}