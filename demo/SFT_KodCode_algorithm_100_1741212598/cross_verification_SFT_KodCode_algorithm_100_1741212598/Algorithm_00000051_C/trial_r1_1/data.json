{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000051_C",
  "question": "def enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result",
  "solution": "from typing import List, Optional\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result",
  "test_code": "import pytest\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n\ndef test_enhanced_inorder_traversal_single_node():\n    root = BinaryTreeNode(10)\n    assert enhanced_inorder_traversal(root) == [10]\n\ndef test_enhanced_inorder_traversal_empty_tree():\n    assert enhanced_inorder_traversal(None) == []\n\ndef test_enhanced_inorder_traversal_balanced_tree():\n    tree = make_tree()\n    assert enhanced_inorder_traversal(tree) == [6, 10, 14, 15, 20, 25, 60]\n\ndef test_enhanced_inorder_traversal_degenerate_tree():\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    assert enhanced_inorder_traversal(root) == [10, 15, 25]\n\ndef test_enhanced_inorder_traversal_negative_numbers():\n    root = BinaryTreeNode(-10)\n    root.left_child = BinaryTreeNode(-20)\n    root.right_child = BinaryTreeNode(-5)\n    root.left_child.left_child = BinaryTreeNode(-30)\n    root.left_child.right_child = BinaryTreeNode(-15)\n    assert enhanced_inorder_traversal(root) == [-30, -20, -15, -10, -5]",
  "test_info": null,
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function called enhanced_inorder_traversal that takes a root of a BinaryTreeNode and returns a list of integers. The function should perform an inorder traversal on the binary search tree (BST) and return the node values in sorted order.\n\nWait, right, since it's a BST, an inorder traversal should naturally visit the nodes in ascending order. So this function is ensuring that the output is sorted. But in this case, maybe the function name is a bit confusing because the standard inorder traversal on a BST already gives sorted results. Hmm.\n\nLooking at the given code. The function starts by checking if the root is None, and if so, returns an empty list. That makes sense.\n\nThen, it initializes a stack and a result list. The current node is set to the root.\n\nThe loop continues as long as the stack is not empty or current is not None. Inside the loop, there's a while loop that pushes nodes onto the stack as it traverses to the leftmost child of the current node. Once there are no more left children, it pops the top of the stack, appends its data to the result, and then moves to the right child, repeating the process.\n\nWait, that's exactly the iterative method for inorder traversal. So the code seems correct. But wait, in some implementations, the order of checking stack or current might vary, but the logic here seems to handle all cases.\n\nLet me think about potential issues. What if the tree is empty? That's handled by the initial check. What if there's only one node? It should correctly process it. What about a normal tree with multiple levels? The stack should correctly capture the left, root, right order.\n\nI think the code is correct. So maybe I don't need to change anything. But the user asked me to write the code, but the assistant is supposed to write the thought process before the code. Hmm.\n\nWait, maybe I should consider if the BinaryTreeNode has the correct attributes. Looking at the given code, it uses current.left_child and current.right_child, and current.data. So I need to make sure that the BinaryTreeNode class has these attributes. So when defining the BinaryTreeNode, it should have left_child and right_child as pointers to child nodes, and data as the value.\n\nSo the function is correctly assuming that the nodes have these attributes.\n\nTherefore, the code seems correct as is.\n\nWait, maybe test cases could help. Let me think of a small tree. For example, a tree with nodes 4, 2, 5, 1, 3. Inorder traversal should give 1, 2, 3, 4, 5.\n\nWhat would the code do? The stack starts empty, current is 4.\n\nFirst loop: stack is empty and current is not null. So enter the while loop, current is 4, push to stack. Then current becomes 2. Push. Then 1, push. Current becomes null. So the inner loop ends. Pop 1, append to result. Current becomes 1's right child, which could be null. Now stack has [4, 2]. Next iteration, current is null, so stack is not empty, so the outer loop continues. Pop 2, append. Set current to 3. Now, process 3: current becomes 3's left, but maybe it doesn't exist, so process: current becomes 3's right, which might be null. So, pop, append 3. Then current is 3's right is null, so in the next iteration, the stack is [4], and current is null. Pop 4, append. Then current is 5. Proceed to push 5 into the stack if possible. So, then append 5.\n\nThe result is 1,2,3,4,5. Correct.\n\nSo the code works for that scenario.\n\nWhat about a tree where current has no left child? Let me see. Suppose the tree is 3, with right child 4, and right's right is 5. So structure is 3 -> null on left, right is 4; 4's right is 5. The traversal should be 3,4,5. Let's see.\n\nCurrent is 3. While loop: since 3's left is null, the inner loop doesn't run. Stack is empty, so the outer loop proceeds. Check stack or current: current is 3, which is non-null.\n\nWait, no. Wait, the code's outer loop is while stack or current. So first iteration: stack is empty, current is 3, so loop runs.\n\nInside, current is 3, which is non-null: we enter the inner loop and try to push current's left. But 3's left is null, so the inner loop doesn't add anything. So stack is still empty.\n\nWait no, wait. Wait in the code's inner loop: while current: stack.append, current = current.left_child.\n\nSo when current is 3, we check if current is non-null, which it is. So push 3 into stack. Then set current to current.left, which is null. So inner loop exits. Then pop stack, which is 3, add to result, then current becomes 3's right, which is 4.\n\nNow, in the next iteration, stack is empty, current is 4.\n\nAgain, the outer loop runs because current is non-null.\n\nInside, current is 4: we process the inner loop.\n\ncurrent is 4, left_child is say, null? Then current becomes 4's left (null). So no push occurs.\n\nPop stack: but wait, the stack is empty here. Wait, let's see.\n\nWait, after popping 3, the stack is empty, and current is set to 4. Now, the next iteration of the outer loop: stack is empty but current is 4. The outer loop runs again.\n\nIn the outer loop:\n\nCheck stack or current: current is 4, so enter.\n\nIn the inner loop: while current is not null, since current is 4, current is non-null. So push 4 into stack (stack becomes [4]), then set current to current.left (4's left may be null). So inner loop ends.\n\nThen, stack.pop() is 4, add to result. current becomes 4's right, which may be 5.\n\nOuter loop continues because stack is now empty but current is 5.\n\nNext iteration: check stack is empty and current is 5, so enter.\n\nInner loop: current is 5, not null. So push 5, current becomes 5's left (null). So inner loop ends.\n\nPop 5, add to result, current becomes 5's right, which is null.\n\nStack is now empty again.\n\nNext iteration: current is null, stack is empty, so outer loop exits.\n\nWait no, when current is 4's right child (5), after popping 4:\n\nWait, perhaps I made a mistake in thinking about this.\n\nWait, initial steps: after processing 3, stack is empty, result is [3], current is 4.\n\nOuter loop: stack is empty, current is 4: so enter.\n\nInner loop: current is 4 (non-null). So push 4, current becomes 4's left, which is null.\n\nNow, stack is [4]. Pop, add to result ([3,4]), current becomes 4's right, 5.\n\nNow, stack is empty, current is 5.\n\n Outer loop continues: stack is empty, current is 5: enter.\n\n Inner loop: current is 5, so push 5 to stack, current becomes 5's left, which may be null.\n\n Stack now is [5].\n\n Pop 5, add to result, current becomes 5's right (null).\n\n Now stack is empty, current is null.\n\n Outer loop checks: stack is empty, current is null: exit.\n\nSo the result is [3,4,5], which is correct.\n\nYes, the code works.\n\nAnother test case: left-only tree. Say, root is 5, left child 4, which has left child 3, which has left child 2, which has left child 1. Inorder traversal is 1,2,3,4,5.\n\nThe code should:\n\nstack starts empty, current 5.\n\nEnter outer loop: process:\n\ncurrent is 5: inner loop runs, pushing 5, current becomes 4.\n\nPush 4, current 3. Push, current 2. Push, current 1. Push, current null.\n\nStack is [5,4,3,2,1]. Now pop 1, add to result, current becomes null.\n\nNext, stack has 5,4,3,2, and current is null. So stack not empty.\n\nPop 2, add, current is 2's right (null). Then pop 3, add, current null. Then pop 4, add, current null. Then pop 5, add, current null.\n\nSo result is [1,2,3,4,5]. Correct.\n\nThus, the code seems to be correct.\n\nHmm. So I think the code is correct as is. So perhaps I don't need to change anything. The user just pasted the code and said to write the function, but since the code is correct, maybe this is the correct version.\n\nWait, perhaps the stack is not needed, but the given code uses a stack, which is fine.\n\nAlternatively, a recursive approach would be straightforward, but the given code uses the iterative approach, which avoids recursion depth issues, perhaps better for large trees.\n\nSo, the code is correct and should be used as is.\n</think>\n\nTo solve this problem, we need to perform an inorder traversal on a given binary search tree (BST) and return the node values in sorted order. In a BST, an inorder traversal naturally visits nodes in ascending order, so the result of this traversal will be a sorted list of node values.\n\n### Approach\nThe approach to solve this problem involves using an iterative method with a stack to simulate the recursion stack used in the standard inorder traversal. The steps are as follows:\n\n1. **Initialization**: Start with an empty stack and an empty result list. Set the current node to the root of the BST.\n2. **Traversal**: Continue the traversal as long as there are nodes in the stack or the current node is not null.\n3. **Left Traversal**: Move to the leftmost child of the current node, pushing each node onto the stack until no more left children are available.\n4. **Visit Node**: Once the leftmost child is reached (current becomes null), pop the top node from the stack, visit it by adding its value to the result list, and then move to its right child.\n5. **Repeat**: Continue the process until all nodes are visited.\n\nThis approach ensures that nodes are visited in the correct order without using recursion, thus avoiding potential stack overflow issues with deep trees.\n\n### Solution Code\n```python\nclass BinaryTreeNode:\n    def __init__(self, data):\n        self.data = data\n        self.left_child = None\n        self.right_child = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result\n```\n\n### Explanation\n- **Initialization**: The function starts by checking if the root is null, returning an empty list if true. Otherwise, it initializes the stack and result list, and sets the current node to the root.\n- **Outer Loop**: The outer loop runs as long as there are nodes in the stack or the current node is not null.\n- **Left Traversal**: The inner loop moves to the leftmost child, pushing nodes onto the stack.\n- **Visit Node**: When the current node becomes null, the top node is popped from the stack, its value is added to the result, and the current node is set to the right child of the popped node.\n- **Repeat**: This process continues, ensuring nodes are visited in left, root, right order, resulting in a sorted list of node values.\n\nThis method efficiently traverses the BST using an iterative approach, ensuring the result is in sorted order as expected from an inorder traversal of a BST.",
  "r1_solution": "class BinaryTreeNode:\n    def __init__(self, data):\n        self.data = data\n        self.left_child = None\n        self.right_child = None\n\ndef enhanced_inorder_traversal(root: BinaryTreeNode | None) -> List[int]:\n    \"\"\"\n    Performs an inorder traversal on a given BST and returns the values in sorted order.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        current = stack.pop()\n        result.append(current.data)\n        current = current.right_child\n    \n    return result",
  "metadata": {
    "prompt_id": "00000051",
    "row_id": 51,
    "seed_ids": [
      358
    ],
    "mode": "algorithm",
    "original_instruction": "### Scenario\nYou are working on a project where you need to efficiently traverse a large Binary Search Tree (BST) and output the values in sorted order. Given the provided code snippet, you have been tasked with implementing an enhanced version of the inorder traversal.\n\n### Requirements\n1. **Function Specification**:\n    - Implement a function `enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]` that performs an inorder traversal on a given BST.\n    - The function should return a list of integers representing the values of the nodes in sorted order.\n2. **Input**:\n    - `root: BinaryTreeNode | None`: The root node of a BST. If `None`, the function should return an empty list.\n3. **Output**:\n    - A list of integers representing the values of the nodes in sorted order.\n4. **Constraints**:\n    - The maximum number of nodes in the tree is \\(10^5\\).\n    - The value of each node is an integer within the range \\([-10^9, 10^9]\\).\n5. **Optimization**:\n    - Use an iterative approach to avoid potential stack overflow issues with deep trees.\n    - Ensure the solution is efficient and handles edge cases properly.\n\n### Example\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\n# Function to test the solution\ndef check_solution(func):\n    tree = make_tree()\n    result = func(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n    print(\"Solution is correct.\")\n\n# Test the function\ncheck_solution(enhanced_inorder_traversal)\n```\n\n### Note\nEnsure your implementation is efficient and handles edge cases such as an empty tree or very deep trees. Use an iterative approach to avoid stack overflow issues."
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}