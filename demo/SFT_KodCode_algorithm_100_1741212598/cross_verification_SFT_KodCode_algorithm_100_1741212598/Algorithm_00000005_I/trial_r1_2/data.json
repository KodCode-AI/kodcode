{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000005_I",
  "question": "### Scenario\n\nYou are given a sorted list of integers and a target sum. Your task is to implement a function that finds the indices of the two numbers in the list that add up to the target sum using the two-pointer technique.\n\n### Requirements\n\n- **Function Name**: `two_sum_indices`\n- **Input**:\n  - A list of integers, `nums`, which is sorted in non-decreasing order.\n  - An integer, `target`, representing the target sum.\n- **Output**:\n  - Return a list of two integers, representing the indices of the two numbers in `nums` that add up to `target`. If no such pair exists, return an empty list.\n\n### Constraints\n\n- The length of `nums` will be in the range \\([2, 10^4]\\).\n- The elements of `nums` will be in the range \\([-10^9, 10^9]\\).\n- There will be exactly one solution, and you may not use the same element twice.\n- `nums` is sorted in non-decreasing order.\n\n### Example\n\n```python\ndef test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()\n```\n\n### Performance Requirements\n\nThe function should run efficiently, with a time complexity of \\(O(n)\\) and a space complexity of \\(O(1)\\).\n\n### Question\n\nImplement the `two_sum_indices` function.",
  "solution": "def two_sum_indices(nums, target):\n    \"\"\"\n    Returns the indices of the two numbers in nums that add up to target.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
  "test_code": "def test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()",
  "test_info": [
    {
      "function_name": "two_sum_indices",
      "parameter_list": "(nums, target)",
      "function_declaration": "def two_sum_indices(nums, target):",
      "docstring": "Returns the indices of the two numbers in nums that add up to target."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function called two_sum_indices that finds the indices of two numbers in a sorted list that add up to a target sum. Hmm, the list is sorted in non-decreasing order. Oh right, the two-pointer technique is required here. I remember that technique is efficient, O(n) time, which fits with the performance requirement.\n\nLet me think about how the two-pointer method works. We start with two pointers, one at the beginning (left) and one at the end (right) of the list. Then, we calculate the sum of the elements at these pointers. If the sum is equal to the target, we return the indices. If it's less than the target, we move the left pointer to the right to increase the sum. If it's more, we move the right pointer to the left to decrease the sum.\n\nWait, but how about duplicates? Oh, in the example given, there's a test case with [1,3,3] and target 6, which returns [1,2]. So the pointers can converge on different positions even if the same value is present.\n\nSo the steps are:\n\n1. Initialize left to 0 and right to len(nums) - 1.\n2. While left < right:\n   a. Calculate current_sum = nums[left] + nums[right]\n   b. If current_sum == target: return [left, right]\n   c. If current_sum < target: move left pointer one step to the right.\n   d. Else: move right pointer one step to the left.\n3. If we exit the loop without finding, return empty list.\n\nBut wait, I need to return the indices, not the values.\n\nI think this should handle all cases even with duplicates because the pointers will traverse all possible pairs in a single pass.\n\nLet's check the example from the test cases.\n\nTest case 1: nums = [2,7,11,15], target = 9. \nLeft is 0 (2), right is 3 (15). Sum is 17 >9, so move right to 2. Now sum is 2+11=13>9. Move right to 1. 2+7=9: yes, return [0,1].\n\nAnother test case: target is 17. Initial sum is 2+15=17: so right away, return [0,3].\n\nTest case where the sum is 18: nums = [2,7,11,15]. 2+15=17, then 7+15=22>18. Wait, no: initial step left=0, right=3. sum 17 <18, so move left to 1. Now sum is 7+15=22 >18: move right to 2. Now 7+11=18: return [1,2].\n\nAnother example: [1,3,3], target 6: 1 +3 =4 <6, so move left to 1. 3+3=6: return [1,2]. That makes sense.\n\nWhat about a case where multiple pairs sum to the target? Wait, the problem says that there will be exactly one solution, so no need to handle multiple possibilities.\n\nWhat if there's no such pair? Like [1,2,3] target 6. Wait sum is 1+3=4, then 1+2=3 (no). Or wait, 1+2=3, 2+3=5. So in that case, the function returns empty.\n\nBut wait, in the test case given, [1,2,3], target is 6, which returns empty. Correct.\n\nAnother test case: [3*i for i in range(10)] which is [0,3,6,...,27]. Target is 19. Hmm, let's see. The pair needs to add to 19. Let me compute 3*i +3*j=19. But 3(i+j) =19: 19 is not divisible by 3. So no solution, returns empty.\n\nNow, for the code.\n\nFunction definition: def two_sum_indices(nums, target):\n\nWe need to get two pointers.\n\nInitialize left = 0, right = len(nums)-1.\n\nLoop while left < right:\n\n   sum_ = nums[left] + nums[right]\n\n   if sum_ == target: return [left, right]\n\n   elif sum_ < target: left +=1\n\n   else: right -=1\n\nIf no solution found after loop, return empty list.\n\nBut wait, the problem statement says that \"you may not use the same element twice\". So pointers must be different, which is ensured by left < right.\n\nBut how about if the array has multiple elements with the same value, but we can't reuse the same index.\n\nWait, for example, the list [2,2] with target 4. Then the function would return [0,1].\n\nIn our initial code, it would work because left is 0, right is 1. Sum is 4, returns [0,1].\n\nSo the code seems to handle that case.\n\nWhat about a list where all elements are the same, but it's longer than two elements?\n\nBut the problem states that there's exactly one solution. So in the test cases, it's designed to have only one possible pair.\n\nSo the code should handle them all.\n\nImplement this logic in Python.\n\nNow, test the example given in the problem:\n\ntest_two_sum_indices():\n\nLooking at the first test case, when called with [2,7,11,15], target 9, the function should return [0,1], which it should.\n\nWhat about the target 8? In [2,7,11,15], since 2+7=9>8, 2+11=13>8, etc. It will check and find no pair. So returns empty list, which is correct.\n\nAnother test case: [1,3,3], target 6: function correctly returns [1,2].\n\nSo the code seems solid.\n\nI think that's the plan. Now write the function.\n</think>\n\nTo solve this problem, we need to find the indices of two numbers in a sorted list that add up to a given target sum using the two-pointer technique. This technique is efficient and works well with sorted lists, ensuring a linear time complexity.\n\n### Approach\n1. **Initialization**: We start by initializing two pointers, `left` at the beginning of the list and `right` at the end.\n2. **Traversal**: While `left` is less than `right`:\n   - Calculate the sum of the elements at the `left` and `right` pointers.\n   - If this sum equals the target, return the indices `[left, right]`.\n   - If the sum is less than the target, move the `left` pointer to the right to increase the sum.\n   - If the sum is greater than the target, move the `right` pointer to the left to decrease the sum.\n3. **Completion**: If the loop completes without finding a pair that sums to the target, return an empty list.\n\nThis approach efficiently narrows down the potential pairs by adjusting the pointers based on the comparison of the current sum and the target.\n\n### Solution Code\n\n```python\ndef two_sum_indices(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n```\n\n### Explanation\n- **Initialization**: The pointers start at the extreme ends of the list.\n- **Sum Calculation**: For each iteration, the sum of the values at the current pointers is calculated.\n- **Adjustment**: Depending on whether the sum is less than, greater than, or equal to the target, one of the pointers is adjusted to find the correct pair.\n- **Efficiency**: This method runs in O(n) time complexity as each element is visited at most once, making it very efficient for large lists.\n\nThis approach ensures that we find the correct pair of indices in a single pass through the list, making it both time and space efficient.",
  "r1_solution": "def two_sum_indices(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
  "metadata": {
    "prompt_id": "00000005",
    "row_id": 5,
    "seed_ids": [
      716
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results2.jsonl"
}