{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000005_I",
  "question": "### Scenario\n\nYou are given a sorted list of integers and a target sum. Your task is to implement a function that finds the indices of the two numbers in the list that add up to the target sum using the two-pointer technique.\n\n### Requirements\n\n- **Function Name**: `two_sum_indices`\n- **Input**:\n  - A list of integers, `nums`, which is sorted in non-decreasing order.\n  - An integer, `target`, representing the target sum.\n- **Output**:\n  - Return a list of two integers, representing the indices of the two numbers in `nums` that add up to `target`. If no such pair exists, return an empty list.\n\n### Constraints\n\n- The length of `nums` will be in the range \\([2, 10^4]\\).\n- The elements of `nums` will be in the range \\([-10^9, 10^9]\\).\n- There will be exactly one solution, and you may not use the same element twice.\n- `nums` is sorted in non-decreasing order.\n\n### Example\n\n```python\ndef test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()\n```\n\n### Performance Requirements\n\nThe function should run efficiently, with a time complexity of \\(O(n)\\) and a space complexity of \\(O(1)\\).\n\n### Question\n\nImplement the `two_sum_indices` function.",
  "solution": "def two_sum_indices(nums, target):\n    \"\"\"\n    Returns the indices of the two numbers in nums that add up to target.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
  "test_code": "def test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()",
  "test_info": [
    {
      "function_name": "two_sum_indices",
      "parameter_list": "(nums, target)",
      "function_declaration": "def two_sum_indices(nums, target):",
      "docstring": "Returns the indices of the two numbers in nums that add up to target."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to implement the two_sum_indices function using the two-pointer technique. Let me think about how to approach this.\n\nThe function takes a sorted list of integers, nums, and a target sum. I have to find two different elements that add up to the target and return their indices. And if no such pair exists, return an empty list.\n\nHmm, since the list is sorted, the two-pointer approach makes sense. This technique is efficient and has O(n) time complexity, which meets the performance requirement.\n\nSo how does the two-pointer approach work? Well, I remember that we typically use one pointer starting at the beginning (left = 0) and another at the end (right = len(nums) -1) of the list. Then, we calculate the sum of the elements at these pointers. Depending on whether this sum is greater than, less than, or equal to the target, we move the pointers accordingly.\n\nWait, for this problem, we need to find two distinct elements. The problem statement says that there's exactly one solution, so I can stop once I find the pair.\n\nBut in this problem, there could be duplicates. Like the test case [1,3,3], target 6: the correct indices are 1 and 2, as 3+3=6.\n\nLet me outline the steps:\n\n1. Initialize two pointers, left at 0 and right at the end of the list.\n2. While left < right:\n   a. Calculate current_sum = nums[left] + nums[right]\n   b. If current_sum == target: return [left, right]\n   c. Else if current_sum < target: move left pointer to the right (left += 1), because we need a larger number.\n   d. Else: move right pointer to the left (right -= 1), because we need a smaller number.\n3. If the loop exits without finding a pair, return an empty list.\n\nBut wait, are there any edge cases I need to handle? Let's think.\n\nFor example, what if the two same elements in the middle are the ones that add up to the target? Like in the test case [1,3,3], when target is 6.\n\nIn the two-pointer method, suppose left starts at 0, right at 2 (nums[2] is 3). sum is 1+3=4 <6, so we move left to 1. Now nums[1] is 3, right is 2. sum is 3+3=6, which is correct. So that should return [1,2] as required.\n\nAnother test case: what if the list has negative numbers? Like [-2, 3, 4], target is 2. The pair is -2 and 4, so indices 0 and 2. Let me see how the pointers would work here.\n\nLeft=0 (num=-2), right=2 (4): sum is -2+4=2, which is the target. So yes, it returns [0,2].\n\nWhat about an empty list? No, the length of nums is at least 2 according to the constraints, so we don't need to handle empty lists.\n\nWhat about if multiple pairs sum to the target but the function should return the correct one. Since the problem statement says there's exactly one solution, so the function can stop at the first occurrence. But wait, no. Wait, the problem says, \"exactly one solution.\" So I can stop once I find the pair.\n\nWait, no\u2014Wait, no, I think the problem says that there is exactly one solution. So the function can return immediately upon finding it, right.\n\nTesting that: for example, in the list [2,7,11,15], if target is 9, the pair is 0 and 1 (2+7=9). The two-pointer method will find that quickly.\n\nHmm, what if the list is [1,2,3,4], target 5? The possible pairs are 0-1 (1+2=3), 0-2 (4), 0-3 (5?), wait: 1+4=5. So left is 0, right is 3.\n\nsum 1+4=5: yes, so return [0,3].\n\nBut maybe there is another pair, like 1 and 3 (2+3=5). But since the list is sorted, and once a pair is found, the function can return it. But according to the two-pointer method, in this case, the first pair would be 0 and 3. Because left starts at 0, right at 3.\n\nSo the two-pointer method might not find all possible pairs, but in the problem statement, it's given that exactly one solution exists. So perhaps the two-pointer method is guaranteed to find it.\n\nWait, but in reality, if you have a list with only two elements, you just check those two.\n\nSo the two-pointer approach should work for finding any possible pair in a sorted list.\n\nOkay, how to implement this in Python.\n\nThe function:\n\ndef two_sum_indices(nums, target):\n\nInitialize left and right pointers. Iterate while left < right.\n\nCompute current sum. Check each condition.\n\nBut wait, what about when there's a duplicate. Like in the test case [2,7,11,15], target 17: 2+15=17, which is correct. The code should return [0,3].\n\nAnother test case: [2,7,11,15], target 18: 7+11=18, so indices [1,2]. The method would start with left=0 (2+15=17 <18, so left increases to 1). Now 7 +11=18? Let's see right is at index 3 (15), but wait:\n\nWait, in the beginning, left=0 and right=3.\n\nsum is 2+15=17 <18. So move left to 1.\n\nNow left=1 (7), right=3 (15). sum is 22, which is >18. So we move right to 2.\n\nNow right is 2, so left=1, right=2.\n\nSum 7+11=18. So return [1,2]. Yes, that works.\n\nSo code steps:\n\nInitialize left = 0, right = len(nums) -1.\n\nLoop while left < right:\n\nsum = nums[left] + nums[right]\n\nif sum == target: return [left, right]\n\nelif sum < target: left +=1\n\nelse: right -=1\n\nIf loop ends without finding, return empty list.\n\nWhat about when nums has even length, but no two elements sum to target? The loop will just end and return empty.\n\nSo implementing that.\n\nBut wait, what about cases where moving left or right may skip over possible pairs?\n\nBut in a sorted list, once a certain sum is not equal to target, moving left or right as per the two-pointer technique will not miss any possibilities. Because, if the current sum is less than target, moving left up will help in getting a larger sum.\n\nSo the code should be correct.\n\nNow, test cases:\n\nTest case 1: [2,7,11,15], target 9. The code should return [0,1].\n\nLet's see:\n\nleft=0, right=3. sum=2+15=17>9. So move right to 2. Now right is 11. sum 2+11=13>9: move right to1. Now sum 2+7=9: correct. So return [0,1]. Correct.\n\nAnother test case: [1,3,3], target 6.\n\nleft=0 (1), right=2 (3). sum 1+3=4 <6: move left to 1 (3). sum=3+3=6. So return [1,2].\n\nAnother test case: [2,7,11,15], target 8.\n\nsum is:\n\nloop:\n\nleft=0 (2), right=3 (15): sum 17>8. move right to 2 (11). sum 2+11=13>8: move right to 1 (7). sum=9>8: move right to 0. Now left is equal to right or beyond. So return empty.\n\nWhich is correct.\n\nWhat about the test case where the list has larger numbers, and no possible pair.\n\nLike the test case [3*i for i in range(10)], target 19.\n\nWait, 3*0 is 0, then 3,6,9,...,27.\n\nLooking for a pair that sums to 19. Let's see:\n\nLooking through the pairs:\n\n0+3=3: no.\n\nBut probably, no two elements sum to 19 here. Let the code handle it.\n\nAnother test case: [1,2,3], target=6. The code will try 1+3=4<6. Move left to 1: 2+3=5<6. Move left to 2: left >= right, so no. So return empty. Which is correct.\n\nWhat about duplicates beyond the immediate next element? Like [2,2,3], target 4. The code will have left=0,2? Let's see.\n\nsum 2+3=5>4. So move right to 1. Then left=0, right=1: sum is 2+2=4. So return [0,1]. Correct.\n\nYes, that scenario is handled.\n\nSo I think the code will handle all the cases correctly.\n\nSo, now write the function.\n\nWait, code structure:\n\ndef two_sum_indices(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\nThat's it.\n\nNow, let me test for the case where the sum is found elsewhere. Like in a list like [1,4,5,6,7], target 11.\n\nThe possible pairs:\n\n1+10? No. 4+7=11.\n\nTwo-pointer steps:\n\nleft=0 (1) and right=4 (7): sum is 8 <11: move left to 1 (4). sum 4+7=11: found. return [1,4].\n\nWhich is correct.\n\nYes, the code should handle that.\n\nAnother case: what if there's a case where the pair is in the middle, but due to some movement, would it not be found? I don't think so.\n\nHmm, perhaps if the list is strictly increasing but requires moving beyond certain points, but since the list is sorted, any solution would be found.\n\nThus, the code should be correct.\n</think>\n\nTo solve this problem, we need to find the indices of two distinct numbers in a sorted list that add up to a given target sum using the two-pointer technique. This approach ensures an efficient solution with a time complexity of \\(O(n)\\) and a space complexity of \\(O(1)\\).\n\n### Approach\n1. **Initialization**: Start with two pointers, one at the beginning (`left`) and one at the end (`right`) of the list.\n2. **Iteration**: Continue iterating while `left` is less than `right`.\n3. **Sum Calculation**: Calculate the sum of the elements at the `left` and `right` pointers.\n4. **Comparison**:\n   - If the sum equals the target, return the indices `[left, right]`.\n   - If the sum is less than the target, move the `left` pointer to the right to increase the sum.\n   - If the sum is greater than the target, move the `right` pointer to the left to decrease the sum.\n5. **Termination**: If the loop completes without finding a pair, return an empty list indicating no such pair exists.\n\nThis method efficiently narrows down potential pairs by leveraging the sorted property of the list, ensuring that each element is checked only once.\n\n### Solution Code\n```python\ndef two_sum_indices(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n```\n\n### Explanation\n- **Initialization**: The `left` pointer starts at the beginning of the list (index 0), and the `right` pointer starts at the end (index len(nums) - 1).\n- **Iteration**: The loop runs as long as `left` is less than `right`, ensuring all possible pairs are checked without repetition.\n- **Sum Calculation**: For each iteration, the sum of the elements at the current `left` and `right` positions is computed.\n- **Comparison and Adjustment**: Depending on whether the current sum is less than, greater than, or equal to the target, the pointers are adjusted to hone in on the target sum efficiently.\n- **Termination**: If a valid pair is found, their indices are returned immediately. If no pair is found by the end of the loop, an empty list is returned.\n\nThis approach ensures that each element is checked in linear time, making it both time and space efficient.",
  "r1_solution": "def two_sum_indices(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
  "metadata": {
    "prompt_id": "00000005",
    "row_id": 5,
    "seed_ids": [
      716
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}