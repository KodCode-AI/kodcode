{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000005_I",
  "question": "### Scenario\n\nYou are given a sorted list of integers and a target sum. Your task is to implement a function that finds the indices of the two numbers in the list that add up to the target sum using the two-pointer technique.\n\n### Requirements\n\n- **Function Name**: `two_sum_indices`\n- **Input**:\n  - A list of integers, `nums`, which is sorted in non-decreasing order.\n  - An integer, `target`, representing the target sum.\n- **Output**:\n  - Return a list of two integers, representing the indices of the two numbers in `nums` that add up to `target`. If no such pair exists, return an empty list.\n\n### Constraints\n\n- The length of `nums` will be in the range \\([2, 10^4]\\).\n- The elements of `nums` will be in the range \\([-10^9, 10^9]\\).\n- There will be exactly one solution, and you may not use the same element twice.\n- `nums` is sorted in non-decreasing order.\n\n### Example\n\n```python\ndef test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()\n```\n\n### Performance Requirements\n\nThe function should run efficiently, with a time complexity of \\(O(n)\\) and a space complexity of \\(O(1)\\).\n\n### Question\n\nImplement the `two_sum_indices` function.",
  "solution": "def two_sum_indices(nums, target):\n    \"\"\"\n    Returns the indices of the two numbers in nums that add up to target.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
  "test_code": "def test_two_sum_indices():\n    assert two_sum_indices([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum_indices([2, 7, 11, 15], 17) == [0, 3]\n    assert two_sum_indices([2, 7, 11, 15], 18) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 26) == [2, 3]\n    assert two_sum_indices([1, 3, 3], 6) == [1, 2]\n    assert two_sum_indices([2, 7, 11, 15], 8) == []\n    assert two_sum_indices([3 * i for i in range(10)], 19) == []\n    assert two_sum_indices([1, 2, 3], 6) == []\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_two_sum_indices()",
  "test_info": [
    {
      "function_name": "two_sum_indices",
      "parameter_list": "(nums, target)",
      "function_declaration": "def two_sum_indices(nums, target):",
      "docstring": "Returns the indices of the two numbers in nums that add up to target."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to implement the two_sum_indices function. The task is to find two numbers in a sorted list that add up to a target sum and return their indices. Hmm, let's think about this.\n\nSo the input is a sorted list of integers and a target. Since the list is sorted and I have to use the two-pointer technique, that's probably the way to go because it's efficient, O(n) time.\n\nWait, how does the two-pointer method work here? Oh right, one pointer starts at the beginning (left) and the other at the end (right). I add the elements at these pointers. If the sum is less than the target, I move the left pointer forward to get a larger number. If it's more, I move the right pointer backward. Continue this until I find the pair or the pointers cross each other.\n\nBut wait, the function needs to return the indices. So I have to track those as I move the pointers. That's manageable.\n\nLet me outline the steps:\n\n1. Initialize left at 0 and right at len(nums)-1.\n2. Loop while left < right.\n3. Calculate current sum: nums[left] + nums[right].\n4. If sum equals target, return [left, right].\n5. If sum is less than target, increment left by 1 to try a larger number.\n6. If sum is greater, decrement right by 1 to try a smaller number.\n7. If the loop ends without finding the pair, return an empty list.\n\nBut wait, what about duplicate numbers? Like in the example [1,3,3], the function returns [1,2], which is correct because 3+3=6. So the algorithm should work with duplicates because the pointers approach from both ends and will eventually find the correct pair if it exists.\n\nLet's think about edge cases:\n\n- What if multiple pairs add up to the target? According to the problem statement, there's exactly one solution, so I don't need to handle that. So in that case, the first pair found would just be the correct one.\n- What if the list has only two elements? Then if they add up to target, return [0,1]; else, return empty.\n- What about negative numbers? Since the list is sorted, same approach applies.\n\nBut wait, no. Negative numbers in the list? Because when adding, there are cases where left and right might point to the correct pair even if one is negative. The two-pointer approach should handle that because it's dependent on the relative sum.\n\nWait, for example, in the case of [ -3, 1, 4], target 0: left is 0 pointing to -3, right pointing to 1: sum is -2 < 0: so increment left. Now left is 1, adding to 1 and 4 gives 5 >0. So decrement right, now right is 2 not possible, loop ends. So it doesn't find, but in reality -3 and 3 would be a pair if they exist. Wait, no, in this example, the target is 0, and possible pairs are -3+1 = -2, -3+4=1, 1+4=5. So no pair, which is correct.\n\nAnother case: [ -2, -1, 4, 5], target 3. Let's see: left is 0 (-2), right 3 (5). Sum is 3: record [0,3]? Wait, but wait, the sum is 3 == target, so yes.\n\nWait no, in [ -2, -1, 4, 5], looking for sum 3: -2 and 5: sum 3. So that's correct. The function would return [0, 3].\n\nSo the algorithm would handle that because when sum is 3, it's a match.\n\nAnother case: sorted list with all negatives? Like [-5,-4], target -9: (-5)+(-4)= -9 \u2192 return [0,1]. That should work.\n\nWait, the list is sorted in non-decreasing order. So for example, [-5,-4,-3], target -7: it would find either (-4 and -3) or (-5 and -2, but no). So in this case, if target is -7, the sum of -3 and -4 is -7. So left is 0 (-5), right is 2 (-3): sum is -8 < target (since -8 < -7). So left increments to 1. Now left is 1 (-4), right is 2 (-3): sum is -7 \u2192 match, return [1,2].\n\nYes, correct.\n\nSo the algorithm seems solid.\n\nNow, implementing it.\n\nInitialize left = 0, right = len(nums) -1.\n\nLoop while left < right:\n\nCompute current_sum.\n\nIf current_sum == target, return [left, right].\n\nElse if current_sum < target: increment left (since the list is sorted, larger numbers are on the right, so moving left rightwards may increase the sum.\n\nElse: decrement right.\n\nIf loop ends without returning, return empty list.\n\nNow, let's see why in one of the test cases.\n\nTest case: two_sum_indices([2,7,11,15],9) \u2192 [0,1]. \n\nAt start, left=0 (2), right=3 (15). Sum is 17>9 \u2192 decrement right to 2.\n\nNow, sum is 2+11=13>9 \u2192 decrement right to 1.\n\nsum 2+7=9 \u2192 found \u2192 return [0,1].\n\nAnother test case: [2,7,11,15], target 18. Need to find 1+15=16, but wait, 7 and 11 sum to 18, which is indices 1 and 2. So step by step:\n\nleft=0, right=3: sum 17<18 \u2192 left increments to 1.\n\nsum 7+15=22>18\u2192 right decrements to 2.\n\nsum 7+11=18 \u2192 found, return [1,2].\n\nAnother test case: [1,3,3], target 6. Sum is 1+3=4, increment left to 1. 3+3=6 \u2192 return [1,2]. Correct.\n\nAnother test case that should return empty list: [1,2,3], target 6. 1+2=3\u2192 move left. 1+3=4 <6\u2192 move left. Then left is 2, right is 2: loop ends. So returns empty. That's correct because the only possible pair would be 3 and 3, but there's no such elements.\n\nWait, wait, 3 is at index 2 but in [1,2,3], that's single element. So for target 6, 3+3=6 but no second 3? So correct.\n\nAnother example: [2,7,11,15], target 8: check.\n\nLeft=0, right=3: sum 17>8\u2192 move right to 2. Sum 13>8\u2192 right to 1. Now left is 0, right 1. Sum 9>8\u2192 move right to 0. Now left is not less than right, so exit. Return empty.\n\nYes.\n\nSo now, the code.\n\nFunction:\n\ndef two_sum_indices(nums, target):\n    left = 0\n    right = len(nums)-1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left +=1\n        else:\n            right -=1\n    return []\nWait, that's the code.\n\nWait, let's think about possible bugs.\n\nWhat if the same number appears multiple times, but only one possible pair adds up to target? Well, as per problem statement, exactly one solution exists. So function will find it as it approaches the correct pointers.\n\nAnother possible issue: should the list be non-empty. Wait constraints say the list is at least length 2.\n\nSo for len(nums)>=2, no problem.\n\nAnother test case given: [3*i for i in range(10)], target 19 \u2192 let's compute.\n\n3*i for i 0 to 9 \u2192 0,3,6,...,27. Target 19.\n\nLooking for two numbers adding to 19. Let's see:\n\n3*6= 18, 3*7=21 \u2192 but no, 18+?\n\nLooking for x + y =19 where x and y are in the list.\n\nThe list is [0, 3,6,9,12,15,18,21,24,27].\n\nFind a pair that sums to 19.\n\nWait none possible:\n\n0: needs 19, not in list.\n\n3: needs 16, not in list.\n\n6: needs 13 \u2192 no.\n\n9: needs 10 \u2192 no.\n\n12: needs 7 \u2192 no.\n\n15: needs 4 \u2192 no.\n\n18: needs 1 \u2192 no.\n\nOnly possibility is 3*i + 3*j = 19. 3(i+j) =19 \u2192 19 is not divisible by 3. So sum is impossible. So function returns empty.\n\nBut wait, wait, wait\u2014 wait 3*i + 3*j is 3*(i+j) = target. Target is 19, which is 19 /3 is not an integer. So no such pairs. So function returns empty. Correct.\n\nAnother test case could be nums = [5, 5], target=10. So function returns [0,1], correct.\n\nBut wait in the code:\n\nAt left=0, right=1. Sum is 10 \u2192 return [0,1].\n\nYes.\n\nWhat about when left is moving but multiple steps are needed.\n\nSo seems correct.\n\nI think this should cover it.\n</think>\n\nTo solve this problem, we need to find the indices of two numbers in a sorted list that add up to a given target sum using the two-pointer technique. This approach ensures an efficient solution with linear time complexity.\n\n### Approach\nThe two-pointer technique is a well-known method for solving problems involving sorted arrays efficiently. The idea is to use two pointers, starting from the beginning and the end of the list, and move them towards each other based on the sum of the elements at these pointers.\n\n1. **Initialize Pointers**: Start with two pointers, `left` at the beginning (index 0) and `right` at the end (index `len(nums) - 1`).\n2. **Calculate Current Sum**: For each iteration, calculate the sum of the elements at the `left` and `right` pointers.\n3. **Adjust Pointers**: \n   - If the current sum is equal to the target sum, return the indices of `left` and `right`.\n   - If the current sum is less than the target sum, move the `left` pointer one step to the right to try a larger number.\n   - If the current sum is greater than the target sum, move the `right` pointer one step to the left to try a smaller number.\n4. **Termination**: If the loop terminates without finding a pair that sums to the target, return an empty list.\n\nThis method ensures that each element is checked at most once, resulting in a time complexity of \\(O(n)\\) and a space complexity of \\(O(1)\\).\n\n### Solution Code\n\n```python\ndef two_sum_indices(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n```\n\n### Explanation\nThe provided code implements the two-pointer technique to efficiently find the indices of two numbers in a sorted list that sum up to the target value. \n\n- **Initialization**: `left` starts at the beginning of the list, and `right` starts at the end.\n- **Loop**: While `left` is less than `right`, calculate the sum of elements at these indices. If the sum matches the target, return the indices. Adjust the pointers based on whether the sum is less than or greater than the target.\n- **Termination**: If no such pair is found, return an empty list.\n\nThis approach ensures that each element is processed exactly once, making the solution both efficient and optimal for the given problem constraints.",
  "r1_solution": "def two_sum_indices(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
  "metadata": {
    "prompt_id": "00000005",
    "row_id": 5,
    "seed_ids": [
      716
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results0.jsonl"
}