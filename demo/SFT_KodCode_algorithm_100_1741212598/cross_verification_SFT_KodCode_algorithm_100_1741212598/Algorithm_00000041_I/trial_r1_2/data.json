{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000041_I",
  "question": "You are given a list of integers and are required to implement a quick sort algorithm. The provided code uses a simple random pivot selection and does not handle in-place sorting. Your task is to enhance the given implementation to achieve the following:\n\n1. Implement quick sort as an in-place sorting algorithm.\n2. Handle edge cases such as empty lists, single-element lists, and nearly sorted lists.\n3. Improve the pivot selection strategy to avoid worst-case performance.\n\n#### Function Signature\n\n```python\ndef quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm.\n\n    :param arr: A list of integers to be sorted.\n    \"\"\"\n```\n\n#### Constraints\n\n- \\(1 \\leq len(arr) \\leq 10^5\\)\n- Elements of `arr` are integers in the range \\([-10^3, 10^3]\\)\n\n#### Example\n\n```python\narr = [10, 5, 2, 3, 7, 6, 8, 4, 9, 1]\nquick_sort_in_place(arr)\nprint(arr)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n### Notes\n\n- You should modify the provided `quick_sort` function to work in-place.\n- Ensure that the function can handle edge cases such as already sorted or nearly sorted arrays.\n- Use a more sophisticated pivot selection strategy, such as the \"median-of-three\" pivot to improve performance.\n\n#### Performance Requirements\n\n- The algorithm should achieve an average-case time complexity of \\(O(n \\log n)\\).",
  "solution": "def quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm with an in-place median-of-three pivot selection.\n    \"\"\"\n    def partition(low, high):\n        # Choosing the median of the first, middle, and last elements as the pivot\n        mid = (low + high) // 2\n        pivot_candidates = [arr[low], arr[mid], arr[high]]\n        pivot_candidates.sort()\n        pivot_value = pivot_candidates[1]\n\n        # Move the pivot to the end for partitioning\n        pivot_index = arr.index(pivot_value)\n        arr[pivot_index], arr[high] = arr[high], arr[pivot_index]\n        pivot_index = high\n\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot_value:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[pivot_index] = arr[pivot_index], arr[i + 1]\n        return i + 1\n\n    def _quick_sort(low, high):\n        if low < high:\n            pi = partition(low, high)\n            _quick_sort(low, pi - 1)\n            _quick_sort(pi + 1, high)\n\n    _quick_sort(0, len(arr) - 1)",
  "test_code": "import random\n\ndef quick_sort_in_place(arr):\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm with an in-place median-of-three pivot selection.\n    \"\"\"\n    def partition(low, high):\n        mid = (low + high) // 2\n        pivot_candidates = [arr[low], arr[mid], arr[high]]\n        pivot_candidates.sort()\n        pivot_value = pivot_candidates[1]\n        pivot_index = arr.index(pivot_value)\n        arr[pivot_index], arr[high] = arr[high], arr[pivot_index]\n        pivot_index = high\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot_value:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[pivot_index] = arr[pivot_index], arr[i + 1]\n        return i + 1\n\n    def _quick_sort(low, high):\n        if low < high:\n            pi = partition(low, high)\n            _quick_sort(low, pi - 1)\n            _quick_sort(pi + 1, high)\n\n    _quick_sort(0, len(arr) - 1)\n\n# Test Cases\ndef test_quick_sort_in_place():\n    arr = [10, 5, 2, 3, 7, 6, 8, 4, 9, 1]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    arr = [1, 2, 3, 4, 5]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5]\n\n    arr = [5, 4, 3, 2, 1]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5]\n\n    arr = []\n    quick_sort_in_place(arr)\n    assert arr == []\n\n    arr = [random.randint(-1000, 1000) for _ in range(10000)]\n    quick_sort_in_place(arr)\n    assert arr == sorted(arr)\n\ntest_quick_sort_in_place()",
  "test_info": [
    {
      "function_name": "quick_sort_in_place",
      "parameter_list": "(arr)",
      "function_declaration": "def quick_sort_in_place(arr):",
      "docstring": "Sorts the given list arr in-place using the quick sort algorithm with an in-place median-of-three pivot selection."
    },
    {
      "function_name": "partition",
      "parameter_list": "(low, high)",
      "function_declaration": "def partition(low, high):",
      "docstring": null
    },
    {
      "function_name": "_quick_sort",
      "parameter_list": "(low, high)",
      "function_declaration": "def _quick_sort(low, high):",
      "docstring": null
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to implement an in-place quick sort algorithm in Python. The given code uses a simple random pivot, and I need to enhance it. Let me think about how to approach this.\n\nFirst, the requirements are: in-place sorting, handle edge cases, and improve pivot selection to avoid worst-case scenarios.\n\nAlright, let's start by recalling how quick sort works. The basic idea is to pick a pivot, partition the array into elements less than, equal to, or greater than the pivot, and recursively sort the subarrays.\n\nIn-place means we shouldn't create new lists for the partitions. We need to do the partitioning in-place using the same array. Wait, no, actually, in the function, we can't create copies, so we have to work within the given array.\n\nSo, looking at the function signature, it's called quick_sort_in_place, which sorts the array in-place, so the function won't return anything but changes the input list.\n\nSo first, I need to think about the base case. If the array has zero or one element, it's already sorted. So in the function, I should check if len(arr) <=1, then return.\n\nBut wait, wait. Wait, the function is called quick_sort_in_place, and it's supposed to handle an empty array as well, which we need to handle.\n\nNext, the pivot selection. The initial code uses a random pivot, which is okay but not great. The problem says to improve it, so perhaps using the median of three approach.\n\nMedian of three is where we take the first, middle, and last elements of the current array, find their median, and use that as the pivot. This can help avoid worst-case time on already sorted arrays.\n\nSo, I need to implement that.\n\nBut in recursive quick sort steps, each call needs to modify the array in place. So I might need helper functions. Alternatively, perhaps use indices to partition subarrays.\n\nLet me outline the structure of the function.\n\nThe main function will be quick_sort_in_place, which calls a helper function to perform the actual quick sort, perhaps something like _quick_sort_helper(arr, low, high), which recursively sorts the subarray arr from low index to high index.\n\nSo, for the function, the initial call would be _quick_sort_helper(arr, 0, len(arr)-1).\n\nNow, in the helper, first check if low < high (if the subarray has more than one element). If not, return.\n\nThen, choose a pivot. For choosing the pivot, implement the median of three strategy. So, for the subarray from low to high, pick the median among the first, middle, and last elements.\n\nThe middle element can be found as (low + high) // 2. Let's say, for example, in the initial call, the array has 10 elements, so the middle is 4. The elements are at indices 0, 4, 9.\n\nCompute their median, and then select the middle one as the pivot.\n\nWait, not just pick the value, but also bring it to a specific position to partition around it.\n\nBut in-place selection would require that. Wait, after choosing the pivot, maybe we need to swap it to a certain position, perhaps the end or the beginning.\n\nAlternatively, perhaps in the helper function, when partitioning, we can choose the pivot value first, then arrange the elements so that all less than are on one side, equal in the middle, and greater are on the other.\n\nWait, but for in-place partitioning, perhaps the standard Lomuto or Hoare partitioning algorithm is used.\n\nSo Lomuto's algorithm can partition the array in-place into three parts: elements less than pivot, equal, and greater. It can be more efficient in practice than re-swapping.\n\nSo perhaps I should implement the Lomuto algorithm for partitioning. Let's recall how that works.\n\nIn Lomuto, the pivot is the last element. The algorithm maintains a pointer (let's say i) which starts at the starting index. Then, we iterate from left to right. If the current element is less than the pivot, it is swapped with the element at index i, and i is incremented.\n\nIn the end, the pivot (last element) is swapped with the element at index i.\n\nIn our case, the pivot will be chosen using the median of three strategy. So first, let's think about how to select the pivot index.\n\nSo in the helper function:\n\n- Compute the mid index as (low + high) // 2.\n\n- Look at the elements arr[low], arr[mid], arr[high]. Find the median of these three.\n\nWait, but the median is the second when sorted. So for example, if the three are 5, 2, 8, the median is 5.\n\nSo the median is the element in the middle when the three are sorted.\n\nThen, among the low, mid, high indices, choose the one whose value is the median. That index becomes the pivot index.\n\nYes.\n\nSo, steps to select pivot:\n\n1. Compute mid index.\n\n2. Create a list of the three elements: [0, mid, high indices' elements].\n\nBut no, wait, but the elements could be in any order, but their indices are fixed as low, mid, high. Wait, okay, for example, we have to get the values at low, mid, high, then determine which of them is the median, and choose that as the pivot index.\n\nWait, but perhaps it's easier to just compute the median position.\n\nFor example, suppose low is 0, mid is (0+9)//2 =4, high is9.\n\nWe get values: arr[0], arr[4], arr[9]. Let's say they are 10,3,9.\n\nWait, the values are 10,3,9. The median is 9.\n\nThen the pivot is 9.\n\nBut then, we can place this pivot element into the high position. Wait, perhaps no. Let me think.\n\nWait, no. If the median is at position 9, which is high, then the pivot is at high index. So the Lomuto partitioning (using last element as pivot) would select it as the pivot, but how?\n\nIn any case, for the partitioning, the pivot is the value, and perhaps its index is set to high position.\n\nAlternatively, perhaps I should swap the median element to the high index, then perform the partition.\n\nYes, because the Lomuto algorithm's implementation will treat the last element as the pivot.\n\nSo in the helper function:\n\n1. If low >= high, return.\n\n2. Else:\n\na. Compute mid = (low + high) //2.\n\nb. Find the positions low, mid, high. Then, take their values.\n\nc. Find which of these three is the median (i.e., when sorted, the second one is the median).\n\nd. Suppose the median is at index median_index.\n\ne. Swap the element at median_index with the high element. So the median becomes the last element.\n\nf. Then perform Lomuto's partition with the (current) last element as the pivot.\n\ng. After partitioning, we get the pivot index (let's say it's i after partitioning). Then recursively sort the left subarray (low to i-1) and the right subarray (i+1 to high).\n\nSo that's the plan.\n\nSo for example, let's say we have elements:\n\narr = [10, 5, 2, 3, 7, 6, 8, 4, 9, 1]\n\nIn the first call, low=0, high=9.\n\nCompute mid: 4.\n\nValues at 0:10, at4:7, at 9:1. So the numbers are 10,7,1.\n\nThe median is7. So the median's index is 4.\n\nSo now we swap 7 and 1 (so arr[4]=1, but wait no: wait, 10 is at 0,4 is7,9 is1. So when choosing which is the median, we sort 10,7,1: 1,7,10 \u2192 median is7. So the median_index is 4.\n\nThen, we swap arr[4] (7) with arr[9] (1). After swapping, the array becomes [10,5,2,3,1,6,8,4,9,7].\n\nWait, no: but 4:7, high is9: 1. Swapping, 7 and 1. So the array becomes 10,5,2,3,1,6,8,4,9,7.\n\nThen the Lomuto's partitioning is done on the subarray [10,5,2,3,1,6,8,4,9,7], treating 7 as the pivot.\n\nSo the algorithm proceeds.\n\nSo in code:\n\nIn the helper function:\n\nlow = 0, high = len(arr)-1.\n\nCompute mid as (low + high) // 2.\n\nGet the elements: a = arr[low], b = arr[mid], c = arr[high].\n\nCompute the median and the corresponding index.\n\nOnce the median index is determined (say, m), swap arr[m] with arr[high].\n\nThen perform the Lomuto partition.\n\nWait, but the helper function is recursive. So after partitioning, i is the position where the pivot ends up.\n\nThen, we recursively sort the left and right subarrays.\n\nNow, the next task is to implement this.\n\nWait, but the helper function needs to handle the entire process.\n\nLet me outline this in code.\n\nBut first, let's handle the edge cases.\n\nIn the function quick_sort_in_place(arr), first check if the array is empty or singleton; return.\n\nBut since len(arr) can be zero, but in that case, no issue. So the function can proceed.\n\nBut for example, if the array has only two elements, after selecting the pivot, the partitioning will arrange them correctly.\n\nSo the steps are:\n\nImplement helper with low and high parameters.\n\nIn the helper:\n\nif low >= high: return.\n\nCompute mid.\n\nFind the three elements and determine the median.\n\nSwap the median element to the high position.\n\nPerform partition.\n\nAfter partition, get the pivot index.\n\nRecursively call helper on low to pivot-1 and pivot+1 to high.\n\nSo, now, code.\n\nWait, but the helper is a function inside the main function, right? Because it's modifying the same array.\n\nYes.\n\nSo the main function will be:\n\ndef quick_sort_in_place(arr: list) -> None:\n    _quick_sort_helper(arr, 0, len(arr)-1)\n\nAnd _quick_sort_helper is a helper function.\n\nSo, code steps:\n\nStep 1: Edge case.\n\nIn _quick_sort_helper:\n\ndef _quick_sort_helper(arr, low, high):\n    if low >= high:\n        return\n\nStep 2: Selecting the pivot as median of three.\n\nCompute mid:\n\nmid = (low + high) // 2\n\nget a = arr[low], b = arr[mid], c = arr[high]\n\nfind the median.\n\nThen, among the three, find the index of the median. Then, swap that element with high.\n\nSo let's see:\n\ncandidates = [ (a, low), (b, mid), (c, high) ]\n\nThen, we need to find which of these three values is the median.\n\nTo do that, we can sort the list of tuples by the value and pick the middle one.\n\nSo sorted_candidates = sorted(candidates, key=lambda x: x[0])\n\nmedian = sorted_candidates[1][0]\n\nWait, but the median is the second in the sorted list of three elements (0-based index 1). So the index in the candidates is the index of the tuple.\n\nWait, perhaps:\n\nsorted_candidates = sorted( [(a, low), (b, mid), (c, high)], key=lambda x: x[0] )\n\nmedian_value = sorted_candidates[1][0]\nmedian_index = sorted_candidates[1][1]\n\nThen, swap arr[median_index] with arr[high].\n\nYes.\n\nSo code:\n\na, b, c = arr[low], arr[mid], arr[high]\n\nmid_val = (arr[low], arr[mid], arr[high])\n# Wait, creating a list of the values and their indices.\n\nWait, perhaps better to do:\n\ncandidates = [ (a, low), (b, mid), (c, high) ]\n\nsorted_candidates = sorted(candidates, key=lambda x: x[0])\n\nmedian_value, median_index = sorted_candidates[1]\n\nThen, swap arr[median_index] and arr[high].\n\narr[median_index], arr[high] = arr[high], arr[median_index]\n\nSo this places the median as the last element.\n\nStep 3: Partition using Lomuto.\n\nImplement Lomuto's partition scheme.\n\nLomuto's method steps:\n\nInitialize i = low.\n\nFor j from low to high-1:\n\nif arr[j] < arr[high], swap arr[i] and arr[j], and i +=1.\n\nAfter the loop, swap arr[i] and arr[high].\n\nThe new pivot index is i.\n\nWait, no: in this code, after j goes up to high-1, the loop, when j is at high-1:\n\nThen, after the loop, we do swap arr[i] and arr[high].\n\nSo the function returns i as the position where the pivot is placed.\n\nWait no: in Lomuto's method, the pivot is placed at i after the loop.\n\nWait no: if you have [i] as the position.\n\nWait, perhaps let me code the Lomuto's partition.\n\ndef _partition(arr, low, high):\n    pivot = arr[high]\n    i = low\n    for j in range(low, high):\n        if arr[j] < pivot:\n            arr[i], arr[j] = arr[j], arr[i]\n            i +=1\n    arr[i], arr[high] = arr[high], arr[i]\n    return i\n\nSo this would be after selecting a pivot at high.\n\nThen, the helper function will call this to partition the subarray, and then recursively sort.\n\nSo, putting it all together.\n\nWait, in the helper function:\n\n- do the median selection, swap to high.\n\ncall i = partition(...) which returns the pivot index.\n\nthen call helper on low to i-1, and i+1 to high.\n\nSo, in code:\n\nIn helper function:\n\nsort_candidates = [ (arr[low], low), (arr[mid], mid), (arr[high], high) ]\nsorted_candidates = sorted(sort_candidates, key=lambda x: x[0])\nmedian_value, median_index = sorted_candidates[1]\narr[median_index], arr[high] = arr[high], arr[median_index]\n\npivot = i = _partition(arr, low, high)\nhelper ... as above.\n\nSo putting it all together:\n\nNow, let's see.\n\nWait, but is the _partition function correct?\n\nYes, the Lomuto method is correct, and returns the index of the pivot.\n\nSo, the helper function would then proceed to call itself for the left and right partitions.\n\nSo, in code:\n\ndef _quick_sort_helper(arr, low, high):\n    if low >= high:\n        return\n\n    # Select the pivot using median-of-three\n    mid = (low + high) // 2\n    # Get the three elements\n    a, b, c = arr[low], arr[mid], arr[high]\n    # Create a list of (value, index)\n    candidates = [ (a, low), (b, mid), (c, high) ]\n    # Sort them by value\n    sorted_candidates = sorted(candidates, key=lambda x: x[0])\n    # Get the median's index\n    median_value, median_index = sorted_candidates[1]\n    # Swap median with the last element\n    arr[median_index], arr[high] = arr[high], arr[median_index]\n\n    # Partition the array\n    pivot_index = _partition(arr, low, high)\n\n    # Recursively sort the left and right subarrays\n    _quick_sort_helper(arr, low, pivot_index - 1)\n    _quick_sort_helper(arr, pivot_index + 1, high)\n\nThen, the _partition function:\n\ndef _partition(arr, low, high):\n    pivot = arr[high]\n    i = low\n    for j in range(low, high):\n        if arr[j] < pivot:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    # Swap the pivot (high) with the element at index i\n    arr[i], arr[high] = arr[high], arr[i]\n    return i\n\nThis should handle the partitioning.\n\nSo putting this into the code, the function should correctly perform in-place quicksort with better pivot selection.\n\nWait, but I shouldn't forget edge cases.\n\nWait, for two elements:\n\narr = [2,1]\n\nlow=0, high=1.\n\nmid=0.\n\na=2, b=2, c=1.\n\nCandidates are (2,0), (2,0), (1,1).\n\nWhen sorted:\n\nsorted_candidates = [(1,1), (2,0), (2,0)]\n\nTaking the middle one, (2,0).\n\nSo after swapping, we are putting 2 at position 1.\n\nThe partition: pivot is 2.\n\ni starts at 0.\n\nj runs from 0 to 0.\n\nCompare arr[0] (1) < 2 \u2192 swap? Yes.\n\nSo, arr[j] is 1, less than pivot 2. So swap arr[0] and arr[0], i increments.\n\nWait, no: initial i is 0.\n\nj=0: since j < high (1 is high), check arr[0] (1) is less than pivot (2). So swap arr[0] and arr[0] (no change), i becomes 1.\n\nSo, after j finishes, i is 1.\n\nSwap arr[1] and arr[1] (no change). Return i=1.\n\nRecurrence on arr [0...0] and [2...1], which are invalid. So function completes.\n\nThus, the array becomes [1,2]. Which is correct.\n\nAnother test case: what about an array that's already sorted.\n\nFor example, [1,2,3,4,5].\n\nAfter first helper call, mid is computed for low=0, high=4.\n\nmid is 2. high is 4.\n\nCandidates are (1,0), (3,2), (5,4).\n\nWhen sorted, the order is 1,3,5 \u2192 median value is3, median index 2.\n\nSwap with high (4): 3 is swapped with arr[4] (5) \u2192 arr becomes [1,2,5,4,3].\n\nWait, wait:\n\nInitial array is [1,2,3,4,5].\n\nAfter this swap, the array changes as [1,2,5,4,3].\n\nThen, in partition, the pivot is 3 (since high is 4, and after swapping, arr[4] is 3).\n\nWait, no.\n\nWait, wait. Let's re-examine.\n\nNo, in the selection, the pivot is 3 (arr[2] is 3). It's swapped with arr[4], which is 5.\n\nSo the array becomes [1,2,5,4,3].\n\nThen the pivot is 3.\n\nSo the array is [1,2,3,4,5] \u2192 after choosing the median of three (1,3,5) is 3, which is at index2.\n\nSwap with high (4), which is5.\n\nSo the array becomes [1,2,5,4,3].\n\nNow, during the partition:\n\ni starts at low=0.\n\nPivot is 3.\n\nLoop j from 0 to 3.\n\nAt j=0:\n\narr[j]=1 <3 \u2192 swap with arr[0], i becomes1.\n\nj=1: arr[1] =2 <3 \u2192 swap with arr[1], i becomes2.\n\nj=2: arr[j]=5>3 \u2192 no swap.\n\nj=3: arr[j]=4>3 \u2192 no swap.\n\nAfter the loop, i is 2.\n\nSwap arr[2] (5) and arr[4] (3). So new array is [1,2,3,4,5].\n\nThe pivot is now at index 3.\n\nWait, no.\n\nWait, after the initial operations, calling arr after swap:\n\narr becomes [1,2,5,4,3].\n\nIn _partition, for low=0, high=4.\n\ni=0.\n\nLoop j in 0-3:\n\nj=0: arr[0] is 1 \u2192 swap with 0: no change. i=1.\n\nj=1: arr[j]=2 < pivot (3). Swap with i=1 \u2192 same. i becomes 2.\n\nj=2: arr[j]=5 >=3 \u2192 no swap.\n\nj=3: arr[3]=4 >=3 \u2192 no swap.\n\nNow, i=2. arr[4 (high) is 3].\n\nSwap arr[2] and arr[4], which are 5 and3 \u2192 array becomes [1,2,3,4,5].\n\nAnd the pivot index is 2.\n\nThen, helper calls on (0,1) and (3,4).\n\nSo each of these will be sorted, but since they are length 2 and 2, respectively:\n\nConsider the first, low=0, high=1.\n\nmid=0.\n\nThree elements: (1,0), (1,0), (2,1).\n\nsorted_candidates = [1,0, 1,0, 2,1]? No.\n\nWait, get a =1, b=1, c=2.\n\ncandidates = [(1,0),(1,0), (2,1)].\n\nWhen sorted, the order is (1,0), (1,0), (2,1).\n\nmedian is (1,0).\n\nSwap with high=1 \u2192 no change since arr[0]=1 is at low which is 0.\n\nThen _partition is called, which is 1 and high=1.\n\nLoop j from0 to0.\n\nIf arr[j] < pivot (high=1 is pivot 1 \u2192 arr[0]=1 is not less.\n\nSo i remains 0. Then swap pivot (arr[0]=1) with itself.\n\nReturn i=0.\n\nRecurrence on low=0 to i-1= -1 and i+1=1.\n\nThus, that side is done.\n\nSimilarly for the (3,4) side: it's [4,5], but mid=3, etc.\n\nThus, the code correctly handles this.\n\nSo, in terms of edge cases, the code seems to handle it.\n\nAnother test case: the sample in the problem.\n\narr = [10,5,2,3,7,6,8,4,9,1]\n\nAfter initial median selection, the code sorts it, producing the sample output.\n\nBut perhaps there's a problem with initializing the helper for empty lists?\n\nWait, the helper function is only called if len(arr) is not zero. In the main function, after calling quick_sort_in_place(arr), it doesn't have any constraints. So the helper function is called when len(arr) >=2.\n\nWait, no. Because the helper is called with low=0 and high = len(arr)-1. For example, if the array is empty, len(arr)-1 is -1, low is 0 \u2192 which will return immediately.\n\nWait, sure, because in the helper function, if low >= high, returns.\n\nSo what if arr is empty or has one element? Then the helper is called with low=0, high=-1 (if len(arr) is 0). So 0 >= -1 \u2192 0>=-1 is true \u2192 helper returns.\n\nNo problem.\n\nSo the code should handle all edge cases.\n\nNow, what about the performance for nearly sorted arrays? With the median of three, the algorithm should take O(n log n) average time, which would satisfy the constraints.\n\nWhat about duplicate elements?\n\nThe Lomuto partitioning will handle duplicates correctly because equal elements are on one side.\n\nI think this implementation should be correct.\n\nSo, the final code is as follows.\n\nWait, but in Python, functions inside other functions can't be defined if they are in a way that the outer function is also being called recursively.\n\nTherefore, I should define the helper functions within quick_sort_in_place.\n\nSo:\n\ndef quick_sort_in_place(arr: list) -> None:\n    def _quick_sort_helper(low, high):\n        if low >= high:\n            return\n        # Select pivot as median of three\n        mid = (low + high) // 2\n        a, b, c = arr[low], arr[mid], arr[high]\n        candidates = [(a, low), (b, mid), (c, high)]\n        # Sort the candidates by their values\n        sorted_candidates = sorted(candidates, key=lambda x: x[0])\n        median_value, median_index = sorted_candidates[1]\n        # Swap the median with the high element\n        arr[median_index], arr[high] = arr[high], arr[median_index]\n        # Partition the array\n        pivot_index = _partition(low, high)\n        # Sort the subarrays\n        _quick_sort_helper(low, pivot_index - 1)\n        _quick_sort_helper(pivot_index + 1, high)\n    \n    def _partition(low, high):\n        pivot = arr[high]\n        i = low\n        for j in range(low, high):\n            if arr[j] < pivot:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n        arr[i], arr[high] = arr[high], arr[i]\n        return i\n    \n    _quick_sort_helper(0, len(arr) - 1)\n\nWait, but what if len(arr) is 0? Then len(arr)-1 is -1. But in the helper function, low=0, high=-1 \u2192 low < high is false, returns.\n\nSo in the case where len(arr) is 0 or 1, nothing is done, which is correct.\n\nYes.\n\nSo in code, that's acceptable.\n\nTesting:\n\nTesting the sample input.\n\nSample input: arr = [10,5,2,3,7,6,8,4,9,1]\n\nAfter quick_sort_in_place(arr), arr should be [1,2,3,4,5,6,7,8,9,10]\n\nTesting with the code.\n\nI think that the code should handle it.\n\nPossible testing in mind:\n\n- Test the initial case.\n\nStep-by-step simulation would take a lot of time, but the code looks correct.\n\nTherefore, this should be the correct implementation.\n</think>\n\nTo solve this problem, we need to implement an in-place quick sort algorithm that efficiently handles edge cases and avoids worst-case performance by using an improved pivot selection strategy.\n\n### Approach\nThe solution involves the following key steps:\n\n1. **In-Place Sorting**: The algorithm must sort the list in-place without using extra space for additional arrays.\n2. **Edge Cases Handling**: The function should handle edge cases such as empty lists, single-element lists, and nearly sorted lists efficiently.\n3. **Pivot Selection Strategy**: To avoid worst-case performance, the \"median-of-three\" pivot selection strategy is used. This involves selecting the median of the first, middle, and last elements of the current subarray as the pivot.\n4. **Partitioning**: The Lomuto partition scheme is used for in-place partitioning of the array, which is efficient and avoids extra space.\n\n### Solution Code\n\n```python\ndef quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm with the median-of-three pivot selection.\n    \n    :param arr: A list of integers to be sorted.\n    \"\"\"\n    def _quick_sort_helper(low, high):\n        if low >= high:\n            return\n        \n        # Select the pivot using median of three strategy\n        mid = (low + high) // 2\n        a, b, c = arr[low], arr[mid], arr[high]\n        candidates = [(a, low), (b, mid), (c, high)]\n        sorted_candidates = sorted(candidates, key=lambda x: x[0])\n        median_value, median_index = sorted_candidates[1]\n        \n        # Swap the median element with the high element\n        arr[median_index], arr[high] = arr[high], arr[median_index]\n        \n        # Partition the array\n        pivot_index = _partition(low, high)\n        \n        # Recursively sort the sub-arrays\n        _quick_sort_helper(low, pivot_index - 1)\n        _quick_sort_helper(pivot_index + 1, high)\n    \n    def _partition(low, high):\n        pivot = arr[high]\n        i = low\n        for j in range(low, high):\n            if arr[j] < pivot:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n        arr[i], arr[high] = arr[high], arr[i]\n        return i\n    \n    if len(arr) > 1:\n        _quick_sort_helper(0, len(arr) - 1)\n```\n\n### Explanation\n1. **In-Place Sorting**: The algorithm modifies the input array directly without creating additional arrays for sorting, ensuring in-place sorting.\n2. **Median-of-Three Pivot Selection**: This strategy reduces the likelihood of worst-case performance by selecting a more central pivot, which helps in balancing the partitioning of the array.\n3. **Lomuto Partitioning**: This method efficiently partitions the array in-place by maintaining a pointer to track the position where elements smaller than the pivot are placed, ensuring optimal performance.\n4. **Recursive Sorting**: The helper function recursively sorts the subarrays to the left and right of the pivot, ensuring the entire array is sorted.\n\nThis approach ensures that the quick sort algorithm runs efficiently, even for edge cases and nearly sorted arrays, with an average time complexity of \\(O(n \\log n)\\).",
  "r1_solution": "def quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm with the median-of-three pivot selection.\n    \n    :param arr: A list of integers to be sorted.\n    \"\"\"\n    def _quick_sort_helper(low, high):\n        if low >= high:\n            return\n        \n        # Select the pivot using median of three strategy\n        mid = (low + high) // 2\n        a, b, c = arr[low], arr[mid], arr[high]\n        candidates = [(a, low), (b, mid), (c, high)]\n        sorted_candidates = sorted(candidates, key=lambda x: x[0])\n        median_value, median_index = sorted_candidates[1]\n        \n        # Swap the median element with the high element\n        arr[median_index], arr[high] = arr[high], arr[median_index]\n        \n        # Partition the array\n        pivot_index = _partition(low, high)\n        \n        # Recursively sort the sub-arrays\n        _quick_sort_helper(low, pivot_index - 1)\n        _quick_sort_helper(pivot_index + 1, high)\n    \n    def _partition(low, high):\n        pivot = arr[high]\n        i = low\n        for j in range(low, high):\n            if arr[j] < pivot:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n        arr[i], arr[high] = arr[high], arr[i]\n        return i\n    \n    if len(arr) > 1:\n        _quick_sort_helper(0, len(arr) - 1)",
  "metadata": {
    "prompt_id": "00000041",
    "row_id": 41,
    "seed_ids": [
      233
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results2.jsonl"
}