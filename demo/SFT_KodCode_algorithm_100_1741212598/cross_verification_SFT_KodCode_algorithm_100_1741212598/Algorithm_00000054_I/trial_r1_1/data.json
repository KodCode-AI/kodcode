{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000054_I",
  "question": "**Scenario**: You are given a list of integers, and you need to find the peak element in the list, which is the maximum value in a unimodal list. A unimodal list is defined as a list that increases to a point and then decreases. If the input list does not strictly follow this pattern, the function should return `None`.\n\n**Function Signature**:\n```python\ndef find_peak(lst: List[int]) -> Optional[int]:\n    pass\n```\n\n**Input**:\n- The function takes a list of integers `lst`.\n\n**Output**:\n- The function returns the peak element of the list as an integer. If the list does not follow the unimodal pattern, the function should return `None`.\n\n**Constraints**:\n- \\(1 \\leq \\text{len}(lst) \\leq 10^6\\)\n- The list can contain duplicate values.\n\n**Performance Requirement**:\n- The function should be efficient, aiming for a time complexity of \\(O(\\log n)\\) where \\(n\\) is the length of the list.\n\n**Example**:\n```python\n>>> find_peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n5\n>>> find_peak([1, 10, 9, 8, 7, 6, 5, 4])\n10\n>>> find_peak([1, 9, 8, 7])\n9\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 0])\n7\n>>> find_peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n4\n>>> find_peak([1, 2, 2, 1, 0, -1, -2])\n2\n>>> find_peak([1, 1])\n1\n>>> find_peak([1])\n1\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10])\n12\n>>> find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10, 9])\n12\n```\n\n**Note**: Ensure that your implementation handles edge cases correctly and efficiently.",
  "solution": "from typing import List, Optional\n\ndef find_peak(lst: List[int]) -> Optional[int]:\n    \"\"\"\n    Returns the peak element in a unimodal list. If the list does not follow the unimodal pattern, returns None.\n    \"\"\"\n    if not lst:\n        return None\n    \n    left, right = 0, len(lst) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if lst[mid] < lst[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return lst[left]",
  "test_code": "import pytest\n\ndef test_find_peak():\n    assert find_peak([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5\n    assert find_peak([1, 10, 9, 8, 7, 6, 5, 4]) == 10\n    assert find_peak([1, 9, 8, 7]) == 9\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 0]) == 7\n    assert find_peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2]) == 4\n    assert find_peak([1, 2, 2, 1, 0, -1, -2]) == 2\n    assert find_peak([1, 1]) == 1\n    assert find_peak([1]) == 1\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10]) == 12\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10, 9]) == 12\n    assert find_peak([]) is None\n    assert find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 10\n    assert find_peak([1, 2, 2, 2, 2, 2, 1]) == 2\n\ndef test_edge_cases():\n    assert find_peak([1]) == 1\n    assert find_peak([1, 2]) == 2\n    assert find_peak([2, 1]) == 2\n    assert find_peak([1, 1]) == 1",
  "test_info": [
    {
      "function_name": "find_peak",
      "parameter_list": "(lst)",
      "function_declaration": "def find_peak(lst):",
      "docstring": "Returns the peak element in a unimodal list. If the list does not follow the unimodal pattern, returns None."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to find the peak element of a unimodal list. A unimodal list increases to a peak and then decreases. But if the list doesn't strictly follow this pattern, I should return None.\n\nWait, the problem says if the list doesn't strictly follow the pattern. So what's the definition of a unimodal list here? Oh right, it's increases and then decreases. So all elements before the peak must be strictly increasing, and all elements after the peak must be strictly decreasing? Or can there be plateaus, like duplicates?\n\nWait, the note says that the list can contain duplicate values. Hmm, that's a bit tricky. So in the function, I have to handle cases where maybe the peak isn't a single point but a plateau. Or maybe the peak is exactly when the trend changes from non-decreasing to non-increasing. Wait, the examples include cases where the peak is a single point, and others like [1,2,2,1], where the peak is 2.\n\nWait, looking at the example:\n\nfind_peak([1, 2, 2, 1, 0, -1, -2]) returns 2. So that suggests that the peak can have duplicates, as it's the maximum value in the list.\n\nSo if the list is strictly increasing up to a point and then strictly decreasing, the peak is that point. But if there's a plateau at the peak, the first element after the rise and before the fall? Or do I just take the maximum value?\n\nWait, but the peak is the maximum element in a unimodal list. Even in the plateau case, the maximum is the same across the plateau. So in the example, it's sufficient to return the maximum value.\n\nWait, but the function is required to verify if the list is unimodal. So I can't just take the maximum; I need to ensure that the list is increasing up to some peak and then decreasing.\n\nWait, more precisely, the list should first non-decreasingly (since duplicates are allowed when the trend is increasing) rise to a peak, then non-increasingly fall. Or does each step have to be strictly increasing and then strictly decreasing? Looking back at the examples.\n\nIn the first example, [1,2,3,4,5,4,3,2,1], the peak is 5. So before 5, each step is increasing by 1, and after, each step decreases by 1. So strictly increasing and strictly decreasing.\n\nIn another example: find_peak([1,2,2,1,0,-1,-2]). It returns 2. So the list is 1, 2, 2, 1... So up to the peak, it allows for non-decreasing (can have duplicates when increasing). And then after the peak, it's non-increasing.\n\nSo I think the definition is that the list can be non-decreasing up to the peak and then non-increasing. So that a plateau is allowed as part of the increasing or the decreasing phase, but the peak is the point where the trend changes.\n\nSo the task is to find if the list increases (allowing equals) until some peak, then decreases (allowing equals). So, no, it's allowed to have equals in the increasing part and even at the peak itself, as long as after the peak, the list is non-increasing.\n\nBut wait, let's see another example: [1,2,3,4,5,6,7,0] returns 7. That implies that after 7, it goes to 0, so a strict decrease. So it's valid.\n\nAnother example: [1, 1], returns 1. So that's allowed; the list never increases beyond 1. So the peak is at the first or second 1.\n\nSo, what's the approach to check this?\n\nThe function needs to check if the list is non-decreasing up to a point, then non-increasing. But wait, not exactly. Because for instance, a unimodal list could have multiple peaks if the list is increasing, then has a plateau, then decreases.\n\nWait, but in the plateau case, all the elements in the plateau are equal to the peak. So perhaps the peak is just the maximum value in the list, which is the maximum across all elements.\n\nHmm, but I'm not just looking for the maximum, because I also need the condition that before the peak, the list is non-decreasing, and after, it is non-increasing.\n\nWait, so the steps are:\n\n1. Find the maximum value in the list.\n\n2. Check if the list is strictly increasing up to that maximum (non-decreasing), and then strictly decreasing afterwards (non-increasing), allowing for the peak to have a plateau before the decrease.\n\nWait, but how to handle the plateau?\n\nAlternatively, after identifying the peak element, I need to verify that before the peak, the list is non-decreasing, and after the peak (including possible duplicates), it is non-increasing.\n\nBut how to do that efficiently, considering the performance constraints of O(log n)?\n\nWait, but O(n) might be acceptable for some cases, but the performance requirement is O(log n). So perhaps a binary search approach.\n\nAlternatively, since the constraints are up to 1e6, an O(n) solution might be acceptable for 1e6, but I think the intended solution is to find a way to get this done in O(log n) time. So maybe using binary search to find the peak.\n\nSo the idea is to use binary search to find the peak point, where the list increases to that point and then decreases.\n\nBut how? Because in a unimodal array, the peak is unique in the sense that prior elements are smaller and next are smaller, but during the Binary Search, I can compare the current index's value with its next element.\n\nLet's think about binary search for the peak.\n\nWait, in the standard \"find a mountain peak\" problem, binary search is used. But in that problem, some variations. Let me see.\n\nIn our case, the list is strictly increasing until some point, then strictly decreasing. But wait, no, it's non-decreasing and non-increasing, as per the examples.\n\nWait no, in the examples, in the list [1,2,2,1], the peak is 2, which is the maximum, and the list is non-decreasing until the peak (1<=2<=2), then non-increasing (2>=1).\n\nSo for the binary search approach, the peak is a point where the slope changes from up to down. So, for each mid index, we can check whether it's increasing from mid-1 to mid, but then decreasing from mid to mid+1. Or maybe not.\n\nAlternatively, the array can be thought of as first non-decreasing, reaches a peak, then non-increasing. So any peak is greater than or equal to all previous, and greater than or equal to all next.\n\nWait, no, that's the definition of the maximum. So the peak in a unimodal array is the maximum element, so perhaps that's the key.\n\nSo, the function needs to check whether the maximum element in the list is a valid peak, i.e., the elements before it are non-decreasing, and the elements after it are non-increasing.\n\nSo the approach would be:\n\n1. Find the index of the maximum element in the list. If the maximum occurs at only one position, then it's our peak. If it occurs at multiple positions, perhaps the earliest peak is the start of the plateau.\n\nWait, actually, if the entire list is increasing, it's unimodal, so the peak is the last element.\n\nIf the list is a single element, it's the peak.\n\nWait, maybe the first idea is:\n\nThe maximum element is the peak, if the list is non-decreasing up to that element and non-increasing after.\n\nSo the algorithm could be:\n\n- Iterate through the list, find all indices where the maximum value occurs. For each such index, check if in the list, all elements before the index are non-decreasing (each element <= next), and all elements after are non-increasing (each element <= next). If so, return the maximum value. Otherwise, return None.\n\nBut how to efficiently find this.\n\nBut the problem is, if there are multiple maxima, which could happen if there's a plateau, but not all are at the peak of the unimodal curve.\n\nFor example, if the list is [1,3,3,3,2], then the maximum is 3. The first occurrence of 3 is at index 1, check whether all elements before (index 0) <= it (yes), and elements after are non-increasing (index 2 is 3, index 3 is 2, so yes). So it's a valid peak.\n\nAnother case: [3,3,3,3], is that a unimodal list? Well, the entire list is non-decreasing, but as a unimodal list, it's a single peak with all elements on a plateau. So the list is both non-decreasing up to any peak point and non-increasing after. So, yes, it's valid and the peak is 3.\n\nAnother example: [1,3,2,3,3]. Oh, but that's a problem. Because it's 1,3,2\u2014so after the first 3, it decreases to 2, then increases again. So this list is not unimodal.\n\nWait, but the maximum is 3; however, the indices where 3 occurs are not all peaks. For eg:\n\nIn [1,3,2,3,3], the first 3 is at index 1, but after that, it increases again. So it's not a unimodal list. So when I find the maximum, I have to also confirm the trend before and after.\n\nSo steps I could take:\n\n1. Find the maximum value in the list.\n\n2. Find the first occurrence of the maximum.\n\n3. Check if all elements before this first occurrence are non-decreasing (i.e., each element <= next). If not, return None.\n\n4. Then, from the first occurrence, check if all elements up to the last occurrence are non-decreasing (if there's plateau) \u2014 but wait, no. Because in the plateau, all values are same, so non-decreasing.\n\n5. Then, check if all elements after the last occurrence of the maximum are non-increasing \u2014 each element >= next.\n\nWait, maybe the approach is:\n\nAfter finding all the indices where the max occurs, the region from the first to last index of max should be the peak. So check if the list is non-decreasing up to the first occurrence and then non-increasing after the last occurrence.\n\nNo, perhaps not. Because for example, in the list [1,3,3,3,2], the peak is the first occurrence of 3 because the list is non-decreasing till that point, and then after, it's non-increasing.\n\nWait, but the plateau is in the middle; in this case, the first max occurrence is 1, last is 3, but the plateau's start is within the non-decreasing part. Hmm, perhaps this approach is getting complicated.\n\nAlternatively, perhaps for a given maximum value, the first index where it occurs must be such that all elements before are non-decreasing and all elements after are non-increasing.\n\nBecause, if all elements before the first occurrence are <= next, and all elements after the last occurrence are non-increasing, but in between, the elements could be fluctuating as long as they are non-increasing after the last occurrence.\n\nWait, no, because in between, between the first and last occurrence, all elements are equal (since they are all the maximum), so it's non-decreasing in the plateau and non-increasing in the plateau.\n\nWait, when the maximum is a plateau, the list must have non-decreasing up to the first occurrence, and then non-increasing from some point.\n\nSo perhaps the approach is:\n\nAfter finding all positions where the maximum occurs, for the first occurrence pos, check if all elements before pos are non-decreasing up to pos, and all elements from the last occurrence onwards are non-increasing.\n\nWait, but if the list is [3,3,3], then yes, it's a unimodal list.\n\nHmm.\n\nAlternatively, perhaps the binary search approach can be modified to find the point where left side is non-decreasing and right side is non-increasing.\n\nBut how?\n\nIn the standard peak finding problem, you look for a point where the current value is greater than or equal to the neighbors. But that would find local maxima, not necessarily a global maximum.\n\nHmm.\n\nBut in this problem, the function needs to ensure the entire list is non-decreasing to the peak and then non-increasing after.\n\nSo binary search might not directly apply, but perhaps a modified approach can be used.\n\nAlternatively, find the maximum value's index, and then check if the left side is non-decreasing up to that max index, and the right side is non-increasing from that index.\n\nWait, but multiple max indices could exist in a plateau.\n\nSo here's an idea:\n\n1. Find all the indices where the list has the maximum value.\n\n2. For each such index, check the surrounding conditions:\n\n   a. All elements before the index are non-decreasing.\n\n   b. All elements after the index are non-increasing.\n\nBut if there are multiple max indices, say indices i, i+1, ..., j, then the check has to be done for each one.\n\nWait, but perhaps the first occurrence of the maximum should be the peak. Because if it's somewhere in the plateau, it's possible that after the plateau, the list increases again, violating the conditions.\n\nWait, perhaps that's not the case.\n\nWait, no: For example, [1,3,5,5,7,5,5]. The maximum is 7 at index 4. The elements before 4 are non-decreasing, and elements after 4 are non-increasing. So it's a valid peak.\n\nBut if the maximum occurs at index 3 and 4: like [1,3,5,5,5,4], then index 4 is the end of the plateau. The elements after 4 are 4, which is non-increasing. The elements before index 4 are non-decreasing.\n\nSo, perhaps for each maximum index i, it's sufficient to check the entire list to the left (from start to i) is non-decreasing and to the right (i to end) is non-increasing.\n\nBut with a list length up to 1e6, this could be O(n) for each check, leading to O(n) time overall.\n\nSo maybe, a way to perform these checks quickly is required.\n\nAlternatively, perhaps, find the maximum element, then find the first occurrence and check the left side (non-decreasing), then find the last occurrence and check the right side (non-increasing). Or wait, perhaps just ensure that starting from the first occurrence, the list is non-decreasing up to that point, and starting from the last occurrence, it is non-increasing.\n\nHmm.\n\nSo steps:\n\n1. Find max_val = max(lst). If the list is empty or has zero length, return None. But according to constraints, len(lst) is at least 1.\n\nWait, function signature says len(lst) can be 1. So if the list is [1], return 1.\n\nProceed:\n\nif len(lst) ==1: return lst[0]\n\nElse:\n\n2. Find the first occurrence and the last occurrence of max_val.\n\nfirst = first index where lst[i] == max_val\n\nlast = last index where lst[i] == max_val\n\n3. Check whether the elements from start to first are non-decreasing:\n\n   for i in 0 to first-1:\n\n       if lst[i] > lst[i+1]: return None\n\n4. Check whether the elements from last to end are non-increasing:\n\n   for i in last to len(lst)-2:\n\n       if lst[i] < lst[i+1]: return None\n\n5. Additionally, within the first to last section, the elements are all equal to max_val, which ensures it's non-decreasing and non-increasing.\n\nSo if all these conditions are satisfied, the list is unimodal, so return max_val.\n\nElse, return None.\n\nBut does this approach cover all cases?\n\nLet me test it against some examples.\n\nExample 1:\n\nlst = [1,2,3,4,5,4,3,2,1]\n\nmax_val =5\n\nfirst=4, last=4.\n\nCheck from 0 to 3: each lst[i] <= lst[i+1] \u2192 1<=2<=3<=4<=5: yes.\n\nCheck from 4 to end: 5,4,3,2,1 non-increasing: yes.\n\nSo return 5.\n\nGood.\n\nAnother example:\n\nlst = [1,2,2,1,0,-1,-2]\n\nmax_val =2.\n\nfirst=1, last=2.\n\nCheck 0 to 1:\n\nelements 1 and 2 \u2192 1<=2 yes.\n\nCheck elements from 2 to end (indices 2 to len-1):\n\nlst[2]=2, and the elements after:\n\nindex 2: 2, index3:1 \u2192 2>=1.\n\nindex3=1, 4:0 \u2192 yes.\n\n4 to 5: yes.\n\nSo overall, function returns 2.\n\nGood.\n\nAnother example: [1,1]\n\nmax_val=1.\n\nfirst=0, last=1.\n\nCheck 0-0: no elements (because first is 0, and in for i in 0 to first-1 (which is -1), no loop.\n\nCheck from last=1 to end: len is 2, so check for i=1 to 0 (no iteration). So condition is satisfied.\n\nReturn 1.\n\nAnother example: [1,3,2,3,3]\n\nmax is 3.\n\nfirst occurs at index1, last at index4.\n\nCheck elements 0 to1: lst[0]=1 <= lst[1] =3: yes.\n\nCheck elements from index4: len-1 is4, so no check (since it's the last element).\n\nSo fails?\n\nOr wait, no: in this list, the elements after first index1: elements are 2, then 3 again.\n\nSo after the last index (4), there's nothing.\n\nBut when you check from first to last, that's fine because all elements are 3.\n\nBut the condition for the left is only up to first. The elements from first to last can stay the same.\n\nBut in the overall list, the elements after first may have a dip but then rise again, which would make it not unimodal.\n\nWait in the example [1,3,2,3,3], after first occurrence of 3, you have 2, then 3 again.\n\nWhen you check from first (index1), the elements after it up to last (index4) have 3,2,3,3: but this is not a non-increasing sequence.\n\nWait but according to the check we outlined earlier, the function would have failed the check? Let's see.\n\nWhen checking the right side:\n\nright check is from last index (4) to end. But index4 is the last element, so no check is done.\n\nBut the problem is that in the overall list, the last element is index4, but between 1 and4, the list is 3,2,3,3.\n\nSo, function would incorrectly accept this list as non-increasing after first occurrence.\n\nBut in reality, the list is not non-increasing after first.\n\nWait, so the condition is not met.\n\nThus, the function as proposed would have failed to catch this.\n\nSo why?\n\nBecause in our approach, we only check that the left is non-decreasing up to first, and the right is non-increasing starting from the last occurrence.\n\nBut if there is an increase after the first occurrence but before last occurrence, it's allowed as long as the elements after last occurrence are non-increasing. But in this case, the list isn't; it has a part that increases again beyond first occurrence.\n\nSo the function would miss that case.\n\nIn the example, the function calls would allow the list [1,3,2,3,3], which is not a unimodal list, as the list increases then decreases, then increases again.\n\nThus, according to the approach, this would return 3, but according to the problem statement, the function should not consider this a unimodal list and return None.\n\nSo the approach is incorrect.\n\nHmm, this suggests that the approach is not sufficient.\n\nThus, what's the problem?\n\nThe problem is that, after the initial peak (first occurrence of max), the list can't decrease and then increase again. So the entire right side of the peak, including any plateaus, must be non-increasing.\n\nSo with the current approach, the function does not check that.\n\nSo, perhaps the correct way is to have:\n\n1. Find the peak as the leftmost occurrence of the maximum.\n\nWait, no, because in a plateau, the peak could be the first occurrence, but then the list decreases and increases again would invalidate.\n\nBut how can I ensure that after the peak, all elements are non-increasing.\n\nHmm.\n\nAlternative idea: the peak is the point where the list stops increasing and starts decreasing.\n\nBut how to find that.\n\nPerhaps the approach is to find the index where all elements to the left are <= current, and all elements to the right are <= current, and then ensure that the entire left is non-decreasing, and the entire right is non-increasing.\n\nSo, the idea is:\n\nLoop through the list, find the point i where before i (from i-1) <= lst[i], and lst[i] >= lst[i+1], and then check that the left is non-decreasing and the right is non-increasing.\n\nBut this would find a peak in a way that, to the left, it's strictly increasing, but if the list is [1,2,2,3], then the peak could be at index 3 (value3), but the previous elements are non-decreasing.\n\nWait, the example [1,2,2,3] is actually increasing, so the peak is 3, and the function should return 3.\n\nSo perhaps, for i being a peak (a candidate), the function must:\n\n- Ensure that from start to i, the list is non-decreasing.\n\n- Ensure that from i to end, the list is non-increasing.\n\nSo, for each i in the list where lst[i] is the maximum, check:\n\n   all elements before i are non-decreasing.\n\n   all elements after i are non-increasing.\n\nSo in the case where i is the first occurrence of the maximum, and in between first and another occurrence, there are other values that break the non-increasing condition, it would be detected during the check of the right side.\n\nSo how to implement this.\n\nWait, perhaps:\n\nFind the index where the maximum occurs, but that index must have the entire list non-decreasing up to it, and non-increasing after it.\n\nSo steps:\n\nFor each element in the list:\n\n   if the element is the maximum.\n\n      check if all elements before are non-decreasing.\n\n      check if all elements after are non-increasing.\n\n      if both yes, return max.\n\nIf no such element (of max value) satisfies the condition, return None.\n\nBut in this case, it's O(n^2) for worst cases (like all elements are max), which is not efficient.\n\nSo that approach could have O(n^2) time, which is not acceptable for len up to 1e6.\n\nBut then, for a million elements, O(n) would be just a loop, which can be done.\n\nWait, perhaps the function can:\n\n1. Find the maximum.\n\n2. Find all positions where the list has this maximum.\n\n3. For each position in these positions:\n\n   a. Check if the list is non-decreasing from start to that position.\n\n   b. Check if the list is non-increasing from that position to end.\n\n   c. If any position satisfies both conditions, return max.\n\n4. If none do, return None.\n\nBut how efficient is this approach.\n\nIn the worst case, if the list is flat, like all elements are the same (the max), then the loop for each position would check all of them, each requiring O(n) time. So for a list like this, which is valid, the first position is checked in O(n), and the rest can be skipped, because we can return early.\n\nSo total time is O(n) in this case.\n\nSimilarly, for a list with one peak.\n\nSo overall, the approach is O(n) in time.\n\nIn that case, even though O(n) may not be O(log n), but perhaps for 1e6, it's manageable.\n\nBut what about if the keys are such that in a list where multiple maxima are present, but the correct one is in the middle? Like a list that has a peak with increasing before, then a plateau, then increasing again (which is invalid).\n\nWait, no: because such a list would not be non-decreasing up to the peak. Because in the plateau, maybe.\n\nSo I think this approach is needed.\n\nNow, let's think about how to implement this.\n\nIn code:\n\nmax_val = max(lst)\n\nmax_indices = [i for i, x in enumerate(lst) if x == max_val]\n\nfor i in max_indices:\n\n   if is_non_decreasing(lst, 0, i) and is_non_increasing(lst, i, len(lst) -1):\n\n       return max_val\n\nreturn None\n\nWait, then functions is_non_decreasing(a, start, end):\n\n   for i in range(start, end):\n\n       if a[i] > a[i+1]:\n\n           return False\n\n   return True\n\nSimilarly for is_non_increasing:\n\n   for i in range(start, end):\n\n       if a[i] < a[i+1]:\n\n           return False\n\n   return True\n\nSo for each max index, we perform two O(n) checks (each up to n-1 comparisons).\n\nIn worst case, for a million elements, each of max steps is O(n), but for 1e6, this could be O(1e12) operations, which is impossible.\n\nSo how can this be optimized.\n\nWait, no, because if the list is 1e6 elements, len(max_indices) can be large, but perhaps in the best case, the correct peak is found early and the function exits.\n\nBut the worst case is O(m*n), where m is len(max_indices), and n is 1e6.\n\nThis would be too slow.\n\nThus, I need a more efficient approach.\n\nAlternative idea:\n\nThe entire list should be non-decreasing up to the peak, then non-increasing.\n\nThus, the peak must be such that all elements before are non-decreasing and all elements after are non-increasing.\n\nThus, perhaps the function can traverse the list once, tracking the state.\n\nBut how.\n\nAnother Idea:\n\nThe process is to:\n\n1. Find the first index where the current element is less than the next. Move the start to that point.\n\n2. Then, from that point, find where the current is less than the next again.\n\nWait, perhaps, but not sure.\n\nAlternatively, think of the list as a hill. Initially, it is in increasing phase. At some point, it starts decreasing, which is the peak.\n\nBut the list may have plateaus before and after the peak.\n\nSo the approach is to find the point where the list stops increasing and starts decreasing.\n\nBut this needs to be done efficiently.\n\nAnother approach inspired by binary search.\n\nInitialize low =0, high = len(lst)-1.\n\nWe need to find a peak element where, when you go to the right, it's non-increasing, and to the left, it's non-decreasing.\n\nBut I'm not sure.\n\nAlternatively, think about whether, for the peak position i, the entire left is non-decreasing, and the entire right is non-increasing.\n\nSo, if during the binary search, I can find a i where the above condition is true.\n\nBut how to do that without checking the entire list each time.\n\nHmm, perhaps for each candidate i during the binary search:\n\n   Check if it is a peak by checking its neighbors.\n\nBut as in the standard approach.\n\nBut that approach would only find a local maximum, not the global maximum.\n\nThus, perhaps not sufficient.\n\nAnother approach: to find the maximum first, then check if all elements before it are non-decreasing and all elements after are non-increasing.\n\nIn that case, the maximum is the candidate for peak.\n\nBut how to make that efficient.\n\nSo process:\n\nCompute max_val = max(lst)\n\npositions = all indices where lst[i] == max_val\n\nfor each pos in positions:\n\n   check if the elements before pos are non-decreasing\n\n   check if the elements after pos are non-increasing\n\n   if both are True for this pos, return max_val\n\nIf no pos satisfies this, return None.\n\nNow, to make this efficient, in the worst case, when the list is invalid, but the for loop runs O(n) checks.\n\nBut in Python, checking two O(n) loops for each pos could be O(n^2), which is not feasible.\n\nWait, but in reality, for each pos, checking the left and right is O(n) per pos, but if the number of pos is O(n) (like all elements are the same), then the total is O(n^2), which is O(1e12) steps, which is not feasible.\n\nThus, this approach is not efficient enough.\n\nHmm.\n\nAlternative Idea: Only check the entire list once.\n\nWe can have a variable 'i' from 0 to len(lst)-1.\n\nDuring the loop, track if the list is in the non-decreasing phase or the non-increasing phase.\n\nInitially, in the non-decreasing phase.\n\nOnce the non-decreasing phase ends (when a[i] > a[i+1]), switch to non-increasing phase.\n\nAfter that, any a[i] < a[i+1] would mean that the list has started increasing again, which is invalid.\n\nAlso, during the transition, the point where a[i] starts to decrease is the peak.\n\nAt the end, the maximum element must have been in that point.\n\nBut the function needs to also check that the maximum is that point.\n\nSo, the steps:\n\nWait, perhaps a way to track the phases:\n\n- Initially, increasing phase.\n\nWe loop through the list.\n\nAt each step, if increasing phase, next value should be >= current. If next < current, then we're at peak.\n\nSwitch to decreasing phase.\n\nAfter that, in decreasing phase, any next >= current is invalid.\n\nOnce loop ends, the list is unimodal.\n\nThen, after loop, check if the maximum occurs only in the increase phase and peak.\n\nBut this approach might not work if the peak is after some plateaus.\n\nLet me try example:\n\nlst = [1,2,3,4,5,5,5,4,3]\n\nSo the maximum is 5, which occurs in the middle.\n\nSo during the loop, 1<2<3<4<5=5=5>4>3.\n\nSo in this case, switch from increasing to decreasing after the first 5.\n\nNo issues.\n\nThe function will mark it as valid.\n\nMax is 5.\n\nSo that's good.\n\nAnother example: [1,3,2,3,3]\n\nIn this case, the condition is invalid, because after the peak, the list increases again.\n\nSo during the loop:\n\nAt 3, next is 2, so switch to decreasing phase. Next is 3, which is ==.\n\nWait, but in the decreasing phase, the next element must be <= current.\n\nWait, no, in the decreasing phase, next can ==, because it's non-increasing.\n\nBut in this example, the next elements after 2 are 3, which is greater than 2. So in the decreasing phase, when the current element (2) is followed by 3, which is greater, so the list isn't non-increasing. So it's invalid.\n\nThus, in the loop, this would be detected.\n\nThus, the approach would be:\n\nLoop through the list, track whether the list is still in increasing phase.\n\n- Start in increasing phase (can include plateaus).\n\n- Once a decrease occurs, switch to decreasing phase (which can't have any increases).\n\n- Additionally, if any increase occurs in the decreasing phase, the list is invalid.\n\n- If the entire loop completes without such an error, the list is unimodal.\n\n- Then, return the maximum element.\n\nIf the maximum element occurred only during the increasing phase.\n\nWait, but the maximum may be in the increasing phase, at the point where the phase changes.\n\nSo in that case, the function would have found that the maximum is present at the peak.\n\nThus, the plan is:\n\n1. Iterate through the list, track increasing phase.\n\n2. Once the peak is found (when a[i] > a[i+1]), track that the decreasing phase begins.\n\n3. If during the decreasing phase, a[i] < a[i+1], return invalid.\n\n4. After processing all elements, if no invalid case is found, return the maximum element.\n\nSo, the key steps:\n\n- Check for the phase transitions.\n\nBut also, after the loop, confirm that the list is in the decreasing phase after the peak.\n\nWait, but what about if the list has multiple peaks, but only one is the maximum.\n\nBut with the above approach, as long as the list is non-decreasing to the peak and then non-increasing, regardless of any other peaks.\n\nThus, the problem reduces to checking whether the list is non-decreasing until a certain point, then non-increasing after that.\n\nSo the function can:\n\nCheck whether the list first is non-decreasing, has a peak (the point after which it starts to decrease), and after that peak it's non-increasing.\n\nSo, the steps:\n\nInitialize state as 'incr' (increasing allowed).\n\npeak_found = False\n\nprev = lst[0]\n\nfor i in range(1, len(lst)):\n\n    if state is 'incr':\n\n        if lst[i] > prev:\n\n            prev = lst[i]\n\n        elif lst[i] < prev:\n\n            state = 'decr'\n\n            peak_val = prev\n\n            peak_pos = i-1\n\n            # need to record the peak_val to check it's the max.\n\n            # but perhaps collect all possible peaks?\n\n            # No, since the peak is at i-1, which is the point of transition.\n\n        else: # equal, so no change to state.\n\n            prev = lst[i]\n\n    elif state is 'decr':\n\n        if lst[i] > prev:\n\n            # violation: increasing after peak.\n\n            return None\n\n        prev = lst[i]\n\nNow, after the loop, the peak_val is of i-1.\n\nThen, check if the peak_val is equal to the max_val. If so, return it. Else, return None.\n\nWait, but this only finds the first peak in the list. So if the list has multiple peaks before the actual maximum, it'll miss it.\n\nWait, no. For example, if previous elements build up to a peak, but then the list continues to increase again after a higher peak.\n\nThis approach would not capture that.\n\nWait, perhaps example:\n\nlst = [1,3,2,5,4]\n\nThe list is: 1,3, then dips to 2, but then peaks at 5.\n\nIn this case, the first peak is 3 (at index 1). Then the state transitions to decr. When the list goes up to 5, it's a violation, so the function returns None.\n\nBut the list has a higher peak at 5, so the function's approach is not sufficient.\n\nSo thus, the approach is incorrect.\n\nHmm.\n\nAnother possible idea: find all possible peaks and check if any of them, when assumed to be the global peak, satisfies the condition that all elements before are non-decreasing and all after are non-increasing.\n\nThis reduces to the initial approach, but with the problem of O(n*m), which is 1e12 steps for m=1e6.\n\nBut perhaps, assuming that the number of possible peaks is small, but worst case still O(n^2).\n\nThus, this suggests that the initial approach is not acceptable.\n\nAlternative Idea: Think about both sides.\n\nThe maximum must be part of the first non-decreasing sequence.\n\nThus, the function can find the maximum, then check if all elements before it are non-decreasing, and all after are non-increasing.\n\nBut again, in the case of [1,3,2,5,4], the maximum is 5.\n\nCheck if the list up to 5 is non-decreasing.\n\nLooking back: 2 <5 is in the middle.\n\nBut before 5, we have 1,3,2, then 5.\n\nWhich is 1<3>2<5: that's not non-decreasing. So indeed, the list is invalid.\n\nSo in that case, the function would correctly return None.\n\nSo the steps are:\n\nFind the maximum in the list.\n\nCheck that all before max are non-decreasing.\n\nAdditionally, check that all after max are non-increasing.\n\nThus, in code:\n\nmax_val = max(lst)\n\nmax_indices = [i for i, x in enumerate(lst) if x == max_val]\n\nfor i in max_indices:\n\n   # check if all elements before i are non-decreasing.\n\n   is_valid_non_decr = True\n\n   for j in range(0, i):\n\n       if lst[j] > lst[j+1]:\n\n           is_valid_non_decr = False\n\n           break\n\n   if not is_valid_non_decr:\n\n       continue\n\n   # check if all elements after i are non-increasing.\n\n   is_valid_non_incr = True\n\n   for j in range(i, len(lst)-1):\n\n       if lst[j] < lst[j+1]:\n\n           is_valid_non_incr = False\n\n           break\n\n   if is_valid_non_incr:\n\n       return max_val\n\nreturn None\n\nThis logic is okay, but again, worst case O(n^2).\n\nSo for 1e6, it's not acceptable.\n\nThus, the code is not efficient enough.\n\nThus, we need a way to find whether the elements before i are non-decreasing, and the elements after are non-increasing.\n\nBut without explicitly checking all elements each time.\n\nSolution Idea:\n\nPrecompute two arrays:\n\n- left_incr[i]: True if the list is non-decr up to i.\n\n- right_decr[i]: True if the list is non-incr from i to end.\n\nBut how to compute these efficiently.\n\nleft_incr can be computed by a single pass:\n\nleft_incr = [True]*(len(lst))\n\nfor i in range(1, len(lst)):\n\n    if lst[i] < lst[i-1]:\n\n        left_incr[i] = False\n\n    else:\n\n        left_incr[i] = left_incr[i-1]\n\nNo, wait, that's not correct. For example, after a decrease, all subsequent left_incr would be False, regardless of later increases.\n\nSo that's not correct.\n\nWait, another approach: left_incr[i] represents whether the subarray lst[0..i] is non-decr.\n\nSo:\n\nleft_incr[0] = True\n\nfor i from 1 to n-1:\n\n   if left_incr[i-1] and (lst[i] >= lst[i-1]):\n\n       left_incr[i] = True\n\n   else:\n\n       left_incr[i] = False\n\nBut this would mark the left_incr[i] as True only if the entire prefix is non-decr up to i.\n\nSo for example, if in a list, the first two elements are non-decr and the third is less than second, then left_incr[2] is False.\n\nSimilarly, if after that we have another element which is higher than the third, left_incr[3] would also be False, because the prefix includes the third element which is a decrease.\n\nWait that's not what we want.\n\nWe need to detect if the entire prefix up to i is non-decr.\n\nThus, a better way to compute left_incr:\n\nleft_incr[0] = True\n\nfor i in 1 to len(lst)-1:\n\n   if lst[i] >= lst[i-1] and left_incr[i-1]:\n\n       left_incr[i] = True\n\n   else:\n\n       left_incr[i] = False\n\nSimilarly, for right_decr:\n\nright_decr[-1] = True\n\nfor i from len(lst)-2 down to 0:\n\n   if lst[i] >= lst[i+1] and right_decr[i+1]:\n\n       right_decr[i] = True\n\n   else:\n\n       right_decr[i] = False\n\nWait, yes.\n\nThen, for each index i (where lst[i] is maximum), if left_incr[i] and right_decr[i], return max_val.\n\nThus, in this case, the code can precompute left_incr and right_decr in O(n) time.\n\nThen, the checking for each candidate i is O(1) per candidate.\n\nThus, the approach would be O(n), which is acceptable.\n\nSo for code:\n\nCompute left_incr array.\n\nleft_incr[0] = True.\n\nFor i from 1 to len(lst)-1:\n\n   if left_incr[i-1] is True and lst[i] >= lst[i-1]:\n\n       left_incr[i] = True\n\n   else:\n\n       left_incr[i] = False\n\nCompute right_decr array.\n\nright_decr[-1] = True\n\nfor i from len(lst)-2 downto 0:\n\n   if right_decr[i+1] and lst[i] >= lst[i+1]:\n\n       right_decr[i] = True\n\n   else:\n\n       right_decr[i] = False\n\nThen, for each i where lst[i] is the maximum.\n\nmax_val = max(lst)\n\nfor i in [i for i, x in enumerate(lst) if x == max_val]:\n\n   if left_incr[i] and right_decr[i]:\n\n       return max_val\n\nReturn None.\n\nWait, but in the right_decr computation, for each i, right_decr[i] is True only if lst[i] >= next and right_decr[i+1] is true.\n\nSo the right_decr array has True only if the entire suffix is non-increasing.\n\nThus, the function can be handled in O(n) time.\n\nTesting this with example.\n\nSample 1:\n\nlst = [1, 2, 3,4,5,4,3,2,1]\n\nCompute left_incr:\n\ni=1: 2>=1, left_incr[1] = True.\n\ni=2:3 >=2: T\n\ni=3:4>=3: T\n\ni=4:5>=4: T.\n\ni=5:4 <5: so left_incr[i] = F.\n\nThen i=6:2 >4 \u2192 but left_incr[5] is False, so F.\n\nSimilarly, after i=4, all are F.\n\nThus, for the index4 (max val 5), left_incr[i] = T.\n\nCompute right_decr:\n\nStarting from end.\n\ni=8: True.\n\ni=7: 2 >=1 and right_decr[8] T \u2192 T.\n\ni=6:3 >=2: T.\n\ni=5:4>=3: T.\n\ni=4:5 >=4 \u2192 T.\n\nThus, right_decr[4] is T.\n\nThus, for i=4, left_incr and right_decr are both True.\n\nThus, return 5.\n\nAnother example:\n\nlst = [1, 3, 2,3,3]\n\nmax_val=3.\n\nmax indices are 1,3,4.\n\nleft_incr for each:\n\nleft_incr[0] = T.\n\ni=1: 3>=1 \u2192 T.\n\ni=2: 2 <3 \u2192 left_incr[2] = F.\n\ni=3: left_incr[2] is F, so F.\n\ni=4: same.\n\nThus, for index1: left_incr is T.\n\nCheck right_decr for index1:\n\nright_decr for i=1:\n\nCompute right_decr from end.\n\ni=4: T.\n\ni=3:3>=3 \u2192 yes, if right_decr[4] is T: T.\n\ni=2:2 >=3? 2 <3 \u2192 F.\n\nThus, right_decr[1] depends on the previous steps:\n\nCompute this.\n\nHmm. Wait for i=1:\n\nIn the right_decr:\n\ni is from4-1 downto0.\n\nCompute right_decr for i=3:\n\nlst[3] =3 >=3? Yes, and right_decr[4] is T. So right_decr[3] = T.\n\ni=2: lst[2] =2 >=3? No. So right_decr[2] = F.\n\ni=1: lst[1] =3 >=2 \u2192 yes, but right_decr[2] is False. So right_decr[1] is F.\n\nThus, for i=1, left_incr is T but right_decr is F. So not a valid.\n\nSimilarly, for i=3: left_incr[i] is F, so even if right_decr is T, no.\n\ni=4: left_incr is F.\n\nThus, no valid i in max_indices.\n\nThus, function returns None.\n\nCorrect because the list is not unimodal.\n\nAnother test case:\n\nlst = [1,2,2,1,0,-1,-2]\n\nmax is 2.\n\nmax_indices are 1,2.\n\nCompute left_incr:\n\ni=1: 2 >=1 \u2192 T.\n\ni=2:2 >=2 \u2192 T.\n\ni=3:1 <2 \u2192 F.\n\ni=4:0 <1 \u2192 F.\n\netc.\n\nright_decr for i=1:\n\nCompute right_decr for i=1.\n\nIn right_decr array, must compute in reverse.\n\nEach step:\n\nCompute right_decr of 5: lst[5] =-1 >=-2 \u2192 right_decr[5] = right_decr[6] (which is T) \u2192 T.\n\ni=4:0 >=-1 and right_decr[5] is T: T.\n\ni=3:1 >=0 and right_decr[4] is T: T.\n\ni=2:2 >=1 and right_decr[3] is T: T.\n\ni=1:2 >=2 and right_decr[2] is T: T.\n\nThus, right_decr for i=1 is T.\n\nThus, for i=1: left_incr[i] = T, right_decr[i] = T.\n\nThus, function returns 2.\n\nGood.\n\nAnother test case: lst = [3,3,3,3]\n\nCompute left_incr:\n\nFor i=1: 3>=3 \u2192 T.\n\ni=2: same.\n\ni=3: same.\n\nright_decr:\n\ni=3 is T.\n\ni=2:3>=3 and right_decr[3] is T: T.\n\ni=1: same.\n\ni=0 same.\n\nThus, for any i where value is3, left_incr[i] and right_decr[i] are T.\n\nThus, returns 3.\n\nCorrect.\n\nAnother test case: lst = [1,2,3,4,5,6,7,0]\n\nmax_val=7, occurs at6 index.\n\nleft_incr[6] is T because all previous steps are non-decreasing.\n\nright_decr[6]: 7 >=0, and right_decr[7] (which is last element, so T) \u2192 T.\n\nThus, function returns7.\n\nCorrect.\n\nThus, this approach seems to handle multiple cases correctly.\n\nThus, the code can be written as follows.\n\nSo the steps are:\n\nImplement the function by first computing the left_incr and right_decr arrays.\n\nThen, for each index where the value is the maximum, check if left_incr[i] and right_decr[i] are true.\n\nIf any such index, return the maximum.\n\nOtherwise, return None.\n\nThus, the code could be written as:\n\ndef find_peak(lst: List[int]) -> Optional[int]:\n    if not lst:\n        return None  # according to constraints, len >=1, so handle len=0?\n    n = len(lst)\n    if n == 0:\n        return None\n    if n == 1:\n        return lst[0]\n    \n    left_incr = [False] * n\n    left_incr[0] = True\n    for i in range(1, n):\n        if lst[i] >= lst[i-1] and left_incr[i-1]:\n            left_incr[i] = True\n        else:\n            left_incr[i] = False\n    \n    right_decr = [False] *n\n    right_decr[-1] = True\n    for i in range(n-2, -1, -1):\n        if lst[i] >= lst[i+1] and right_decr[i+1]:\n            right_decr[i] = True\n        else:\n            right_decr[i] = False\n    \n    max_val = max(lst)\n    max_indices = [i for i, x in enumerate(lst) if x == max_val]\n    \n    for i in max_indices:\n        if left_incr[i] and right_decr[i]:\n            return max_val\n    return None\n\nWait, but what about a case where the peak is the last element.\n\nFor example: [1,2,3,4].\n\nmax_val is4, occurring at3.\n\nCheck left_incr[3] (True).\n\nright_decr[3] is True (no next element).\n\nThus, returns4.\n\nAnother example: [4,3,2,1], which is strictly decreasing.\n\nmax_val is4, at0.\n\nCheck:\n\nleft_incr[0] is True.\n\nright_decr[0] is right_decr[0]= will compute during the right_decr.\n\nIn right_decr, for i=0:\n\nIt's lst[0] >= lst[1], and right_decr[1]?\n\nright_decr[1] is computed as lst[1] >= 2, then right_decr[2], which is lst[2] >=1, etc.\n\nYes, because [4,3,2,1] is non-increasing.\n\nThus, for i=0, left_incr and right_decr are True. So peak is 4.\n\nAnother case: [5,5,5,5]. All are max_val.\n\nEach i:\n\nleft_incr[i] is T only up to where the trend is non-decreasing.\n\nIn this case, the entire list is non-decr, so all i have left_incr as T.\n\nright_decr for all i: T.\n\nSo function returns 5.\n\nSo it correctly handles these cases.\n\nThus, the code should be correct.\n\nNow, test the case where the list is [1,3,2,5,4].\n\nIn this case, the maximum is5, at index3.\n\nCheck left_incr[i=3]:\n\nCompute left_incr:\n\ni=1:3 >=1, left_incr[1] = T.\n\ni=2:2 <3 \u2192 left_incr[2] = F.\n\ni=3: left_incr[3] = F, because left_incr[2] is F.\n\nThus, for index3, left_incr is F. So code returns None, which is correct because the list is not unimodal.\n\nAnother test case: [1,2,3,4,3,2,1,0].\n\nmax_val is4, at index3.\n\nleft_incr[3] = T.\n\nright_decr[i=3]: from i=3, 4 >=3, then 3 >=2: all true.\n\nThus, code returns4.\n\nSo appears to be working.\n\nThus, this approach should work.\n</think>\n\nTo solve this problem, we need to identify the peak element in a unimodal list. A unimodal list is defined as one that strictly increases to a peak and then strictly decreases. If the list does not follow this pattern, the function should return `None`. The solution must be efficient, ideally with a time complexity of \\(O(\\log n)\\), but we will aim for an efficient \\(O(n)\\) solution given the constraints.\n\n### Approach\n1. **Identify the Maximum Value**: The peak element is the maximum value in the list. We first compute this maximum value.\n2. **Check Non-Decreasing Trend**: We compute an array `left_incr` where each element indicates whether the list is non-decreasing up to that point.\n3. **Check Non-Increasing Trend**: We compute another array `right_decr` where each element indicates whether the list is non-increasing from that point to the end.\n4. **Validate the Peak**: For each occurrence of the maximum value, we check if the subarray before it is non-decreasing and the subarray after it is non-increasing. If any such occurrence satisfies both conditions, we return the maximum value as the peak.\n\n### Solution Code\n```python\nfrom typing import List, Optional\n\ndef find_peak(lst: List[int]) -> Optional[int]:\n    if not lst:\n        return None  # Though per constraints, len >=1, so this might be unnecessary.\n    n = len(lst)\n    if n == 1:\n        return lst[0]\n    \n    # Compute left_incr: True if the subarray lst[0..i] is non-decreasing\n    left_incr = [False] * n\n    left_incr[0] = True\n    for i in range(1, n):\n        if lst[i] >= lst[i-1] and left_incr[i-1]:\n            left_incr[i] = True\n        else:\n            left_incr[i] = False\n    \n    # Compute right_decr: True if the subarray lst[i..n-1] is non-increasing\n    right_decr = [False] * n\n    right_decr[-1] = True\n    for i in range(n-2, -1, -1):\n        if lst[i] >= lst[i+1] and right_decr[i+1]:\n            right_decr[i] = True\n        else:\n            right_decr[i] = False\n    \n    max_val = max(lst)\n    max_indices = [i for i, x in enumerate(lst) if x == max_val]\n    \n    for i in max_indices:\n        if left_incr[i] and right_decr[i]:\n            return max_val\n    return None\n```\n\n### Explanation\n- **Identifying Maximum Value**: The maximum value is found using Python's built-in `max` function.\n- **Left Array (`left_incr`)**: This array is used to track if the subarray from the start to each index is non-decreasing. It is populated by iterating through the list and checking each element against the previous one.\n- **Right Array (`right_decr`)**: This array is used to track if the subarray from each index to the end is non-increasing. It is populated by iterating backward through the list and checking each element against the next one.\n- **Validation**: For each index where the maximum value occurs, we check if the subarray up to that index is non-decreasing and the subarray from that index to the end is non-increasing. If both conditions are met, the maximum value is returned as the peak.\n\nThis approach ensures that we efficiently check the necessary conditions using precomputed arrays, resulting in an overall time complexity of \\(O(n)\\), which is efficient for large lists.",
  "r1_solution": "from typing import List, Optional\n\ndef find_peak(lst: List[int]) -> Optional[int]:\n    if not lst:\n        return None  # Though per constraints, len >=1, so this might be unnecessary.\n    n = len(lst)\n    if n == 1:\n        return lst[0]\n    \n    # Compute left_incr: True if the subarray lst[0..i] is non-decreasing\n    left_incr = [False] * n\n    left_incr[0] = True\n    for i in range(1, n):\n        if lst[i] >= lst[i-1] and left_incr[i-1]:\n            left_incr[i] = True\n        else:\n            left_incr[i] = False\n    \n    # Compute right_decr: True if the subarray lst[i..n-1] is non-increasing\n    right_decr = [False] * n\n    right_decr[-1] = True\n    for i in range(n-2, -1, -1):\n        if lst[i] >= lst[i+1] and right_decr[i+1]:\n            right_decr[i] = True\n        else:\n            right_decr[i] = False\n    \n    max_val = max(lst)\n    max_indices = [i for i, x in enumerate(lst) if x == max_val]\n    \n    for i in max_indices:\n        if left_incr[i] and right_decr[i]:\n            return max_val\n    return None",
  "metadata": {
    "prompt_id": "00000054",
    "row_id": 54,
    "seed_ids": [
      942
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results1.jsonl"
}