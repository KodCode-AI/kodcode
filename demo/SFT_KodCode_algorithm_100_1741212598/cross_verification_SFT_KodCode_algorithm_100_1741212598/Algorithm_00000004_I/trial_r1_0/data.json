{
  "style": "instruct",
  "subset": "Algorithm",
  "question_id": "Algorithm_00000004_I",
  "question": "You are given a Python function `integer_square_root` that calculates the integer square root of a non-negative integer using a binary search approach. Your task is to implement a more efficient version of this function. Specifically, you need to optimize the current implementation to reduce the number of iterations in the binary search while handling edge cases properly.\n\n**Function Signature**:\n```python\ndef optimized_integer_square_root(num: int) -> int:\n    pass\n```\n\n**Requirements**:\n- The function must handle non-negative integers as input and raise a `ValueError` if the input is negative.\n- The function should return the integer square root of `num` rounded down to the nearest integer.\n- The optimized version should have a time complexity of \\(O(\\log(n))\\) and use \\(O(1)\\) space complexity.\n- Implement an early return for perfect squares and optimize the bounds checking in the binary search.\n\n**Test Cases**:\n```python\nassert optimized_integer_square_root(15) == 3\nassert optimized_integer_square_root(31) == 5\nassert optimized_integer_square_root(25) == 5\nassert optimized_integer_square_root(1) == 1\nassert optimized_integer_square_root(0) == 0\nassert optimized_integer_square_root(2_147_483_647) == 46340\nassert optimized_integer_square_root(-1) is None  # Should raise ValueError\n```\n\n**Note**:\nEnsure that the edge cases and performance are handled correctly. Optimize the bounds checking and early returns to improve the efficiency of the function.",
  "solution": "def optimized_integer_square_root(num: int) -> int:\n    \"\"\"\n    Returns the integer square root of a non-negative integer num.\n    Raises ValueError for negative inputs.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    lower_bound = 1\n    upper_bound = num // 2\n    \n    while lower_bound <= upper_bound:\n        mid = (lower_bound + upper_bound) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            lower_bound = mid + 1\n            result = mid\n        else:\n            upper_bound = mid - 1\n    \n    return result",
  "test_code": "import pytest\n\ndef test_optimized_integer_square_root():\n    assert optimized_integer_square_root(15) == 3\n    assert optimized_integer_square_root(31) == 5\n    assert optimized_integer_square_root(25) == 5\n    assert optimized_integer_square_root(1) == 1\n    assert optimized_integer_square_root(0) == 0\n    assert optimized_integer_square_root(2_147_483_647) == 46340\n    with pytest.raises(ValueError):\n        optimized_integer_square_root(-1)",
  "test_info": [
    {
      "function_name": "optimized_integer_square_root",
      "parameter_list": "(num)",
      "function_declaration": "def optimized_integer_square_root(num):",
      "docstring": "Returns the integer square root of a non-negative integer num.\nRaises ValueError for negative inputs."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, I need to implement an optimized integer square root function using binary search. Let's see. The function is called optimized_integer_square_root and it takes a non-negative integer num. First, I should think about handling the edge cases.\n\nWait, the function must raise a ValueError if the input is negative. So at the beginning, I'll check if num is negative and raise ValueError. For num == 0 or num ==1, it can return 0 and 1 directly because those are the base cases.\n\nHmm, what is the integer square root? Oh right, it's the largest integer x such that x\u00b2 \u2264 num. So for example, sqrt(15) is 3 because 3\u00b2 is 9 which is less than 15, and 4\u00b2 is 16 which is more than 15.\n\nSo the binary search approach is suitable here. We can find the maximum x where x\u00b2 is less than or equal to num.\n\nBut wait, I need to optimize the binary search to have fewer iterations. How can I do that?\n\nWell, the standard binary search starts with low as 0 and high as num. But for large numbers, this might not be efficient. Maybe I can find a better initial value for high.\n\nAlternatively, I can adjust the high value to be the minimum between num and something else. Wait a minute, for numbers larger than 1, the square root can't be larger than num//2 plus one, but wait, no, that's not correct. Because as num increases, the square root is roughly proportional to sqrt(num), so the high can be set to num initially and binary search is O(log n) anyway. So perhaps optimizing the initial high isn't necessary.\n\nHmm, but for the binary search, I can do some early returns as well. Like, check if the number is a perfect square quickly.\n\nBut for the general case, binary search is efficient. So maybe I don't need to change the high initial value. But let's think again: For a very large num, such as 2^31, the square root is 46340, which is much smaller than the high starting at num.\n\nSo perhaps it's more efficient to bound the high as follows: initially set high to 1. While high squared is less than or equal to num, keep doubling high. Wait, that way, for numbers like 2^30, high can find the upper bound quickly, thus reducing the binary search space.\n\nYes, that's a good approach. So the steps are:\n\n1. Handle edge cases (num <0, return ValueError; num is 0 or 1, return directly)\n2. Otherwise, set low = 0, high to 1, and while high^2 <= num, keep doubling high. So high starts at 1, then 2, 4, 8, etc., until high squared exceeds num. This gives a tighter upper bound for the binary search, reducing the initial steps.\n\nThen perform binary search between low and high to find the maximum x such that x\u00b2 <= num.\n\nWait, but what about when num is a perfect square? Like 25: high would be 5*2=10, but we can maybe detect this early.\n\nSo, perhaps before starting the main loop, I can check whether high is the exact square root, but perhaps that's not necessary.\n\nLet me outline the steps in code:\n\nFunction optimized_integer_square_root(num):\n\n- if num <0: raise ValueError.\n- elif num is 0 or 1: return num.\n- else:\n   - set low = 0, high = 1\n   - while high^2 <= num: high *=2\n   - now, high is larger than the square root. So the actual root is in [low, high)\n   - Then perform binary search:\n      - while low <= high:\n          - compute mid = (low + high) // 2\n          - mid_squared = mid * mid\n          - if mid_squared == num: return mid. This is exact square, so return immediately.\n          - elif mid_squared < num: low = mid +1\n          - else: high = mid -1\n   - after the loop, high is the floor of the square root.\n\nWait, but after the loop, when the function exits, the maximum x where x\u00b2 <= num is high, because high is low after the last iteration.\n\nWait, no. Because when the loop ends, high is less than low. At that point, high is the largest x such that x squared <= num.\n\nYes, for example, if num is 15:\n\nAfter the initial expansion, high becomes 16, since iteratively: 1, 2, 4, 8, 16. Because 16\u00b2 is 256, which is larger than 15.\n\nWait wait no, wait the initial expansion is:\n\nhigh starts at 1.\n\nLoop: while high^2 <= num:\n\nWait, no: wait, initially high is 1.\n\nSo for num=15:\nhigh =1 -> check 1^2 (1) <=15: yes, high becomes 2. 2^2 is 4 <=15 \u2192 high becomes4. 4^2 is 16 >15? No. Wait, 4^2 is 16, which is bigger than 15. So the loop stops. So high is 4.\n\nWait no because for num=15, the initial high is 1. 1 squared <=15 \u2192 yes, so high = 2.\n\nThen 2 squared is 4 \u226415 \u2192 high=4.\n\n4 squared is 16, which is larger than 15 \u2192 the loop condition fails, so high remains 4.\n\nSo now the binary search is from 0 to 4.\n\nHmm, binary search:\n\nlow=0, high=4.\n\nmid=2. 2\u00b2=4 <=15.\n\nSo low becomes 3.\n\nNext iteration: mid=(3+4)//2=3.5~3? mid=3. 9 <=15 \u2192 low=4.\n\nNow low equals high: mid=4. 16>15 \u2192 high=3.\n\nNow loop ends. So the function returns high, which is 3.\n\nThat's correct.\n\nAnother example: num=25.\n\nAfter initial expansion:\n\nhigh=1 \u2192 1\u00b2<=25 \u2192 high becomes 2. 2\u00b2=4 <=25 \u2192 high=4. 4\u00b2=16 <=25 \u2192 high=8.8\u00b2=64>25, loop ends.\n\nHigh is 8.\n\nNow binary search between 0 and 8.\n\nMid=4 \u2192 16<=25 \u2192 low=5.\n\nMid=6 \u2192 36>25 \u2192 high=5.\n\nMid is (5+5)/2=5. 5\u00b2=25 \u2192 equals, return 5.\n\nWhich is correct.\n\nSo the approach seems solid.\n\nAnother test case: num=2_147_483_647 (this is 2^31-1, which is 2147483647). The square root is 46340.x, so function should return 46340.\n\nAnother case: num=31. The function should return 5 since 5\u00b2=25,6\u00b2=36>31.\n\nSo the algorithm should correctly find 5.\n\nSo the steps are:\n\n- Handle edge cases.\n- Expand high until high\u00b2>num.\n- Binary search between low and high to find x.\n\nNow, time for code:\n\nLet's write code:\n\ndef optimized_integer_square_root(num: int) -> int:\n    if not isinstance(num, int):\n        raise TypeError(\"Input must be an integer.\")\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num ==0 or num ==1:\n        return num\n\n    low = 0\n    high = 1\n    while high * high <= num:\n        high *=2\n\n    # Now high is larger than the square root\n    while low <= high:\n        mid = (low + high) // 2\n        mid_squared = mid * mid\n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            low = mid +1\n        else:\n            high = mid -1\n    # After loop, high is the floor\n    return high\n\nWait, but in the case when num is 0 or 1, we return immediately.\n\nWait, also, what about num=2?\n\nTesting num=2, the initial expansion:\n\nhigh starts at 1: 1\u00b2=1 <=2 \u2192 high becomes 2.\n\n2\u00b2=4>2 \u2192 loop stops. Now binary search between 0 and 2.\n\nMid = 1, 1\u00b2=1 <2 \u2192 low becomes 2.\n\nNow low is 2, high is 2. Mid is (2+2)//2= 2. 2\u00b2=4>2 \u2192 high becomes 1.\n\nNow low is2 <= high is1 \u2192 loop ends. High is1, which is the correct sqrt(2)=1.\n\nYes.\n\nAnother test case: num=31: high starts at 1, then 2,4,8,16,32.\n\n32 squared is 1024>31 \u2192 loop steps: 1\u00b2<=31 \u2192 high=2, 2\u00b2<=31? 4<=31 \u2192 high=4.\n\n4\u00b2=16 <=31 \u2192 high=8.\n\n8\u00b2=64 <=31? 64>31 \u2192 no. So high is 8.\n\nWait wait wait. Oh no, wait: in the expansion, the loop condition is 'while high * high <= num'. So for high=8: 8\u00b2 is 64, which for num=31 is 64>31, so the condition (high^2 <= num) is false. So the loop breaks and high is8.\n\nWait but 8 is larger than the sqrt of 31, which is about 5.56.\n\nSo binary search is done between 0 and8.\n\nWait no: initial high is1, then 2,4,8.\n\nSo yes.\n\nSo function like this would process 31 correctly.\n\nAnother test: num=2_147_483_647.\n\nThis number is 2^31-1, which is 2,147,483,647. Its square root is about 46340.95, so the function should return 46340.\n\nSo in the expansion phase, high starts at 1 and doubles until high^2>num.\n\nLet's see:\n\nhigh=1 \u2192 squared 1 < num? Yes, double to2.\n\n2^2=4 < num: yes, 4.\n\n4^2=16...\n\nEventually, high will reach a point where it is double each time.\n\nOnce the high is beyond 46340, and high squared exceeds num, the binary search will take over.\n\nBut for numbers that are not perfect squares, the binary search will find the high correctly.\n\nAnother edge case: num=2. As before.\n\nSo the function seems to handle these cases.\n\nBut wait about dealing with 2e31: what about num= (2^46). So the function should handle very big numbers.\n\nNow, another point: what about mid in binary search? For large numbers, computing mid^2 may exceed integer limits, but in Python, integers can be arbitrarily large, so mid*mid is okay.\n\nSo what about early returns? If during the initial high expansion, high could be equal to sqrt(num). For example, if num is a perfect square, like 25. Oh wait, in the expansion, high would stop at 8. Then in the binary search, mid is 4, then 6, then 5, which after mid_squared=25, returns 5.\n\nBut another thought: after expanding high, what if the initial high is a perfect square?\n\nFor example, num=64: initial high is 1, then 2,4,8,16,32,64.\n\nAt each step:\n\nhigh squared is 64: when high=8, squared is 64, which is equal to num. So high doubles to 16 next, but 16\u00b2 is 256>64, so the loop stops with high=16.\n\nSo in binary search, high=16, which is more than sqrt(64)=8.\n\nBut in the binary search step, when mid is 8, it's found to be exact, so it returns 8.\n\nWait, no. Because in the expansion loop, high becomes 16 before the binary search starts.\n\nSo in the binary search, mid will be (0+16)//2=8. Mid_squared is 64 ==num. So it returns 8 immediately.\n\nThat's correct.\n\nWhat about when high becomes 2^2... etc.\n\nWait, I think the code handles all cases correctly.\n\nTesting another case: num=16.\n\nInitially, high=1. High squared 1 <=16: high=2.\n\nHigh squared 4<=16 \u2192 high=4.\n\nHigh squared 16<=16 \u2192 high becomes 8.\n\nCheck 8\u00b2=64>16 \u2192 loop stops. high=8.\n\nBinary search:\n\nlow=0, high=8 \u2192 mid=4. 4\u00b2=16 ==num \u2192 return 4.\n\nThat's correct.\n\nAnother case when num is 2_147_483_647. So as per the test case.\n\nNow, about time complexity: Since high is set with O(log n) steps (because each step doubles high), and the binary search is also O(log n), the total time is still O(log n), which satisfies the requirement.\n\nSpace is O(1): no extra data structures, only variables, so space efficiency is as required.\n\nEdge case handling: num=1 returns 1, num=0 returns 0, and any negative number raises ValueError.\n\nLet me think about other corner cases.\n\nWhat about num=2: returns 1 as discussed.\n\nWhat about num=3: returns 1.\n\nWait, no.\n\nWait 3's integer square root is 1, since 1^2=1 \u22643 <2\u00b2=4. Yes.\n\nSo function returns high=1. Which is correct.\n\nAnother case: num=12.\n\nWhat is integer square root of 12? 3, since 3\u00b2=9, 4\u00b2=16>12.\n\nFunction steps:\n\nhigh expansion:\n\nhigh=1 \u21921\u00b2<=12 \u2192 high=2.\n\n2\u00b2=4 <=12 \u2192 high=4.\n\n4\u00b2=16>12 \u2192 loop stops. high=4.\n\nSo binary search: low=0, high=4.\n\nmid=(0+4)//2=2. 2\u00b2=4 <=12 \u2192 low=2+1=3.\n\nmid=(3+4)//2=3. 3\u00b2=9 <=12 \u2192 low=4.\n\nNow mid becomes(4+4)//2=4. 4\u00b2=16>12 \u2192 high=3.\n\nNow loop ends. low is4, high is3. So function returns high=3, correct.\n\nAll seems to work.\n\nNow, code itself looks correct.\n\nTesting cases with the given test cases:\n\nTest 1: optimized_integer_square_root(15) \u21923 \u2192correct.\n\nTest2: optimized_integer_square_root(31)\u21925.\n\nBecause 5\u00b2=25 \u226431, 6\u00b2=36>31.\n\nTest: 25\u21925.\n\n1\u21921.\n\n0\u21920.\n\nFor the negative case: test -1 should raise ValueError.\n\nAnd for 2,147,483,647 \u219246340.\n\nYes.\n\nSo code seems to handle all test cases.\n\nCan I make any optimizations in the code?\n\nIn the binary search, if the mid is x, and x squared is exactly num, we return immediately. So that's good.\n\nSo I think the code as written should suffice.\n</think>\n\nTo solve this problem, we need to compute the integer square root of a non-negative integer efficiently using a binary search approach. The integer square root of a number `num` is the largest integer `x` such that \\(x^2 \\leq num\\). \n\n### Approach\nThe approach involves using binary search to efficiently find the integer square root. The steps are as follows:\n\n1. **Handle Edge Cases**: Check if the input number is negative and raise a `ValueError` if it is. Directly return the result for the base cases where `num` is 0 or 1.\n\n2. **Expand Upper Bound**: Start with an initial upper bound (`high`) of 1 and double it iteratively until `high^2` exceeds `num`. This step ensures that the upper bound is tight and reduces the number of iterations needed in the subsequent binary search.\n\n3. **Binary Search**: Perform binary search between the lower bound (`low`) and the derived upper bound (`high`) to find the maximum integer `x` such that \\(x^2 \\leq num\\). If the square of the midpoint (`mid`) equals `num`, return `mid` immediately as it is an exact square root. Adjust the bounds based on whether the midpoint squared is less than or greater than `num`.\n\nThis approach ensures a time complexity of \\(O(\\log n)\\) and uses constant space, making it efficient for large inputs.\n\n### Solution Code\n```python\ndef optimized_integer_square_root(num: int) -> int:\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    low = 0\n    high = 1\n    while high * high <= num:\n        high *= 2\n    \n    while low <= high:\n        mid = (low + high) // 2\n        mid_squared = mid * mid\n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return high\n```\n\n### Explanation\n- **Edge Cases Handling**: The function immediately handles the cases where `num` is negative, 0, or 1.\n- **Expanding Upper Bound**: By doubling the upper bound (`high`) iteratively, we quickly narrow down the range within which the integer square root must lie, reducing the number of iterations needed in the binary search.\n- **Binary Search**: The binary search efficiently narrows down the possible values for the integer square root by adjusting the bounds based on the comparison of the midpoint squared with `num`.\n\nThis method ensures that we efficiently find the integer square root with minimal iterations, making it suitable for very large numbers.",
  "r1_solution": "def optimized_integer_square_root(num: int) -> int:\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if num == 0 or num == 1:\n        return num\n    \n    low = 0\n    high = 1\n    while high * high <= num:\n        high *= 2\n    \n    while low <= high:\n        mid = (low + high) // 2\n        mid_squared = mid * mid\n        if mid_squared == num:\n            return mid\n        elif mid_squared < num:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return high",
  "metadata": {
    "prompt_id": "00000004",
    "row_id": 4,
    "seed_ids": [
      691
    ],
    "mode": "algorithm",
    "original_instruction": ""
  },
  "file_source": "KodCode_algorithm_100_1741212598_prepared_results0.jsonl"
}