{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000040_C",
  "question": "from typing import List\n\nclass CustomQueue:\n    \"\"\"Design a class CustomQueue that supports the following operations:\n    - CustomQueue(int capacity) Initializes the queue with a given capacity.\n    - void enqueue(int value) Adds a value to the end of the queue if there is still space. Returns false if the queue is full.\n    - int dequeue() Removes and returns the value at the front of the queue. Returns -1 if the queue is empty.\n    - bool isFull() Returns true if the queue is full, otherwise returns false.\n    - bool isEmpty() Returns true if the queue is empty, otherwise returns false.\n    - List[int] getQueue() Returns the current elements in the queue as a list, maintaining the order of elements as they were added.\n    \"\"\"",
  "solution": "class CustomQueue:\n    def __init__(self, capacity: int):\n        self.queue = []\n        self.capacity = capacity\n        self.front = 0\n        self.rear = 0\n\n    def enqueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.queue.append(value)\n        self.rear += 1\n        return True\n\n    def dequeue(self) -> int:\n        if self.isEmpty():\n            return -1\n        value = self.queue[self.front]\n        self.front += 1\n        return value\n\n    def isFull(self) -> bool:\n        return self.rear - self.front == self.capacity\n\n    def isEmpty(self) -> bool:\n        return self.front == self.rear\n\n    def getQueue(self) -> list:\n        return self.queue[self.front:self.rear]",
  "test_code": "import pytest\n\ndef test_customqueue_operations():\n    custom_queue = CustomQueue(3)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.enqueue(3) is True\n    assert custom_queue.enqueue(4) is False  # Queue is full\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.getQueue() == [2, 3]\n    assert custom_queue.dequeue() == 2\n    assert custom_queue.dequeue() == 3\n    assert custom_queue.dequeue() == -1  # Queue is empty\n    assert custom_queue.enqueue(5) is True\n    assert custom_queue.getQueue() == [5]\n\ndef test_queue_limit():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.isFull() is True\n    assert custom_queue.enqueue(3) is False\n    assert custom_queue.getQueue() == [1, 2]\n\ndef test_empty_queue():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.isEmpty() is True\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.getQueue() == [1]\n    assert custom_queue.isEmpty() is False\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.isEmpty() is True\n\ndef test_enqueue_and_dequeue_mixed():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.enqueue(3) is True\n    assert custom_queue.getQueue() == [2, 3]\n    assert custom_queue.dequeue() == 2\n    assert custom_queue.dequeue() == 3\n    assert custom_queue.isEmpty() is True",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to design a class called CustomQueue. The requirements given are specific, so I should go through each method and think about how to implement them.\n\nFirst, the constructor: CustomQueue(int capacity). So when an instance is created, it's initialized with a certain capacity. I should probably store this capacity as an instance variable. Also, I'll need to keep track of the elements in the queue. Maybe using a list to represent the queue, with the front being index 0.\n\nNext, the enqueue method. It should add a value to the end of the queue if there's space. If the queue is full, return False. So I need to check if the length of the queue is equal to capacity. If yes, return False. Otherwise, append the value to the list.\n\nThen dequeue. It removes and returns the front value. If empty, return -1. So I'll check if the queue is empty. If not, pop the first element and return it. Wait, popping the first element from a list is O(n) time because the elements have to shift, but for the scope of this problem, I think it's acceptable.\n\nThe isFull method is straightforward. Just return if the length of the queue is equal to the capacity.\n\nThe isEmpty method returns if the length is zero.\n\nThe getQueue method should return the current elements as a list, in the order they were added. So simply return a copy of the internal list, perhaps, or a reference, but maybe a new list so that modifications to the returned list don't affect the queue.\n\nLet me think about the data structure. The list in Python can be used as a queue. When elements are added to the end, dequeue would remove the first element. So for example, if the queue is [1,2,3], dequeue would return 1, and the queue becomes [2,3].\n\nWait, but using a list and popping from the front is not the most efficient, but again, for this problem, the solution is acceptable.\n\nSo, I'll go ahead and structure the class as follows:\n\n- Attributes: capacity (an integer), queue (a list).\n- Methods as per the requirements.\n\nLet's outline each method.\n\nThe constructor: def __init__(self, capacity). Then self.capacity = capacity, and self.queue = [].\n\nEnqueue: Check if len(self.queue) < self.capacity. If yes, append; return True? Wait, wait. Wait the problem says the enqueue method returns False if the queue is full. Otherwise adds the value. So, for enqueue, if after adding, if the queue's length exceeds capacity, but given that we check before, maybe not. Wait, wait, no: the method should add the value if there is still space, and return False only when the queue is full.\n\nWait the problem says returns false if the queue is full. So when we call enqueue, if the queue is already full (length == capacity), it returns False. Else, appends and returns True (wait no, function says void enqueue(int value) in the comment above, but wait the user's problem statement says:\n\nAh wait no, the instructions describe each function with its return type. Let me look back:\n\nYes, in the problem statement. So enqueue adds a value to the end if space, returns False if queue is full.\n\nWait, the initial problem says:\n\n- void enqueue(int value) ... but the description says returns False when full. Oh, perhaps in Python, it's adjusted, so the function returns a boolean: True for success, False if full.\n\nWait, but in the problem statement, looking again:\n\nProblem says:\n\nvoid enqueue(int value) Adds a value to the end of the queue if there is still space. Returns false if the queue is full.\n\nBut in Python, void isn't a type, but for this class, perhaps the method returns a boolean.\n\nWait, the original problem description:\n\nThe comment says:\n\n- enqueue(int value) adds value to end ... returns false if the queue is full.\n\nSo the method returns a boolean. So the signature in code would be def enqueue(self, value) -> bool:.\n\nBut let me look back.\n\nYes, the initial problem says:\n\nclass CustomQueue has methods like enqueue(int value) which returns false when full.\n\nSo, for enqueue, return True when successfully added; False when full.\n\nSo implementing:\n\ndef enqueue(self, value):\n\nif len(self.queue) >= self.capacity:\n\nreturn False\n\nelse:\n\nself.queue.append(value)\n\nreturn True\n\nSimilarly, dequeue returns the front element, which is the first element. So:\n\ndef dequeue(self):\n\nif not self.queue:\n\nreturn -1\n\nelse:\n\nreturn self.queue.pop(0)\n\nWait, but popping from the front is O(n), but since it's a simple problem, perhaps it's acceptable.\n\nIsFull: return len(self.queue) == self.capacity.\n\nIsEmpty: return len(self.queue) == 0.\n\nGetQueue: return self.queue.copy() ?\n\nWait, no, because the problem says to return the current elements in the queue. So we can just return a copy of the list, as the method.\n\nWait, but if I return self.queue.copy(), it would be a list. Or, perhaps, can just return the list as is. Or, return a list, perhaps to prevent external modifications.\n\nBut the question says to return it as a list. So I'll return list(self.queue).\n\nAlternatively, in the code, return self.queue.copy() or simply self.queue[:] ?\n\nAlternatively, maybe I should return a new list, not a reference. Because, if someone modifies the returned list, the queue's internal state shouldn't change.\n\nYes, so better to return a copy. So self.queue.copy() would be a shallow copy, which is sufficient here since the elements are integers.\n\nWait, but in Python, lists are mutable so returning a copy is better.\n\nSo, def getQueue(self): return self.queue.copy()\n\nNow, putting it all together.\n\nWait, but the capacity is fixed, so when it's initialized, the maximum number of elements is that value.\n\nWait, let me take example.\n\nSample usage:\n\nq = CustomQueue(3)\n\nprint(q.isEmpty())  # True\n\nprint(q.isFull())   # False\n\nq.enqueue(1)  # returns True\n\nq.enqueue(2)  # True\n\nq.enqueue(3)  # True\n\nq.enqueue(4)  # returns False\n\nprint(q.isEmpty()) # False\n\nq.dequeue() # returns 1\n\nq.getQueue() # [2,3]\n\nIs that the case?\n\nSo, the code seems to handle that.\n\nSo, the code outline is:\n\nclass CustomQueue:\n\n    def __init__(self, capacity):\n\n        self.capacity = capacity\n\n        self.queue = []\n\n    def enqueue(self, value):\n\n        if len(self.queue) >= self.capacity:\n\n            return False\n\n        self.queue.append(value)\n\n        return True\n\n    def dequeue(self):\n\n        if not self.queue:\n\n            return -1\n\n        return self.queue.pop(0)\n\n    def isFull(self):\n\n        return len(self.queue) == self.capacity\n\n    def isEmpty(self):\n\n        return len(self.queue) == 0\n\n    def getQueue(self):\n\n        return self.queue.copy()\n\nWait, but in getQueue, do we need to return a new list? self.queue.copy() or list(self.queue). Either is fine.\n\nWait, but what about if someone appends to the returned list? Let's say:\n\nlst = q.getQueue()\n\nlst.append(5)\n\nWe don't want q.queue to be affected. Since self.queue.copy() creates a shallow copy, the original queue remains unchanged.\n\nYes, so the implementation seems correct.\n\nTesting for some edge cases.\n\nTest case 1:\n\nq = CustomQueue(0)\n\nTrying to enqueue anything returns False.\n\nBut wait, can capacity be zero? The problem description says initializes with a given capacity, but doesn't specify whether capacity can be zero. So the problem may not handle that. But in Python, if someone passes zero, the queue cannot hold any elements.\n\nTest case 2:\n\nq = CustomQueue(2)\n\nEnqueue 1 and 2 (both successful).\n\nEnqueue 3\u2014returns False.\n\nDequeue once\u2014returns 1. Then, check isFull: returns False.\n\nWait:\n\nAfter adding 1, 2, and trying 3, queue is [1,2].\n\nThen dequeue returns 1.\n\nNow, queue is [2].\n\nSo getQueue returns [2]. Then, enqueue 3 would now return True.\n\nWait len is 1, capacity is 2.\n\nSo yes.\n\nSo the code works as expected.\n\nAnother test case:\n\nq = CustomQueue(1)\n\nEnqueue 5: success.\n\nDequeue: returns 5.\n\nEnqueue 6: success.\n\nSo queue is [6].\n\nAll right.\n\nNow, what about if the capacity is a negative number? Probably, the class should handle that as invalid, but since the problem description says the constructor takes an int capacity, perhaps zero is allowed (but that makes a queue that can't hold anything). So, the code doesn't enforce that capacity is positive.\n\nBut the problem may expect us to handle negative values in some way. Oh, but in practice, a CustomQueue with a negative capacity is invalid, but since the problem doesn't specify, perhaps we don't need to handle it.\n\nIn code, it's as per the problem statement.\n\nThus, the code seems to handle all the required cases.\n</think>\n\nTo solve this problem, we need to design a class `CustomQueue` that implements a queue with fixed capacity and supports several operations including adding elements, removing elements, checking if the queue is full or empty, and retrieving the current list of elements.\n\n### Approach\n\n1. **Initialization**: The queue is initialized with a given capacity, which determines the maximum number of elements the queue can hold. We use a list to store the elements of the queue.\n\n2. **Enqueue Operation**: This operation adds an element to the end of the queue if there is space available. If the queue is full, it returns `False`.\n\n3. **Dequeue Operation**: This operation removes the element at the front of the queue and returns it. If the queue is empty, it returns `-1`.\n\n4. **Full Check**: This operation checks if the queue is full by comparing the current number of elements with the capacity.\n\n5. **Empty Check**: This operation checks if the queue is empty by verifying the length of the list.\n\n6. **Retrieve Elements**: This operation returns a copy of the current list of elements in the queue, maintaining the order in which they were added.\n\n### Solution Code\n\n```python\nfrom typing import List\n\nclass CustomQueue:\n    \"\"\"A class to implement a queue with fixed capacity.\"\"\"\n    \n    def __init__(self, capacity: int):\n        \"\"\"Initialize the queue with the given capacity.\"\"\"\n        self.capacity = capacity\n        self.queue = []\n    \n    def enqueue(self, value: int) -> bool:\n        \"\"\"Add a value to the end of the queue if there is space. Returns False if the queue is full.\"\"\"\n        if len(self.queue) >= self.capacity:\n            return False\n        self.queue.append(value)\n        return True\n    \n    def dequeue(self) -> int:\n        \"\"\"Remove and return the value at the front of the queue. Returns -1 if the queue is empty.\"\"\"\n        if not self.queue:\n            return -1\n        return self.queue.pop(0)\n    \n    def isFull(self) -> bool:\n        \"\"\"Return True if the queue is full, otherwise False.\"\"\"\n        return len(self.queue) == self.capacity\n    \n    def isEmpty(self) -> bool:\n        \"\"\"Return True if the queue is empty, otherwise False.\"\"\"\n        return len(self.queue) == 0\n    \n    def getQueue(self) -> List[int]:\n        \"\"\"Return the current elements in the queue as a list, maintaining the order.\"\"\"\n        return self.queue.copy()\n```\n\n### Explanation\n\n- **Initialization**: The constructor `__init__` sets the capacity and initializes an empty list to hold the queue elements.\n  \n- **Enqueue Method**: This method checks if the queue has reached its capacity. If not, it appends the value to the list and returns `True`. If the queue is full, it returns `False`.\n\n- **Dequeue Method**: This method checks if the queue is empty. If it is, it returns `-1`. Otherwise, it removes and returns the first element using `pop(0)`.\n\n- **isFull Method**: This method checks if the length of the queue list is equal to the capacity and returns the result.\n\n- **isEmpty Method**: This method checks if the queue list is empty and returns the result.\n\n- **getQueue Method**: This method returns a copy of the queue list to prevent external modifications from affecting the internal state of the queue.\n\nThis approach ensures that all queue operations are handled efficiently, with each method providing the required functionality as described. The use of a list allows for straightforward implementation of queue operations, adhering to the constraints and requirements specified.",
  "r1_solution": "from typing import List\n\nclass CustomQueue:\n    \"\"\"A class to implement a queue with fixed capacity.\"\"\"\n    \n    def __init__(self, capacity: int):\n        \"\"\"Initialize the queue with the given capacity.\"\"\"\n        self.capacity = capacity\n        self.queue = []\n    \n    def enqueue(self, value: int) -> bool:\n        \"\"\"Add a value to the end of the queue if there is space. Returns False if the queue is full.\"\"\"\n        if len(self.queue) >= self.capacity:\n            return False\n        self.queue.append(value)\n        return True\n    \n    def dequeue(self) -> int:\n        \"\"\"Remove and return the value at the front of the queue. Returns -1 if the queue is empty.\"\"\"\n        if not self.queue:\n            return -1\n        return self.queue.pop(0)\n    \n    def isFull(self) -> bool:\n        \"\"\"Return True if the queue is full, otherwise False.\"\"\"\n        return len(self.queue) == self.capacity\n    \n    def isEmpty(self) -> bool:\n        \"\"\"Return True if the queue is empty, otherwise False.\"\"\"\n        return len(self.queue) == 0\n    \n    def getQueue(self) -> List[int]:\n        \"\"\"Return the current elements in the queue as a list, maintaining the order.\"\"\"\n        return self.queue.copy()",
  "metadata": {
    "prompt_id": "00000040",
    "row_id": 40,
    "seed_ids": [
      "1656",
      "733",
      "352"
    ],
    "mode": "leetcode",
    "original_instruction": "Design a class `CustomQueue` that supports the following operations:\n\n- `CustomQueue(int capacity)` Initializes the queue with a given capacity.\n- `void enqueue(int value)` Adds a value to the end of the queue if there is still space. Returns `false` if the queue is full.\n- `int dequeue()` Removes and returns the value at the front of the queue. Returns `-1` if the queue is empty.\n- `bool isFull()` Returns `true` if the queue is full, otherwise returns `false`.\n- `bool isEmpty()` Returns `true` if the queue is empty, otherwise returns `false`.\n\nImplement the `CustomQueue` class such that all operations are performed in constant time, i.e., O(1). Additionally, provide a method `getQueue()` that returns the current elements in the queue as a list, maintaining the order of elements as they were added."
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results1.jsonl"
}