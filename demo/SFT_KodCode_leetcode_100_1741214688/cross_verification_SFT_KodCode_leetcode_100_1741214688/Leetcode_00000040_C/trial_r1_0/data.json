{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000040_C",
  "question": "from typing import List\n\nclass CustomQueue:\n    \"\"\"Design a class CustomQueue that supports the following operations:\n    - CustomQueue(int capacity) Initializes the queue with a given capacity.\n    - void enqueue(int value) Adds a value to the end of the queue if there is still space. Returns false if the queue is full.\n    - int dequeue() Removes and returns the value at the front of the queue. Returns -1 if the queue is empty.\n    - bool isFull() Returns true if the queue is full, otherwise returns false.\n    - bool isEmpty() Returns true if the queue is empty, otherwise returns false.\n    - List[int] getQueue() Returns the current elements in the queue as a list, maintaining the order of elements as they were added.\n    \"\"\"",
  "solution": "class CustomQueue:\n    def __init__(self, capacity: int):\n        self.queue = []\n        self.capacity = capacity\n        self.front = 0\n        self.rear = 0\n\n    def enqueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.queue.append(value)\n        self.rear += 1\n        return True\n\n    def dequeue(self) -> int:\n        if self.isEmpty():\n            return -1\n        value = self.queue[self.front]\n        self.front += 1\n        return value\n\n    def isFull(self) -> bool:\n        return self.rear - self.front == self.capacity\n\n    def isEmpty(self) -> bool:\n        return self.front == self.rear\n\n    def getQueue(self) -> list:\n        return self.queue[self.front:self.rear]",
  "test_code": "import pytest\n\ndef test_customqueue_operations():\n    custom_queue = CustomQueue(3)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.enqueue(3) is True\n    assert custom_queue.enqueue(4) is False  # Queue is full\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.getQueue() == [2, 3]\n    assert custom_queue.dequeue() == 2\n    assert custom_queue.dequeue() == 3\n    assert custom_queue.dequeue() == -1  # Queue is empty\n    assert custom_queue.enqueue(5) is True\n    assert custom_queue.getQueue() == [5]\n\ndef test_queue_limit():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.isFull() is True\n    assert custom_queue.enqueue(3) is False\n    assert custom_queue.getQueue() == [1, 2]\n\ndef test_empty_queue():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.isEmpty() is True\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.getQueue() == [1]\n    assert custom_queue.isEmpty() is False\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.isEmpty() is True\n\ndef test_enqueue_and_dequeue_mixed():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.enqueue(3) is True\n    assert custom_queue.getQueue() == [2, 3]\n    assert custom_queue.dequeue() == 2\n    assert custom_queue.dequeue() == 3\n    assert custom_queue.isEmpty() is True",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to design a class called CustomQueue. Hmm, the problem says it should have several operations. Let me think about each of them.\n\nFirst, the constructor takes an integer for capacity. So I'll need to track that. Oh right, when the queue is created, it has a maximum number of elements it can hold.\n\nThen there's enqueue which adds a value to the end if there's space. It returns False if the queue is full. Oh wait, I remember in some languages enqueue returns a boolean for success or failure. So I need to check if the queue is already full before adding. How do I track that? Maybe keep a count of the current number of elements.\n\nDequeue removes and returns the front value. If empty, returns -1. So I have some structure that allows me to get the first element out. Also, I need to handle cases where it's empty.\n\nThe isFull method returns true if full. That's straightforward by checking if current count equals capacity. Similarly, isEmpty checks if count is zero or the queue is empty.\n\nThe getQueue method returns the current elements in order as a list. So I need to have a data structure that maintains the order. Like a list in Python, where I can append to the end and pop from the front.\n\nSo putting this together, I think using a list as the underlying data structure makes sense. The enqueue would append to the list, but only if the length is less than capacity. Dequeue would pop from the front, but if the list is empty, return -1.\n\nWait, popping from the front of a list is O(n) because all elements shift, but since the problem doesn't specify high performance, maybe it's acceptable. For the given problem, let's proceed with a list.\n\nLet me outline the attributes:\n\n- self.capacity: to store the maximum allowed elements.\n- self.queue: a list to hold the elements in order.\n\nNow, the methods:\n\nConstructor:\n- Initializes the queue with a given capacity.\n- So self.capacity = capacity, and self.queue = [] maybe. Or self.queue could be a deque for more efficient pops from front. Oh right, because appending and popping from the front of a list is not efficient, but for the scope of this problem, perhaps the straightforward list is acceptable unless it's expected to handle large data.\n\nWait, but if using a deque, the code is more efficient because popping from the front is O(1). But for simplicity, maybe just a regular list is sufficient. Alternatively, using a deque could be better. Let me consider.\n\nBut in the custom queue, the problem doesn't mention anything about this, so perhaps the standard list is acceptable.\n\nSo let's proceed with a regular list.\n\nEnqueue method:\n\ndef enqueue(self, value):\n\nCheck if len(self.queue) is equal to self.capacity. If yes, return False. Else, append the value to the queue and return True.\n\nWait, but the problem says enqueue adds and returns False on failure. So the method should return a boolean indicating success.\n\nDequeue:\n\ndef dequeue(self):\n\nIf self.isEmpty() is True, return -1. Else, pop the first element (self.queue.pop(0)) and return it. But popping from index 0 of a list is O(n), which is less efficient for large queues. But again, for the problem, perhaps it's acceptable.\n\nAlternatively, using a deque and popleft() is O(1). Maybe I should use deque for more efficient operations.\n\nLet me think about this: I can import deque from collections, but in that case, the problem didn't mention that. Alternatively, implement a circular array or something, but that's more complicated.\n\nWell, perhaps in the solution code, a simple list with pop(0) is sufficient. Or maybe the custom queue doesn't have to be the most efficient.\n\nSo each method would do as follows:\n\nEnqueue: check if current size is sufficient, append, return True or False.\n\nDequeue: check if empty, if so return -1, else pop and return.\n\nIs full: return whether len(queue) == capacity.\n\nIs empty: return len(queue) ==0.\n\nGetQueue: return a copy of self.queue? Or return self.queue as a list. Wait, the problem calls it getQueue() which returns the list in order as they were added. So maybe just return self.queue.copy() to avoid external modifications? Or do we need to make it immutable? Well, the method is supposed to return the list, but in Python, lists are mutable. So perhaps returning a copy is safer. Alternatively, perhaps the method is intended to just return the elements in order, and making a new list each time, so the user can't modify the internal state.\n\nSo in the getQueue method, returning list(self.queue) would create a copy.\n\nLet me outline this step by step.\n\nSo the CustomQueue class will have:\n\ndef __init__(self, capacity):\n    self.capacity = capacity\n    self.queue = []  # or deque for better performance\n\ndef enqueue(self, value):\n    if len(self.queue) >= self.capacity:\n        return False\n    self.queue.append(value)\n    return True\n\nWait wait, no: condition should be if len is equal to capacity, because after adding, it would be higher. So the condition is correct.\n\nBut wait, for a queue, we cannot add beyond the capacity. So before adding, check if there's space.\n\nNow for the dequeue:\n\ndef dequeue(self):\n    if self.isEmpty():\n        return -1\n    return self.queue.pop(0)\n\nBut for a deque, we can use popleft(), which is O(1). So perhaps using a deque is better.\n\nWait, I should now think: Should I use a deque or a list?\n\nWell, for this problem, perhaps the solution will not be tested against extremely large data. So it might not matter. But in a real-world scenario, the deque is better for FIFO operations as append and popleft are O(1).\n\nBut without importing deque, perhaps the problem expects a list-based solution.\n\nAlternatively, perhaps if I don't import from collections, self.queue can be a deque. Wait, but in Python, if you create a deque but don't import or define it, it would cause issues. So perhaps the solution should use a deque for efficiency.\n\nWait, but the problem statement didn't specify performance constraints, so perhaps it's better to go with a simple list, which is easier to explain and implement.\n\nBut for now, perhaps better to proceed with a deque for efficiency.\n\nWait, no, that would require from collections import deque. But in the code, that import is not present in the initial code. So perhaps the solution expects a list-based approach.\n\nAlternatively, for the dequeue to pop from the front, perhaps using pop(0) is acceptable.\n\nIn that case, the getQueue method can just return self.queue.copy().\n\nSo, putting it all together.\n\nImplementing the methods:\n\n1. enqueue: check current length, if it's >= capacity, return False. Else append, return True.\n\nWait, code:\n\ndef enqueue(self, value):\n    if len(self.queue) >= self.capacity:\n        return False\n    self.queue.append(value)\n    return True\n\nBut wait, supposeCapacity is 3, and queue has length 3. So trying to enqueue should return False.\n\nYes.\n\nDequeue:\n\ndef dequeue(self):\n    if self.isEmpty():\n        return -1\n    return self.queue.pop(0)\n\nWait that's O(n), but perhaps acceptable.\n\nThen, isFull():\n\ndef isFull(self):\n    return len(self.queue) == self.capacity\n\nisEmpty():\n\ndef isEmpty(self):\n    return len(self.queue) ==0\n\nWait, the problem states that returns True if the queue is empty, otherwise False. So our method is correct.\n\nLastly, getQueue:\n\ndef getQueue(self):\n    return list(self.queue)  # or self.queue.copy() or something similar\n\nBut in Python, self.queue is a list, so list(self.queue) creates a new list. Or perhaps self.queue.copy() is more efficient. Although for small data, it doesn't matter.\n\nWait, but actually, the queue is stored as a list, and getQueue is supposed to return the current elements in order. So no, it should return exactly that. So no problem.\n\nWait no: suppose within enqueue, the appending is done at the end, which represents the end of the queue, which is correct. So the list self.queue is stored as a list where the first element is the front, then the next, etc. So for the getQueue list, this order is correct.\n\nWait no: if self.queue is a list where self.enqueue appends to the end, and self.dequeue pops from front, then after dequeues, the front is at the beginning of the list. So getQueue() would return the elements correctly.\n\nWait, for example: enqueue 1, 2, 3. self.queue is [1,2,3]. Dequeue 1. Now self.queue is [2,3]. So getQueue returns [2,3], which is correct.\n\nWait, but if we have a capacity of 3.\n\nWait, let me test a scenario.\n\nSuppose capacity is 3.\n\nEnqueue 1: queue is [1].\n\nEnqueue 2: [1,2].\n\nEnqueue 3: [1,2,3].\n\nDequeue: returns 1, queue becomes [2,3].\n\nEnqueue 4: is the queue isFull? Because len([2,3) is 2 < capacity 3, so 4 is added.\n\nQueue becomes [2,3,4].\n\nDequeue returns 2, queue [3,4].\n\nDequeue returns 3, queue [4].\n\nDequeue returns 4, queue empty.\n\nSo seems correct.\n\nBut when using a deque, perhaps it's even better. Alternatively, using deque.popleft().\n\nHmm, perhaps it's better to use deque, because pop(0) is O(n), and for large queues, it's slow.\n\nBut for the problem's sake, perhaps the efficiency is not important, and the code expects to use a basic list.\n\nBut perhaps in the code, if I use a deque, it will be more efficient, but requires adding from collections import deque.\n\nBut in the initial problem setup, the code is not given. So the code needs to have the import, or not.\n\nSo perhaps the solution can include using deque, but that requires importing.\n\nAlternatively, proceed with the list-based approach, but in that case, dequeue is O(n).\n\nGiven that, perhaps it's better to include deque.\n\nWait, but the initial code given to the user only provides the method signatures and no imports. So to use deque, I have to import it.\n\nSo the code would have:\n\nfrom collections import deque.\n\nBut the initial code only has the class. So perhaps in the answer, I have to include the import.\n\nAlternatively, perhaps for the problem's sake, it's better to proceed without deque, and just use a list.\n\nWell, in that case, proceed with a list.\n\nSo putting it all together, the class would be as follows:\n\nImplement the methods as described.\n\nWait, but I have to implement each of the functions. Also, check the return types.\n\nFor example, enqueue returns False when full, else True.\n\nDequeue returns -1 when empty, else the int.\n\nSo in code:\n\nclass CustomQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = []\n\n    def enqueue(self, value):\n        if len(self.queue) >= self.capacity:\n            return False\n        self.queue.append(value)\n        return True\n\n    def dequeue(self):\n        if self.isEmpty():\n            return -1\n        return self.queue.pop(0)\n\n    def isFull(self):\n        return len(self.queue) == self.capacity\n\n    def isEmpty(self):\n        return len(self.queue) == 0\n\n    def getQueue(self):\n        return self.queue.copy()  # returns a copy to prevent external modification.\n\nWait, but the getQueue method is to return the current elements as a list in the order as they were added. So the order is correct as our queue is a list with elements in order, with front at index 0, end at the end.\n\nWait, but in this setup, if you use pop(0) and then append, the queue is [v1, v2, v3, etc.], so dequeue() returns v1.\n\nYes, that's correct.\n\nSo the getQueue() returns the list of elements starting from the front.\n\nSo for example, after enqueing 1, then 2, the getQueue returns [1,2].\n\nHmm, that's correct.\n\nYes, this should work.\n\nBut wait, in some queue implementations, the front is at the end of the list. No, in this case, the first element is front.\n\nWait, no: when we append elements, they are added to the end of the list. And when dequeuing, we pop from the front of the list. So the front is at the beginning of the list.\n\nWait no: Let me think again.\n\nIn the code above, when you do self.queue.append(value), the value is added to the end of the list. Then, dequeue does a pop(0), which is the first element of the list. So, the order of the queue is this:\n\nWhen elements are added, they go to the end: queue is [a, b, c].\n\nWhen you dequeue, you pop a, then next dequeue pops b.\n\nSo the first element is at the beginning of the list, which is correct.\n\nSo the getQueue() method returns the list in order of insertion, so the elements are as they were added, but in the order they are in the queue.\n\nYes, that's correct.\n\nSo the code seems correct.\n\nNow, I should check some test cases.\n\nTest case 1:\n\nInitialize with capacity 2.\n\nEnqueue 1: queue becomes [1].\n\nEnqueue 2: queue [1,2].\n\nEnqueue 3: should return False.\n\nDequeue: returns 1. Queue [2].\n\nisEmpty: False. isFull: No.\n\nThen enqueue 3: should be allowed, queue becomes [2,3].\n\nEnqueue 4: returns False.\n\nDequeue: returns 2. Queue [3].\n\nDequeue: returns 3. Queue empty.\n\nDequeue: returns -1.\n\nThis is correct.\n\nAnother test case.\n\nSo code seems to handle these cases.\n\nAnother edge case: capacity 0. Wait, what happens? If capacity is initialized to 0: then enqueue always returns False, because len(queue) is 0, which is equal to capacity. Because in the code, the condition is len>=capacity. So when capacity is 0, any enqueue is False.\n\nBut in the constructor, is allowing capacity to be zero? Well, as per the setup, it's up to the code. What if someone creates a CustomQueue with capacity 0? The code allows that, but the queue can't hold any elements.\n\nSo if someone tries to enqueue, it fails.\n\nBut is it a problem? I think according to the problem statement, the capacity is given as an int; perhaps 0 or negative capacity is possible. But the problem says \"if the queue is full\" for enqueue.\n\nWait, the description says, CustomQueue(int capacity), so it's initializing with a given capacity. So perhaps the code should set capacity to max(0, given value) to avoid negative capacities.\n\nWait, but that's an assumption. The problem didn't mention handling cases where capacity is negative. Perhaps the code should handle that.\n\nFor example, a user initializes a CustomQueue(-5). Setting the capacity to something meaningful, like 0, perhaps.\n\nSo perhaps in the __init__ method, we should set capacity to max(0, given capacity).\n\nBut that's an assumption beyond the problem statement. Since the problem doesn't specify, perhaps it's better to proceed.\n\nSo the code doesn't handle negative capacity. But according to the initial code, the constructor takes an int, which could be any value.\n\nWell, perhaps in the problem, the capacity is positive.\n\nBut if the user provides a negative capacity, the isFull condition will always return False, but enqueue will always allow adds since len(self.queue) is 0, which is < capacity if capacity is negative.\n\nWait, no. Let's think about:\n\ncapacity = -5.\n\nenqueue is allowed if len < capacity.\n\nWait, df in this scenario.\n\ncapacity is -5.\n\nFirst enqueue: len(queue) is 0, which is < -5? No, 0 is not less than -5. 0 is bigger.\n\nWait, 0 is greater than -5. So len(queue) >= capacity (since capacity is -5, could be if len is 0 >= -5, which is True). So in enqueue: len is 0 >= -5 \u2192 False? No, or is it?\n\nWait, len(queue) is 0.\n\nif len(queue) >= self.capacity \u2192 0 >= -5, which is True. So enqueue returns False.\n\nWait, wait in this case, the queue is supposed to have a capacity of -5. So maximum number of elements is 5? Or is capacity allowed to be negative, implying that the queue can have unlimited elements? Or that's not a case that is considered.\n\nIn this problem, the setup expects that the queue has a given capacity. So perhaps the constructor should ensure that capacity is at least zero.\n\nSo to avoid negative capacities, perhaps in the __init__, we can set capacity to a max of 0 and the given value.\n\nSo adjust the __init__:\n\nself.capacity = capacity if capacity >0 else 0\n\nSo now, if the passed capacity is <=0, the capacity becomes zero.\n\nBut then, for CustomQueue(0) \u2192 capacity is 0.\n\nEnqueue always returns False.\n\nThis avoids allowing any elements into the queue.\n\nWhat about a capacity of 5, but as a maximum limit. So the code is correct.\n\nBut perhaps the problem expects that the capacity is positive, but nothing is stated.\n\nSo perhaps in the __init__, handle that case.\n\nBut the initial code in the problem didn't specify that, so perhaps it's an oversight. So, can I include that?\n\nAlternatively, perhaps it's not required.\n\nBut since the problem is a code to be filled, perhaps better to write a robust code, handling the case.\n\nSo, in the __init__ method:\n\ndef __init__(self, capacity):\n    self.capacity = capacity\n    if self.capacity < 0:\n        self.capacity = 0\n\nBut even better, set self.capacity to max(0, capacity).\n\nSo that capacity is at least 0.\n\nThus:\n\nself.capacity = max(0, capacity)\n\nBecause if the capacity is negative, setting it to 0.\n\nYes, this makes more sense.\n\nOther test cases considered, the code should handle when a negative capacity is given.\n\nSo adding:\n\ndef __init__(self, capacity):\n    self.capacity = max(0, capacity)  # ensure capacity is non-negative.\n    self.queue = []\n\nYes.\n\nI think that's more robust.\n\nSo with that, the code is ready.\n\nThus, the class will have:\n\n- __init__ with max 0, capacity.\n\n- The other methods as designed.\n</think>\n\nTo solve this problem, we need to design a class `CustomQueue` that supports various queue operations, including initialization with a given capacity, enqueueing elements, dequeueing elements, checking if the queue is full or empty, and retrieving the current elements in the queue. \n\n### Approach\n1. **Initialization**: The queue is initialized with a specified capacity, which is the maximum number of elements the queue can hold. The capacity is set to a non-negative value to handle any invalid inputs.\n2. **Enqueue**: Adds an element to the end of the queue if there is space. If the queue is full, it returns `False`.\n3. **Dequeue**: Removes and returns the element at the front of the queue. If the queue is empty, it returns `-1`.\n4. **Check Full**: Returns `True` if the queue is full, otherwise `False`.\n5. **Check Empty**: Returns `True` if the queue is empty, otherwise `False`.\n6. **Retrieve Elements**: Returns the current elements in the queue as a list, maintaining the order they were added.\n\nThe approach uses a list as the underlying data structure for simplicity. The operations are implemented to ensure efficient addition and removal of elements, while maintaining the order of elements.\n\n### Solution Code\n```python\nclass CustomQueue:\n    def __init__(self, capacity):\n        self.capacity = max(0, capacity)\n        self.queue = []\n\n    def enqueue(self, value):\n        if len(self.queue) >= self.capacity:\n            return False\n        self.queue.append(value)\n        return True\n\n    def dequeue(self):\n        if self.isEmpty():\n            return -1\n        return self.queue.pop(0)\n\n    def isFull(self):\n        return len(self.queue) == self.capacity\n\n    def isEmpty(self):\n        return len(self.queue) == 0\n\n    def getQueue(self):\n        return self.queue.copy()\n```\n\n### Explanation\n- **Initialization**: The constructor initializes the queue with a given capacity, ensuring it is non-negative. If the provided capacity is negative, it defaults to 0.\n- **Enqueue**: Checks if there is space in the queue before adding a new element. If the queue is full, returns `False`; otherwise, adds the element to the end of the list and returns `True`.\n- **Dequeue**: Removes the element from the front of the list. If the queue is empty, returns `-1`.\n- **Check Full**: Compares the current number of elements with the queue capacity to determine if the queue is full.\n- **Check Empty**: Returns `True` if there are no elements in the queue.\n- **Retrieve Elements**: Returns a copy of the list containing the current elements in the queue, ensuring the original queue remains unchanged.\n\nThis implementation provides a clear and efficient way to handle queue operations, ensuring robust handling of edge cases such as negative capacities and attempts to enqueue when full.",
  "r1_solution": "class CustomQueue:\n    def __init__(self, capacity):\n        self.capacity = max(0, capacity)\n        self.queue = []\n\n    def enqueue(self, value):\n        if len(self.queue) >= self.capacity:\n            return False\n        self.queue.append(value)\n        return True\n\n    def dequeue(self):\n        if self.isEmpty():\n            return -1\n        return self.queue.pop(0)\n\n    def isFull(self):\n        return len(self.queue) == self.capacity\n\n    def isEmpty(self):\n        return len(self.queue) == 0\n\n    def getQueue(self):\n        return self.queue.copy()",
  "metadata": {
    "prompt_id": "00000040",
    "row_id": 40,
    "seed_ids": [
      "1656",
      "733",
      "352"
    ],
    "mode": "leetcode",
    "original_instruction": "Design a class `CustomQueue` that supports the following operations:\n\n- `CustomQueue(int capacity)` Initializes the queue with a given capacity.\n- `void enqueue(int value)` Adds a value to the end of the queue if there is still space. Returns `false` if the queue is full.\n- `int dequeue()` Removes and returns the value at the front of the queue. Returns `-1` if the queue is empty.\n- `bool isFull()` Returns `true` if the queue is full, otherwise returns `false`.\n- `bool isEmpty()` Returns `true` if the queue is empty, otherwise returns `false`.\n\nImplement the `CustomQueue` class such that all operations are performed in constant time, i.e., O(1). Additionally, provide a method `getQueue()` that returns the current elements in the queue as a list, maintaining the order of elements as they were added."
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results0.jsonl"
}