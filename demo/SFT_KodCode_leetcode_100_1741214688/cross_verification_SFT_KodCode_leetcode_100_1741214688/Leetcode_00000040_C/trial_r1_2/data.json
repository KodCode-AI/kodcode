{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000040_C",
  "question": "from typing import List\n\nclass CustomQueue:\n    \"\"\"Design a class CustomQueue that supports the following operations:\n    - CustomQueue(int capacity) Initializes the queue with a given capacity.\n    - void enqueue(int value) Adds a value to the end of the queue if there is still space. Returns false if the queue is full.\n    - int dequeue() Removes and returns the value at the front of the queue. Returns -1 if the queue is empty.\n    - bool isFull() Returns true if the queue is full, otherwise returns false.\n    - bool isEmpty() Returns true if the queue is empty, otherwise returns false.\n    - List[int] getQueue() Returns the current elements in the queue as a list, maintaining the order of elements as they were added.\n    \"\"\"",
  "solution": "class CustomQueue:\n    def __init__(self, capacity: int):\n        self.queue = []\n        self.capacity = capacity\n        self.front = 0\n        self.rear = 0\n\n    def enqueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.queue.append(value)\n        self.rear += 1\n        return True\n\n    def dequeue(self) -> int:\n        if self.isEmpty():\n            return -1\n        value = self.queue[self.front]\n        self.front += 1\n        return value\n\n    def isFull(self) -> bool:\n        return self.rear - self.front == self.capacity\n\n    def isEmpty(self) -> bool:\n        return self.front == self.rear\n\n    def getQueue(self) -> list:\n        return self.queue[self.front:self.rear]",
  "test_code": "import pytest\n\ndef test_customqueue_operations():\n    custom_queue = CustomQueue(3)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.enqueue(3) is True\n    assert custom_queue.enqueue(4) is False  # Queue is full\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.getQueue() == [2, 3]\n    assert custom_queue.dequeue() == 2\n    assert custom_queue.dequeue() == 3\n    assert custom_queue.dequeue() == -1  # Queue is empty\n    assert custom_queue.enqueue(5) is True\n    assert custom_queue.getQueue() == [5]\n\ndef test_queue_limit():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.isFull() is True\n    assert custom_queue.enqueue(3) is False\n    assert custom_queue.getQueue() == [1, 2]\n\ndef test_empty_queue():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.isEmpty() is True\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.getQueue() == [1]\n    assert custom_queue.isEmpty() is False\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.isEmpty() is True\n\ndef test_enqueue_and_dequeue_mixed():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.enqueue(3) is True\n    assert custom_queue.getQueue() == [2, 3]\n    assert custom_queue.dequeue() == 2\n    assert custom_queue.dequeue() == 3\n    assert custom_queue.isEmpty() is True",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, so I need to design a Python class called CustomQueue. Hmm, the problem says that this queue should support several operations: enqueue, dequeue, isFull, isEmpty, and getQueue. Also, when initializing, it's given a capacity.\n\nLet me see. The constructor is CustomQueue(int capacity), so the queue can't hold more than that number of elements. So first, I need a way to keep track of the elements. Maybe a list inside the class would work. So I'll have an attribute, say self.queue, which is a list that stores the elements in order.\n\nNow, for enqueue(int value). It adds the value to the end if there's space. So I need to check if the current length of the queue is less than the capacity. If yes, append it and return True or something. Wait, but the function is supposed to return false if it's full. Oh right, but the note says to return False. So the method should return a boolean\u2014wait, no, looking back: \"Returns false if the queue is full.\" So wait, in the problem description for enqueue it says \"returns false\" which I assume is a boolean. So the function returns False if it can't add, else returns True? Or does it return something else? Let me recheck.\n\nThe function definitions:\n\n- void enqueue(int value) adds the value if there's space. Returns false if the queue is full. Wait, no, looking again, the user wrote:\n\nWait, in the problem statement, the method is written as void, but with a return condition. Wait that's a bit conflicting. Because in Python, functions can't have a return type of void. So the user probably meant that the enqueue function returns a boolean indicating success or failure.\n\nWait, looking again:\n\nThe problem says each function's return type and what it returns. So for enqueue, it's void, but then returns false if the queue is full. That doesn't make sense for Python, because in Python, void functions don't return a value. So perhaps that's a mistake.\n\nWait, no. Oh, perhaps the problem is using a more general description, regardless of the language, but we have to implement it in Python.\n\nWait looking again: the function definitions given in the problem:\n\n- enqueue returns False if full.\n\nWait, perhaps the user meant that enqueue returns a boolean indicating whether the operation succeeded. Because for a queue, it's common for the enqueue function to return true if the element was added, false otherwise.\n\nSo perhaps the enqueue method should return False when it can't add because the queue is full, else return True. Otherwise, after appending.\n\nSo, in the implementation, when the enqueue is called, if the length of the queue is >= capacity, return False, else append the value and return True.\n\nNext, dequeue(). It should remove and return the front element. If the queue is empty, return -1. So I need to check if the queue is empty; if yes, return -1 else pop from index 0 and return that value.\n\nBut popping from the front is O(n), but for a queue structure implemented with a list, that's normal.\n\nThen, isFull() returns True if the queue is at capacity. So, return self.size == capacity.\n\nWait, but wait: in the implementation, wait, perhaps it's better to track the current size, but for this we can compute it using len(self.queue). Hmm.\n\nSimilarly, isEmpty() is whether the queue has zero elements, which is len(self.queue) == 0.\n\nThen, the getQueue() method returns the current elements as a list, in order. So just return a copy of self.queue. Or maybe the list as is, but perhaps return a shallow copy or a new list. So, return self.queue.copy() or something.\n\nWait, but what's the structure of queue? The elements are added to the end and removed from the front, so the list stays in order.\n\nSo, for each function:\n\nConstructor:\n\ndef __init__(self, capacity):\n\n    self.capacity = capacity\n\n    self.queue = []\n\nEnqueue:\n\ndef enqueue(self, value):\n\n    if len(self.queue) >= self.capacity:\n\n        return False\n\n    else:\n\n        self.queue.append(value)\n\n        return True\n\nWait, but wait, in the problem statement, for the enqueue function, the return condition is \"returns false if the queue is full.\" So perhaps it's supposed to return False if it could not add, else True.\n\nWait, maybe the function returns a boolean. So the enqueue method will return True when it successfully adds the element, and False if it's full.\n\nWait, but according to the function description, it's void, but notes say returns false. So perhaps in Python, the function should return a bool.\n\nSo the logic is correct.\n\nDequeue:\n\ndef dequeue(self):\n\n    if len(self.queue) == 0:\n\n        return -1\n\n    else:\n\n        return self.queue.pop(0)\n\nIs that efficient? Well, for the purposes of this problem, assuming the capacity isn't excessively large, this should be manageable.\n\nIsFull:\n\ndef isFull(self):\n\n    return len(self.queue) == self.capacity\n\nEmpty:\n\ndef isEmpty(self):\n\n    return len(self.queue) == 0\n\nGetQueue:\n\ndef getQueue(self):\n\n    return self.queue.copy()\n\nWait, but why a copy? Because if someone modifies the list returned, it shouldn't affect the queue's internal state. So returning a copy makes sense.\n\nAlternatively, we could return list(self.queue), which is another way of making a shallow copy.\n\nWait, but in the example, when we add elements, they are added to the end, so the order is preserved. For getQueue, when we return the list, it should represent the elements in the queue in order. So yes, for getQueue, we can just return a copy or the list.\n\nWait, but in the dequeue method, when I pop from the front, that maintains the order correctly. Because the first element is removed, the others are ordered correctly.\n\nWait, in the list, the first element is the head of the queue. So when we enqueue, appending to the end (which is the tail). So when dequeue, pop(0) gives the head.\n\nTherefore, the getQueue returns the elements in order from head to tail? Or in the order they were added, which is from front to back. Because when you enqueue 1, then 2, the queue is [1,2]. So dequeue removes 1, then when 3 is added, it becomes [2,3]. So getQueue would return the list as [2,3], which is in order of how they were added, but starting from the current front.\n\nWait, does that matter? Let me see: if the queue has elements [1,2,3], then dequeue 1, [2,3], so getQueue would return [2,3]. So the order is correct, just the elements in the queue now.\n\nBut that's exactly what should happen.\n\nSo the implementation seems solid.\n\nSo to sum up:\n\nThe class will have:\n\n- __init__, takes capacity, initializes queue as an empty list, and stores the capacity.\n\n- enqueue: appends if possible, returns True/False based on success.\n\n- dequeue: pops first element, returns it, or -1 if empty.\n\n- isFull: checks if queue is at capacity.\n\n- isEmpty: checks if the queue is empty.\n\n- getQueue: returns a copy of the queue list.\n\nBut wait, what about when the queue is empty and dequeue is called? It returns -1.\n\nLet me test the logic.\n\nTest case 1: Capacity is 3.\n\nqueue = CustomQueue(3)\n\nqueue.isEmpty() \u2192 True.\n\nqueue.isFull() \u2192 False.\n\nThen, enqueue 1 \u2192 returns True. Enqueue 2 \u2192 True. Enqueue 3 \u2192 True. Enqueue 4 \u2192 returns False.\n\nSo, is that correct.\n\nYes.\n\nTest case 2: Dequeue from empty queue returns -1.\n\nYes.\n\nAnother test case: dequeue once from non-empty.\n\nAfter enqueue(1), dequeing gives 1, and queue is empty.\n\nYes.\n\nNow, for the getQueue function:\n\nWhat if we add 1,2,3. Dequeue once. getQueue returns [2,3]. Enqueue 4 (can't). So queue is still [2,3]. Then enqueue 4 when capacity is 3. So returns false.\n\nNow, getQueue will have [2,3].\n\nYes.\n\nAnother scenario: capacity is 0. Hmm, not sure. Because in __init__, capacity is given as an int, but a capacity of 0 would mean the queue can't enqueue anything. So in enqueue, immediately returns False.\n\nBut that's perhaps an edge case but the code would handle it.\n\nAnother edge case: capacity is 1.\n\nSo, in the code, a capacity of 1:\n\nEnqueue(5): returns True, queue has [5]. Enqueue again: returns False. Dequeue: 5, queue is empty.\n\nYes.\n\nThus, the code seems correct.\n\nI think that's the plan. Now, code it as per these thoughts.\n</think>\n\nTo solve this problem, we need to design a class `CustomQueue` that supports several queue operations with a given capacity. The queue should allow adding elements to the end, removing elements from the front, checking if the queue is full or empty, and retrieving the current elements in order.\n\n### Approach\n1. **Initialization**: The class is initialized with a given capacity, and an internal list is used to store the queue elements.\n2. **Enqueue Operation**: Adds an element to the end of the queue if there is space. Returns `True` if successful and `False` if the queue is full.\n3. **Dequeue Operation**: Removes the element at the front of the queue. Returns the element if successful and `-1` if the queue is empty.\n4. **Is Full Check**: Returns `True` if the queue has reached its capacity, otherwise `False`.\n5. **Is Empty Check**: Returns `True` if the queue has no elements, otherwise `False`.\n6. **Get Queue Elements**: Returns the current elements in the queue as a list, maintaining the order they were added.\n\n### Solution Code\n\n```python\nclass CustomQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = []\n    \n    def enqueue(self, value):\n        if len(self.queue) >= self.capacity:\n            return False\n        self.queue.append(value)\n        return True\n    \n    def dequeue(self):\n        if len(self.queue) == 0:\n            return -1\n        return self.queue.pop(0)\n    \n    def isFull(self):\n        return len(self.queue) == self.capacity\n    \n    def isEmpty(self):\n        return len(self.queue) == 0\n    \n    def getQueue(self):\n        return list(self.queue)\n```\n\n### Explanation\n- **Initialization**: The constructor initializes the queue with a specified capacity and an empty list to hold the elements.\n- **Enqueue**: This method checks if the queue has space before adding a new element to the end. It returns `True` if the element is added successfully and `False` if the queue is full.\n- **Dequeue**: This method removes the front element of the queue. If the queue is empty, it returns `-1`.\n- **Is Full Check**: This method checks if the current number of elements equals the queue's capacity.\n- **Is Empty Check**: This method checks if there are no elements in the queue.\n- **Get Queue Elements**: This method returns a copy of the list containing the current queue elements in the order they were added.\n\nThis implementation efficiently handles all specified queue operations while maintaining the correct order of elements and respecting the queue's capacity constraint.",
  "r1_solution": "class CustomQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = []\n    \n    def enqueue(self, value):\n        if len(self.queue) >= self.capacity:\n            return False\n        self.queue.append(value)\n        return True\n    \n    def dequeue(self):\n        if len(self.queue) == 0:\n            return -1\n        return self.queue.pop(0)\n    \n    def isFull(self):\n        return len(self.queue) == self.capacity\n    \n    def isEmpty(self):\n        return len(self.queue) == 0\n    \n    def getQueue(self):\n        return list(self.queue)",
  "metadata": {
    "prompt_id": "00000040",
    "row_id": 40,
    "seed_ids": [
      "1656",
      "733",
      "352"
    ],
    "mode": "leetcode",
    "original_instruction": "Design a class `CustomQueue` that supports the following operations:\n\n- `CustomQueue(int capacity)` Initializes the queue with a given capacity.\n- `void enqueue(int value)` Adds a value to the end of the queue if there is still space. Returns `false` if the queue is full.\n- `int dequeue()` Removes and returns the value at the front of the queue. Returns `-1` if the queue is empty.\n- `bool isFull()` Returns `true` if the queue is full, otherwise returns `false`.\n- `bool isEmpty()` Returns `true` if the queue is empty, otherwise returns `false`.\n\nImplement the `CustomQueue` class such that all operations are performed in constant time, i.e., O(1). Additionally, provide a method `getQueue()` that returns the current elements in the queue as a list, maintaining the order of elements as they were added."
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results2.jsonl"
}