{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000040_I",
  "question": "Design a class `CustomQueue` that supports the following operations:\n\n- `CustomQueue(int capacity)` Initializes the queue with a given capacity.\n- `void enqueue(int value)` Adds a value to the end of the queue if there is still space. Returns `false` if the queue is full.\n- `int dequeue()` Removes and returns the value at the front of the queue. Returns `-1` if the queue is empty.\n- `bool isFull()` Returns `true` if the queue is full, otherwise returns `false`.\n- `bool isEmpty()` Returns `true` if the queue is empty, otherwise returns `false`.\n\nImplement the `CustomQueue` class such that all operations are performed in constant time, i.e., O(1). Additionally, provide a method `getQueue()` that returns the current elements in the queue as a list, maintaining the order of elements as they were added.",
  "solution": "class CustomQueue:\n    def __init__(self, capacity: int):\n        self.queue = []\n        self.capacity = capacity\n        self.front = 0\n        self.rear = 0\n\n    def enqueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.queue.append(value)\n        self.rear += 1\n        return True\n\n    def dequeue(self) -> int:\n        if self.isEmpty():\n            return -1\n        value = self.queue[self.front]\n        self.front += 1\n        return value\n\n    def isFull(self) -> bool:\n        return self.rear - self.front == self.capacity\n\n    def isEmpty(self) -> bool:\n        return self.front == self.rear\n\n    def getQueue(self) -> list:\n        return self.queue[self.front:self.rear]",
  "test_code": "import pytest\n\ndef test_customqueue_operations():\n    custom_queue = CustomQueue(3)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.enqueue(3) is True\n    assert custom_queue.enqueue(4) is False  # Queue is full\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.getQueue() == [2, 3]\n    assert custom_queue.dequeue() == 2\n    assert custom_queue.dequeue() == 3\n    assert custom_queue.dequeue() == -1  # Queue is empty\n    assert custom_queue.enqueue(5) is True\n    assert custom_queue.getQueue() == [5]\n\ndef test_queue_limit():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.isFull() is True\n    assert custom_queue.enqueue(3) is False\n    assert custom_queue.getQueue() == [1, 2]\n\ndef test_empty_queue():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.isEmpty() is True\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.getQueue() == [1]\n    assert custom_queue.isEmpty() is False\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.isEmpty() is True\n\ndef test_enqueue_and_dequeue_mixed():\n    custom_queue = CustomQueue(2)\n    assert custom_queue.enqueue(1) is True\n    assert custom_queue.enqueue(2) is True\n    assert custom_queue.dequeue() == 1\n    assert custom_queue.enqueue(3) is True\n    assert custom_queue.getQueue() == [2, 3]\n    assert custom_queue.dequeue() == 2\n    assert custom_queue.dequeue() == 3\n    assert custom_queue.isEmpty() is True",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to design a class called CustomQueue with specific operations. Let's see. The operations are initializing with a capacity, enqueuing a value, dequeuing the front value, checking if it's full or empty, and getting the queue as a list.\n\nHmm, the key here is that all operations need to be performed in constant time, O(1). So I need a data structure that allows adding and removing elements quickly. An array-based queue would fit because array operations can be done in constant time if managed correctly.\n\nWait, but when you dequeue from an array-based queue, moving all the elements isn't O(1). So maybe I should use a circular array approach with front and rear pointers. That way, when elements are dequeued, you just move the front pointer, no need to shift elements.\n\nLet me outline the class structure. I'll need:\n\n- An array to hold the elements.\n- A variable for the front index, starting at 0.\n- A variable for the rear index, starting at 0.\n- A variable to keep track of the size (number of elements currently in the queue).\n- The capacity is given at initialization, so that's when the array is created.\n\nOkay, for the enqueue method:\n- If the size is equal to capacity, return false.\n- Otherwise, add the value to the array at the rear index.\n- Increment rear. Since it's a circular queue, I'll mod it with capacity to wrap around when it reaches the end.\n- Increase the size.\n\nDequeue method:\n- If size is zero, return -1.\n- Otherwise, get the value at the front index.\n- Increment front with mod.\n- Decrease size and return the value.\n\nIsFull checks if size equals capacity.\n\nIsEmpty checks if size is zero.\n\nNow, the getQueue method. Because the array is being used in a circular way, the elements might not be in the front part of the array. So I need a way to extract the elements in order, starting from front.\n\nWait, the front is where the next dequeue will happen, so the queue is front -> rear-1. But the order isn't contiguous, they might loop around the array.\n\nSo, how do I get all the elements in order? For example, if the array is [1,2,3,0,0], with front at 3, then the queue is [1,2,3], but if after some dequeues, front is at index 2, rear is at index 4. So how to extract correctly.\n\nAlternatively, I could calculate the number of elements, and loop from front for size elements, wrapping around if necessary.\n\nSo to build the list for getQueue:\n\nInitialize an empty list.\nFor i from 0 to size-1:\n   index = (front + i) % capacity\n   add array[index] to the list.\n\nThis way, even if front is beyond the initial indices, it will correctly wrap around.\n\nWait, but if front is 2 and size is 3, capacity is 5, the indices are 2,3,4. If size is 3 and front is 4, it's 4,0,1, which correctly wraps around.\n\nYes, that makes sense.\n\nSo in the getQueue method, create a list, iterate from 0 to size-1, calculate (front + i) mod capacity each time, and add the value to the list.\n\nThat should give the elements in the order they were added, maintaining FIFO.\n\nNow, let me think about the implementation.\n\nIn Python, the CustomQueue class will have:\n\n- self.array = [None] * capacity\n- self.front = 0\n- self.rear = 0\n- self.size = 0\n- self.capacity = capacity\n\nWait, but what about negative values? The queue allows adding any integer, including negative ones. So returning -1 for dequeue when empty is acceptable, as specified.\n\nFor the enqueue method:\n\ndef enqueue(self, value):\n    if self.size == self.capacity:\n        return False\n    self.array[self.rear] = value\n    self.rear = (self.rear + 1) % self.capacity\n    self.size +=1\n    return True\n\nWait, wait, wait. Wait, no, the method is supposed to return False if full. So in the enqueue function, return False when no more space, else return True as in the problem statement says. Because I initially thought it was a void return in the problem statement but looking again:\n\nWait, the problem statement says enqueue adds a value if space and returns false if queue is full. So the enqueue function returns a boolean. Same with dequeue returns an integer, but returns -1 if empty.\n\nSo wait, wait, the method signature is:\n\ndef enqueue(self, value) -> bool:\n\nNo, wait, the original problem says \"Adds a value to the end... Returns false if the queue is full.\"\n\nSo in code:\n\ndef enqueue(self, value):\n    if self.isFull():\n        return False\n    # else add\n    ...\n\nDoes that make sense.\n\nBut for isFull(), it's a method, which is just self.size == self.capacity.\n\nWait, maybe I can make isFull() and isEmpty() as properties via methods.\n\nWait, the code for methods would be:\n\nIn enqueue:\n\nif self.size == self.capacity:\n   return False\nelse:\n   enqueue and return True.\n\nSo same logic.\n\nNow, for the dequeue method:\n\ndef dequeue(self):\n    if self.isEmpty():\n        return -1\n    value = self.array[self.front]\n    self.front = (self.front +1) % self.capacity\n    self.size -=1\n    return value\n\nBut wait, the array could have some elements when it's empty? No, because dequeuing is only allowed when size >0.\n\nYes, but what about when the queue is empty (size=0) and someone tries to dequeue, returns -1.\n\nTesting cases:\n\nExample 1:\n\nQueue is initialized with capacity 3.\n\nEnqueue 1: size 1, rear becomes 1.\n\nEnqueue 2: size 2, rear becomes 2.\n\nEnqueue 3: size 3, returns True (queue is full now).\n\nEnqueue 4: returns False.\n\nDequeue: returns 1, size 2, front is 1.\n\nGetQueue should return [2,3].\n\nWait, no. Wait, the getQueue function should return the elements in the order they were added. Wait, that's ambiguous. Or, perhaps, in the current queue order.\n\nWait, no, the problem says, \"the current elements in the queue as a list, maintaining the order as they were added.\"\n\nSo, after enqueuing 1,2,3, the queue is [1,2,3]. After dequeue() called once, the queue is [2,3], so getQueue would return [2,3].\n\nIs that correct? Or does getQueue return the elements in the order they are in the array, including those that have been dequeued but are still in the array.\n\nWait, no. Because getQueue should return the current elements in the queue in the same order as they were added. So for the above scenario, after enqueuing 1,2,3 and dequeue once, the queue is 2 and 3. So getQueue should return [2,3].\n\nSo with the logic for getQueue as I outlined earlier, it should return the correct list.\n\nAnother test case: capacity 5.\n\nEnqueue 1: indices 0.\n\nenqueue 2: index 1.\n\nenqueue 3: index 2.\n\ndequeue: front becomes 1, size 2. So elements 2,3, but in array, indices 1 and 2.\n\nIf we dequeue again, front becomes 2, size 1.\n\nenqueue 4: rear is 3, so index 3 is 4.\n\nqueue is [3,4].\n\ngetQueue() should return [3,4].\n\nWhich the code should handle.\n\nAnother scenario: after rear wraps around.\n\nCapacity 4.\n\nenqueue 0,1,2,3: size is 4, queue is full.\n\ndequeue 0: front becomes 1.\n\nenqueue 4: rear is 0, which was the first position. So array[0] =4.\n\nqueue size is 4 again.\n\nqueue should be [1,2,3,4].\n\nSo getQueue should return [1,2,3,4].\n\nWait wait, no. Because we dequeued 0, then enqueued4. So the queue is [1,2,3,4], which is correct.\n\nSo when implementing getQueue, it should collect from front to front + size, wrapping as necessary.\n\nWait, to make sure.\n\nLet me think about the indices:\n\nfront is 1, size is 3: the elements are array[1], array[2], array[3].\n\nIf then we enqueue 4, which has index 0.\n\nNow, front is 1, size 4.\n\nWait, capacity is 4. So when size is 4, could that happen? Because capacity is 4, so no. Because in this scenario, after dequeue of 0, size decreases to 3, enqueueing 4 would make size 4.\n\nSo in this case, the front is at 1, the next dequeue should get 1, then 2, 3, and 4.\n\nSo how does the for loop in getQueue collect the elements.\n\nIn for i in range(size):\n    index = (front + i) % capacity.\n\nIn this case, size is 4, front is 1.\n\ni=0: 1 -> 1\n\ni=1: 2 -> 2.\n\ni=2: 3 ->3.\n\ni=3:1+3 =4 mod 4 =0.\n\nSo the elements would be array[1], array[2], array[3], array[0].\n\nWhich is 1,2,3,4.\n\nBut wait, the array would have array[0]=4 (since after dequeuing 0, which is array[0] value, then enqueuing 4 to array[0]. So array is [4,1,2,3].\n\nWait, no, initial array:\n\nAfter initial four enqueues, array is [0,1,2,3].\n\nWhen you dequeue(), size becomes 3, front is 1.\n\nThen enqueue 4: since size is 3 <4, we can enqueue. Rear is (0 +1) (assuming initial rear is 0,1,2,3, dequeues front becomes 1, rear then was 3. So enqueue 4 at index (3+1) mod4=0. So array becomes [4,1,2,3]. Rear is 0.\n\nNow, the front is 1, the queue's elements are 1, 2, 3, 4? Or are they 1,2,3,4 or 1,2,3.\n\nWait, after dequeue 0: front is 1, size is 3.\n\nenqueue 4:\n\narray at 0 is 4. rear is (3+1)%4=0. size becomes 4.\n\nSo isFull is true.\n\nThus, the queue now contains four elements: 1,2,3,4.\n\nIn the array: [4,1,2,3].\n\nSo the getQueue method:\n\nfront is 1. So for i=0: 1, value 1.\n\ni=1: 2, value 2.\n\ni=2: 3, value3.\n\ni=3:4 mod4 is 0, value4.\n\nSo the list returned is [1,2,3,4], which is correct.\n\nSo yes, the way of computing index as (front + i) % capacity for i from 0 to size-1 gives the correct order.\n\nSo now, putting all together.\n\nThe class will have:\n\n- __init__: initializes array, front, rear, size, capacity.\n\n- enqueue: adds value to rear, increments rear and size if possible.\n\n- dequeue: removes front value, increments front and reduces size.\n\n- isFull: returns whether size equals capacity.\n\n- isEmpty: returns whether size is 0.\n\n- getQueue: builds the list by iterating size times.\n\nIn Python, for code:\n\nSo code outline:\n\nclass CustomQueue:\n    def __init__(self, capacity):\n        self.array = [None] * capacity\n        self.front = 0\n        self.rear = 0\n        self.size = 0\n        self.capacity = capacity\n\n    def enqueue(self, value):\n        if self.size == self.capacity:\n            return False\n        self.array[self.rear] = value\n        self.rear = (self.rear + 1) % self.capacity\n        self.size += 1\n        return True\n\n    def dequeue(self):\n        if self.size == 0:\n            return -1\n        value = self.array[self.front]\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return value\n\n    def isFull(self):\n        return self.size == self.capacity\n\n    def isEmpty(self):\n        return self.size == 0\n\n    def getQueue(self):\n        current_list = []\n        for i in range(self.size):\n            index = (self.front + i) % self.capacity\n            current_list.append(self.array[index])\n        return current_list\n\nWait, but in initial state, the array is filled with None.\n\nBut when we enqueue, all elements are filled with the given values, so the initial Nones are overwritten.\n\nWhen dequeues are called, front moves, but array is not cleared. So getQueue() should only get the valid elements, not the older ones.\n\nBecause when we use getQueue, we are only iterating up to self.size. So Nones that are not in the current queue are not included.\n\nBecause when the queue has size 3, and the array has 5 elements, the getQueue will return three elements, starting from front, and the rest are ignored.\n\nYes, because for i in 0..size-1.\n\nThus, the implementation should correctly build the current_list.\n\nTesting this:\n\nTest case 1:\n\nq = CustomQueue(2)\nq.enqueue(1) -> True, array [1, None], size 1.\n\nq.enqueue(2) -> True, array [1,2], size 2.\n\ngetQueue() returns [1,2].\n\nq.dequeue() -> 1, array [2,2] (wait no, because front becomes 1, so array[0] is still 1, but it's not considered anymore.\n\nWait, after dequeuing 1, front is 1. array[0] is still 1, but size is 1.\n\nSo getQueue should return [2], because in the for loop i=0: (1+0) mod2 =1, which is array[1] =2.\n\nYes, because:\n\nsize is 1.\n\ni=0: index 1, value 2.\n\nSo correct.\n\nAnother test case.\n\nSo the code seems to handle these cases.\n\nSo this should work.\n</think>\n\nTo solve this problem, we need to design a class `CustomQueue` that supports several operations with constant time complexity, O(1). The operations include initializing the queue with a given capacity, enqueuing a value, dequeuing a value, checking if the queue is full or empty, and retrieving the current elements in the queue as a list.\n\n### Approach\n1. **Data Structure Selection**: Use an array-based approach with pointers for the front and rear of the queue. This allows efficient addition and removal of elements in constant time.\n2. **Circular Array Management**: Use front and rear pointers to manage elements in a circular manner, which allows wrapping around the array when elements are added or removed.\n3. **Operations**:\n   - **enqueue**: Adds a value to the end of the queue if space is available, returns `False` if the queue is full.\n   - **dequeue**: Removes and returns the value at the front of the queue, returns `-1` if the queue is empty.\n   - **isFull**: Checks if the queue is full by comparing the size with the capacity.\n   - **isEmpty**: Checks if the queue is empty by verifying the size.\n   - **getQueue**: Returns the current elements in the queue in the order they were added, using the front pointer and size to correctly wrap around the array.\n\n### Solution Code\n```python\nclass CustomQueue:\n    def __init__(self, capacity):\n        self.array = [None] * capacity\n        self.front = 0\n        self.rear = 0\n        self.size = 0\n        self.capacity = capacity\n\n    def enqueue(self, value):\n        if self.size == self.capacity:\n            return False\n        self.array[self.rear] = value\n        self.rear = (self.rear + 1) % self.capacity\n        self.size += 1\n        return True\n\n    def dequeue(self):\n        if self.isEmpty():\n            return -1\n        value = self.array[self.front]\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return value\n\n    def isFull(self):\n        return self.size == self.capacity\n\n    def isEmpty(self):\n        return self.size == 0\n\n    def getQueue(self):\n        current_list = []\n        for i in range(self.size):\n            index = (self.front + i) % self.capacity\n            current_list.append(self.array[index])\n        return current_list\n```\n\n### Explanation\n- **Initialization**: The queue is initialized with a given capacity, creating an array of that size. Front and rear pointers are set to 0, and the size is initialized to 0.\n- **Enqueue**: Checks if the queue is full using the size. If not full, adds the value to the array at the rear pointer, increments the rear pointer (with modulo to wrap around), and increases the size.\n- **Dequeue**: Checks if the queue is empty. If not, retrieves the value at the front pointer, increments the front pointer (with modulo to wrap around), and decreases the size.\n- **getQueue**: Constructs a list by iterating from the front pointer for the current size, correctly handling the circular nature of the array to maintain the order of elements.\n\nThis approach ensures that all operations are performed in constant time, O(1), making the implementation efficient and scalable for various use cases.",
  "r1_solution": "class CustomQueue:\n    def __init__(self, capacity):\n        self.array = [None] * capacity\n        self.front = 0\n        self.rear = 0\n        self.size = 0\n        self.capacity = capacity\n\n    def enqueue(self, value):\n        if self.size == self.capacity:\n            return False\n        self.array[self.rear] = value\n        self.rear = (self.rear + 1) % self.capacity\n        self.size += 1\n        return True\n\n    def dequeue(self):\n        if self.isEmpty():\n            return -1\n        value = self.array[self.front]\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return value\n\n    def isFull(self):\n        return self.size == self.capacity\n\n    def isEmpty(self):\n        return self.size == 0\n\n    def getQueue(self):\n        current_list = []\n        for i in range(self.size):\n            index = (self.front + i) % self.capacity\n            current_list.append(self.array[index])\n        return current_list",
  "metadata": {
    "prompt_id": "00000040",
    "row_id": 40,
    "seed_ids": [
      "1656",
      "733",
      "352"
    ],
    "mode": "leetcode",
    "original_instruction": ""
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results2.jsonl"
}