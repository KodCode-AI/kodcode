{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000000_C",
  "question": "from typing import List\n\nclass CircularQueue:\n    \"\"\"Implement a class CircularQueue that supports the following operations:\n    - CircularQueue(int k) constructs the CircularQueue with a maximum size of k.\n    - int Front() retrieves the element at the front of the queue without removing it. Returns -1 if the queue is empty.\n    - int Rear() retrieves the element at the rear of the queue without removing it. Returns -1 if the queue is empty.\n    - boolean enQueue(int value) inserts the element value into the queue. Returns true if the operation is successful, false otherwise (i.e., the queue is full).\n    - boolean deQueue() deletes an element from the queue. Returns true if the operation is successful, false otherwise (i.e., the queue is empty).\n    - boolean isEmpty() returns true if the queue is currently empty, false otherwise.\n    - boolean isFull() returns true if the queue is currently full, false otherwise.\n    \n    Ensure that all operations are performed in constant time (O(1)).\n    \"\"\"",
  "solution": "class CircularQueue:\n    def __init__(self, k: int):\n        assert k > 0, \"k must be a positive integer\"\n        self.max_size = k\n        self.queue = [None] * k\n        self.head = -1\n        self.tail = -1\n\n    def Front(self) -> int:\n        if self.head == -1:\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -> int:\n        if self.head == -1:\n            return -1\n        return self.queue[self.tail]\n\n    def enQueue(self, value: int) -> bool:\n        if self.head == -1 and self.tail == -1:\n            self.head = 0\n            self.tail = 0\n            self.queue[self.tail] = value\n            return True\n        elif (self.tail + 1) % self.max_size == self.head:\n            return False\n        else:\n            self.tail = (self.tail + 1) % self.max_size\n            self.queue[self.tail] = value\n            return True\n\n    def deQueue(self) -> bool:\n        if self.head == -1:\n            return False\n        elif self.head == self.tail:\n            self.head = -1\n            self.tail = -1\n            return True\n        else:\n            self.head = (self.head + 1) % self.max_size\n            return True\n\n    def isEmpty(self) -> bool:\n        return self.head == -1\n\n    def isFull(self) -> bool:\n        return (self.tail + 1) % self.max_size == self.head",
  "test_code": "import pytest\n\ndef test_circular_queue():\n    cq = CircularQueue(3)\n\n    assert cq.enQueue(1) is True\n    assert cq.enQueue(2) is True\n    assert cq.enQueue(3) is True\n    assert cq.enQueue(4) is False\n\n    assert cq.Rear() == 3\n    assert cq.Front() == 1\n\n    assert cq.deQueue() is True\n    assert cq.enQueue(4) is True\n\n    assert cq.Front() == 2\n\ndef test_queue_operations():\n    cq = CircularQueue(2)\n\n    assert cq.enQueue(1) is True\n    assert cq.enQueue(2) is True\n    assert cq.enQueue(3) is False\n\n    assert cq.deQueue() is True\n    assert cq.enQueue(3) is True\n\n    assert cq.Front() == 2\n    assert cq.Rear() == 3\n\n    assert cq.deQueue() is True\n    assert cq.deQueue() is True\n    assert cq.Rear() == -1\n    assert cq.Front() == -1",
  "test_info": null,
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to implement a CircularQueue class in Python that supports several operations. Let me read through the problem statement again carefully to understand the requirements.\n\nSo, the CircularQueue has a constructor that takes an integer k, which is the maximum size. Then there are several methods: Front, Rear, enQueue, deQueue, isEmpty, and isFull. Each of these needs to perform constant time operations. Hmm.\n\nLet me think about the data structure. A circular queue is typically implemented using an array that wraps around. So I should use an array where the front and rear pointers can move circularly.\n\nWait, how does that work? Normally, for a queue, you have enqueue at the rear and dequeue from the front. But in a circular array, when you reach the end, the next element wraps around to the beginning. So I'll need to manage indices that can wrap around using modulo operations.\n\nI think I'll represent the queue using a list. But since the list in Python is dynamic, but for this structure, the size is fixed once initialized, I'll need to manage a list of size k, initialized with some default values. But since we're adding and removing elements frequently, perhaps initializing a list with k elements is manageable. Or maybe not\u2014since in Python, list appends are O(1) amortized, but for a fixed-size queue, I have to manage it differently.\n\nWait, the constructor is given k, which is the max size. Let's say that the internal data is a list of size k, maybe initialized with None or some placeholder. Then, I'll keep track of the front and rear indices, as well as the current size.\n\nWait, but let's think about how the circular queue works. We can have a front and rear pointer, both starting at 0. When you enqueue, you add at the rear, then move rear to (rear +1) mod k. Dequeue would remove the front element, then front becomes (front +1) mod k. However, to manage the empty and full conditions, we can track the number of elements in the queue.\n\nAlternatively, another approach is to have front and rear pointers, and when the queue is empty, front == rear. But for a circular queue, when it's full, (rear + 1) % k == front.\n\nWait, yes. Let me outline the variables I need:\n\n- data: a list of size k to hold the elements.\n- front: the index of the front element.\n- rear: the index where the next element will be added.\n- size: the number of elements currently in the queue.\n- k: the maximum capacity.\n\nSo, the queue is empty when size is 0.\n\nWhen enqueuing, if size is less than k, we add the element to the data[rear], then rear becomes (rear +1) mod k, and size increases by 1. However, since the list is initially empty, perhaps I need to initialize all elements to some default value like None.\n\nWait, but in Python, if I create a list like [None]*k, that's manageable. So when the queue is initialized, data is a list [None] * k, and front and rear are 0, and size is 0.\n\nNow, for methods:\n\nFront() method: returns the element at the front. So if the queue is empty (size 0), return -1. Else, return data[front].\n\nRear() method: similar, returns data[rear - 1] because rear points to the next available position. Wait, let's see. After an element is enqueued, rear is incremented. So the last enqueued element is at rear - 1. Because when you enqueue, rear is the index where the next element will go. So for Rear(), when size >0, the rear element is data[(rear-1) % k]. Or wait, perhaps I should think: when the queue has elements, what is the rear element's index?\n\nMaybe it's better to have front and rear, and for Rear(), when the queue is not empty, rear is the current rear element's index. Or wait, no. Wait:\n\nLet me think with an example. Suppose k=4.\n\nInitially, front=0, rear=0, size=0. Queue is empty.\n\nenQueue(1): data[0] =1, size=1, rear becomes (0+1)%4=1.\n\nenQueue(2): data[1]=2, size=2, rear=2.\n\nRear() should return 2, yes. So Rear() is data[rear -1 % k] = data[1], which is 2.\n\nAnother enQueue(3): data[2]=3, size=3, rear=3.\n\nRear() returns data[2]=3.\n\nAnother enQueue(4): data[3]=4, size=4, rear = (3+1)%4=0.\n\nNow, the queue is full. Front is 0, but data[0] is 1, data[1]=2, etc.\n\nSo Rear() is at index (rear-1) mod k = (0-1) mod4 = 3, which is the last element.\n\nYes. So for Rear(), when the queue is not empty, return data[(rear -1) %k].\n\nOk.\n\nFor enQueue, the method should return True if the operation is successful\u2014so if the size is less than k.\n\nSo steps for enQueue:\n\nif isFull() which is size ==k, then return False.\n\nElse, assign data[rear] = value.\n\nincrement rear as (rear+1) %k.\n\nincrement size by 1.\n\nReturn True.\n\nSimilarly, deQueue:\n\nif isEmpty(), return False.\n\nElse, set data[front] to None or some invalid value (or just ignore, as the queue will manage pointers). But in Python, perhaps we can just leave it as is, since when we call Front(), it will point to the next front.\n\nWait, in reality, in circular queue implementation, when you deQueue, you don't remove the data, you just move the front pointer. So perhaps, no need to set data[front] to None.\n\nWait, but how is the data handled in our structure. For a circular queue, when dequeuing, the element is considered removed, and the next dequeue will take the next one. In our case, since the data is stored in the array, but the front is the index of the next element to read, the actual data remains in the array. So if someone calls Front again, it's the new front element.\n\nWait, let me think. No, when you deQueue, the element is removed, so as per standard queue, after deQueue, the front moves to next. So in our data structure, deQueue doesn't modify the data in the array. So perhaps the data array will contain \"stale\" or \"garbage\" values after dequeue, but the front and size prevent them from being accessed via Front(), etc.\n\nWait, perhaps it's better to not modify the data when dequeuing. Because in a circular queue, when elements are enqueued and dequeued, the same index can be overwritten after it has been dequeued.\n\nWait, perhaps the way to look at this is that the elements in the data array that are at positions before front (in the circular sense) have already been dequeued.\n\nWait, no. The front is the next element to be dequeued. So when you call deQueue(), the method is successful, then size decreases by 1. Front is then (front +1) mod k.\n\nSo the deQueue method doesn't modify the data array; it just increments front and decreases size.\n\nBut then, when you enqueue again, it will write over the data[rear], which may have previously been a dequeued element. That's correct behavior.\n\nYes. So in the data array, some elements may not be part of the current queue, but the pointers and size control what's considered as part of the queue.\n\nSo for enQueue, when the queue is not full, data[rear] = value, then rear is incremented.\n\nFor deQueue, as long as the queue is not empty, size is decremented, and front is incremented.\n\nWait, no. Size is decremented, and front is incremented.\n\nWait, but size is the count of elements. So deQueue is supposed to remove the front element. So front is the next to be dequeued. So when you deQueue(), you remove data[front], then front becomes (front + 1) mod k, and size -=1.\n\nWait, no, the front is the current front. So the steps are:\n\nif queue is empty, return False.\n\nelse:\n\nvalue = data[front]\n\nfront = (front +1) % k\n\nsize -=1\n\nBut since we're not using the value for anything except popping it, but actually, the data remains in the array.\n\nWait, no, in our case, the values remain in the data array, so if someone calls Front(), they might get a value that was previously enqueued but then dequeued. That's a problem.\n\nWait, that's a serious concern. So perhaps in the data array, when we dequeue, we should set the value to None, or mark it as invalid.\n\nBut how?\n\nWait, because in the standard array-based implementation of a circular queue, when elements are dequeued, the space is reused. So, for example, after enqueuing 1,2,3,4, then dequeuing 1 and 2, the data array contains positions 0 (emptied?), 1 (emptied?), 2 (3), 3 (4).\n\nWait, perhaps the data array can have a default value (like None) to indicate that the position is empty. So during initialization, all positions are None. When you enqueue, you replace a None with the value. When you dequeue, you don't change the value, so that the position is still present but considered 'invalid'?\n\nNo, that's not correct.\n\nWait, that can't be. Because in a queue, once you dequeue, the data is removed. So the data structure needs to handle that state.\n\nAlternatively, perhaps the data array only contains valid data in the positions that are considered part of the queue, and the pointers and size indicate which data is valid.\n\nWait, perhaps I'm overcomplicating. Let me think step by step about the data structure.\n\nThe queue has:\n\n- data: a list of size k, initialized to some default (like 0 or None)\n- front: points to the first element in the queue\n- rear: points to the next position to enqueue an element\n- size: number of elements in the queue\n\nSo when enqueuing, the data[rear] is filled with the value, rear is incremented, and size increases. When dequeuing, front is incremented, size decreases.\n\nSo for example:\n\nk=4.\n\nInitially data = [None, None, None, None], front=0, rear=0, size=0.\n\nEnqueue 1: data[0] =1, rear=1, size=1.\n\nEnqueue 2: data[1] =2, rear=2, size=2.\n\nDequeue: front increments to 1, size=1.\n\nSo data[0] was 1, but after dequeuing, the front is 1. So Front() would now return data[1] =2.\n\nWait, but data[0] is still 1, but maybe it's considered invalid now.\n\nSo when someone calls Front(), the method looks at data[front], which is now 2, which is correct.\n\nSo in the data array, the 'old' front (data[front-1]) is not touched. So it remains 1.\n\nBut that's okay, as long as the front is correctly managed. Because the next Front() will look at data[front], which points to the next valid element.\n\nSo in that sense, the data array doesn't need to be cleared. Only front, rear, and size are important.\n\nSo for implementing CircularQueue, the steps are:\n\nInitialize data as [None] * k, front=0, rear=0, size=0.\n\nMethods:\n\nFront() returns data[front] if size>0, else -1.\n\nRear() returns data[(rear -1) %k] if size>0, else -1.\n\nWait, when the queue is empty (size=0), Rear() should return -1.\n\nElse, it's the last element added, which is at (rear-1) mod k.\n\nIs that correct?\n\nYes, as in the earlier examples.\n\nEnQueue: if size <k, assign data[rear] = value, rear becomes (rear+1)%k, size increments by 1. Return True.\n\nElse, return False.\n\nDeQueue: if size>0, size decrements by 1, front becomes (front+1) %k. Return True.\n\nElse, return False.\n\nWait, but maybe isFull() is when size == k, isEmpty() when size ==0?\n\nYes.\n\nSo that gives me all the pieces.\n\nNow, how to implement this in Python.\n\nIn the __init__ method, take k as parameter, and initialize data as [None] *k.\n\nBut in Python, when you create a list with [None] *k, the initial elements are None. So when you set data[rear] = value, it replaces None.\n\nSo the implementation steps are:\n\nClass CircularQueue:\n\n    def __init__(self, k):\n        self.k = k\n        self.data = [None] * k\n        self.front = 0\n        self.rear = 0\n        self.size = 0\n\nThen:\n\ndef enQueue(self, value):\n    if self.isFull():\n        return False\n    else:\n        self.data[self.rear] = value\n        self.rear = (self.rear + 1) % self.k\n        self.size +=1\n        return True\n\nBut wait, isFull is a method here, right? Because in the problem statement, methods like isFull are part of the class. So I need to implement helper methods.\n\nWait, but to call isFull() within enQueue, that's acceptable. However, perhaps it's better to write it as a condition based on the size.\n\nAlternatively, implement isFull as:\n\ndef isFull(self):\n    return self.size == self.k\n\nSimilarly, isEmpty() is size ==0.\n\nHmm.\n\nNow, let's see methods:\n\nFront():\n\ndef Front(self):\n    if self.isEmpty():\n        return -1\n    else:\n        return self.data[self.front]\n\nYes.\n\nRear():\n\ndef Rear(self):\n    if self.isEmpty():\n        return -1\n    else:\n        return self.data[(self.rear -1) % self.k]\n\nYes.\n\ndeQueue function:\n\ndef deQueue(self):\n    if self.isEmpty():\n        return False\n    else:\n        self.size -=1\n\n        # Move the front index\n        self.front = (self.front + 1) % self.k\n\n        return True\n\nWait, no. Because when you dequeue, you just need to move the front pointer. Because the data is still present in the array, but the front moves. So, for example, if front was pointing to index 0, after dequeuing, it moves to 1, indicating that element is now the front.\n\nYes, correct.\n\nWait, but what about when the queue is empty after dequeue?\n\nAfter dequeuing, if the front is 0, and after moving front becomes 1, but if size is 0, the next call to Front() will return data[front] = data[1], but since size is 0, it returns -1. So that's correct.\n\nSo the methods' behavior is correct.\n\nLet me test with an example.\n\nTest case 1:\n\nq = CircularQueue(3)\n\nq.enQueue(1) \u2192 True. data is [1, None, None], front=0, rear=1, size=1.\n\nq.enQueue(2) \u2192 data [1,2, None], front=0, rear=2, size=2.\n\nq.enQueue(3) \u2192 data [1,2,3], front=0, rear=0 (mod 3), size=3.\n\nNow, isFull() \u2192 True. Enqueue another \u2192 returns False.\n\nFront \u2192 1. Rear() \u2192 (rear-1) mod3 = 2 \u2192 3.\n\nDeQueue \u2192 size becomes 2, front \u2192 (0+1)=1 mod3.\n\ndata is [1,2,3], size is 2.\n\nNow, Front() is data[1] \u2192 2. Rear is data[2-1=1 \u21922]. Wait, Rear gives 2[(0 + enqueued 3 times, then one dequeued. So Rear() is 2.\n\nWait, no:\n\nAfter dequeuing 1, front is 1.\n\nRear is 0.\n\nSo Rear() is data[(0-1) mod3] \u2192 (-1 mod3) \u2192 2. Data[2] is 3. So Rear is 3.\n\nWhich is correct.\n\nSo the next DeQueue would return True, size becomes 1. Front becomes 2.\n\ndata remains [1, 2, 3]. So front is 2, data[2] is 3.\n\nFront() now is 3.\n\nIf we deque again, size becomes 0. Front becomes 0. So again, the queue is empty.\n\nSo that seems correct.\n\nWhat about if the queue wraps around?\n\nq = CircularQueue(3)\n\nEnqueue 1, 2, 3. Now, the queue is full.\n\nDequeue, data becomes front 1. Enqueue 4: sets data[0] =4, rear becomes 1. Size is 3 (after dequeue was 2, enqueue brings to 3).\n\nRear is data[0] is 4. So Rear() is 4.\n\nFront is data[1] which is 2.\n\nYes.\n\nThis seems correct.\n\nAnother test case: empty queue.\n\nq = CircularQueue(5).\n\nFront() \u2192 -1, Rear() \u2192 -1. isEmpty() \u2192 True.\n\nSo now, code structure.\n\nImplement all methods as specified.\n\nWait, but one concern is for Rear(). Since in Python, negative indexes are allowed but will wrap. So (rear-1) mod k is the right way. So in code, for Rear():\n\nindex = (self.rear -1) % self.k\nreturn self.data[index]\n\nYes.\n\nThus, the code should be:\n\nImplement the methods according to this logic.\n\nSo the code is as follows.\n\nAlso, note that the methods' names are in PascalCase? No, in the problem statement, the method names are Front, Rear, etc. So they should be named with capital letters.\n\nBut in Python, it's conventional to have snake_case. But let's stick to the problem statement's naming.\n\nWait, the problem statement says:\n\n- CircularQueue(int k) constructs the queue.\n\n- int Front(), etc. So the method names are Front, Rear.\n\nYes.\n\nSo in code:\n\nclass CircularQueue:\n    def __init__(self, k):\n        self.k = k\n        self.data = [None] * k\n        self.front = 0\n        self.rear = 0\n        self.size = 0\n\n    def Front(self):\n        if self.isEmpty():\n            return -1\n        return self.data[self.front]\n\n    def Rear(self):\n        if self.isEmpty():\n            return -1\n        return self.data[(self.rear -1) % self.k]\n\n    def enQueue(self, value):\n        if self.isFull():\n            return False\n        self.data[self.rear] = value\n        self.rear = (self.rear +1) % self.k\n        self.size +=1\n        return True\n\n    def deQueue(self):\n        if self.isEmpty():\n            return False\n        self.size -=1\n        self.front = (self.front +1) % self.k\n        return True\n\n    def isEmpty(self):\n        return self.size == 0\n\n    def isFull(self):\n        return self.size == self.k\n\nWait, but for the enQueue function, after setting data[rear]=value, since rear is going to be (rear+1) %k.\n\nYes.\n\nTesting with a few cases, as I did before. But what about edge cases.\n\nFor example, when the queue is of size 1.\n\nq = CircularQueue(1)\n\nq.enQueue(5): yes. data[0] =5. Front is 0. Rear becomes (0+1)%1=0.\n\nNow, isFull() is True.\n\nThen, enQueue(6): returns False.\n\nDeQueue: Front becomes (0+1) mod1=0. Size is 0. So after dequeue, the queue is empty.\n\nCalling Rear after that returns -1.\n\nYes.\n\nAnother test case for Rear: queue with one element.\n\nenQueue 5: Rear() returns (0-1) mod1 = 0. So data[0] =5. Correct.\n\nYes.\n\nAnother test case: empty queue.\n\nCalling Rear returns -1; Front returns -1.\n\nI think the code should handle these cases.\n\nSo now, that's the implementation.\n\nI think all the required operations are implemented, each in O(1) time.\n</think>\n\nTo solve this problem, we need to implement a CircularQueue class that supports several operations in constant time (O(1)). The operations include enqueuing an element, dequeuing an element, checking if the queue is empty, checking if the queue is full, retrieving the front element, and retrieving the rear element.\n\n### Approach\n\nThe CircularQueue is implemented using an array-based approach with pointers to track the front and rear of the queue. The key steps are as follows:\n\n1. **Initialization**: The queue is initialized with a fixed size `k`. An array of size `k` is used to store the elements, and two pointers, `front` and `rear`, are used to track the current front and rear positions of the queue.\n2. **Enqueue Operation**: When an element is added to the queue, it is placed at the position indicated by the `rear` pointer. After placing the element, the `rear` pointer is moved to the next position using modulo arithmetic to wrap around when the end of the array is reached.\n3. **Dequeue Operation**: When an element is removed from the queue, the `front` pointer is moved to the next position using modulo arithmetic. The size of the queue is decremented accordingly.\n4. **Checking Front and Rear Elements**: The front element is the element at the `front` pointer, and the rear element is the element just before the `rear` pointer (using modulo arithmetic to handle wrapping).\n5. **Empty and Full Checks**: The queue is considered empty if the size is zero and full if the size equals the maximum capacity `k`.\n\n### Solution Code\n\n```python\nclass CircularQueue:\n    def __init__(self, k):\n        self.k = k\n        self.data = [None] * k\n        self.front = 0\n        self.rear = 0\n        self.size = 0\n\n    def Front(self):\n        if self.isEmpty():\n            return -1\n        return self.data[self.front]\n\n    def Rear(self):\n        if self.isEmpty():\n            return -1\n        return self.data[(self.rear - 1) % self.k]\n\n    def enQueue(self, value):\n        if self.isFull():\n            return False\n        self.data[self.rear] = value\n        self.rear = (self.rear + 1) % self.k\n        self.size += 1\n        return True\n\n    def deQueue(self):\n        if self.isEmpty():\n            return False\n        self.size -= 1\n        self.front = (self.front + 1) % self.k\n        return True\n\n    def isEmpty(self):\n        return self.size == 0\n\n    def isFull(self):\n        return self.size == self.k\n```\n\n### Explanation\n\n- **Initialization (`__init__` method)**: The constructor initializes the queue with a specified size `k`, creating an array of `k` elements initialized to `None`. The `front` and `rear` pointers are set to 0, and `size` is set to 0.\n- **Front Method**: Returns the element at the `front` pointer if the queue is not empty; otherwise, returns -1.\n- **Rear Method**: Returns the element just before the `rear` pointer (using modulo arithmetic) if the queue is not empty; otherwise, returns -1.\n- **Enqueue Method**: Adds an element to the queue if there is space. Updates the `rear` pointer and increments the size. Returns `True` if successful, otherwise `False`.\n- **Dequeue Method**: Removes the front element by moving the `front` pointer and decrementing the size. Returns `True` if successful, otherwise `False`.\n- **Empty Method**: Checks if the queue is empty by comparing `size` to 0.\n- **Full Method**: Checks if the queue is full by comparing `size` to `k`.\n\nThis approach ensures all operations are performed in constant time, O(1), making the CircularQueue efficient for typical queue operations.",
  "r1_solution": "class CircularQueue:\n    def __init__(self, k):\n        self.k = k\n        self.data = [None] * k\n        self.front = 0\n        self.rear = 0\n        self.size = 0\n\n    def Front(self):\n        if self.isEmpty():\n            return -1\n        return self.data[self.front]\n\n    def Rear(self):\n        if self.isEmpty():\n            return -1\n        return self.data[(self.rear - 1) % self.k]\n\n    def enQueue(self, value):\n        if self.isFull():\n            return False\n        self.data[self.rear] = value\n        self.rear = (self.rear + 1) % self.k\n        self.size += 1\n        return True\n\n    def deQueue(self):\n        if self.isEmpty():\n            return False\n        self.size -= 1\n        self.front = (self.front + 1) % self.k\n        return True\n\n    def isEmpty(self):\n        return self.size == 0\n\n    def isFull(self):\n        return self.size == self.k",
  "metadata": {
    "prompt_id": "00000000",
    "row_id": 0,
    "seed_ids": [
      "1797",
      "1403",
      "2583"
    ],
    "mode": "leetcode",
    "original_instruction": "Implement a class `CircularQueue` that supports the following operations:\n\n*   `CircularQueue(int k)` constructs the `CircularQueue` with a maximum size of `k`.\n*   `int Front()` retrieves the element at the front of the queue without removing it. Returns `-1` if the queue is empty.\n*   `int Rear()` retrieves the element at the rear of the queue without removing it. Returns `-1` if the queue is empty.\n*   `boolean enQueue(int value)` inserts the element `value` into the queue. Returns `true` if the operation is successful, `false` otherwise (i.e., the queue is full).\n*   `boolean deQueue()` deletes an element from the queue. Returns `true` if the operation is successful, `false` otherwise (i.e., the queue is empty).\n*   `boolean isEmpty()` returns `true` if the queue is currently empty, `false` otherwise.\n*   `boolean isFull()` returns `true` if the queue is currently full, `false` otherwise.\n\nEnsure that all operations are performed in **constant time** (O(1))."
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results2.jsonl"
}