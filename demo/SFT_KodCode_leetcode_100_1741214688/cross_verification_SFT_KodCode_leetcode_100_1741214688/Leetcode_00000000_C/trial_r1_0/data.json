{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000000_C",
  "question": "from typing import List\n\nclass CircularQueue:\n    \"\"\"Implement a class CircularQueue that supports the following operations:\n    - CircularQueue(int k) constructs the CircularQueue with a maximum size of k.\n    - int Front() retrieves the element at the front of the queue without removing it. Returns -1 if the queue is empty.\n    - int Rear() retrieves the element at the rear of the queue without removing it. Returns -1 if the queue is empty.\n    - boolean enQueue(int value) inserts the element value into the queue. Returns true if the operation is successful, false otherwise (i.e., the queue is full).\n    - boolean deQueue() deletes an element from the queue. Returns true if the operation is successful, false otherwise (i.e., the queue is empty).\n    - boolean isEmpty() returns true if the queue is currently empty, false otherwise.\n    - boolean isFull() returns true if the queue is currently full, false otherwise.\n    \n    Ensure that all operations are performed in constant time (O(1)).\n    \"\"\"",
  "solution": "class CircularQueue:\n    def __init__(self, k: int):\n        assert k > 0, \"k must be a positive integer\"\n        self.max_size = k\n        self.queue = [None] * k\n        self.head = -1\n        self.tail = -1\n\n    def Front(self) -> int:\n        if self.head == -1:\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -> int:\n        if self.head == -1:\n            return -1\n        return self.queue[self.tail]\n\n    def enQueue(self, value: int) -> bool:\n        if self.head == -1 and self.tail == -1:\n            self.head = 0\n            self.tail = 0\n            self.queue[self.tail] = value\n            return True\n        elif (self.tail + 1) % self.max_size == self.head:\n            return False\n        else:\n            self.tail = (self.tail + 1) % self.max_size\n            self.queue[self.tail] = value\n            return True\n\n    def deQueue(self) -> bool:\n        if self.head == -1:\n            return False\n        elif self.head == self.tail:\n            self.head = -1\n            self.tail = -1\n            return True\n        else:\n            self.head = (self.head + 1) % self.max_size\n            return True\n\n    def isEmpty(self) -> bool:\n        return self.head == -1\n\n    def isFull(self) -> bool:\n        return (self.tail + 1) % self.max_size == self.head",
  "test_code": "import pytest\n\ndef test_circular_queue():\n    cq = CircularQueue(3)\n\n    assert cq.enQueue(1) is True\n    assert cq.enQueue(2) is True\n    assert cq.enQueue(3) is True\n    assert cq.enQueue(4) is False\n\n    assert cq.Rear() == 3\n    assert cq.Front() == 1\n\n    assert cq.deQueue() is True\n    assert cq.enQueue(4) is True\n\n    assert cq.Front() == 2\n\ndef test_queue_operations():\n    cq = CircularQueue(2)\n\n    assert cq.enQueue(1) is True\n    assert cq.enQueue(2) is True\n    assert cq.enQueue(3) is False\n\n    assert cq.deQueue() is True\n    assert cq.enQueue(3) is True\n\n    assert cq.Front() == 2\n    assert cq.Rear() == 3\n\n    assert cq.deQueue() is True\n    assert cq.deQueue() is True\n    assert cq.Rear() == -1\n    assert cq.Front() == -1",
  "test_info": null,
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to implement a CircularQueue class in Python. Let me think about what each method should do.\n\nThe constructor, CircularQueue(int k), creates a queue with a max size of k. So, I'll need an array or list to hold the elements. Let's say I'll use a list initialized with a size k. Also, since it's a circular queue, I'll need to track the front and rear indices, and the current number of elements.\n\nWait, but how do I handle the circular part efficiently. Oh right, I'll need to maintain a count of the elements, the front index, and the rear index. But in a circular queue, when you enqueue/dequeue, the front and rear can wrap around.\n\nHmm. So the data structure I have in mind is an array with a fixed size. Let's initialize the data as a list of None, but no, maybe better to track the elements using the current count. Or, perhaps it's better to represent it with a list that's initialized with None for all possible positions, and then manage the front, rear, and count.\n\nWait, perhaps it's better to use a fixed-size list where the front is the index of the first element, the next element is front+1 mod size, and so on until the count is reached.\n\nSo the plan is:\n\n- Initialize the data structure as a list whose length is k. All entries can be initialized to None or to a default value indicating they are empty.\nWait, but maybe initializing with a specific 'empty' value is better. Or, since in the enQueue, we'll be adding elements, and in deQueue we'll remove, perhaps we can track the number of elements in the queue with a count variable. So, when count is 0, it's empty. When count is k, it's full.\n\nWait, yes. So the state variables will be:\n\n- data: a list of size k, storing the elements. The front is the position from which we dequeue, the rear is the position where we enqueue next.\n\nWait, maybe I should think of it in terms of an array where each position can hold a value, but we have front and rear pointers (or indices) that indicate the next element to dequeue (front), and the next position to enqueue (rear). But also, the count will keep track of how many elements are in the queue. So enQueue can only add if count < k.\n\nBut in the circular queue, when you enqueue, the rear pointer moves forward, and wraps around if necessary. Similarly, when you dequeue, the front moves forward.\n\nSo let's outline the variables:\n\n- data: the underlying list of size 'k' that holds the elements.\n- front: the index of the front element.\n- rear: the index where the next enqueued element will go.\n- count: the number of elements currently in the queue.\n\nWait, perhaps it's better to have the front index be the position of the next element to dequeue, and the rear index is the position where the next element will be enqueued. When dequeued, front increases by 1 mod k. When enqueued, we set data[rear] = value, and then rear is incremented mod k, and count increases by 1.\n\nYes, that makes sense. So, initially, front and rear can both start at 0. Count will be 0, so the queue is empty.\n\nLet's think about each method:\n\n1. Front(): returns the front element. If empty, return -1. So, if count is 0, return -1. Else, return data[front].\n\n2. Rear(): returns the last element enqueued. If empty, return -1. So, if count is 0, return -1. Else, return data[rear] ? Wait, wait\u2014after enqueuing, the rear was just incremented. So next enqueued element would go to the current rear. So, the last element is at position rear-1, modulo k.\n\nAlternatively, perhaps the rear is pointing to the next position. So when you enQueue, you put the value at data[rear], then increment rear. So for example, if rear was 0 and you enqueue, data[0] is set, rear becomes 1. Then, the last element added is at index 0, not at index 1. So in Rear(), you need to access data[rear - 1] modulo k.\n\nWait, let me think:\n\nInitially, front is 0, rear is 0, count is 0.\n\nWhen you enQueue(5), data[rear] (data[0]) =5. Then rear is incremented mod k (if rear was k-1, it wraps to 0). Also, count increases by 1.\n\nSo for Rear(), if count is >0, data[rear -1] is the rear element.\n\nYes, that makes sense.\n\nSo Rear() should check if count is 0, return -1. Else, compute (rear -1) % size to get the index, and return data at that index.\n\nNow for enQueue: if count is equal to size, return False. Otherwise, place the value at the current rear index, increment rear mod size, increase count, return True.\n\nSimilarly, deQueue: if count is 0, return False. Otherwise, just move front to front +1 mod size, decrease count by 1, return True.\n\nWait, no, because in deQueue, you are not necessarily removing the data. Are we supposed to maintain the array with the elements, not changing them, so that the elements are still present but the queue acts as if they're removed by adjusting front and count.\n\nWait, that's the thing about circular queues\u2014usually, they don't actually remove the data but manage their indexes. So when you dequeue, you don't change the data, but front is moved. So when enQueue is called again, it will overwrite the front positions once we dequeue all current elements.\n\nSo in our case, the data array remains as is, and enQueue will overwrite it. Wait, no: when adding to the rear, if the queue is full, we return false. Else, we add the data and move the rear. So perhaps the initial data is filled as the queue grows.\n\nWait, perhaps, actually, the data is allocated to the maximum size, and as the queue is enqueued, it's stored in the next position, and when it's full, it returns False.\n\nNo, the underlying data is stored. So when elements are dequeued, their positions are not removed; the front index moves, but the data remains in the array. Only when enQueue is called again, the data at the rear position is overwritten.\n\nBut in our case, it's not necessary to remove the data; we can just manage the front and rear indices.\n\nSo, for deQueue, we are just supposed to return True or False indicating success, and move the front pointer.\n\nWait no, because for the front, the method Front() returns the front element for the queue, which is the same as data[front]. So when deQueue is called, the front is moved, but the data in the front is not removed.\n\nYes.\n\nSo the five variables:\n\nProbably, data, front, rear, size, count.\n\nNow, let's think about how to manage them.\n\nIn the constructor:\n\ndef __init__(self, k):\n    self.size = k\n    self.data = [None] * k  # or some default value\n    self.front = 0\n    self.rear = 0\n    self.count = 0\n\nWait, but initializing data with None may cause issue when retrieving Front() or Rear(), because a value of None can be present as a legitimate value? Wait no, the operations return -1 when empty, and their return type is int. So if the queue is empty, None is never returned.\n\nWait, in Python, None is returned only when the function expects to return a certain type but finds None.\n\nLooking at the function definitions:\n\nFront() returns int, but in Python, the return type is just aided by type hints. So, in our case, we can represent an empty queue with data elements as None or as some sentinel value, but perhaps it's better to manage the data as we enqueue.\n\nWait, perhaps in the initial state, all data is None. When enqueuing, we set data[rear] = value. So, for example, in a queue of size 3:\n\nInitially, data is [None, None, None].\n\nenQueue(5): data becomes [5, None, None], rear is 1, count is 1.\n\nenQueue(3): data [5,3,None], rear is 2, count is 2.\n\nfront is 0.\n\ndeQueue(): count becomes 1, front is 1, data remains as is.\n\nenQueue(2): data becomes [5,3,2], rear is 0, count is 3.\n\nNow, isFull() is true.\n\nSo Front() would return data[1], which is 3.\n\nWait, no: Front() returns the first element in the queue, which after deQueue(), the front was 1, so the next element is data[1]. Wait no, after first deQueue, front moves to 1, which is the next element.\n\nSo in this example, the queue has 2 elements.\n\nWait, perhaps I need to think more carefully about managing the data, front, rear, count.\n\nAnother approach: the queue is empty when count is 0. Full when count == size.\n\nEvery enQueue adds an element if possible, updating rear and count. deQueue removes front, updating front and count.\n\nBut for the data, it's always stored in the positions, so rear points to the next possible position to put an element.\n\nFor example, if size is 3:\n\nAfter enQueue(1), the data is [1, None, None], front=0, rear=1, count=1.\n\nenQueue(2): [1,2,None], rear=2, count=2.\n\nenQueue(3): [1,2,3], rear=0, count=3.\n\nNow queue is full.\n\ndeQueue(): data is still [1,2,3], front becomes 1 mod 3 = 1 (because deQueue increments front by 1). count decreases to 2.\n\nenQueue(4): since count is 2, can enqueue. data[rear=0] =4. So data is [4,2,3], then rear becomes 1, count becomes 3.\n\nNow queue is full.\n\nThen front is 1: the current front element is data[1] = 2.\n\nYes.\n\nSo the data is being overwritten as new elements are added. So the data at front is 2 in this case.\n\nWait, what happens to the data when dequeuing? For example, when the front is at position 0, after deQueue(), it moves to position 1, but the data remains.\n\nWait, that's correct because the front only points to the current front, the elements that have been dequeued are logically removed, but their data remains in the array until new elements are enqueued which overwrite them.\n\nThis is acceptable as the data structure ensures that when enqueuing, the next available position is used, possibly overwriting old, dequeued elements.\n\nThus, in our implementation, the data array is fixed in size, and the front, rear, and count variables manage which parts of the array are considered to be in the queue.\n\nNow, putting all that into code.\n\nLet's outline the methods:\n\n1. __init__(self, k): initializes the data structure.\n\nBut what if k is 0? Well, that might be an error. But probably, according to the problem statement, k is a positive integer.\n\nSo in the constructor, data = [None] * k.\n\nThen front = 0, rear =0, count=0.\n\nBut wait, in some implementations, front is the index of the next element to be dequeued, and rear is the next position to be filled. So, for a newly created queue with k=3, after first enQueue, rear is 0, after increment (mod k) it's 1.\n\nWait, perhaps in the initial state, the queue is empty, front and rear at 0. So the first enQueue will put the element at rear (0), then rear is incremented to 1.\n\nSo, during enQueue, the element is inserted into the data[rear], then rear is incremented modulo k.\n\nBut after the first dequeue, the front is incremented modulo k.\n\nWait, perhaps the logic is:\n\nenQueue:\nif count == k \u2192 return False (queue is full)\nelse:\n    data[rear] = value\n    rear = (rear + 1) % k\n    count +=1\n    return True\n\ndeQueue:\nif count == 0 \u2192 return False\nelse:\n    front = (front +1) % k\n    count -=1\n    return True\n\nThen Front():\nif count ==0 \u2192 return -1\nelse \u2192 data[front]\n\nSimilarly, Rear():\nif count ==0 \u2192 return -1\nelse \u2192 data[ (rear -1) % size ]\n\nWait, let me test Rear with the example I had earlier.\n\nAfter we enqueued 1, rear is 1. data [0] is 1.\n\nRear method: (rear -1) mod size \u2192 (1-1) mod 3 \u21920 mod 3 \u2192 0.\n\nYes, returns data[0] which is correct.\n\nAnother example: after enQueue 1, 2, 3\u2014rear is 0.\n\nRear() \u2192 (0-1) mod 3 \u2192 2 \u2192 data[2] =3. Correct.\n\nAnother example: deque some elements. For front.\n\nLike after 1,2,3 are enqueued, deque once.\n\nSo front becomes 1, count is 2.\n\nFront() returns data[1].\n\nYes, which is 2.\n\nBut what about the enQueue after the next element is full.\n\nLike, after enqueuing 1,2,3, and dequeuing once so count is 2.\n\nThen enQueue 4: data[0] is 4.\n\nrear becomes 1.\n\nSo data is [4,2,3].\n\nThen Rear() is (1-1)=0 \u2192 data[0] is 4. And front is 1.\n\nSo, the next deQueue returns front of 2? And front increments to 2.\n\nYes.\n\nSo, with that, I think this logic should all work.\n\nNow, implementing the methods.\n\nFirst, the constructor:\ndef __init__(self, k: int):\n    self.size = k\n    self.data = [None] * self.size\n    self.front = 0\n    self.rear = 0\n    self.count = 0\n\nWait, but perhaps what if the default data is a list of a specific value, like 0? Well, it depends on the problem statement whether it accepts 0 as a possible value. But since in enQueue, it's supposed to allow any int, including 0, perhaps a None initial value is better.\n\nBut when we enqueue, we just overwrite the data, so the initial None's are not a problem because None will only be present when the data wasn't set (i.e., count is 0, or in positions that are not being pointed to by front to front + count -1).\n\nWait, but in our implementation, the data represents a buffer, and the valid elements are from front to front + count, wrapping around.\n\nBut perhaps having data elements initialized to a sentinel like None is better.\n\nBut in the enQueue function, we only write when we're adding a new element, regardless of whether the position was None.\n\nSo the data can be correctly read in Front and Rear.\n\nSo in code, in the Front method, check if count is 0, return -1, else return data[front].\n\nSimilarly for Rear, as data[ (rear-1) % size ].\n\nNow, coding all the methods.\n\nWait, but what about overflow? Like, when the enQueue is called on a full queue, it returns False.\n\nThe same for deQueue on an empty queue.\n\nSo, for enQueue:\n\ndef enQueue(self, value: int) -> bool:\n    if self.count == self.size:\n        return False\n    self.data[self.rear] = value\n    self.rear = (self.rear + 1) % self.size\n    self.count += 1\n    return True\n\nFor deQueue:\n\ndef deQueue(self) -> bool:\n    if self.count == 0:\n        return False\n    self.front = (self.front + 1) % self.size\n    self.count -= 1\n    return True\n\nWait, but deQueue doesn't actually modify the data, just move the front and reduce count.\n\nWhat about Front method?\n\ndef Front(self) -> int:\n    if self.isEmpty():\n        return -1\n    return self.data[self.front]\n\nSimilarly, Rear method:\n\ndef Rear(self) -> int:\n    if self.isEmpty():\n        return -1\n    else:\n        return self.data[ (self.rear -1) % self.size ]\n\nWait, but wait\u2014what if the queue is empty? Then for Rear(), return -1.\n\nBut when else? Well, for example, after dequeue, front has moved beyond where data is considered present.\n\nBut in Rear(), the index is (rear-1) mod size, because when the queue is not empty, rear points to the next position.\n\nLet me think:\n\nenQueue once, rear is 1, data[0] is the element. Rear() is data[0]. Correct.\n\nenQueue again, rear is 2, data[0] and data[1] have elements. Rear() is data[1]. Correct.\n\nAnother enQueue, rear is 0 (mod 3), data[2] =element. Rear() is data[2]. Correct.\n\nYes, that's correct.\n\nNow, for isEmpty and isFull:\n\ndef isEmpty(self) -> bool:\n    return self.count == 0\n\ndef isFull(self) -> bool:\n    return self.count == self.size\n\nWait, but according to the problem statement, isFull() should return True if the queue is full.\n\nYes.\n\nNow, that's the code.\n\nBut wait\u2014what about the data? Initially, data is [None] * k. So for example, if k=3, data is [None, None, None].\n\nWhen enQueue is called, say for value=5, rear is 0, data becomes [5, None, None]. Rear becomes 1, etc.\n\nBut when reading front or rear, it's possible that some positions are None, but only when the queue is not empty.\n\nLet's test some scenarios.\n\nTest case 1: empty queue.\n\nqueue = CircularQueue(3)\n\nFront() returns -1.\n\nRear() returns -1.\n\ndeQueue() is False.\n\nisEmpty() is True.\n\nisFull() is False.\n\nTest case 2: enQueue(5). Count is 1.\n\nFront() returns 5. Rear() returns 5.\n\nTest case 3: enQueue(3). Count is 2.\n\nFront is still 5, rear returns 3.\n\nTest case 4: enQueue(2). Count is 3. Queue is full.\n\nNow, deQueue is called. count becomes 2.\n\nFront was 0. Now front becomes 1.\n\nSo, Front() is data[1], which was 3.\n\nRear() is data[ (rear-1) ].\n\nearlier, rear was 0 (after enqueuing).\n\nso (0-1) mod3 = 2.\n\nBut data[2] was set to 2.\n\nSo Rear() returns 2.\n\nYes, correct.\n\nThen, after deQueue, front is 2.\n\nSo, data[2] is 2.\n\ndeQueue again sets front to 0, and count is 1.\n\nNow, the data is [5,3,2], but the queue has one element, whose front is 0.\n\nWait, no.\n\nWait, how does that work?\n\nLet's walk through.\n\nAfter enqueuing to full: data is [5,3,2], front is 0, rear is 0, count 3.\n\ndeQueue is called once.\n\ncount is 2, front is (0+1) mod 3 =1.\n\nSo Front() is data[1], which is 3.\n\ndeQueue again: count becomes 1, front becomes (1+1) =2.\n\nSo Front() is data[2], which is 2.\n\ndeQueue again: count becomes 0, front is 0 again.\n\nSo Front() returns -1.\n\nWait, yes. Because after deQueue, front becomes (2+1) mod3 =0. count is 0, so front =0. So in this case, when the queue is empty, front is 0.\n\nBut data is [5,3,2]; why?\n\nBecause the data isn't cleared, but the count is 0, making the queue look empty.\n\nSo, for example, any enQueues after that would start filling from the front position and then wrap.\n\nBut then, when count is 0, both front and rear are 0. So, when enQueue(4): data[0] becomes 4, rear becomes 1.\n\nSo, the data is [4,3,2], count is 1.\n\nThe Front() is 4, Rear() is4, since (rear -1) is 0: data[0] is4.\n\nYes, correct.\n\nThus, the code seems to handle all the cases.\n\nWait, but let's think about another situation.\n\nWhat's the queue after:\nenQueue 1 \u2192 count 1, data[0]=1, front=0, rear=1.\n\nenQueue 2 \u2192 data[1]=2, front=0, rear=2.\n\nenQueue 3 \u2192 data[2]=3, front=0, rear=0 (since 3 enqueued, count=3).\n\nNow it's full.\n\ndeQueue \u2192 count=2, front becomes 1 mod3=1.\n\nFront is data[1] =2.\n\ndeQueue \u2192 count=1, front becomes 2.\n\nFront() returns 3.\n\ndeQueue \u2192 count 0, front becomes0.\n\nSo the queue is empty again.\n\nThus, the code should be correct.\n\nSo, now, implementing all the code.\n\nThe functions are:\n\n- __init__(self, k)\n- Front(self)\n- Rear(self)\n- enQueue(self, value)\n- deQueue(self)\n- isEmpty(self)\n- isFull(self)\n\nWait, the function names are a bit inconsistent, but according to the problem statement, the functions have the written names.\n\nNow, all the functions need to run in constant time. Which our code does, since all operations are O(1).\n\nHence, the code above should satisfy all the requirements.\n</think>\n\nTo solve this problem, we need to implement a CircularQueue class that supports various operations such as enqueuing, dequeuing, checking the front and rear elements, and checking if the queue is empty or full. The operations must be performed in constant time, O(1).\n\n### Approach\nThe CircularQueue class uses an array to store the elements. The queue uses two pointers, `front` and `rear`, to keep track of the current front and rear elements. The queue also maintains a `count` variable to track the number of elements currently in the queue. The operations are managed using modular arithmetic to handle the circular nature of the queue.\n\n1. **Initialization**: The constructor initializes the queue with a specified maximum size and sets up the front and rear pointers at the start of the array, with an initial count of zero elements.\n\n2. **Enqueue Operation**: Adds an element to the queue if there is space. The element is placed at the rear pointer, which is then incremented modulo the size of the array to handle the circular nature.\n\n3. **Dequeue Operation**: Removes an element from the queue if there are elements present. The front pointer is incremented modulo the size of the array, and the count is decremented.\n\n4. **Front and Rear Operations**: Retrieve the front and rear elements of the queue without removing them. If the queue is empty, these operations return -1.\n\n5. **Empty and Full Checks**: Determine if the queue is empty or full using the count variable.\n\n### Solution Code\n\n```python\nfrom typing import List\n\nclass CircularQueue:\n    def __init__(self, k: int):\n        self.size = k\n        self.data = [None] * self.size\n        self.front = 0\n        self.rear = 0\n        self.count = 0  # Number of elements in the queue\n\n    def Front(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[self.front]\n\n    def Rear(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[(self.rear - 1) % self.size]\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.data[self.rear] = value\n        self.rear = (self.rear + 1) % self.size\n        self.count += 1\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.front = (self.front + 1) % self.size\n        self.count -= 1\n        return True\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.size\n```\n\n### Explanation\n- **Initialization (`__init__` method)**: This sets up the queue with a specified size, initializes the data array, and sets the front and rear pointers to the start of the array with an initial count of zero.\n- **Enqueue (`enQueue` method)**: Checks if the queue is full. If not, it places the element at the rear pointer, updates the rear pointer, and increments the count.\n- **Dequeue (`deQueue` method)**: Checks if the queue is empty. If not, it updates the front pointer and decrements the count.\n- **Front and Rear (`Front` and `Rear` methods)**: Return the elements at the front and rear of the queue. If the queue is empty, they return -1.\n- **Empty and Full Checks (`isEmpty` and `isFull` methods)**: Use the count variable to determine if the queue is empty or full.\n\nThis approach ensures that each operation is performed in constant time, O(1), making the implementation efficient and suitable for scenarios where time constraints are critical.",
  "r1_solution": "from typing import List\n\nclass CircularQueue:\n    def __init__(self, k: int):\n        self.size = k\n        self.data = [None] * self.size\n        self.front = 0\n        self.rear = 0\n        self.count = 0  # Number of elements in the queue\n\n    def Front(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[self.front]\n\n    def Rear(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[(self.rear - 1) % self.size]\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.data[self.rear] = value\n        self.rear = (self.rear + 1) % self.size\n        self.count += 1\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.front = (self.front + 1) % self.size\n        self.count -= 1\n        return True\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.size",
  "metadata": {
    "prompt_id": "00000000",
    "row_id": 0,
    "seed_ids": [
      "1797",
      "1403",
      "2583"
    ],
    "mode": "leetcode",
    "original_instruction": "Implement a class `CircularQueue` that supports the following operations:\n\n*   `CircularQueue(int k)` constructs the `CircularQueue` with a maximum size of `k`.\n*   `int Front()` retrieves the element at the front of the queue without removing it. Returns `-1` if the queue is empty.\n*   `int Rear()` retrieves the element at the rear of the queue without removing it. Returns `-1` if the queue is empty.\n*   `boolean enQueue(int value)` inserts the element `value` into the queue. Returns `true` if the operation is successful, `false` otherwise (i.e., the queue is full).\n*   `boolean deQueue()` deletes an element from the queue. Returns `true` if the operation is successful, `false` otherwise (i.e., the queue is empty).\n*   `boolean isEmpty()` returns `true` if the queue is currently empty, `false` otherwise.\n*   `boolean isFull()` returns `true` if the queue is currently full, `false` otherwise.\n\nEnsure that all operations are performed in **constant time** (O(1))."
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results0.jsonl"
}