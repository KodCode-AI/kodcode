{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000064_I",
  "question": "Given a binary search tree (BST) and a node value `target`, return `true` if the `target` is found in the BST, and `false` otherwise. You may assume that each node in the BST has **uniquely** valued children. Additionally, provide a method to insert a new node with a given value into the BST while maintaining its properties.",
  "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_in_bst(root: TreeNode, target: int) -> bool:\n    \"\"\"\n    Searches for the target value in the BST and returns True if found, False otherwise.\n    \"\"\"\n    if root is None:\n        return False\n    if root.val == target:\n        return True\n    elif root.val < target:\n        return find_in_bst(root.right, target)\n    else:\n        return find_in_bst(root.left, target)\n\ndef insert_in_bst(root: TreeNode, val: int) -> TreeNode:\n    \"\"\"\n    Inserts a new node with given value into the BST.\n    \"\"\"\n    if root is None:\n        return TreeNode(val)\n    if val < root.val:\n        root.left = insert_in_bst(root.left, val)\n    else:\n        root.right = insert_in_bst(root.right, val)\n    return root",
  "test_code": "from solution import TreeNode, find_in_bst, insert_in_bst\n\ndef test_find_in_bst():\n    # Create a simple BST\n    root = TreeNode(8, TreeNode(3, TreeNode(1), TreeNode(6, None, TreeNode(7))), TreeNode(10, None, TreeNode(14)))\n    assert find_in_bst(root, 3) == True\n    assert find_in_bst(root, 10) == True\n    assert find_in_bst(root, 5) == False\n\ndef test_insert_in_bst():\n    # Create a simple tree and insert nodes\n    root = TreeNode(8)\n    insert_in_bst(root, 3)\n    insert_in_bst(root, 10)\n    assert find_in_bst(root, 3) == True\n    assert find_in_bst(root, 10) == True\n\ndef test_insertion_multiple_nodes():\n    root = TreeNode(8)\n    insert_in_bst(root, 3)\n    insert_in_bst(root, 10)\n    insert_in_bst(root, 1)\n    assert find_in_bst(root, 3) == True\n    assert find_in_bst(root, 10) == True\n    assert find_in_bst(root, 1) == True\n    assert find_in_bst(root, 14) == False  # Before insertion\n    insert_in_bst(root, 14)\n    assert find_in_bst(root, 14) == True",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to solve this problem where I have a binary search tree (BST) and I need to check if a target value exists in it. Also, I need a method to insert a new node while maintaining the BST properties. Hmm, let me think about how to approach this.\n\nFirst, I should remember how a BST works. Each node has at most two children: a left child and a right child. For any node, all the values in its left subtree are less than the node's value, and all the values in the right subtree are greater than the node's value. And each node's value is unique because the problem says the children have unique values.\n\nSo for the search function, I need to traverse the BST in a way that follows these properties. If the target is less than the current node's value, I should go left. If it's greater, I go right. If it's equal, then I've found the target and return true. If I reach a point where there's no child to go to (i.e., I've hit a leaf node) and still haven't found the target, then I return false.\n\nLet me outline the steps for the search function:\n\n1. Start at the root node.\n2. Compare the target with the current node's value.\n   a. If equal, return true.\n   b. If target < current value, move to the left child.\n   c. Else, move to the right child.\n3. Repeat step 2 until the target is found or there are no more nodes to check.\n\nOkay, that makes sense. Now for the insertion function. Inserting a node into a BST also follows similar logic. I need to find the appropriate place to insert the new node such that the BST properties are maintained.\n\nThe steps for insertion would be:\n\n1. Start at the root.\n2. Compare the new value with the current node's value.\n3. If new value is less than current, check the left child:\n   a. If left child exists, move to it and repeat.\n   b. If left child doesn't exist, add the new node as the left child.\n4. Else (new value is greater), check the right child:\n   a. If right child exists, move to it and repeat.\n   b. If right child doesn't exist, add the new node as the right child.\n5. Make sure that the new node has null left and right children.\n\nWait, but what about duplicates? The problem states that each node has uniquely valued children, implying that the BST contains distinct values. So if the target is already present, we shouldn't insert it again. Or does the insertion function not check for that? The problem says to insert a new node with a given value but doesn't specify handling duplicates. Hmm, perhaps it's better to assume that the tree doesn't have duplicates and the insertion should only add the node if it's not present. Or maybe the insertion can handle that, by not inserting if the value already exists.\n\nThe problem statement isn't entirely clear on whether the insert function should handle duplicates. But since \"uniquely valued children\" likely means each node's value is unique in the tree, the insert function should not allow inserting a value that already exists. So in the search function, we can return if the target is found, which also helps in the insert function to avoid duplicates.\n\nSo, in the insert function's logic, before inserting, I should check if the value already exists, but wait, that would mean I have to perform a search first. Alternatively, during the insertion process, once I reach a point where the new node can't go further left or right and that position is null, I can check if the current path leads to that. So the insertion function should traverse the BST and find the correct spot without inserting duplicates.\n\nWait, no. The search function and the insert function are separate. So in the insert function, during traversal, if I find the target exists, I should return without inserting. Or perhaps, the problem expects that we can insert even if the node exists, but in that case, the uniqueness is no longer maintained, which would violate BST properties.\n\nBut according to the problem statement, each node in the BST has uniquely valued children, so the tree doesn't have duplicates already. Therefore, during insertion, the function should ensure that the new value is not already present, thus avoiding duplicates.\n\nSo the insertion function can first check if the target is already present by using the search function. If it is, return without inserting. Else, proceed with insertion. Or alternatively, during the traversal, if a node's value is equal to the new value, we don't insert and perhaps return false or something. But looking at standard BST insertion logic, it usually just allows insertion and in many cases, the insert allows duplicates by perhaps going to the left or right. But for this problem, since it's given that all children are unique, perhaps we need to prevent insertion if the value is already present.\n\nSo, in the code, the insert function should first search for the value. If found, do nothing. Else, insert the new node.\n\nAlternatively, the insertion function can proceed as usual, and during traversal, once it finds a node with the same value, it just returns without inserting. That way, duplicates are not inserted, which maintains the BST's unique value property.\n\nNow, I need to structure this into code. Let's sketch some pseudocode for the search and insert functions.\n\nFirst, define a Node class:\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nThen, for the BST class, perhaps create a BST class that has root, and methods search and insert.\n\nWait, but the problem says that the function is given the BST and the target. So maybe the function doesn't need a BST class. Alternatively, perhaps the function will take the root as a parameter.\n\nWait, the problem says: given a BST and a node value target, so the function needs to search in that BST.\n\nSo for example, in Python, perhaps the function will have 'root' as a parameter, but since there's no BST class in Python, perhaps I should handle it with the root node.\n\nAlternatively, perhaps a helper function within a class.\n\nBut the question says, \"provide a method to insert a new node into the BST\". So perhaps the code should have a class-based approach.\n\nAlternatively, perhaps in the solution, it's acceptable to write two functions: contains(root, target) and insert(root, value) where root is the root node of the BST.\n\nSo the solution may have two separate functions.\n\nLet me proceed with writing functions.\n\nFirst, the search function:\n\ndef contains_BST(root, target):\n    # base case: if tree is empty, return False\n    if root is None:\n        return False\n    # compare target with current node's value\n    if target == root.value:\n        return True\n    elif target < root.value:\n        # go left\n        return contains_BST(root.left, target)\n    else:\n        # go right\n        return contains_BST(root.right, target)\n\nWait, yes, this is a recursive approach. It starts at root, compares target and current node's value. If equal, return True. If less, search left subtree. If more, search right. Base case: if current node is None, return False.\n\nNow, for the insert function. Since the tree must maintain the BST property, the function must find the correct position to insert the new node.\n\nSo, the insert function could be recursive as well.\n\ndef insert_BST(root, value):\n    # base case: if tree is empty, create new node\n    if root is None:\n        return Node(value)\n    # compare with root's value\n    if value == root.value:\n        # since duplicates are not allowed, return as is\n        return root\n    elif value < root.value:\n        # insert into left subtree\n        root.left = insert_BST(root.left, value)\n    else:\n        # insert into right subtree\n        root.right = insert_BST(root.right, value)\n    # return the modified root\n    return root\n\nWait, but in the insert function, the root's left or right is being updated. But when the function is called initially, it may return a new root if the original root was None. So the initial call would have to assign the result to the root, but in a class-based approach, the root is a member variable.\n\nAlternatively, the insert function is a helper and the user would manage the root themselves.\n\nHmm, perhaps in the problem, we can assume that the functions are given the root node, and they can modify the tree accordingly.\n\nWait, but in the code, the function may not have side effects on the root. Because in the insert function, for each node, it's reassigning the left or right child, which is valid in a mutable structure like a tree.\n\nWait, but in the code, for instance, when calling insert_BST with the root, during each recursive step, if we go to the left or right, we pass root.left or root.right as the new current node. So the function builds the new tree structure by linking the nodes properly.\n\nTesting for this:\n\nSuppose the BST is empty. Insert a value 5. The function returns a new Node(5). So the root is updated to this.\n\nThen, insert 3. It goes to the root (5), since 3 <5, so it inserts into root.left. So the root's left child becomes a new node 3.\n\nYes, this approach should work.\n\nSo, the insertion function seems correct.\n\nWait, but in the case where the target is already present. For example, suppose the root is 5, and we try to insert 5 again. Since in the function, it's checking if value == root.value, in which case it does nothing except return the root. So no new node is created, which maintains the uniqueness.\n\nSo, that's correct.\n\nSo overall, the functions should be structured as such.\n\nBut then, the problem says to return True or False for the search function. So that's handled.\n\nTesting some cases:\n\nTest case 1: Search for a present node.\n\nroot: 4, left: 2, right: 6, right's right:7. Target:7. Should return True.\n\nTest case 2: Target is not present. E.g., root is 5, left is 3 (left is 2), right is 7, target:4. Should return False.\n\nInserting 4 into root 5: would go to the right of 3, since 4>3 and 3's right was null.\n\nSo the insert function would correctly add it.\n\nWhat about when the tree is unbalanced, like all insertions on right or left? The functions handle it as the traversal is correct.\n\nPotential issues:\n\n- What if the initial root is None? Both functions handle it. The search function returns False, and the insert creates a new node.\n\n- Also, in the insert function, since it's using a recursive approach, for very large trees, a stack overflow could occur, but the problem doesn't specify handling that, so it's acceptable.\n\nAnother approach could be iterative, but recursive is straightforward.\n\nSo, to sum up:\n\nThe search function is implemented recursively, checking each node according to BST properties.\n\nThe insert function is also recursive, finding the correct place to insert the new node, handling duplicates by not inserting if the value is already present.\n\nThus, the code seems to correctly implement the required functionality.\n</think>\n\nTo solve this problem, we need to determine if a target value exists in a binary search tree (BST) and provide a method to insert a new node into the BST while maintaining its properties.\n\n### Approach\n\n1. **Search Function**:\n    - **Objective**: Check if a given target value exists in the BST.\n    - **Intuition**: BSTs have the property that values in the left subtree of a node are smaller, and values in the right subtree are larger. Using this property, we can efficiently search for the target by traversing the tree.\n    - **Algorithm**:\n        - Start at the root of the tree.\n        - Compare the target value with the current node's value.\n        - If they are equal, the target is found, return true.\n        - If the target is smaller, move to the left subtree. If the target is larger, move to the right subtree.\n        - Continue this process until the target is found or all nodes have been checked.\n        - If the target is not found, return false.\n\n2. **Insert Function**:\n    - **Objective**: Insert a new node with a given value into the BST while maintaining its properties.\n    - **Intuition**: Similar to the search function, traverse the tree to find the correct position to insert the new node. The new node should be placed as a left child if its value is smaller than the current node, or as a right child if it's larger.\n    - **Algorithm**:\n        - Start at the root of the tree.\n        - Compare the new value with the current node's value.\n        - If the tree is empty, create a new node as the root.\n        - If the new value is already present, do not insert it to maintain uniqueness.\n        - If the new value is smaller, move to the left child and continue checking.\n        - If the new value is larger, move to the right child and continue checking.\n        - Once the correct position is found, insert the new node.\n\n### Solution Code\n\n```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef contains_BST(root, target):\n    if root is None:\n        return False\n    if target == root.value:\n        return True\n    elif target < root.value:\n        return contains_BST(root.left, target)\n    else:\n        return contains_BST(root.right, target)\n\ndef insert_BST(root, value):\n    if root is None:\n        return Node(value)\n    if value == root.value:\n        return root\n    elif value < root.value:\n        root.left = insert_BST(root.left, value)\n    else:\n        root.right = insert_BST(root.right, value)\n    return root\n```\n\n### Explanation\n\n- **Node Class**: Represents each node in the BST, containing a value, and pointers to left and right children.\n- **Search Function (`contains_BST`)**:\n  - Recursively traverses the BST, checking each node to see if it contains the target value.\n  - Returns `True` if found, otherwise `False`.\n- **Insert Function (`insert_BST`)**:\n  - Recursively finds the correct position to insert the new node while maintaining the BST properties.\n  - Handles duplicate values by not inserting if the value already exists.\n  - Returns the modified root of the BST after insertion.\n\nThis approach efficiently searches and inserts nodes in the BST, ensuring the tree's properties are maintained.",
  "r1_solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef contains_BST(root, target):\n    if root is None:\n        return False\n    if target == root.value:\n        return True\n    elif target < root.value:\n        return contains_BST(root.left, target)\n    else:\n        return contains_BST(root.right, target)\n\ndef insert_BST(root, value):\n    if root is None:\n        return Node(value)\n    if value == root.value:\n        return root\n    elif value < root.value:\n        root.left = insert_BST(root.left, value)\n    else:\n        root.right = insert_BST(root.right, value)\n    return root",
  "metadata": {
    "prompt_id": "00000064",
    "row_id": 64,
    "seed_ids": [
      "1470",
      "1431",
      "114"
    ],
    "mode": "leetcode",
    "original_instruction": ""
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results1.jsonl"
}