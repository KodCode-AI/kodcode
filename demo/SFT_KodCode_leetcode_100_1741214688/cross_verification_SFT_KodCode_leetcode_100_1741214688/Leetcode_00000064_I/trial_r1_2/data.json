{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000064_I",
  "question": "Given a binary search tree (BST) and a node value `target`, return `true` if the `target` is found in the BST, and `false` otherwise. You may assume that each node in the BST has **uniquely** valued children. Additionally, provide a method to insert a new node with a given value into the BST while maintaining its properties.",
  "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_in_bst(root: TreeNode, target: int) -> bool:\n    \"\"\"\n    Searches for the target value in the BST and returns True if found, False otherwise.\n    \"\"\"\n    if root is None:\n        return False\n    if root.val == target:\n        return True\n    elif root.val < target:\n        return find_in_bst(root.right, target)\n    else:\n        return find_in_bst(root.left, target)\n\ndef insert_in_bst(root: TreeNode, val: int) -> TreeNode:\n    \"\"\"\n    Inserts a new node with given value into the BST.\n    \"\"\"\n    if root is None:\n        return TreeNode(val)\n    if val < root.val:\n        root.left = insert_in_bst(root.left, val)\n    else:\n        root.right = insert_in_bst(root.right, val)\n    return root",
  "test_code": "from solution import TreeNode, find_in_bst, insert_in_bst\n\ndef test_find_in_bst():\n    # Create a simple BST\n    root = TreeNode(8, TreeNode(3, TreeNode(1), TreeNode(6, None, TreeNode(7))), TreeNode(10, None, TreeNode(14)))\n    assert find_in_bst(root, 3) == True\n    assert find_in_bst(root, 10) == True\n    assert find_in_bst(root, 5) == False\n\ndef test_insert_in_bst():\n    # Create a simple tree and insert nodes\n    root = TreeNode(8)\n    insert_in_bst(root, 3)\n    insert_in_bst(root, 10)\n    assert find_in_bst(root, 3) == True\n    assert find_in_bst(root, 10) == True\n\ndef test_insertion_multiple_nodes():\n    root = TreeNode(8)\n    insert_in_bst(root, 3)\n    insert_in_bst(root, 10)\n    insert_in_bst(root, 1)\n    assert find_in_bst(root, 3) == True\n    assert find_in_bst(root, 10) == True\n    assert find_in_bst(root, 1) == True\n    assert find_in_bst(root, 14) == False  # Before insertion\n    insert_in_bst(root, 14)\n    assert find_in_bst(root, 14) == True",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, so I need to solve this problem where I have a binary search tree (BST) and I have to check if a target value exists in it. Also, I need to provide a method to insert a new node into the BST while maintaining its properties. Hmm, let's think about how to approach this.\n\nFirst, the BST properties. I remember that in a BST, each node has at most two children, and all the nodes in the left subtree have values less than the parent node, while all the nodes in the right subtree have values greater. So for any node, everything to the left is smaller and everything to the right is larger. Also, the question says each node has uniquely valued children, so there are no equal values in the left or right subtrees. Wait, wait, does that mean the BST has strict unique values throughout? Because it says 'uniquely' valued children, but I think it's possible that the BST is defined so that all values are unique, right?\n\nSo for the first part, checking if the target exists in the BST: I can probably use a recursive approach. Start at the root. If the root's value is equal to the target, return true. Otherwise, if the target is less than the current node's value, check the left subtree. If it's greater, check the right. If the subtree is null in that direction, return false. But wait, maybe I should do this iteratively as well. Which one is better? Well, for simplicity, maybe a recursive approach is straightforward and easier to implement.\n\nAlternatively, in Python, using a while loop with a current node pointer could be efficient. Maybe either approach is fine. I should choose the one I'm more comfortable with.\n\nNow, for the insert method. Inserting into a BST requires finding the correct position to put the new node. So again, we can start at the root and traverse down. For each current node, compare the value with the new value. If it's less, go right. If it's more, go left. But wait, no, if the new value is less than current, we go left. Wait, the standard behavior is: if the new value is less than current, it goes to the left. Otherwise, to the right.\n\nBut for insertion, we continue this until we reach a null pointer, and then assign the new node to the appropriate side of the last non-null node. Because in BST, when inserting, we traverse down to where the node can be placed as a child.\n\nWait, but I should make sure that the insertion maintains the BST properties. So no duplicates, so during insertion, we don't have to handle duplicate values. Because the problem statement says each node in the BST has uniquely valued children, but maybe in the function, the insertion is possible. Oh wait, actually the initial tree is a BST with uniquely valued nodes. So when inserting, the function is supposed to correctly place the new node without creating duplicates.\n\nBut wait, perhaps if the target already exists, do we allow insertion? Or should we prevent that? The question says nothing about handling duplicates, just that each node has uniquely valued children. So perhaps the insert function should not insert the node if it's already present. Or perhaps it should, but the BST may have duplicates for some reason. Wait, the problem says the nodes have uniquely valued children. Hmm, the way the problem is phrased is that given a BST with uniquely valued children, to provide an insertion method that maintains the BST properties.\n\nWell, perhaps the standard insertion without checking for duplicates is acceptable, because the BST as given has all nodes with unique values, so when inserting a new node, it's assumed that it's not already present.\n\nSo, the plan is:\n\n1. For the contains function:\n\n   - If the tree is empty (root is None), return False.\n   - Else, if the current node's value is equal to target, return True.\n   - If the target is less than current's value, recursively check the left child.\n   - If target is greater, check the right.\n\n2. For the insert function:\n\n   - If the tree is empty, create a new node as root.\n   - Else, traverse the tree to find where to insert the new value.\n   - For each node, based on comparison with the new value, decide whether to go left or right.\n   - When a null pointer is reached, attach the new node as the child in the appropriate direction.\n\nWait, but for insertion, I'll have to pass the root to the function and then return the new root. Or modify it in-place. But in Python, since everything is passed by assignment, if the root is None, the function will create the new node as root. Otherwise, for other insertions, how do I modify the tree? Because the root pointer won't be changed unless I return it.\n\nSo, perhaps the insert function should return the root node after insertion, allowing for the root to change in case the tree was empty.\n\nAlternatively, the insert method can be a part of a class. But I think for this problem, since the user is to provide functions, perhaps it's done in a functional way, passing the root.\n\nWait, but looking at the original problem, perhaps the user is supposed to write a function that takes the root and target and returns a boolean, and another function that takes possibly the root and value, and returns the new root.\n\nLet me think: for the contains function, something like this:\n\ndef contains(root, target):\n    if root is None:\n        return False\n    if root.value == target:\n        return True\n    elif target < root.value:\n        return contains(root.left, target)\n    else:\n        return contains(root.right, target)\n\nBut wait, I'm assuming each node has a value, left, and right attributes.\n\nSimilarly, for the insert function:\n\ndef insert(root, value):\n    if root is None:\n        return Node(value)\n    if value < root.value:\n        root.left = insert(root.left, value)\n    else:\n        root.right = insert(root.right, value)\n    return root\n\nBut that's for a recursive approach. Or perhaps it's better to write it iteratively.\n\nAlternatively, for insert, using iterative approach:\n\ndef insert(root, value):\n    if root is None:\n        return Node(value)\n    current = root\n    while True:\n        if value < current.value:\n            if current.left is None:\n                current.left = Node(value)\n                break\n            current = current.left\n        else:\n            if current.right is None:\n                current.right = Node(value)\n                break\n            current = current.right\n    return root\n\nEither method is acceptable. I think the recursive method is more concise, but sometimes for larger trees, stack overflow could be an issue, but in Python and for most cases, that's not a problem.\n\nNow, the problem is about the binary search tree. So each node is compared based on being greater or less than the current node.\n\nWait, but wait a minute: in some BST definitions, the insertion doesn't check for duplicates. So when inserting a value that's already present, it can overwrite or ignore. But in our case, the tree is built with uniquely valued children, so we can assume that the insertion is for a new unique value.\n\nSo what should the insert function do if the value is already present? Well, the problem says \"insert a new node with a given value into the BST while maintaining its properties.\" Since the given BST has uniquely valued children, inserting a duplicate would violate that. So the insert function should avoid inserting duplicates. So perhaps before inserting, the function should check if the value already exists.\n\nWait, but the contains function can help with that. So in the insert function, first check if the value already exists in the tree. If it does, do nothing. Otherwise, proceed with insertion.\n\nBut that's an extra step which requires a contains check, which could be O(h) time, where h is the height. Alternatively, during the insertion traversal, we can check whether the path is correct, without visiting the same node twice.\n\nWait, but during the insertion, we can check whether we reach a point where the value is found, and if so, return without inserting.\n\nAlternatively, perhaps the insert function can be written as:\n\ndef insert(root, value):\n    if root is None:\n        return Node(value)\n    if value == root.value:\n        return root  # or do nothing, since the tree already has the value\n    elif value < root.value:\n        root.left = insert(root.left, value)\n    else:\n        root.right = insert(root.right, value)\n    return root\n\nWait, no. If the current node's value is equal to the value to insert, then since the tree has unique values, we can't insert it, so return immediately.\n\nWait, no, the original BST has uniquely valued nodes, and in the insert function, we should not insert a duplicate.\n\nSo in the insert function, during traversal, when comparing, if the value equals, we just return the current root as is.\n\nSo in the function, first check if root is None: create new node. Else, if value is less than current root's value, go left. If greater, go right. If equal, return root.\n\nWait, but the equals case should be considered. So the initial code would prevent inserting a node with a value that's already present.\n\nSo the function would be:\n\ndef insert(root, value):\n    if root is None:\n        return Node(value)\n    if value < root.value:\n        root.left = insert(root.left, value)\n    elif value > root.value:\n        root.right = insert(root.right, value)\n    # else do nothing\n    return root\n\nSo in this code, if the value is equal to root.value, which can happen once since each node's value is unique, we do nothing.\n\nWait, suppose the root is 5, and the value to insert is 5. Then in the insert function, the root is not None, and since 5 is not less than 5, nor greater than 5, so it's equal, and then we return root. So no new node is created and attached, which is correct because duplicates are not allowed.\n\nSo that function should work.\n\nSo putting it together, the two functions are:\n\n1. contains function, which recursively checks the tree.\n\n2. insert function, which recursively inserts a new node if needed, else does nothing.\n\nNow, considering the case where the tree is empty. The contains function correctly returns False. The insert function correctly creates a new node as the root.\n\nWait, let me test the insert function in a small example.\n\nCase 1: Empty tree. Insert 5. The root becomes a node with value 5.\n\nCase 2: Insert 3. Since 5 is the root, 3 is less, so left of 5 is set to 3.\n\nCase 3: Insert 7. 5's right is None, so it is assigned 7.\n\nCase 4: Insert 3 again. When the function is called, it finds that the new value 3 is equal to 5? No, because it's in the left subtree. Wait, no. Let's trace it.\n\nInsert root is 5 (nodes 5, 3, 7). Now insert 3.\n\nFunction starts, root is not None, 3 < 5, so insert into left child 3.\n\nWait, wait, then the function is called with root = 5, value=3.\n\nCheck 3 <5: yes, so function calls insert on root.left, which is 3.\n\nSo in the next step, the current node is 3. So value=3 is the parameter.\n\nSo current root is 3. Value is 3, so compares to root.value (3). Then, 3 is not less than 3, nor greater, so it does nothing and returns root as 3. So the root.left remains 3. So no new node is added. So insert(3) after the initial insertion won't change the tree.\n\nSo the insert function will not deduplicate, since the tree is already in a BST with unique values.\n\nWait, but in this case, the function returns root as 3, but the original root was 3 already as a child. So correct.\n\nBut what about a case where a node's child is None, but we're trying to insert a value that's correct, but the child is missing.\n\nAnother example: Tree is:\n\n     5\n   /   \\\n  3     7\n\nInsert 6. So in the 5's right is 7. So when inserting 6, function goes to 5's right (7) and then since 6 <7, goes to left child of 7, which is None. So create a new node as 6 and assign it as left child of 7.\n\nThat should be correct.\n\nAnother example: Insert 2 at root 5.\n\n5's left is 3, so 2 is less than 5, go left (3). 2 is less than 3, go left of 3 (which is None). So set 3.left to 2.\n\nYes.\n\nSo the functions should handle these cases correctly.\n\nWait, but the code for the insert function is writing in a way that, for each recursive step, the node is processed. So, the function will correctly place the new node at the appropriate position.\n\nNow, thinking about possible errors: What if the initial tree is not a BST? But the question says we are given a BST, so we can assume the initial tree is correct.\n\nSo the functions should be correct.\n\nNow, implementing this in Python:\n\nWe'll need a Node class. Or perhaps assuming that each node is an object with value, left, right.\n\nWait, but in Python, for code submission, sometimes people create a Node class. So, perhaps:\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nSo, for the functions:\n\ndef contains(root, target):\n    if root is None:\n        return False\n    if root.value == target:\n        return True\n    elif target < root.value:\n        return contains(root.left, target)\n    else:\n        return contains(root.right, target)\n\ndef insert(root, value):\n    if root is None:\n        return Node(value)\n    if value < root.value:\n        root.left = insert(root.left, value)\n    elif value > root.value:\n        root.right = insert(root.right, value)\n    return root\n\nWait, but in the insert function, the code doesn't handle if the value equals the current root's value elsewhere in the tree. For example, after the root, if the value exists elsewhere, it could still be present. But no, in a BST, each value is unique, so once you have the not equal, and not less than, you can proceed.\n\nWait, but no: for example, a tree where left is 3, and in some subtree, a node is 3. But the problem says the BST has uniquely valued children. So that's impossible.\n\nSo in the tree, all values are unique. So, the insert function, when it finds a node with value equal to the inserted value, will not insert. This could mean that if the value already exists, the function won't insert. So this is consistent.\n\nSo now, putting this into Python code.\n\nTest cases:\n\nTest 1:\n\nBST: None (empty), target=5:\n\ncontains(None, 5) \u2192 False\nInsert(5):\nroot becomes Node(5).\n\nTest 2:\n\nBST: 5\n   /   \\\n 3      7\n\nLooking for target 3 \u2192 True\nLooking for target 6 \u2192 False\nInsert 2: BST becomes 5\u2019s left is 3, whose left is 2.\n\nSo that's correct.\n\nTest 3:\n\nInsert same value as existing node:\n\nAfter inserting 5, insert 5. The insert function will not insert, so tree remains the same.\n\nSo functions work.\n\nSo I think the code is correct.\n</think>\n\nTo solve this problem, we need to determine if a given target value exists in a binary search tree (BST) and provide a method to insert a new node into the BST while maintaining its properties. \n\n### Approach\n1. **Check if Target Exists in BST**:\n   - This involves traversing the BST to see if the target value is present. We can use a recursive approach where we start at the root. If the root's value is the target, return true. If the target is less than the current node's value, recursively check the left subtree; otherwise, check the right subtree. If the subtree is null, return false.\n\n2. **Insert a New Node into BST**:\n   - Insertion into a BST involves finding the correct position to place the new node while maintaining BST properties. We start at the root and compare the new value with the current node's value. If the new value is less, move to the left subtree; if greater, move to the right. When a null pointer is reached, attach the new node as a child. This can be efficiently done using recursion.\n\n### Solution Code\n\n```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef contains(root, target):\n    if root is None:\n        return False\n    if root.value == target:\n        return True\n    elif target < root.value:\n        return contains(root.left, target)\n    else:\n        return contains(root.right, target)\n\ndef insert(root, value):\n    if root is None:\n        return Node(value)\n    if value < root.value:\n        root.left = insert(root.left, value)\n    elif value > root.value:\n        root.right = insert(root.right, value)\n    return root\n```\n\n### Explanation\n- **Node Class**: Represents a node in the BST with a value, left child, and right child.\n- **Contains Function**: Recursively checks if the target value exists in the BST. It starts at the root and navigates left or right based on comparisons, returning true if the target is found.\n- **Insert Function**: Recursively inserts a new node in the appropriate position. If the tree is empty, the new node becomes the root. Otherwise, it navigates left or right until it finds the correct spot, ensuring the BST properties are maintained.\n\nThis approach ensures both operations are efficient, with each function having a time complexity of O(h), where h is the height of the BST, making the solution optimal for typical BST structures.",
  "r1_solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef contains(root, target):\n    if root is None:\n        return False\n    if root.value == target:\n        return True\n    elif target < root.value:\n        return contains(root.left, target)\n    else:\n        return contains(root.right, target)\n\ndef insert(root, value):\n    if root is None:\n        return Node(value)\n    if value < root.value:\n        root.left = insert(root.left, value)\n    elif value > root.value:\n        root.right = insert(root.right, value)\n    return root",
  "metadata": {
    "prompt_id": "00000064",
    "row_id": 64,
    "seed_ids": [
      "1470",
      "1431",
      "114"
    ],
    "mode": "leetcode",
    "original_instruction": ""
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results2.jsonl"
}