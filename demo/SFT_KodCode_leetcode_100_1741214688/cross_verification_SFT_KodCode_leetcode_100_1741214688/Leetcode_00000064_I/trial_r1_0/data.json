{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000064_I",
  "question": "Given a binary search tree (BST) and a node value `target`, return `true` if the `target` is found in the BST, and `false` otherwise. You may assume that each node in the BST has **uniquely** valued children. Additionally, provide a method to insert a new node with a given value into the BST while maintaining its properties.",
  "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_in_bst(root: TreeNode, target: int) -> bool:\n    \"\"\"\n    Searches for the target value in the BST and returns True if found, False otherwise.\n    \"\"\"\n    if root is None:\n        return False\n    if root.val == target:\n        return True\n    elif root.val < target:\n        return find_in_bst(root.right, target)\n    else:\n        return find_in_bst(root.left, target)\n\ndef insert_in_bst(root: TreeNode, val: int) -> TreeNode:\n    \"\"\"\n    Inserts a new node with given value into the BST.\n    \"\"\"\n    if root is None:\n        return TreeNode(val)\n    if val < root.val:\n        root.left = insert_in_bst(root.left, val)\n    else:\n        root.right = insert_in_bst(root.right, val)\n    return root",
  "test_code": "from solution import TreeNode, find_in_bst, insert_in_bst\n\ndef test_find_in_bst():\n    # Create a simple BST\n    root = TreeNode(8, TreeNode(3, TreeNode(1), TreeNode(6, None, TreeNode(7))), TreeNode(10, None, TreeNode(14)))\n    assert find_in_bst(root, 3) == True\n    assert find_in_bst(root, 10) == True\n    assert find_in_bst(root, 5) == False\n\ndef test_insert_in_bst():\n    # Create a simple tree and insert nodes\n    root = TreeNode(8)\n    insert_in_bst(root, 3)\n    insert_in_bst(root, 10)\n    assert find_in_bst(root, 3) == True\n    assert find_in_bst(root, 10) == True\n\ndef test_insertion_multiple_nodes():\n    root = TreeNode(8)\n    insert_in_bst(root, 3)\n    insert_in_bst(root, 10)\n    insert_in_bst(root, 1)\n    assert find_in_bst(root, 3) == True\n    assert find_in_bst(root, 10) == True\n    assert find_in_bst(root, 1) == True\n    assert find_in_bst(root, 14) == False  # Before insertion\n    insert_in_bst(root, 14)\n    assert find_in_bst(root, 14) == True",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to solve this problem where I have to search a binary search tree for a target value and also provide a method to insert a new node. Let me think about how to approach this.\n\nFirst, I remember that a binary search tree is a tree where each node has up to two children. For any node, all the nodes in its left subtree have values less than the node's value, and all the nodes in the right subtree have values greater. And each node's value is unique.\n\nSo for the search function, the plan is to start at the root and compare the target with the current node's value. If the target is less than the current node's value, I should go left. If it's greater, I go right. I keep doing this recursively until I either find the target or reach a point where there are no more nodes to check.\n\nWait, but what if the tree is empty? Oh right, then the target isn't there, so return false.\n\nNow, for the insertion part. Adding a new node while maintaining the BST properties. I should start at the root and compare the new value with the current node. If it's less than the current node, we go left unless there's no left child, then we add it there. Similarly, if it's greater, we go right. But I need to make sure not to overwrite the child of a node if it already exists. So this is a straightforward iterative process.\n\nWait, but how do I handle inserting when the tree is empty? That's a base case\u2014if the root is null, the new node becomes the root.\n\nLet me outline the steps for each function.\n\nFor the search function:\n1. If the tree is empty, return false.\n2. Start with the root node.\n3. Compare the target with the current node's value.\n   a. If equal, return true.\n   b. If target is less, proceed to the left child.\n   c. If target is more, proceed to the right child.\n4. Recurse on the appropriate subtree.\n5. If recursion returns false, meaning the target isn't found, then return false.\n\nFor the insert function:\n1. If the tree is empty, create a new node as the root.\n2. Else, start with the root node.\n3. Compare the new value with the current node's value.\n4. If new value is less than current, check left child.\n   a. If left exists, move to left child.\n   b. Else, add new node as left child.\n5. If new value is greater, check right child.\n   a. If right exists, move to right child.\n   b. Else, add new node as right child.\n\nWait, actually, the insert function is often implemented recursively too. Maybe I should write it recursively for simplicity, but sometimes iterative is easier to avoid stack overflows, but in this problem, perhaps recursion is fine.\n\nAlternatively, think about both approaches. Let's see.\n\nAnother point: How to represent the nodes? I'm assuming a Node class with properties like value, left, right. Or maybe just have a data structure with these attributes.\n\nAlright, now time to think about code structure.\n\nIn Python, I can define a Node class:\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nThen, the BST can be represented by its root node.\n\nSo, for the search function, the function could be something like:\n\ndef search_bst(root, target):\n    if root is None:\n        return False\n    if root.value == target:\n        return True\n    elif target < root.value:\n        return search_bst(root.left, target)\n    else:\n        return search_bst(root.right, target)\n\nWait, but wait\u2014because if the target is less than root.value, we go left, but if the target is equal, we've already checked that earlier.\n\nYes, that should handle the cases.\n\nFor the insert function, perhaps a recursive approach is also manageable:\n\ndef insert_bst(root, value):\n    if root is None:\n        return Node(value)\n    if value < root.value:\n        root.left = insert_bst(root.left, value)\n    else:\n        root.right = insert_bst(root.right, value)\n    return root\n\nWait, but this assumes that for equal values, we add to the right or left. Oh, right, wait in the problem statement, it's given that each node has uniquely valued children. So, but when inserting a new node, what happens if the value is the same as an existing node's value? Wait, the BST is defined to have unique values, so the insert function may assume that the value is not already present, or it's up to us. But the problem says each node has uniquely valued children, but the insert function can handle duplicates or not.\n\nWait, wait, in the problem statement: 'each node in the BST has uniquely valued children'\u2014but that may mean that no two children have the same value. Or perhaps that all the values in the BST are unique. So, for insertion, perhaps the new value is unique and doesn't exist in the tree.\n\nBut in the function, we may need to handle duplicate insertions, but I don't think so. So, our insert can assume that the value is not present, or perhaps will be inserted in right subtree if already present. But since the BST is defined to have unique values, perhaps the insert function will not insert duplicate values.\n\nWait, but the problem says each node has uniquely valued children, but perhaps it's referring to unique in the sense that across all nodes, not just siblings. Because in a BST, values are unique across the entire tree.\n\nSo, for insert, we can assume that the value is new. Otherwise, we can return the root as is.\n\nSo in the code above, for insert_bst(), when the value is equal to the node's value, it goes to the right. But in reality, since each node's value is unique, maybe this situation never occurs.\n\nWait, but perhaps the problem says to assume that the insert function is given a value not already present, or perhaps it's up to the function to decide whether to insert it or replace.\n\nHmm. But that's probably beyond the scope of the problem. Let's proceed with the code.\n\nWait, in the BST insert function, duplicates are usually inserted in the right subtree, but in our problem, is it allowed? Since the problem statement says that each node has uniquely valued children\u2014I think each node's children are unique, not necessarily that the entire tree is unique. Oh no, wait the problem says each node in the BST has uniquely valued children, which I think it means that the children have unique values, not that the whole tree is unique.\n\nWait, perhaps not. The problem statement says: \"each node in the BST has uniquely valued children.\" Hmm, maybe it means that for each node, its left and right children have unique values compared to each other and the node's value.\n\nWait, that's a standard BST property: for each node, all left descendants are less than the node's value, and all right descendants are greater. So each node's value is unique in the entire tree.\n\nWait, because in a BST, each node's value is unique. That is, no two nodes have the same value. Because in a BST, when you insert a value that's equal to a node, you have to decide to go left or right, but if the tree's uniqueness is enforced, then insert will not create duplicates.\n\nSo, perhaps, in the insert function, the given value is not already present, so the function can safely handle it without checking for duplicates.\n\nSo for the function, the code I have written assumes that. So inserting recursively as such is correct.\n\nSo, the function looks okay.\n\nPutting it all together:\n\nWe need to provide two methods: one for searching and one for inserting.\n\nWait, but according to the problem statement, the user may have provided the BST as root, and then functions are to be called.\n\nNow, in the code, the functions are as I wrote.\n\nBut wait, when I return from insert_bst, the root remains, or if the tree was empty, it's assigned.\n\nSo, in code, the insert function returns the new root, but in most BST implementations, inserting will change the root only if the tree was empty.\n\nThus, in the code, when the root is not None, the recursive function proceeds down the tree and when the situation to add as left or right child is found, it creates the node and returns it upwards, until it's attached.\n\nThat seems correct.\n\nSo, the code for the two functions is as follows.\n\nBut wait, let me test it.\n\nLet's see for the search function:\n\nTest case 1: A simple tree:\n\nroot is 5.\n\nleft child is 3, right is 7.\n\nSearch for 3: Should find true.\n\nAnother test case: search for 8, not present: returns false.\n\nSearch function seems correct.\n\nInsert function: Let's create a tree.\n\nInsert 5 into empty tree. Root is 5.\n\nInsert 3. It becomes left of 5.\n\nInsert 7. Right of 5.\n\nInsert 2. Left of 3.\n\nInsert 4. Right of 3.\n\nInsert 6. Left of 7.\n\nInsert 8. Right of 7.\n\nNow, the tree should look like:\n\n        5\n      /   \\\n     3     7\n    / \\   / \\\n   2  4  6  8\n\nYes.\n\nNow, function calls in code may need to be correct.\n\nBut wait, the problem requires to return a method to insert a new node. So perhaps the functions are part of a class, but in the given problem statement, maybe only these functions are required.\n\nBut in Python, perhaps we can proceed as follows.\n\nWait, but the question says, in the problem prompt, to provide methods. So perhaps in the language-agnostic way, the functions can be presented, perhaps with the code I've written.\n\nBut perhaps in the answer, the code is to be presented.\n\nWait, but the problem doesn't specify a programming language. Hmm, the initial question was in tags as Python.\n\nYes, because the original code samples in the questions are in Python format.\n\nSo, probably, the answer should be presented in Python.\n\nSo, putting all together, the code is:\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef search_bst(root, target):\n    if not root:\n        return False\n    if root.value == target:\n        return True\n    elif target < root.value:\n        return search_bst(root.left, target)\n    else:\n        return search_bst(root.right, target)\n\ndef insert_bst(root, value):\n    if not root:\n        return Node(value)\n    if value < root.value:\n        root.left = insert_bst(root.left, value)\n    else:\n        root.right = insert_bst(root.right, value)\n    return root\n\nHmm, that seems correct.\n\nBut wait, in the insert function, what happens when the value is already present in the tree? For example, trying to insert 5 again.\n\nIn the current code, when we reach a node where root.value == value, it will go into the else clause and try to insert into root.right. But that might overwrite existing nodes.\n\nBut the problem statement says that each node has uniquely valued children, but doesn't specify what to do when inserting a duplicate. So perhaps we can assume that the insert function is called with a value not present in the tree, so the current code is correct.\n\nSo, assuming uniqueness, the functions are correct.\n\nAnother test case:\n\nInsert 5, 3, 7, 2, 4, 6, 8.\n\nSearch for 2: yes.\n\nSearch for 9: no.\n\nYes.\n\nI think that's correct.\n</think>\n\nTo solve this problem, we need to determine if a given target value exists in a binary search tree (BST) and provide a method to insert a new node into the BST while maintaining its properties.\n\n### Approach\n1. **Search Function**: The search function will recursively traverse the BST starting from the root node. At each node, it compares the target value with the node's value. If the target is less than the node's value, it continues the search in the left subtree. If the target is greater, it continues in the right subtree. If the target is found, it returns `true`; if it reaches a leaf node without finding the target, it returns `false`.\n\n2. **Insert Function**: The insert function will also traverse the BST to find the appropriate position for the new node. If the tree is empty, it creates a new node as the root. Otherwise, it compares the value to be inserted with the current node's value. If the value is less than the current node's value, it proceeds to the left subtree. If the value is greater, it proceeds to the right subtree. This continues until an appropriate position is found, where the new node is inserted.\n\n### Solution Code\n```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef search_bst(root, target):\n    if not root:\n        return False\n    if root.value == target:\n        return True\n    elif target < root.value:\n        return search_bst(root.left, target)\n    else:\n        return search_bst(root.right, target)\n\ndef insert_bst(root, value):\n    if not root:\n        return Node(value)\n    if value < root.value:\n        root.left = insert_bst(root.left, value)\n    else:\n        root.right = insert_bst(root.right, value)\n    return root\n```\n\n### Explanation\n- **Node Class**: Defines a simple node structure for the BST, each containing a value and pointers to left and right children.\n- **Search Function**: \n  - Checks if the current node is `None`, indicating the target is not in the tree.\n  - If the target is found at the current node, returns `true`.\n  - Recursively searches the left subtree if the target is less than the current node's value.\n  - Recursively searches the right subtree if the target is greater than the current node's value.\n- **Insert Function**:\n  - If the tree is empty, creates a new node as the root.\n  - Recursively finds the correct position to insert the new node, maintaining BST properties.\n  - Adjusts the root of the tree if necessary and returns the root after insertion.\n\nThis approach ensures that both operations (search and insert) are efficient, leveraging the properties of BSTs for optimal performance.",
  "r1_solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef search_bst(root, target):\n    if not root:\n        return False\n    if root.value == target:\n        return True\n    elif target < root.value:\n        return search_bst(root.left, target)\n    else:\n        return search_bst(root.right, target)\n\ndef insert_bst(root, value):\n    if not root:\n        return Node(value)\n    if value < root.value:\n        root.left = insert_bst(root.left, value)\n    else:\n        root.right = insert_bst(root.right, value)\n    return root",
  "metadata": {
    "prompt_id": "00000064",
    "row_id": 64,
    "seed_ids": [
      "1470",
      "1431",
      "114"
    ],
    "mode": "leetcode",
    "original_instruction": ""
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results0.jsonl"
}