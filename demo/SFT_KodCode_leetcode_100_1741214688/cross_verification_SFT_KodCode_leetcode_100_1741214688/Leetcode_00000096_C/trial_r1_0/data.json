{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000096_C",
  "question": "def find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n    \"\"\" Given a list of n unique integers, determine if there exists a pair of integers\n    in the list whose sum is equal to a given target integer k. If such a pair exists,\n    return the indices of the two integers (0-indexed) in any order. If no such pair exists,\n    return an empty list. Note that the same integer cannot be used twice.\n\n    >>> find_pair_with_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> find_pair_with_index([3, 2, 4], 6)\n    [1, 2]\n    >>> find_pair_with_index([3, 3], 6)\n    [0, 1]\n    >>> find_pair_with_index([1, 2, 3, 4, 5], 10)\n    []\n    >>> find_pair_with_sum([], 10)\n    []\n    \"\"\"",
  "solution": "def find_pair_with_sum(nums, k):\n    \"\"\"\n    Returns a list containing the indices of the two integers whose sum equals k.\n    If no such pair exists, returns an empty list.\n    \"\"\"\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []",
  "test_code": "def test_find_pair_with_sum():\n    assert find_pair_with_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert find_pair_with_index([3, 2, 4], 6) == [1, 2]\n    assert find_pair_with_index([3, 3], 6) == [0, 1]\n    assert find_pair_with_index([1, 2, 3, 4, 5], 10) == []\n    assert find_pair_with_sum([], 10) == []\n\ndef find_pair_with_index(nums, k):\n    return find_pair_with_sum(nums, k)",
  "test_info": [
    {
      "function_name": "find_pair_with_sum",
      "parameter_list": "(nums, k)",
      "function_declaration": "def find_pair_with_sum(nums, k):",
      "docstring": "Returns a list containing the indices of the two integers whose sum equals k.\nIf no such pair exists, returns an empty list."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to solve this problem where I have to find two numbers in a list that add up to a given sum k. And then return their indices. Hmm.\n\nLet me think about how to approach this. Oh right, the same integer can't be used twice, so I can't have the same element twice unless it appears twice in the list. Wait, but the note says the integers are unique? Wait, looking back at the problem statement: \"a list of n unique integers.\" Oh right! So each number appears exactly once. Well, in one example, there is [3,3], but looking back, oh, wait, in one of the test cases, the input is [3,3], so maybe the list can have duplicates. Or maybe the function is supposed to handle duplicates? Hmm, perhaps the problem allows multiple same numbers.\n\nWait, wait, the initial problem statement says \"given a list of n unique integers.\" So perhaps each integer is unique in the list. So no duplicates. So I don't have to handle cases where the same element is used. So each element is unique, but the list can have two elements that are same, but perhaps that's ok.\n\nWait, maybe the problem allows duplicates. Let's see the examples. For instance, the third test case: find_pair_with_index([3,3],6) returns [0,1]. So in that case, the elements are same but different indices. So, in our code, we have to consider that two different indices with possibly same values can add up to k.\n\nWait, but the first line says \"list of n unique integers.\" So perhaps that is a typo in the test case? Or maybe the note that same integer can't be used twice is referring to same index, not same value. So perhaps the problem allows same values but different indices. So in the code, even if the elements are same but at different indices, we need to consider them as a pair.\n\nSo regardless of whether the values are unique, the indices are unique, so each element is considered once.\n\nSo for the function, the plan is: look for two different indices i and j where nums[i] + nums[j] = k.\n\nWhat is the approach to find such a pair efficiently?\n\nWell, the brute force way would be to check all possible pairs, and return the first pair that adds to k.\n\nBut for a more efficient method, perhaps we can use a hash map (dictionary) that keeps track of the values we've seen so far and their indices.\n\nYes, that's a common approach for two-sum problems. So, for each number in the list, we can calculate what value complements it to reach k, and check if that complement is already in the map.\n\nWait, but since we have to return the indices, the order in which we process might matter. Let's see.\n\nFor example, in the first test case, [2,7,11,15], looking for 9. So the numbers are 2 and7.\n\nAt index 0, we have 2, so we check if (9-2=7) is in the map. So 7 is present at index 1. So when processing each element left to right, the moment we find a complement in the map, we can pair it with the current index.\n\nBut wait, that approach may not return the earliest possible pair. Because if later elements have a complement already in the map, but we haven't processed the current index yet.\n\nWait, no, in that approach, the order is such that for each element, you check if the complement existed before it. So it captures the first occurrence where the current element plus a previous element equals the target.\n\nHmm, but that might not capture all possible pairs, especially if duplicates are allowed. Wait, but the problem says to return any pair in any order.\n\nWait, but in the test case [3,3], the target is 6, so we have to return the two indices 0 and 1. So in this case, the code would process the first 3, check if 3 is in the map (map is empty), then add 3:0. Then process the next 3: check if 3 is in the map, which it is, so return [0, 1].\n\nSo yes, the approach works.\n\nBut wait: what about when the list is processed, for each element, you look for complement before adding to the map. Because if you add current element to the map before checking, you might pick the same index. For example, in a list of [x, x], with target 2x, as in the third test case, the second x would have complement x, which has already been added to the map.\n\nWait, no: when processing the first element, x is added to the map with index 0. Then processing the second x, 2x - x =x, which is in the map, so we get [0,1].\n\nBut say another test case like [5, 5, 5], target is 10. Processed as:\n\n1. index 0: 5. complement is 5, not in map. Add 5:0 to map.\n2. index1:5. complement is 5, which is in map. So return [0,1].\n3. Done.\n\nSo yes, that works.\n\nWait, but suppose the list is [3,2,4], target 6.\n\nSo indices 1 and 2 sum to 6 (2 +4 =6). So the code would process each element:\n\nProcess 3: look for 3, since 3 not in map, add 3:0.\n\nProcess 2: target is 6-2=4. The map contains 3:0. No 4 in map. So add 2:1.\n\nProcess4: target is 6-4=2. 2 is in the map at index1. So return [1,2].\n\nWhich is correct as per the second test case.\n\nSo the approach seems to work.\n\nNow, implementing this:\n\nWe'll initialize an empty dictionary called seen, which maps numbers to their indices.\n\nIterate through each index i, num in the list:\n\nFor each, compute complement = k - num.\n\nIf complement is in seen, then return [seen[complement], i].\n\nElse, add num:i to seen.\n\nIf no such pair is found after iterating all elements, return empty list.\n\nYes, but wait: Why aren't we adding the current number to the map before checking? Wait: wait, the map is for numbers that have been processed before the current number. So for each num, we check if complement exists in 'seen', which contains all numbers before i.\n\nSo for the first test case [2,7,11,15], target 9.\n\nProcessing 2: com=7, not in seen (seen is empty), add 2:0.\n\nProcessing7: com=2 (9-7=2). 2 is in seen. So return [0,1].\n\nWhich is correct.\n\nAnother case: [3,2,4], target6.\n\nProcessing 3: seen is empty, add 3:0.\n\nProcessing2: com=4, which is not in seen (contains 3:0). Add 2:1.\n\nProcessing4: com=2 (6-4=2). 2 is in seen, value is1. So return [1,2].\n\nSo yes.\n\nWhat about when the list is empty? Return empty.\n\nWhat about when only one element? Then no pair, return empty.\n\nAnother test case is [5,5], target10. According to code, processing first 5: adds to seen. Second 5: com=5, which is in seen, returns [0,1].\n\nNow, what about when there are multiple possible pairs? Like [1, 3, 5, 7], k=8. So pairs are (1,7), (3,5). Which one is chosen depends on the order of checking. For example:\n\ni=0, num=1: com=7 not in seen. Add 1:0.\n\ni=1, num=3: com=5 not in seen. Add3:1.\n\ni=2, num=5: com=3, which is in seen. So returns [1,2].\n\nSo the first found pair is returned.\n\nYes, which is any order per the problem statement.\n\nSo the code approach looks solid.\n\nNow, coding this:\n\nFunction signature is find_pair_with_sum(nums: List[int], k: int) -> List[int].\n\nSo in Python:\n\nWe can create a seen dictionary, empty.\n\nLoop over the indices, and for each index i and num:\n\ncomplement = k - num.\n\nIf complement is in seen, then return [seen[complement], i].\n\nElse, add the num to the seen dict with its index.\n\nProceed.\n\nBut wait, is the first occurrence of the complement the one we want? Like, in the first possible pair?\n\nBut considering that we process the list from left to right, and for each num, we check if complement exists in the previous elements, which is correct, because once the current num is at i, the complement must be in the earlier part of the list to form a pair.\n\nYes.\n\nWait, but in the example [2, 7, ...], 7 is after 2, so when processed, the code expects 2 is in the seen.\n\nYes.\n\nBut what if the order in the list is such that the complement comes after a future element? Well, for the function's purpose, it just needs to find any pair, and it's ok to return the first found pair as per this approach.\n\nSo, in code:\n\ndef find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\nWait, but let's test some edge cases.\n\nTest case where same value appears multiple times, but in list len>2. For example: [3, 5, 3], k=6.\n\nProcess 3 (i=0), com=3. seen is empty, so add 3:0.\n\ni=1: 5, com=1. Not in seen. Add 5:1.\n\ni=2: 3. com=6-3=3. 3 is in seen. So return [0,2], which is a correct pair.\n\nYes.\n\nAnother test case: [1, -5, 3, 4], k=-2.\n\ncom = -2 -1=-3. Not in seen.\n\nAdd 1:0.\n\ni=1: num=-5. com=-2 - (-5) =3. 3 is not in seen. Add -5:1.\n\ni=2: num=3. com=-2-3=-5. which is in seen (value is1). So return [1,2].\n\nIndeed, 1 and2 indices have nums -5 and 3. -5+3=-2. So correct.\n\nEdge cases.\n\nWhat if the list is empty? The code returns empty list, correct.\n\nWhat if the list has one element? Also returns empty.\n\nWhat if the two elements are in reverse order? Like [7,2], target 9: code would, when processing 2, find 7 in the seen as 0, so returns [0,1], correct.\n\nWait, no: for nums = [7,2], processing 7: add to seen (7:0). Processing 2: 9-2=7, which is in seen. So return [0,1].\n\nYes.\n\nSo the code correctly handles all test cases.\n\nBut wait, let's test the sample inputs.\n\nSample 1:\n\nfind_pair_with_sum([2,7,11,15],9) should return [0,1].\n\nYes, which happens because 7 is processed after 2. So the code returns [0,1] as per the test.\n\nSample 2:\n\nfind_pair_with_index is called as find_pair_with_index([3,2,4],6) returns [1,2]. Process 3: no, 2: is 4 in seen? seen is {3:0}. No, add 2:1. 4: 6-4=2, which is in seen, return [1,2]. Correct.\n\nSample3:\n\nfind_pair_with_index([3,3],6) returns [0,1]. Correct.\n\nSample4:\n\n[1,2,3,4,5],10: no pair? 1+9=10 (no). 2+8=10(nope). 3+7=10(nope). 4+6=10(nope). So returns empty.\n\nSample5:\n\nempty list, returns empty.\n\nYes, all test cases handled.\n\nTherefore, the code should be correct.\n</think>\n\nTo solve this problem, we need to determine if there exists a pair of integers in a given list such that their sum equals a specified target integer. If such a pair exists, we return their indices; otherwise, we return an empty list.\n\n### Approach\nThe approach to solve this problem efficiently involves using a hash map (dictionary) to keep track of the numbers we have seen so far and their corresponding indices. This method allows us to check for the complement of the current number (i.e., the value needed to reach the target sum) in constant time.\n\nHere's the step-by-step approach:\n\n1. **Initialize a Dictionary**: Create an empty dictionary called `seen` to store numbers as keys and their indices as values.\n2. **Iterate Through the List**: For each number in the list, compute the complement, which is the difference between the target sum and the current number.\n3. **Check for Complement**: If the complement exists in the `seen` dictionary, return the indices of the complement and the current number.\n4. **Update Dictionary**: If the complement is not found, add the current number and its index to the `seen` dictionary.\n5. **Return Result**: If no such pair is found after iterating through the entire list, return an empty list.\n\nThis approach ensures that we efficiently find the pair in linear time, O(n), where n is the number of elements in the list.\n\n### Solution Code\n```python\nfrom typing import List\n\ndef find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n```\n\n### Explanation\n- **Initialization**: We start by initializing an empty dictionary `seen` to keep track of the numbers and their indices as we iterate through the list.\n- **Iteration**: For each element in the list, we calculate the complement that would sum up to the target `k` when added to the current element.\n- **Complement Check**: We check if this complement exists in our `seen` dictionary. If it does, it means we have already encountered a number that, when added to the current number, equals the target sum. We then return the indices of these two numbers.\n- **Dictionary Update**: If the complement is not found, we add the current number and its index to the `seen` dictionary and continue to the next element.\n- **Completion**: If we finish iterating through the list without finding any such pair, we return an empty list.\n\nThis method efficiently handles all edge cases, including empty lists, single-element lists, and lists with duplicate values, ensuring optimal performance and correctness.",
  "r1_solution": "from typing import List\n\ndef find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
  "metadata": {
    "prompt_id": "00000096",
    "row_id": 96,
    "seed_ids": [
      "2485",
      "2345",
      "796"
    ],
    "mode": "leetcode",
    "original_instruction": "Given a list of `n` unique integers, determine if there exists a pair of integers in the list whose sum is equal to a given target integer `k`. If such a pair exists, return the indices of the two integers (0-indexed) in any order. If no such pair exists, return an empty list. Note that the same integer cannot be used twice."
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results0.jsonl"
}