{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000096_C",
  "question": "def find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n    \"\"\" Given a list of n unique integers, determine if there exists a pair of integers\n    in the list whose sum is equal to a given target integer k. If such a pair exists,\n    return the indices of the two integers (0-indexed) in any order. If no such pair exists,\n    return an empty list. Note that the same integer cannot be used twice.\n\n    >>> find_pair_with_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> find_pair_with_index([3, 2, 4], 6)\n    [1, 2]\n    >>> find_pair_with_index([3, 3], 6)\n    [0, 1]\n    >>> find_pair_with_index([1, 2, 3, 4, 5], 10)\n    []\n    >>> find_pair_with_sum([], 10)\n    []\n    \"\"\"",
  "solution": "def find_pair_with_sum(nums, k):\n    \"\"\"\n    Returns a list containing the indices of the two integers whose sum equals k.\n    If no such pair exists, returns an empty list.\n    \"\"\"\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []",
  "test_code": "def test_find_pair_with_sum():\n    assert find_pair_with_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert find_pair_with_index([3, 2, 4], 6) == [1, 2]\n    assert find_pair_with_index([3, 3], 6) == [0, 1]\n    assert find_pair_with_index([1, 2, 3, 4, 5], 10) == []\n    assert find_pair_with_sum([], 10) == []\n\ndef find_pair_with_index(nums, k):\n    return find_pair_with_sum(nums, k)",
  "test_info": [
    {
      "function_name": "find_pair_with_sum",
      "parameter_list": "(nums, k)",
      "function_declaration": "def find_pair_with_sum(nums, k):",
      "docstring": "Returns a list containing the indices of the two integers whose sum equals k.\nIf no such pair exists, returns an empty list."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, so I've got this problem to solve, and I need to find a pair of integers in a list that add up to a given sum k. And then return their indices. Hmm.\n\nLet me read the problem again to make sure I get all the details. Oh right, the integers are unique, so no duplicates in the list that I have to worry about except when two different elements have the same value, but since they have different indices, that's allowed. Also, I can't use the same integer twice, meaning I need two distinct elements.\n\nSo, the input is a list of integers and a target sum, and I have to return the indices of two numbers that add up to k. If there are multiple pairs, any of them is fine. If none, return an empty list.\n\nHow do I approach this?\n\nWell, the straightforward way is to check every possible pair of indices, but that's O(n^2) time, which is probably acceptable unless the list is really large, but for the given problem, maybe it's manageable.\n\nAlternatively, I can think about using a hash map to store numbers with their indices. Then, for each number, I can check if (k - number) exists in the hash map. If it does, and it's not the same number (unless there are duplicates, but the problem states that the integers are unique, so same number isn't an issue since indices are different as long as we have two occurrences. Wait, wait, the problem says the integers are unique. Wait, looking back: \"Given a list of n unique integers\" \u2014 yes. So each number appears once. So for the pair a and b, a must not be equal to b only if the target k is such that a + a = k and there are two a's. But since the integers are unique, there's at most one a, so even if the number is exactly half of k, we can't have two. Wait, but in the examples given, like in sample input, [3,3] gives 6 as the sum (indices 0 and 1). But the initial problem statement says the list is of n unique integers? Or is that not the case? Oh wait, looking back, in the function definition, perhaps I should double-check: the first line says \"n unique integers\". But one of the test cases in the examples uses [3,3] \u2014 that's a list with two 3s, which are not unique. Wait, no, in the sample, the list is [3,3], but their sum is 6, so that's allowed. So maybe I misread the problem.\n\nWait, the original problem says, \"Given a list of n unique integers\" \u2014 no, wait, in the function def, the description says \"Given a list of n unique integers\". Or wait, no, let me re-check. The problem statement says \"Given a list of n unique integers, determine if there exists a pair...\" So each integer in the list is unique, meaning there are no duplicates. So, the test case [3,3] is possible? Or that's perhaps a miscalculation. Oh, looking at the sample inputs, like find_pair_with_index([3,3],6) returns [0,1]. So in that case, it's allowed to have two 3s, so perhaps the list can have duplicates\u2014wait, but the problem states that the list is of unique integers. Hmm, perhaps I got that wrong. Or maybe the problem allows for the same integer as long as they are two different elements with the same value. Because the note says \"the same integer cannot be used twice\"\u2014so, I can't pick the same index twice, but if there are two elements with the same value but different indices, that's allowed.\n\nWait no, the note says the same integer cannot be used twice. So if the list is, say, [3,3], the sum is 6, so we can use both as a pair, even though they are the same integer, but different indices. So, in that case, it's allowed.\n\nSo I can proceed under the understanding that the list can have duplicate values, but for each element, the indices are unique. So, even if two elements have the same value, their indices are different.\n\nWait, that makes more sense. So the function can have a list with duplicate values, but the same index can't be used twice for the same element.\n\nSo for example, [3,3], target 6: return [0,1].\n\nSo, when going through the list, I need to find two elements whose sum is k, regardless of whether their values are the same or different.\n\nWait, but wait again. Looking back at the problem statement: \"the same integer cannot be used twice.\" So, if I have only one instance of 3 in the list, even if it's required, but if the problem requires two 3s (if k is 6, and the only elements is 3 and nothing else), then that's impossible. Wait no\u2014question is whether the same integer can be used twice: like, perhaps in the case where the list has a single 3, and the target is 6, then we cannot form a pair because it's trying to use the same integer (same index) twice. But if the list has two 3s at different indices, then yes.\n\nSo yes, the problem allows for pairs using two different elements that have the same value.\n\nSo the first approach is to think about using a hash map that for each number, stores its index. Then, for each number, we can see if k - number is present in the hash map and it's a different index.\n\nBut wait, one optimization: in the function, for each element, when we check whether (k - num) exists in the map, and if so, return that pair. But since we are building the map as we go, we might encounter the case where the required complement was added earlier.\n\nBut let's think: if we have the list [2,7,11,15], target 9: 2 and 7 are the pair. In the loop, when processing 2, the map is empty except 2. So, looking for 7, which hasn't been processed yet. So, 2's complement is 7, which is not in the map yet. So when 7 is processed, its complement is 2, which is in the map \u2014 so that's when the pair is found.\n\nBut in this approach, for any num in the list, we check if (k - num) is in the map before processing num. So perhaps building the map as we iterate.\n\nWait, but in this approach, the loop steps would be:\n\nInitialize an empty hash map (dictionary) to store numbers as keys and their indices as values.\n\nLoop through each index i and num in nums:\n\n   check if (k - num) is in the map.\n\n   if yes, then return [map[k-num], i]\n\n   if not, add num to the map with its index.\n\nBut wait, this would only capture cases where the other number has been added before the current num.\n\nFor example, in the first sample:\n\nnums is [2,7,11,15], k=9.\n\nAt i=0, num=2:\n\nCheck if 9-2=7 is in the map. It's not, so add 2:0.\n\ni=1, num=7:\n\n9-7=2 is in the map (2:0). So return [0,1]\n\nThis works.\n\nAnother example: find_pair_with_sum([2, 7, 11, 15], 17). Do 7+10? No. Wait, 2+15=17 \u2192 indices 0 and 3?\n\nBut in the hash approach, for 2, 17-2=15 is not in the map. For 7: 17-7=10. Not in the map. 11: 17-11=6. Not in the map. 15: 17-15=2, which is in the map. So returns [0,3].\n\nSo this approach works.\n\nBut wait, what about the list [3,3], target 6.\n\nProcessing first 3: check if 3 is in the map. It's not. So map becomes {3:0}.\n\nSecond 3 comes in. Check if 6-3=3 is in the map. Yes, so returns [map[3], 1] \u2192 [0,1]. Correct.\n\nBut what about a case where the two required numbers are after each other? Like nums = [1,4], k=5. 1 comes first, 4 is next. When processing 1: 4 is not in map. Add 1. When processing 4: 5-4=1 is in the map (index 0). So returns [0,1]. Correct.\n\nSo this approach seems to handle all cases correctly.\n\nBut wait, is this correct for all cases where the pair exists? Well, it should be, because it's an O(n) approach and it's catching the earliest occurrence of the pair.\n\nWait, but what about when two different pairs exist? Like nums = [1,2,3,4], k=5.\n\nSo the pairs could be (1,4), (2,3). The algorithm will find the first possible pair: 1 and 4 may not be found first. Let's see:\n\nProcessing nums[i] =1: check 5-1=4 not in map. Add 1. i=1, num=2: 5-2=3 not in map. Add 2. i=2, num=3: 5-3=2 which is in the map (i=1). So returns [1,2]. So in this case, (2 and 3) is the pair that's returned before (1 and4). Does the problem require any pair, or only the first possible? The problem states that any correct pair can be returned.\n\nSo this approach works.\n\nAnother example: [3,2,4], target 6.\n\nProcessing 3: check for 3. 3: not in the map yet. Add 3\u21920.\n\nThen 2: 6-2=4; not in map (so far 3 is there). Add 2\u21921.\n\nThen 4: 6-4=2 is in map. So returns [1,2]. Which is correct.\n\nSo, the approach seems correct.\n\nSo, moving ahead, the plan is to use a hash map. So, the code outline is:\n\nCreate an empty dictionary.\n\nLoop through each index i and num in nums:\n\n   calculate target = k - num\n\n   if target is in the dict:\n\n       return [dict[target], i]\n\n   else:\n\n       add num: index to dict\n\nIf loop ends and no pair found, return empty list.\n\nNow, in code:\n\nWait, but in the sample code, the function is defined as find_pair_with_sum, but in some examples, it's called find_pair_with_index. Probably a typo.\n\nSo, in Python, I can write:\n\ndef find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        target = k - num\n        if target in seen:\n            return [seen[target], i]\n        seen[num] = i\n    return []\n\nTesting this code against the examples.\n\nFirst sample:\n\nnums = [2,7,11,15], k=9.\n\nProcess 2: target 7 not in seen (empty). Add 2:0.\n\nProcess 7: target 2 is in seen (0). So return [0,1]. Correct.\n\nSecond example in the samples, but the function is called as find_pair_with_index\u2014probably a typo. So the second sample is find_pair_with_sum([3,2,4], 6) should return [1,2].\n\nLet's see. Our code:\n\nLoop:\n\ni=0, num=3 \u2192 target 3, which is not in seen. Add 3:0.\n\ni=1, num=2: target 4. Not in seen. Add 2:1.\n\ni=2, num=4: target 2. Is in seen (1). So returns [1,2] correct.\n\nThird sample: [3,3], k=6.\n\ni=0, num=3 \u2192 target 3 not in seen. Add 3:0.\n\ni=1, num=3: target 3, which is in seen (0). So returns [0,1]. Correct.\n\nFourth sample:\n\nnums=[1,2,3,4,5], k=10.\n\nWe need to see if any pair adds to 10.\n\nPossible pairs:\n\n1+9? No.\n\n2+8? No.\n\n3+7? No.\n\n4+6? No.\n\n5+5? But only one 5.\n\nWait, but in the code:\n\nfor each number:\n\ni=0, num=1 \u2192 target 9. Not in map. Add 1:0.\n\ni=1, num=2 \u2192 target 8. Not in map. Add 2:1.\n\ni=2, num=3 \u2192 target7. Not in map. Add 3:2.\n\ni=3, num=4 \u2192 target6. Not in map. Add 4:3.\n\ni=4, num=5 \u2192 target5. 5 is not in the map yet. So, after processing, returns nothing. So function returns empty list. Correct.\n\nSo sample 4 returns empty. Correct.\n\nSample 5: empty list. So code returns empty. Correct.\n\nSo, it seems all samples are handled correctly.\n\nBut wait, what about the order of the indices? For example, if the pair is found where the index in the map is after the current i? But in the code, it's always looking for elements that have been processed before, so it's guaranteed that the first occurrence of the target is before.\n\nSo, the function works.\n\nSo the code can be written as:\n\nImplement the above.\n\nBut wait! Wait a second\u2014can adding the current num to the dictionary before checking cause any issue? Because right now, I'm checking if the target is in the dictionary before adding the current num. So for each current num, I'm checking for the target in the previous elements.\n\nYes. Because suppose that one element is the target, which is the same as the current num, but only occurs once. Wait, no\u2014the problem allows that as long as the two are different indices.\n\nWait, consider the list [3,3], k=6. As in sample 3.\n\nAt i=0: target is 3.\n\nCheck if 3 is in seen? No, since it's the first element. So add 3:0.\n\nAt i=1: current num is 3. Target is 3, which is in seen (0).\n\nSo, yes.\n\nSo the logic is correct.\n\nThus, the code should be as outlined.\n\nNow, think about any possible issues.\n\nCase where a number is exactly half of k: if the same number appears twice.\n\nBut since the list is allowed to have duplicates, the code correctly finds them.\n\nAnother test case:\n\nnums = [5,5], k=10.\n\nProcessing 5: target is 5. Not in the map. Add 5:0.\n\nProcessing the second 5: target 5 is in map (0), returns [0,1]. Correct.\n\nAnother test:\n\nnums = [1]. Only one element. So function returns empty.\n\nAnother test where the list has [2, 4, 3, 5], and k=7.\n\nProcess 2: target 5 not in map. Add 2:0.\n\nProcess4: target 3 not in map. Add4:1.\n\nProcess3: target4 (is 3 is 7-3=4. 4 is in map (1). So returns [1,2]. So, but as the list is [2,4,3,5], this is indices 1 (4) and 2 (3). The sum is 7. Correct.\n\nSo I think the code is solid.\n</think>\n\nTo solve this problem, we need to determine if there exists a pair of integers in a given list whose sum equals a specified target. If such a pair exists, we return their indices; otherwise, we return an empty list.\n\n### Approach\nThe approach to solve this problem efficiently involves using a hash map (dictionary) to store the indices of the numbers as we iterate through the list. This allows us to check if the complement of the current number (i.e., the target sum minus the current number) has already been encountered. If it has, we can immediately return the indices of these two numbers.\n\n1. **Hash Map Initialization**: Create an empty dictionary to keep track of the numbers we have seen so far along with their indices.\n2. **Iterate Through List**: For each number in the list, calculate the complement (target sum minus the current number).\n3. **Check for Complement**: If the complement exists in the hash map, return the indices of the complement and the current number.\n4. **Update Hash Map**: If the complement is not found, add the current number and its index to the hash map.\n5. **Return Result**: If the loop completes without finding a pair, return an empty list.\n\nThis approach ensures that we only traverse the list once, resulting in an efficient O(n) time complexity.\n\n### Solution Code\n```python\nfrom typing import List\n\ndef find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        target = k - num\n        if target in seen:\n            return [seen[target], i]\n        seen[num] = i\n    return []\n```\n\n### Explanation\n- **Hash Map Usage**: The hash map (dictionary) is used to store each number's index as we iterate through the list. This allows for quick lookups to check if the complement of the current number exists in the previously seen numbers.\n- **Efficiency**: By checking each number and its complement in constant time, the overall time complexity is O(n), making this approach very efficient even for larger lists.\n- **Correctness**: The algorithm correctly handles cases with duplicate values as long as their indices are different, ensuring that the same number can be used twice if it appears at different indices.\n\nThis method ensures that we find a valid pair efficiently, returning the correct indices or an empty list if no such pair exists.",
  "r1_solution": "from typing import List\n\ndef find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        target = k - num\n        if target in seen:\n            return [seen[target], i]\n        seen[num] = i\n    return []",
  "metadata": {
    "prompt_id": "00000096",
    "row_id": 96,
    "seed_ids": [
      "2485",
      "2345",
      "796"
    ],
    "mode": "leetcode",
    "original_instruction": "Given a list of `n` unique integers, determine if there exists a pair of integers in the list whose sum is equal to a given target integer `k`. If such a pair exists, return the indices of the two integers (0-indexed) in any order. If no such pair exists, return an empty list. Note that the same integer cannot be used twice."
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results2.jsonl"
}