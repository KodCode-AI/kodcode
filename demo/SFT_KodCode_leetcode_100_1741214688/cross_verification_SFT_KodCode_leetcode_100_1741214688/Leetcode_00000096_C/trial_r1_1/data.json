{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000096_C",
  "question": "def find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n    \"\"\" Given a list of n unique integers, determine if there exists a pair of integers\n    in the list whose sum is equal to a given target integer k. If such a pair exists,\n    return the indices of the two integers (0-indexed) in any order. If no such pair exists,\n    return an empty list. Note that the same integer cannot be used twice.\n\n    >>> find_pair_with_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> find_pair_with_index([3, 2, 4], 6)\n    [1, 2]\n    >>> find_pair_with_index([3, 3], 6)\n    [0, 1]\n    >>> find_pair_with_index([1, 2, 3, 4, 5], 10)\n    []\n    >>> find_pair_with_sum([], 10)\n    []\n    \"\"\"",
  "solution": "def find_pair_with_sum(nums, k):\n    \"\"\"\n    Returns a list containing the indices of the two integers whose sum equals k.\n    If no such pair exists, returns an empty list.\n    \"\"\"\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []",
  "test_code": "def test_find_pair_with_sum():\n    assert find_pair_with_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert find_pair_with_index([3, 2, 4], 6) == [1, 2]\n    assert find_pair_with_index([3, 3], 6) == [0, 1]\n    assert find_pair_with_index([1, 2, 3, 4, 5], 10) == []\n    assert find_pair_with_sum([], 10) == []\n\ndef find_pair_with_index(nums, k):\n    return find_pair_with_sum(nums, k)",
  "test_info": [
    {
      "function_name": "find_pair_with_sum",
      "parameter_list": "(nums, k)",
      "function_declaration": "def find_pair_with_sum(nums, k):",
      "docstring": "Returns a list containing the indices of the two integers whose sum equals k.\nIf no such pair exists, returns an empty list."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to solve this problem where I have to find two integers in a list whose sum equals a given number k. And I have to return their indices. Hmm.\n\nLet me think, how should I approach this. So the function is called find_pair_with_sum or find_pair_with_index. Oh right, the user provided different names for the examples, maybe they meant that need correction, but probably it's a typo. So I'll just focus on the function definitions provided.\n\nThe problem is, given a list of unique integers, check if any two distinct elements (since the same integer can't be used twice, but wait, the note says the same integer can't be used twice. Oh, but wait, the examples have [3,3] and return [0,1], so in the case where the number appears twice, for a sum equal to twice that value, it's allowed.\n\nSo, for example, the third test case is [3,3], k=6, returns [0,1]. So while numbers are unique in the list, wait, no, the problem says the list has unique integers? Or just any integers?\n\nLooking back, the problem statement says, \"a list of n unique integers\". Oh, right! So in the sample, I see [3,3], but wait that's not unique. So that's a possible mistake. Wait, no, looking back: the problem says \"n unique integers\" \u2014 so the list has unique integers. But then some of the examples have duplicates? That's confusing.\n\nWait, looking at the examples:\n\nFirst example: [2,7,11,15], which are unique.\n\nSecond example: [3,2,4], all unique.\n\nThird example: [3,3], which is two same elements. But if the list should have unique elements, then this example might be a typo. Or maybe the function can manage with lists that have duplicates as in the example provided.\n\nWait, the problem wording says \"a list of n unique integers\" in the first line. So perhaps I need to handle lists with unique integers. Therefore, in practice, each integer in the list occurs exactly once.\n\nBut in the third example, the function is given [3,3], which may have been a mistake. Because the function returns [0,1], which suggests that even though the same numbers are present, since they are at different indices, it's acceptable.\n\nWait, perhaps the problem expect us to return the indices if two distinct elements sum to k, regardless of whether the numbers are the same, but the list may have duplicates, but the note clarifies that same integer cannot be used twice, but in the note, it refers to using the same instance, like the same index, I think.\n\nWait, no. The note says the same integer cannot be used twice, which suggests that even if an integer appears multiple times, you can't choose the same element twice.\n\nBut in the third example, [3,3], k=6 returns [0,1]. So the integers are 3 and 3, which are in the list, so their sum is 6. So in that case, the list doesn't have unique integers.\n\nThus, perhaps the initial assumption of unique is wrong. The problem in the description says 'n unique integers', but looking at the examples, I can handle lists with non-unique integers as well.\n\nSo perhaps, the list can have any integers, not necessarily unique, but the function must find two distinct indices i and j such that nums[i] + nums[j] == k.\n\nWait, but the problem says, 'two integers' but the same integer can't be used twice. So that refers to that each integer in the list (even if same as another) is a separate element. So for example, in [3,3], the two elements are used once each.\n\nOkay, maybe the problem allows for duplicates in the list.\n\nNow, back to solving the problem.\n\nWhat's the optimal way to find a pair sum?\n\nOne approach is to use a hash map to store the elements we've seen so far as we iterate through the list. For each element, we check if the complement (k - current number) exists in the hash map. If yes, then we return the indices of the two numbers.\n\nBut wait, how do we handle the storing of indices? Because if the same number appears more than once, but we have different indices.\n\nWait, let's think: For each number in nums, we can walk through it. For the current number num, we need to see if (k - num) is present in the previously seen numbers.\n\nIf it is, then we can take the current index and the index of the saved (k - num). So the indices will be [previously stored index, current index] or vice versa, but in the examples, they seem to return the earliest occurrence as first index.\n\nWait, looking at the first example:\n\nnums = [2,7,11,15], k=9. So 2 and 7 sum to 9. The indices are 0 and 1. If our approach is to store the indices as we go, then when we reach 7, which is index 1, we look for k-7 (which is 2). Since 2 is in the hash map with index 0. So yes, return [0,1].\n\nIn the second example, [3,2,4], k=6. So 2 and 4 sum to 6. Indices are 1 and 2.\n\nSo yes, the approach would capture that.\n\nSo the plan is:\n\n- Initialize an empty dictionary to store the numbers we've seen, along with their indices.\n\n- Iterate through each number in nums along with their indices.\n\n- For each number, num, at index i:\n\n   - Calculate complement = k - num.\n\n   - Check if complement is in the dictionary.\n\n   - If it is, then return [dictionary[complement], i].\n\n   - Else, add (num, i) to the dictionary.\n\n- If we finish iterating and no such pair is found, return an empty list.\n\nBut wait, let's think about the order.\n\nWait, the function is supposed to return the indices in any order. So [0,1] or [1,0] are both acceptable for the first example.\n\nWait, looking at the examples:\n\nIn the first example, the function returns [0,1].\n\nIn the third example, [3,3] returns [0,1].\n\nWhich suggests that for the first occurrence, the pair is returned in their ordering.\n\nSo the approach of once we find a complement, we immediately return the earlier index followed by the current index meets this.\n\nSo in the third example, when we iterate:\n\ni=0, num=3. complement is 6-3=3. 3 is not in the dict. So add 3:0.\n\ni=1, num=3. complement is 3 is in dict. So return [0,1].\n\nSo that's correct.\n\nAnother test case: [1,2,3,4,5], k=10.\n\nPossible pairs: 1+9 (no. 9), 2+8 (no), 3+7 (no), etc. Check if any two sum to 10. 5 +5 no, but the example returns empty list.\n\nAnother possible case: [5,5], with k=10. So that's allowed because the same number is at two different indices, so their sum is 10. So this function should return [0,1].\n\nWait, in this scenario, the code as planned would find complement 5 in the dict when i=1, and return [0,1]. Correct.\n\nSo, but what about if the same number appears later beyond second index?\n\nLike [1,5,5] and k=10. Then when i=2, compliment 5 is in the dict as 1-> 5, i=2.\n\nWait: nums[0]=1. So complement 10-1=9\u2014 not in dict (since empty). Add 1->0.\n\nAt i=1, nums[1]=5. Compliment is 5. Not in dict (it's empty). So add 5 as key with index 1.\n\nAt i=2, nums[2]=5. Compliment is 5\u2014 which exists in the dict. So returns [1, 2], but 5+5=10. So this is correct, as 5 and 5.\n\nSo the function returns [1,2] in this case. But what if the list is [5,4,5], and k is 10. Then the first 5 is at i=0, next 5 at i=2. When processing i=2, we check 10-5=5, which is in the dict (value 0). So returns [0,2], which is correct.\n\nSo the algorithm handles this correctly.\n\nWait, but there's a problem when and index j is before i, which is indeed the case.\n\nBut what if the same number appears earlier but in previous index. That's handled correctly.\n\nThus, the approach is solid.\n\nSo now, how to implement this.\n\nIn Python, the function is given nums as a list of ints, and k as an int. It returns a list of two ints (indices), or an empty list.\n\nSo the steps:\n\n- Check if nums is empty or length is 1: return empty list.\n\nBut wait, since a pair needs two elements, if len(nums) <2, return empty.\n\nBut perhaps, in the code, it's handled automatically.\n\nProceeding.\n\nLet me write the pseudocode.\n\nCreate an empty dictionary: seen = {}.\n\nFor i, num in enumerate(nums):\n\n   complement = k - num\n\n   if complement is in seen:\n\n       return [seen[complement], i]\n\n   else:\n\n       add num to seen with value i.\n\nContinue until the end.\n\nIf no such pair, return empty list.\n\nYes, that's the plan.\n\nBut what if multiple pairs exist? For example, [2, 1, 3, 4], k=5: 2+3=5, 1+4=5.\n\nWe want the first occurrence where a pair is found. So in this example, when i=1, the number is 1. complement is 4, which isn't in seen yet.\n\nBut then i=2: number is 3. complement is (5-3)=2, which is in seen at index 0. So returns [0,2].\n\nSo the correct first pair.\n\nBut in the list [4, 1, 2, 3], k=3:\n\nLooking for pairs:\n\nAt i=0: num 4. complement is -1 not in seen. add 4:0.\n\ni=1: num 1. complement 2 not in seen. add 1:1.\n\ni=2: num=2. complement is 1, which is in seen as 1. So returns [1, 2] because 1+2=3.\n\nYes.\n\nSo this approach finds the pair as soon as possible.\n\nNow, in code:\n\nWe can write:\n\nfor i, num in enumerate(nums):\n\n   complement = k - num\n\n   if complement in seen:\n\n       return [seen[complement], i]\n\n   seen[num] = i\n\nAfter the loop, return [].\n\nTesting:\n\nSample 1:\n\nnums = [2,7,11,15], k=9.\n\ni=0, num=2.\n\ncomplement is 7, not in seen (empty), seen[2] = 0.\n\ni=1, num=7.\n\ncomplement 2: present, so returns [0,1]. Correct.\n\nSample 2:\n\nWait, in the examples, the function was called 'find_pair_with_index' in the second example, but perhaps that's a typo.\n\nBut in code, that's not an issue.\n\nSample 3:\n\nnums = [3,3], k=6.\n\nseen starts empty.\n\ni=0, num=3:\n\ncomplement 3 not present. seen[3]=0.\n\ni=1, num=3:\n\ncomplement 3 is present. seen[3] is 0. So return [0,1]. Correct.\n\nSample 4:\n\nnums = [1,2,3,4,5], k=10.\n\nCheck for any pair adding to 10.\n\nLooking:\n\nPossible pairs: (1,9 no, so 2,8 no, 3,7 no, 4,6 no, 5,5 no. So function returns empty list.\n\nSample:\n\nnums empty \u2192 return empty list.\n\nAnother test: [0, 0], k=0 \u2192 return [0,1].\n\nSo in code:\n\nNow, what about duplicate numbers:\n\nWhat about nums like [2, 2, 3], k=4.\n\ni=0, num=2: complement is 2, not in seen. Add to seen: 2:0.\n\ni=1, num=2: complement is 2, which is in seen (at 0). So returns [0,1]. Which is 2+2=4.\n\nSo handles it correctly.\n\nAnother case: nums = [10, -5, 3, 7], k=5.\n\ni=0: num=10, complement is -5. Not in seen.\n\ni=1: num=-5. complement is 10. 10 is in seen at 0. So returns [0,1]. Since 10 + (-5) =5. Correct.\n\nSo yeah, the code seems solid.\n\nPossible edge cases:\n\nTest case where same number appears later, but no earlier.\n\nLike nums = [5, 3, 5], k=8.\n\nAt i=0: num=5. complement is 3, not seen. Add 5:0.\n\ni=1: num=3. complement is5, which is in seen. return [0,1]. 5+3=8.\n\ni=2: num=5, not processed as function returns early.\n\nSo all good.\n\nAnother edge case: nums has exactly two elements, which sum to k.\n\nLike [1, 2], k=3 \u2192 returns [0,1].\n\nAnother edge case: nums has one element: returns empty.\n\nAnother case: k=0 and have both 0. Or something like [5, -5], which is sum 0.\n\ni for 5 is 0:\n\ncomplement -5 not in seen.\n\ni for -5: complement is5, which is seen. Returns [0,1].\n\nWhich is correct.\n\nSo It's all handled.\n\nSo I'll implement this in Python.\n\nThe function is:\n\ndef find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n\n    seen = {}\n\n    for i, num in enumerate(nums):\n\n        complement = k - num\n\n        if complement in seen:\n\n            return [seen[complement], i]\n\n        seen[num] = i\n\n    return []\n\nWait, but in Python, the List type is from collections.abc or typing.\n\nBut the starter code probably expects to return a list, or an empty list.\n\nTesting something like [5,5] is handled?\n\nYes.\n\nAnother thought: What if the same number is found after a previous occurrence, but another pair exists earlier? Which for the function, wouldn't matter because it returns as soon as it finds a pair.\n\nYes.\n\nSo the code seems correct.\n\nI think this should handle all cases.\n</think>\n\nTo solve this problem, we need to determine if there exists a pair of integers in a given list whose sum equals a specified target integer. If such a pair exists, we return the indices of these two integers; otherwise, we return an empty list.\n\n### Approach\nThe approach involves using a hash map (dictionary) to efficiently track the elements we have seen so far as we iterate through the list. Here's a step-by-step breakdown of the approach:\n\n1. **Initialize a Dictionary**: Create an empty dictionary called `seen` to store each number along with its index as we traverse the list.\n\n2. **Iterate Through the List**: For each number in the list, calculate its complement with respect to the target sum `k` (i.e., `complement = k - current_number`).\n\n3. **Check for Complement**: If the complement exists in the `seen` dictionary, it means we have encountered a number before that, when added to the current number, equals the target sum `k`. In this case, return the indices of these two numbers.\n\n4. **Update Dictionary**: If the complement is not found, add the current number and its index to the `seen` dictionary.\n\n5. **Return Result**: If the loop completes without finding any such pair, return an empty list.\n\nThis approach ensures that we efficiently find the pair with minimal time complexity, O(n), where n is the number of elements in the list.\n\n### Solution Code\n```python\nfrom typing import List\n\ndef find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n```\n\n### Explanation\n- **Dictionary Usage**: The dictionary `seen` is used to keep track of the numbers we have encountered and their respective indices. This allows quick look-up to check if the complement of the current number exists.\n  \n- **Early Return**: As soon as we find a valid pair (i.e., when the complement of the current number is found in `seen`), we return the indices immediately. This ensures that we do not perform unnecessary iterations once a solution is found.\n\n- **Time Complexity**: The solution runs in O(n) time, as each element is processed exactly once, and dictionary operations (insertion and look-up) are average O(1).\n\n- **Space Complexity**: The space complexity is O(n), as in the worst case, the dictionary will store all elements of the list.\n\nThis approach efficiently handles the problem of finding a pair of integers with a given sum, ensuring optimal performance even for larger lists.",
  "r1_solution": "from typing import List\n\ndef find_pair_with_sum(nums: List[int], k: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
  "metadata": {
    "prompt_id": "00000096",
    "row_id": 96,
    "seed_ids": [
      "2485",
      "2345",
      "796"
    ],
    "mode": "leetcode",
    "original_instruction": "Given a list of `n` unique integers, determine if there exists a pair of integers in the list whose sum is equal to a given target integer `k`. If such a pair exists, return the indices of the two integers (0-indexed) in any order. If no such pair exists, return an empty list. Note that the same integer cannot be used twice."
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results1.jsonl"
}