{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000096_I",
  "question": "Given a list of `n` unique integers, determine if there exists a pair of integers in the list whose sum is equal to a given target integer `k`. If such a pair exists, return the indices of the two integers (0-indexed) in any order. If no such pair exists, return an empty list. Note that the same integer cannot be used twice.",
  "solution": "def find_pair_with_sum(nums, k):\n    \"\"\"\n    Returns a list containing the indices of the two integers whose sum equals k.\n    If no such pair exists, returns an empty list.\n    \"\"\"\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []",
  "test_code": "def test_find_pair_with_sum():\n    assert find_pair_with_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert find_pair_with_index([3, 2, 4], 6) == [1, 2]\n    assert find_pair_with_index([3, 3], 6) == [0, 1]\n    assert find_pair_with_index([1, 2, 3, 4, 5], 10) == []\n    assert find_pair_with_sum([], 10) == []\n\ndef find_pair_with_index(nums, k):\n    return find_pair_with_sum(nums, k)",
  "test_info": [
    {
      "function_name": "find_pair_with_sum",
      "parameter_list": "(nums, k)",
      "function_declaration": "def find_pair_with_sum(nums, k):",
      "docstring": "Returns a list containing the indices of the two integers whose sum equals k.\nIf no such pair exists, returns an empty list."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, so I've got this problem to solve. Let's see. The task is to determine if there's a pair of integers in a list whose sum equals a given target k. If such a pair exists, I need to return their indices in a list, otherwise return an empty list. Oh right, and each integer is unique, so no duplicates, and I can't use the same element twice.\n\nHmm, how do I approach this? Let me think about possible methods. Well, the first thing that comes to mind is the brute force approach. That is, checking every possible pair in the list. For each element, I can look at every other element and see if they add up to k. But wait, how efficient is that? If the list is big, say n is large, this could be O(n^2) time, which might not be efficient for very big n. But for the problem constraints, I'm not sure what the expected input size is. Since the problem isn't stating any constraints, maybe a brute force approach is acceptable.\n\nAnother approach is to use a hash map. Oh right, because for each element, if I store the value and its index, then for any given element, I can quickly look up if there's another element that, when added to it, equals k. Let me think about how this works.\n\nSo, for example, let's say my list is [3, 1, 4, 2], and the target is 5. As I iterate through each element:\n\n- The first element is 3. I see if 5 - 3 = 2 exists in the map. Since the map is empty at this point, it doesn't. So I add 3 to the map with its index 0.\n\n- Next element is 1. 5 -1 equals 4. Check if 4 is in the map. No, so add 1 and index 1 to the map.\n\n- Then comes 4. 5-4 is 1. Oh, 1 is already in the map. So here, the pair is (1,4) which has indices 1 and 2. So I return [1,2], but wait, wait, wait. Wait a minute. No, 1 is at index 1 and 4 is at index 2. So the sum is indeed 5, so that's a correct pair.\n\nSo this approach uses a single pass, right? Because I process each element once and at each step check the hash. If the required complementary value exists, return the indices. This is O(n) time, which is better than O(n^2), which would be better for larger n.\n\nBut let me think about edge cases. For example, when the list is empty or has a single element. Wait, but the problem says n is the number, so maybe n is at least 2? Or do I consider n can be 0 or 1, in which case obviously no pairs exist.\n\nWait, the problem says a list of n unique integers. So for n < 2, the answer is obviously an empty list since you can't form a pair.\n\nSo, in code, I should handle that first. But for n >= 2, proceed.\n\nBut also, when using the hash map method, what happens if the current element plus a previously stored element equals k?\n\nAlso, how do I store the indices? Using a dictionary where the key is the value, and the value is the index. This way, when I have a current element, the needed number is k - current number. I just check if that needed number is in the dictionary. If yes, then return [dictionary[needed], current index]. Else, add current number and index to the dictionary.\n\nWait, what about the order of the pair? The problem says to return the indices in any order. So either way is fine.\n\nLet me test this with another example. Suppose list is [5, 6, 3, 4], target is 9. Process each element:\n\n1. 5: needed is 4. Not in dict. Add 5:0.\n\n2. 6: needed is 3. Not in dict. Add 6:1.\n\n3. 3: needed is 6. 6 is in dict (value 1). So the pair is [1,2]. So return.\n\nBut wait, that's 6 at index 1 and 3 at index 2. So adding 3, the pair is 6 and 3, which sum to 9. So correct.\n\nAnother example: list is [3, 2, 4], target 6. So [3, 3 is needed 3 which isn't present yet (but wait, can an element pair with itself? No, because the same integer cannot be used twice, but in this case, list elements are unique, so for 3, another 3 isn't present. So:\n\nAt element 3: check, 6-3=3. But no, no 3 in dict (dict has nothing before). So add 3:0.\n\nNext element is 2: 6-2=4. Not present, add 2:1.\n\nNext element 4: 6-4=2. 2 is present, index 1. So return [1, 2]. Sum is 2 +4=6, correct.\n\nAnother case: a case where a later element forms a pair with an earlier one, but a previous iteration may have already found a pair. But in our approach, we stop at the first occurrence. That's okay because the problem just asks for the existence, any pair.\n\nWhat about when the target is to find a pair where the required complement is found in a later element? Wait, no, because the dictionary only contains elements that have been processed before. So in this case, for each current element, it's looking for something that was already in the list and stored in the dictionary.\n\nWait, so when processing the element, we find a pair if any previous element can pair with it. So the first pair found will be returned, but the continuation may find others.\n\nBut for the problem's sake, as soon as a pair is found, we can return it. So what if the code breaks early as soon as a pair is found?\n\nWait, but in my approach, let's think: for each element, the code checks if (k - element) is in the dict before adding the current element to the dict. So that way, once the pair is found, you can return immediately without further processing.\n\nYes. For example, in the list [5, 3, 1], target 8.\n\nLet's see:\n\nelement 5: check 3 (8-5=3), not in dict, add 5:0.\n\nelement 3: check 5 (8-3=5), which is in dict (at 0). So return [0, 1].\n\nThus, this approach finds the pair correctly, and in early steps.\n\nNow, what about when there's no such pair? For example, list is [1,2,3], target 7. Processing each element:\n\n1: check for 6, not present. Add 1:0\n\n2: check for 5, not present. Add 2:1\n\n3: check for 4, not present. Add 3:2.\n\nAt end, return empty list.\n\nYes.\n\nNow, the question is: which approach should I use? The hash map approach is better for efficiency, but for very small lists, maybe the brute force is more straightforward. However, considering that O(n) is better, perhaps implementing the hash approach is better.\n\nSo for the code, perhaps the hash map is the way to go.\n\nSo the plan is:\n\n- Initialize an empty dictionary.\n\n- Iterate through each element in the list, keeping track of the current index.\n\n- For each element, calculate the needed complement: k - current element.\n\n- Check if the complement exists in the dictionary.\n\n- If yes, return [dictionary[complement], current index] or [current index, dictionary[complement]] (order doesn't matter).\n\n- If no, add the current element and index to the dictionary.\n\n- If loop ends without finding, return empty list.\n\nBut wait, let me think about the order. Because the indices are of the two numbers whose sum is k. But, if the numbers are repeated but with the same indices, that would complicate things. But the problem states unique integers, so no duplicates in values. So the hash map will have unique keys and values.\n\nEdge Cases to test in code:\n\n1. When the list has exactly two elements, and they add to k: returns [0,1].\n\n2. When list is size 1: returns empty.\n\n3. When all possible pairs don't add up to k: returns empty.\n\nAnother possible issue: if k is smaller than any of the pair's values? Or, like negative numbers. But the approach remains the same because for any element, we look for k-current.\n\nWait, what if the list is [ -1, 3], target is 2. Then k - (-1) = 3, which is present. So [0,1] is correct.\n\nSo the approach handles negatives as well.\n\nNow, let's think about the data structures. The dictionary in Python can have int keys mapped to int values (indices). So for each element, it's added as key: value.\n\nNow, what about once a pair is found, return immediately. So the code stops processing further elements once a pair is found.\n\nThus, code structure:\n\ndef findPair(nums, k):\n\n    num_dict = {}\n    for index, num in enumerate(nums):\n        complement = k - num\n        if complement in num_dict:\n            return [num_dict[complement], index]\n        num_dict[num] = index\n\n    return []\n\nWait, no, because the function wants 0-indexed indices. Let me test this.\n\nYes, in enumerate, index is 0, 1, etc.\n\nTesting the first example:\n\nnums = [3,1,4,2], k =5.\n\nProcessing:\n\nelement 3 (index 0): complement 2 not in dict. Add 3:0.\n\nelement 1 (index1): complement 4 not in dict. Add 1:1.\n\nelement4 (index2): complement is 1. Is 1 in dict? Yes, at index1. So return [1,2].\n\nWhich is correct.\n\nWhat about the pair is 1 and 4 as opposed to 3 and 2? Well, because 3 and 2 sum to 5, but in this example, the code returns the first pair found, which is 1 and4 because we found it earlier in the list.\n\nWait, in the list [3,1,4,2], the 3 is at index0, and then comes 1, index1. Then 4: complement is 1 which is in the dict, so returns the indices 1 and 2. That's correct as well.\n\nYes.\n\nAnother test case: nums = [5,6], k=11.\n\nProcessing:\n\n5: complement is 6. Not in dict (dict is empty at first step). Add 5:0.\n\nnext, 6: complement is 5. Yes, it's in dict at index0. So returns [0,1], which is correct.\n\nAnother test case: when the pair is the last two elements. E.g., nums = [1,2,3], k=5. 3 and 2 are the pair. The code will process 1: add, 2: add, 3: complement 2 exists, so returns [1,2].\n\nYes.\n\nSo, this approach seems solid.\n\nWait, but in the problem statement, the function should return a list of two indices, in any order. So [1,2] is correct here.\n\nAnother problem: what if a pair exists but is found in such a way that the stored index comes after? Say, for example, the list is [1,4,3,2], target 5.\n\nLooking for 1 and 4: sum is5. So during the processing:\n\nelement1: added.\n\nelement4: complement is 1, which is in dict. So returns [0,1], which is correct. So that's fine.\n\nSo, I think this approach should work.\n\nNow, writing the code.\n\nSo, function takes 'nums' as the list, and 'k' as target.\n\nInitialize an empty dictionary.\n\nLoop through each index, num in nums with enumerate.\n\nFor each, compute complement=k-num.\n\nCheck if complement exists in the dictionary.\n\nIf yes: return [dictionary[complement], index], as a list.\n\nIf no, add the current num and index to the dictionary.\n\nAt the end, after all elements, if no pair found, return empty list.\n\nWhat about if the same num appears twice but their indices are same? But the list has unique integers, and the same num can't be there. So no issue.\n\nAnother thing: if the current number is exactly half of k, but then twice. But since list has unique integers, each element is unique, so it's safe.\n\nSo, code seems solid.\n\nTesting for the sample inputs, seems correct.\n\nLet me think about the example the user provided, which I need to write as a test case.\n\nWait, the initial problem didn't provide a sample input but it doesn't matter. But let's imagine some test cases.\n\nTest Case 1:\n\nnums = [1, 3, 4, 2]\n\nk =5\n\nThe code will process 1 (add 1:0), 3 (add 3:1), then 4: looking for 5-4=1, which is at 0, so returns [0,2]. But wait, wait: for the third element (element at index2, which is 4), the complement is 1. 1 is in dict, which is at index0. So the code would return [0,2], not waiting for 2. But 3 and 2 sum to 5 as well.\n\nBut regardless, the problem asks for any pair. So our code returns [0,2], which is acceptable since 1 and4 sum to5.\n\nAnother test case: nums = [3,2,1,4], k =5.\n\nProcess:\n\n3: add to dict.\n\n2: add to dict.\n\n1: look for 4; 4 not in dict. Add 1.\n\n4: look for 1. Yes, at index2. So return [2,3]. Which is correct since 1 and4 are next.\n\nSo, the code works correctly.\n\nAnother possible thing: if the same number is required, but that's not possible because the list has unique integers. So for example, [2,3,4], k=4: would have 2 and 2. But since the problem states unique, this case is impossible. So the code can't have a case where two same elements (like in [2,2,3], which is not allowed) so we don't need to handle that.\n\nThus, the code is correct.\n</think>\n\nTo solve this problem, we need to determine if there exists a pair of integers in a given list whose sum equals a specified target value. If such a pair exists, we return their indices in any order; otherwise, we return an empty list.\n\n### Approach\nThe approach to solve this problem efficiently involves using a hash map (dictionary) to store the indices of the numbers as we iterate through the list. Here's a step-by-step breakdown of the approach:\n\n1. **Initialize a Dictionary**: Use a dictionary to keep track of the numbers we have seen so far along with their respective indices.\n2. **Iterate Through the List**: For each element in the list, calculate the complement value needed to reach the target sum.\n3. **Check for Complement**: If the complement value exists in the dictionary, it means we have found a pair of numbers that sum up to the target. Return the indices of these two numbers.\n4. **Store Current Number**: If the complement is not found, store the current number and its index in the dictionary.\n5. **Return Result**: If the loop completes without finding any valid pair, return an empty list.\n\nThis approach ensures that each element is processed exactly once, resulting in an efficient O(n) time complexity, where n is the number of elements in the list.\n\n### Solution Code\n```python\ndef find_pair(nums, k):\n    num_dict = {}\n    for index, num in enumerate(nums):\n        complement = k - num\n        if complement in num_dict:\n            return [num_dict[complement], index]\n        num_dict[num] = index\n    return []\n```\n\n### Explanation\n- **Initialization**: We start by initializing an empty dictionary `num_dict` to keep track of the numbers and their indices as we traverse the list.\n- **Iteration and Calculation**: For each number in the list, we calculate the complement value needed to reach the target sum `k`. This is done by subtracting the current number from the target.\n- **Check and Store**: We check if this complement value has already been seen (exists in `num_dict`). If it does, we return the indices of the current number and its complement. If not, we store the current number and its index in the dictionary.\n- **Efficiency**: This method ensures that we only traverse the list once, making it very efficient with a time complexity of O(n), which is optimal for large lists.\n\nBy using this approach, we leverage the fast lookup capabilities of hash maps to efficiently find pairs without having to resort to a less efficient brute-force method.",
  "r1_solution": "def find_pair_with_sum(nums, k):\n    num_dict = {}\n    for index, num in enumerate(nums):\n        complement = k - num\n        if complement in num_dict:\n            return [num_dict[complement], index]\n        num_dict[num] = index\n    return []",
  "metadata": {
    "prompt_id": "00000096",
    "row_id": 96,
    "seed_ids": [
      "2485",
      "2345",
      "796"
    ],
    "mode": "leetcode",
    "original_instruction": ""
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results0.jsonl"
}