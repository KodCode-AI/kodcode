{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000096_I",
  "question": "Given a list of `n` unique integers, determine if there exists a pair of integers in the list whose sum is equal to a given target integer `k`. If such a pair exists, return the indices of the two integers (0-indexed) in any order. If no such pair exists, return an empty list. Note that the same integer cannot be used twice.",
  "solution": "def find_pair_with_sum(nums, k):\n    \"\"\"\n    Returns a list containing the indices of the two integers whose sum equals k.\n    If no such pair exists, returns an empty list.\n    \"\"\"\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []",
  "test_code": "def test_find_pair_with_sum():\n    assert find_pair_with_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert find_pair_with_index([3, 2, 4], 6) == [1, 2]\n    assert find_pair_with_index([3, 3], 6) == [0, 1]\n    assert find_pair_with_index([1, 2, 3, 4, 5], 10) == []\n    assert find_pair_with_sum([], 10) == []\n\ndef find_pair_with_index(nums, k):\n    return find_pair_with_sum(nums, k)",
  "test_info": [
    {
      "function_name": "find_pair_with_sum",
      "parameter_list": "(nums, k)",
      "function_declaration": "def find_pair_with_sum(nums, k):",
      "docstring": "Returns a list containing the indices of the two integers whose sum equals k.\nIf no such pair exists, returns an empty list."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, so I have this programming problem to solve. The task is to determine if there's a pair of integers in a list whose sum equals a target value k. If such a pair exists, I need to return their indices, else an empty list. Hmm, right.\n\nLet me think about how to approach this. Well, the naive way would be to check every possible pair of elements in the list. But that might be inefficient, especially since for each element, I'd have to loop through the rest of the list. That's O(n^2) time complexity, which isn't great for large n, but maybe it's manageable since the constraints aren't given. Wait, but I'm not sure about the constraints here. Oh, well, regardless, I can consider a better approach.\n\nAnother idea is to use a hash map or dictionary to keep track of the elements we've seen so far. As we iterate through the list, for each element, we can check if the difference between the target (k) and the current element exists in the hash map. If it does, we've found the pair. And since we're looking for indices, we can store the value as the key and the index as the value in the hash map.\n\nWait, but in my case, the problem requires me to return the indices of the two integers. So storing the indices along with the elements is necessary. So for each element, I'll do the following steps:\n\n1. For the current element, calculate the complement which is (k - current_element).\n2. Check if this complement exists in the hash map.\n3. If it exists, return the indices: the index of the complement and the current index.\n4. If not, add the current element and its index to the hash map.\n5. Continue this until either a pair is found or the list is exhausted. If the loop finishes without finding a pair, return an empty list.\n\nThat makes sense. This approach would be O(n) time complexity since each element is checked once and hash lookups are O(1) on average. That's pretty efficient.\n\nLet me think about some test cases.\n\nTest Case 1: list = [2,7,11,15], k=9\nHere, 2 and 7 add up to 9. So the function should return [0,1] or [1,0], but the order shouldn't matter as per the problem statement.\n\nTest Case 2: list = [1,3,4,5], k=8\nHere, 3 and 5 make 8. So indices 1 and 3.\n\nAnother test case where no such pair exists. For example, list = [1,2,3,4], k=10. Then 1+4=5, 2+4=6, 3+4=7, nothing. So return empty list.\n\nEdge case: list has two elements, they sum to k. E.g., list [5,5], but wait the problem says unique integers. So that's allowed? Wait wait, problem statement says \"n unique integers\" but the list has to have unique elements? Oh, wait, the first line says 'given a list of n unique integers' so each element is unique. So [5,5] isn't a possible input. So we don't have to worry about same elements, but their sum.\n\nAnother edge case: the list has only two elements, and their sum is k. Then return their indices.\n\nNow, let me think about how to implement this.\n\nI'll start by initializing an empty dictionary. Let's say in Python, called 'seen'. Then iterate over each element in the list using enumerate to get both the index and the value.\n\nFor each element:\n\nCalculate complement = k - current_element.\n\nCheck if complement is in seen. If yes, then return [seen[complement], current_index].\n\nIf not, add current_element as the key and index as the value to 'seen'.\n\nWait, but what if there are multiple pairs? The way the problem is stated, seems like returning the first such pair found is acceptable. Yes.\n\nTest Case 1 processing:\n\nseen is initially empty.\n\ni=0, element=2. complement is 9-2=7. 7 not in seen, add 2:0.\n\ni=1, element=7. complement=9-7=2. 2 is in seen as 0. So return [0,1].\n\nYes, correct.\n\nAnother test case, like [3,1,4,5], k=8. Let's process:\n\nseen starts empty.\n\ni=0, element=3. complement is 5. Not in seen. Add 3:0.\n\ni=1, element=1. complement is 7. Not present. Add 1:1.\n\ni=2, element=4. complement is 4 (8-4=4). 4 is not in seen. Add 4:2.\n\ni=3, element=5. complement is 3, which is in seen at 0. So return [0,3].\n\nWhich is correct (3+5=8, indices 0 and 3).\n\nSo the algorithm seems to handle that.\n\nWhat if there's no pair?\n\nE.g., [1,2,3], k=7: possible sums are 3,4,5. None equals 7. So function should return empty.\n\nProcessing:\n\ni=0, element=1. complement 6 not in seen. Add 1:0.\n\ni=1, element=2, complement 5: not in seen. Add 2:1.\n\ni=2, element=3, complement 4: not in seen. Add 3:2.\n\nSo no returns; after loop, return empty.\n\nHow about if the list is [4,3,2,1], k=5.\n\nProcessing:\n\ni=0, 4: complement 1. Not in seen.\n\ni=1, 3: complement 2. Not in seen.\n\ni=2, 2: complement 3, which is in seen at 1. So return [1,2] since 3 and 2 are elements at indices 1 and 2. Sum is 5.\n\nYes.\n\nSo the algorithm seems solid.\n\nNow, what about when the same number appears again but earlier hasn't been used? Let's say [3,4,3], but problem statement says the list is unique, so this case is impossible. So in all cases, each element is unique.\n\nWait, wait, problem says \"a list of n unique integers.\" So the list can't have duplicates. So I don't need to handle cases where two same numbers make the sum.\n\nThus, in the code, no issues about adding the same number again.\n\nSo in code:\n\ndef find_pair(nums, k):\n\n    seen = {}\n\n    for index, num in enumerate(nums):\n\n        complement = k - num\n\n        if complement in seen:\n\n            return [seen[complement], index]\n\n        seen[num] = index\n\n    return []\n\nBut wait, the problem says that the same integer cannot be used twice. So for example, in [1,3,5], target is 8, which would require 3 and 5. Wait, that's 8? 3+5 is 8, yes. So indices 1 and 2. So the code works.\n\nWhat about for nums = [0, 10], k=10. Because 0 is in the list, and 10 is also. 0's complement is 10-0=10, which isn't in the map the first time, then 10 is processed, its complement is 0, which is in map at index 0. So returns [0,1], which is correct.\n\nAnother case: nums = [5], k=5. Only one element. So no pair. Return empty.\n\nSo the code seems to handle all these cases.\n\nWait, in Python, if the function is within a specific scope, do I need to return a list? Yes, the problem expects a list of two integers or an empty list.\n\nAnother test case: nums = [9, -5, 7, 3], k = 4. Let's see: 9's complement is -5 (4-9 = -5). Then -5 is added. Next, the second element is -5, but its complement is 9 (4 - (-5) = 9). So when processing -5 at index 1, the complement 9 is already in seen (index 0). So returns [0,1], sum 9+(-5)=4, which is correct.\n\nYes.\n\nSo in code, the process should be:\n\n- Iterate through each element using enumerate.\n\n- For current element, compute (k - num) as complement.\n\n- If complement is in seen, return [seen[complement], current index].\n\n- Else, add num and index to 'seen' dictionary.\n\nNow, code implementation in Python.\n\nWait, in the code above, in the function find_pair(nums, k), if during iteration, a pair is found, returns [seen[complement], index] as the two indices. But what if the nums list is a list of n unique integers, and the loop processes from left to right\u2014so the first pair found is returned, which may not necessarily be the pair with the earliest possible indexes, but is that a problem? The problem says to return the indices in any order.\n\nFor example, if there are two pairs: [i,j] and [k,l], and the function returns the first one it finds, regardless of their indices.\n\nSo it's acceptable, no problem. Because the function just needs to return any valid pair.\n\nSo, the code as written should handle all cases correctly.\n\nTesting again the example in LeetCode's problem, which may have certain test cases. Wait no, the problem isn't from LeetCode, but just similar.\n\nPotential issues:\n\n- Handling the case where the complement is the same number but not yet in 'seen' because it's processed later. For example, if the pair is [num, num2] later in the list.\n\nBut because in our approach, we add the current num to 'seen' after checking for the complement, any previous numbers are only those before current index. So for a[i] and a[j], j>i, they will be considered as a valid pair.\n\nYes.\n\nI think this approach covers all cases.\n</think>\n\nTo solve this problem, we need to determine if there exists a pair of integers in a given list whose sum is equal to a specified target value. If such a pair exists, we return their indices; otherwise, we return an empty list.\n\n### Approach\nThe approach uses a hash map (dictionary) to efficiently keep track of the elements we have seen so far as we iterate through the list. Here's a detailed breakdown:\n\n1. **Hash Map Initialization**: We initialize an empty dictionary called `seen` to store the elements and their respective indices as we iterate through the list.\n2. **Iterate Through List**: For each element in the list, we calculate the complement, which is the difference between the target value `k` and the current element. This complement represents the value needed to form a pair that sums up to `k` when added to the current element.\n3. **Check for Complement**: If the complement is found in the `seen` dictionary, it means we have already encountered the number that can form the required pair with the current element. We then return the indices of these two numbers.\n4. **Update Hash Map**: If the complement is not found, we add the current element and its index to the `seen` dictionary and continue to the next element.\n5. **Return Result**: If the loop completes without finding any such pair, we return an empty list.\n\nThis approach ensures that we efficiently check each element in O(1) average time for each hash map operation, leading to an overall time complexity of O(n), where n is the number of elements in the list.\n\n### Solution Code\n```python\ndef find_pair(nums, k):\n    seen = {}\n    for index, num in enumerate(nums):\n        complement = k - num\n        if complement in seen:\n            return [seen[complement], index]\n        seen[num] = index\n    return []\n```\n\n### Explanation\n- **Hash Map Usage**: The hash map `seen` is used to store each number and its index as we iterate through the list. This allows for quick lookups to check if the complement of the current number exists.\n- **Complement Calculation**: For each number, the complement is calculated as `k - num`. Checking if this complement exists in `seen` tells us if there is a previous number that can form the required sum.\n- **Index Storage**: By storing the index of each number as we iterate, we can quickly return the indices of the pair when a valid complement is found.\n\nThis method ensures that we efficiently solve the problem with optimal time complexity, making it suitable for large lists of integers.",
  "r1_solution": "def find_pair_with_sum(nums, k):\n    seen = {}\n    for index, num in enumerate(nums):\n        complement = k - num\n        if complement in seen:\n            return [seen[complement], index]\n        seen[num] = index\n    return []",
  "metadata": {
    "prompt_id": "00000096",
    "row_id": 96,
    "seed_ids": [
      "2485",
      "2345",
      "796"
    ],
    "mode": "leetcode",
    "original_instruction": ""
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results1.jsonl"
}