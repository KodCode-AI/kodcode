{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000096_I",
  "question": "Given a list of `n` unique integers, determine if there exists a pair of integers in the list whose sum is equal to a given target integer `k`. If such a pair exists, return the indices of the two integers (0-indexed) in any order. If no such pair exists, return an empty list. Note that the same integer cannot be used twice.",
  "solution": "def find_pair_with_sum(nums, k):\n    \"\"\"\n    Returns a list containing the indices of the two integers whose sum equals k.\n    If no such pair exists, returns an empty list.\n    \"\"\"\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []",
  "test_code": "def test_find_pair_with_sum():\n    assert find_pair_with_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert find_pair_with_index([3, 2, 4], 6) == [1, 2]\n    assert find_pair_with_index([3, 3], 6) == [0, 1]\n    assert find_pair_with_index([1, 2, 3, 4, 5], 10) == []\n    assert find_pair_with_sum([], 10) == []\n\ndef find_pair_with_index(nums, k):\n    return find_pair_with_sum(nums, k)",
  "test_info": [
    {
      "function_name": "find_pair_with_sum",
      "parameter_list": "(nums, k)",
      "function_declaration": "def find_pair_with_sum(nums, k):",
      "docstring": "Returns a list containing the indices of the two integers whose sum equals k.\nIf no such pair exists, returns an empty list."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to solve this problem where I have a list of unique integers and a target k. I have to find if there are two numbers in the list that add up to k. If they do, return their indices; otherwise, return an empty list.\n\nHmm, first, I remember that this is a classic two-sum problem. The straightforward approach is to use a hash map to store the elements and their indices as we iterate through the list. For each element, we check if the complement (which is k minus the current element) exists in the hash map. Wait, but wait\u2014since the elements are unique, each element can be used once, and we can't use the same element twice, right.\n\nWait, so the steps could be like this:\n\n1. Create an empty dictionary to hold the numbers as keys and their indices as values.\n2. Iterate through each number in the list:\n   a. For the current number, calculate the complement as k - number.\n   b. Check if the complement is already in the dictionary.\n   c. If it is, then return the current index and the index of the complement.\n   d. If it's not, add the current number and its index to the dictionary.\n3. If after processing all elements no pair is found, return an empty list.\n\nWait, but what about the order of indices? Like, it says that the pair can be returned in any order. So, for example, if we find the complement first, the index might be earlier, but we can just return as is.\n\nLet me think of an example. Suppose the list is [2, 7, 11, 15] and k is 9. So for 2, complement is 7, which would not be in the map yet. Then for 7, complement is 2, which is already in the map. So return indices 0 and 1.\n\nAnother example: list is [3, 1, 4, 4]. Wait no, the problem says the list has unique integers, so that's not possible. So in the list, all elements are unique.\n\nAnother test case: list is [1, -1], k is 0. It should return the two indices.\n\nWait, but each element is unique, but that's okay because they are different elements.\n\nAnother corner case is if the list has exactly two elements, and their sum is k. Then return those two indices.\n\nWhat about if no such pair exists? E.g., list [1, 2, 3], k=7. 1+2=3 <7, 1+3=4 <7, 2+3=5 <7. So return empty.\n\nSo the algorithm should efficiently do this in O(n) time. Using a hash map is perfect.\n\nLet's sketch the code.\n\nWe can initialize an empty dictionary, say seen = {}.\n\nThen loop through each index i, and for each num in the list at i:\n\ncomplement = k - num\n\nif complement in seen, then return [seen[complement], i]\n\nelse, add num: i to seen.\n\nAfter all elements and no pair found, return empty list.\n\nWait, wait a minute. Because the list may have negative numbers, but that's handled automatically as the complement is k-num.\n\nYes, that's correct.\n\nLet me test the logic with some examples.\n\nExample 1:\n\nList = [2, 7, 11, 15], k=9.\n\nProcessed as follows:\ni=0, num=2. complement is 7. 7 not in seen. Add 2:0.\n\ni=1, num=7. complement 2 is in seen. Return [0,1].\n\nCorrect.\n\nAnother example:\n\nList = [3, 5, 8], k=13.\n\n3: complement 10 not in map.\n5: complement 8 not in map.\n8: complement 5, which is already in map. So return [1,2].\n\nAnother test case: no pair. list [1,2,4], k=8. 1+2=3, 1+4=5, 2+4=6. Nothing.\n\nAnother consideration: what if the same element is used? Like in a list with multiple instances, but since the list is given as having unique integers, that's not an issue.\n\nWait, but what about when the list has length 1 or zero? Oh, in the problem statement, n can be as low as 2? Wait, no\u2014n is the list of unique integers. So the list can be any size, but for a pair. So, if the list has less than 2 elements, automatically no solution. For example, list of 1, and any k.\n\nSo in code, first check if the list has less than 2 elements.\n\nWait, no, because for a list of exactly one element, obviously no pair exists.\n\nSo in code:\n\nn is len(nums). If n < 2, return empty.\n\nWait but let's see for n=0: same, returns empty.\n\nSo in code:\n\ndef two_sum(nums, k):\n\n    seen = {}\n\n    for i, num in enumerate(nums):\n\n        complement = k - num\n\n        if complement in seen:\n\n            return [seen[complement], i]\n\n        seen[num] = i\n\n    return []\n\nYes. That's the code.\n\nWait but wait: what if the list has a zero? Like if target is 0 and there's a zero in the list. For example, list = [0, 1, 2], target k=0. Then when num is 0, complement is 0. Check if 0 is in seen. It's no, for the first 0. Then when processing 0, we compute 0, and find nothing in seen (since seen is empty). Then we add 0:0. Then when processing 1, complement is -1, not in seen. Then processing 2, complement is -2, not in seen. So returns empty. But wait, that's correct because two elements can't sum to 0 unless they are the same. Since the list is [0, 1, 2], 0 can only be added to another 0, but the list has unique integers, so it's not possible.\n\nWait, wait that's a misunderstanding. The list can have a zero, but the two-sum is only possible if another zero exists, but since the elements are unique, zero can't be used. So in the case where the list is [0, 1], target 0: no, because 0 is only once. So the code correctly handles that.\n\nAnother case: list is [3,5, -5], target 0. So 5 and -5 sum to 0. Let's see when i=1, num=5: complement is -5. Is -5 in the map? The current map has 3. Not present.\n\nThen add 5:1. Then when i=2, num=-5: complement is 5. Is 5 in the map? Yes, index 1. So return [1,2]. Correct.\n\nSo yes, code works.\n\nI think this should handle all cases.\n\nAnother test: nums = [1, 2, 3], k=5.\n\nAt i=0, 1: add 1.\n\ni=1, 2: complement 3 not in seen yet. Add 2.\n\ni=2, 3: complement is 2, which is in seen. So return [1, 2], since seen[2]=1 and i=2.\n\nYes, correct.\n\nAnother case where the two elements are in reverse order. Let's see:\n\nnums = [3, 5], k=8. Then during i=0, num=3: complement 5 is not in seen. Add 3.\n\nAt i=1, num=5: complement 3 is in seen. So return [0,1].\n\nCorrect.\n\nAnother scenario: nums = [4, 6], k=10. So 4+6=10. So i=0, 4: add to seen.\n\ni=1: 6, complement 4 is in seen, so return [0, 1].\n\nYes.\n\nSo I think the code works.\n</think>\n\nTo solve this problem, we need to determine if there exists a pair of integers in a given list whose sum equals a specified target integer `k`. If such a pair exists, we return their indices; otherwise, we return an empty list.\n\n### Approach\nThe approach to solve this problem efficiently involves using a hash map (dictionary) to keep track of the elements and their indices as we iterate through the list. Here's a step-by-step breakdown of the approach:\n\n1. **Initialize a Dictionary**: Create an empty dictionary to store the elements of the list as keys and their corresponding indices as values.\n\n2. **Iterate Through the List**: For each element in the list, compute the complement (i.e., the difference between the target `k` and the current element).\n\n3. **Check for Complement**: Check if this complement exists in the dictionary. If it does, return the indices of the current element and the complement. If not, add the current element and its index to the dictionary.\n\n4. **Return Result**: If no such pair is found by the end of the iteration, return an empty list.\n\nThis approach ensures that we efficiently find the pair in O(n) time complexity, where n is the number of elements in the list, as each element is processed exactly once.\n\n### Solution Code\n```python\ndef two_sum(nums, k):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n```\n\n### Explanation\n- **Dictionary Initialization**: We use a dictionary `seen` to store each number and its index as we iterate through the list.\n- **Complement Calculation**: For each number, we calculate `complement` as `k - num`. This helps us determine if there exists another number in the list that can sum up to `k`.\n- **Check in Dictionary**: By checking if `complement` is already in the dictionary, we can determine if we have previously encountered a number that can form the required sum with the current number.\n- **Index Return**: If the complement is found, we immediately return the indices of the complement and the current number.\n- **Empty List Return**: If the loop completes without finding any such pair, an empty list is returned.\n\nThis method efficiently handles all edge cases, including negative numbers and zeros, ensuring that we find the correct pair or determine their absence in linear time.",
  "r1_solution": "def find_pair_with_sum(nums, k):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = k - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
  "metadata": {
    "prompt_id": "00000096",
    "row_id": 96,
    "seed_ids": [
      "2485",
      "2345",
      "796"
    ],
    "mode": "leetcode",
    "original_instruction": ""
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results2.jsonl"
}