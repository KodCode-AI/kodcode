{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000056_I",
  "question": "Given an unsorted array of integers `nums`, return the maximum number of **distinct** elements in any **continuous subarray** of size `k`. A **continuous subarray** is defined as a subarray that contains `k` consecutive elements from the original array.",
  "solution": "from collections import defaultdict\n\ndef max_distinct_elements_in_subarray(nums, k):\n    \"\"\"\n    Given an unsorted array of integers and a positive integer k, returns the maximum number of distinct elements\n    in any continuous subarray of size k.\n    \"\"\"\n    if k == 0:\n        return 0\n    distinct_count = defaultdict(int)\n    max_distinct = 0\n    left = 0\n    \n    for right in range(len(nums)):\n        distinct_count[nums[right]] += 1\n        while right - left + 1 > k:\n            distinct_count[nums[left]] -= 1\n            if distinct_count[nums[left]] == 0:\n                del distinct_count[nums[left]]\n            left += 1\n        max_distinct = max(max_distinct, len(distinct_count))\n    \n    return max_distinct",
  "test_code": "from solution import max_distinct_elements_in_subarray\n\ndef test_max_distinct_elements_in_subarray():\n    assert max_distinct_elements_in_subarray([1, 2, 1, 3, 4, 3], 3) == 3\n    assert max_distinct_elements_in_subarray([1, 2, 1, 3, 4, 3, 5], 3) == 3\n    assert max_distinct_elements_in_subarray([1, 2, 1, 3, 4, 3, 5], 4) == 4\n    assert max_distinct_elements_in_subarray([1, 2, 1, 3, 4, 3, 5], 7) == 5\n    assert max_distinct_elements_in_subarray([1, 1, 2, 2, 3, 3], 3) == 2\n    assert max_distinct_elements_in_subarray([1, 2, 3, 4, 5, 6], 1) == 1\n    assert max_distinct_elements_in_subarray([], 3) == 0\n    assert max_distinct_elements_in_subarray([1, 2, 3, 4, 5, 6], 0) == 0",
  "test_info": [
    {
      "function_name": "max_distinct_elements_in_subarray",
      "parameter_list": "(nums, k)",
      "function_declaration": "def max_distinct_elements_in_subarray(nums, k):",
      "docstring": "Given an unsorted array of integers and a positive integer k, returns the maximum number of distinct elements\nin any continuous subarray of size k."
    }
  ],
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, so I have this problem where I'm given an unsorted array of integers called nums, and I need to return the maximum number of distinct elements in any continuous subarray of size k. Hmm, let me think about how to approach this.\n\nWait, wait, a continuous subarray of size k. So for example, in an array like [1,2,3,4], the continuous subarrays of size 3 are [1,2,3], [2,3,4], right? Each has 3 elements, but perhaps overlapping.\n\nSo the task is to find among all these possible k-length subarrays, which one has the maximum number of distinct elements. So for each window of size k, I need to compute how many unique elements are present, and then take the maximum of all those.\n\nLet me think about how to compute this efficiently. I remember that sliding window techniques are often used for problems involving subarrays. But in this case, since the elements are not necessarily unique and we need the count of distinct elements, how can I efficiently track this as the window slides?\n\nLet's consider a brute force approach first, just to understand the problem. For each possible starting index i, I can take the subarray from i to i+k-1 and count the distinct elements. Then, keep track of the maximum. However, this is O(n*k), which might be acceptable if k is small, but if n is large and k is also large, this could be inefficient. But maybe for the problem constraints, this is acceptable?\n\nI'm not sure about the problem constraints, but for the purposes of an interview, I might consider this approach first as it's straightforward.\n\nSo let's think about the steps:\n\n1. Iterate through each possible starting index i of the subarray. That will run from 0 to n - k inclusive (since the subarray has length k).\n2. For each i, extract the subarray nums[i:i+k]\n3. Convert this subarray into a set to get the unique elements.\n4. Find the size of this set, which is the count of distinct elements.\n5. Keep track of the maximum size encountered.\n\nLet me think of an example. Suppose nums is [1,2,1,3,2,2,4] and k = 3. Let's see:\n\nPossible subarrays of size 3:\n[1,2,1] \u2192 {1,2} \u2192 size 2\n[2,1,3] \u2192 {1,2,3} \u2192 size 3\n[1,3,2] \u2192 {1,3,2} \u2192 size 3\n[3,2,2] \u2192 {3,2} \u2192 size 2\n[2,2,4] \u2192 {2,4} \u2192 size 2\n\nSo the maximum is 3.\n\nAnother example: nums = [1,2,3,2,1,4,5], k=4\nSubarrays are:\n[1,2,3,2] \u2192 {1,2,3} \u2192 3\n[2,3,2,1] \u2192 {2,3,1} \u2192 3\n[3,2,1,4] \u2192 {3,2,1,4} \u21924\nSo the maximum would be 4.\n\nSo the approach is correct. But the question is whether this brute force method is efficient enough.\n\nIn terms of time complexity, the brute force approach has O(n * k) time, because for each of the (n -k +1) subarrays, we process k elements. But when n is large (like 10^5), this could be O(1e5 * 1e5) = 1e10 operations, which is way too slow.\n\nSo, the brute force approach won't work for large n. We need a more efficient way.\n\nSo moving beyond the brute force approach, I think I need to find a way to compute the number of distinct elements in each sliding window without reprocessing each element every time. Maybe using a sliding window technique with a hashmap to track the count of each element in the current window, and keeping a variable for the current number of distinct elements.\n\nLet's outline this approach:\n\nInitialize a hashmap (like a dictionary in Python) to keep track of the count of each element in the current window. Also, have a variable current_distinct that keeps track of the number of unique elements in the current window.\n\nThe sliding window has a left and right pointer. We'll move the right pointer from 0 to n-1. When adding a new element (at right), if it's not in the map or its count is zero before adding, we increment current_distinct. Then, we add the element to the map (increment its count by 1).\n\nOnce the window size equals k (i.e., right - left + 1 == k), we need to check if this window is the maximum. So before processing, when the window is of size k, we calculate the current_distinct and compare it to the global maximum.\n\nBut wait, how do we handle when the window exceeds size k? We need to slide the left pointer to the right, removing elements from the hashmap as necessary, and decrementing current_distinct when necessary.\n\nSo, more precisely:\n\nWe move right from 0 to n-1:\n\n- For each right, add nums[right] to the window.\n   - If nums[right] is not in the hashmap or has a count of 0: add it, increment count, current_distinct +=1\n   - Else: increment count in the hashmap.\n\n- After adding, check if window exceeds size k:\n   - is (right - left + 1) > k?\n      - If yes, need to remove the leftmost element.\n         - While window size is bigger than k:\n             - Decrement count of nums[left] in hashmap by 1.\n             - If the count becomes zero: current_distinct -=1\n             - left +=1\n\nBut wait, the condition here is that when the window size exceeds k, we have to move the left pointer until the window is within k.\n\nBut in the problem, the subarrays are exactly of size k. So perhaps the approach can be: for each right, when the window's size is k, process it.\n\nSo perhaps wait until right has moved such that the window is exactly k elements. Then, compute and track.\n\nLet me try to formalize:\n\nWe can move the right pointer. For each step:\n\n- Add nums[right] to the map as per above.\n- Then, while the window is larger than k, move left:\n   - Remove nums[left], decrement in the map.\n   - If the count goes to zero, decrement current_distinct.\n   - Move left.\n- Now, if the window size is exactly k:\n   - Update the max_distinct with current_distinct.\n\nWait, but for the condition to reach window size k, after moving the left, the window would be k. So perhaps, every time after moving the right and adjusting left, we can check if the window is exactly k.\n\nAlternatively, we can just process the window when right is at i and left is at i -k +1 (for i >=k-1). Hmm.\n\nWait, no. Because adding a new element right may have caused the left to be incremented until the window is size <=k.\n\nWait, let's think again.\n\nWe can always ensure that left starts at a position such that the window is at most k elements. So whenever right is i, left starts from where it left off.\n\nFor instance, for each element right, we add it to the window, then while window size (right - left +1) >k, we move left.\n\nSo, the window is always of size at most k.\n\nBut we're only interested in windows of exactly size k. So, when right >= k-1, the window can potentially be size k.\n\nSo for each right >=k-1, the window after moving left will adjust to exactly k elements, assuming the array has enough elements.\n\nWait, perhaps I should iterate right from 0 to n-1, and for each right, add it to the window. Then while (window size >k, i.e., right-left+1 >k?), yes, we need to move left. But for window sizes >k, not sure.\n\nWait, no. For the original problem, each window is exactly k elements. So the way to model this is:\n\nWe can track the window, but always after adding a new element and adjusting, only process the window size when it's exactly k.\n\nSo the process would be:\n\nInitialize left =0, right=0, current_distinct=0, max_distinct=0.\n\nCreate a frequency map.\n\nIterate right from 0 to n-1:\n\n   add nums[right] to freq map:\n      if count was 0 before: current_distinct +=1\n      count +=1\n\n   while (right - left +1) >k:\n      remove nums[left]:\n          count = freq[nums[left]] -=1\n          if count ==0:\n              current_distinct -=1\n      left +=1\n\n   If window size is equal to k (which after the while loop, it's guaranteed to be <=k. So when the window was exactly k before, after processing, the window is now k. So the step is, after moving left, check if the window size is now k.\n\n   Or, perhaps, when (right - left +1) ==k, then process and update max_distinct.\n\nYes.\n\nSo, after adding the right and while sliding left until window is <=k, if after that (right - left +1) ==k, then compute and update.\n\nIn other words, in the code:\n\nfor right in 0 to len(nums)-1:\n\n   add nums[right] to the map as per.\n\n   while right - left +1 > k:\n      remove left element...\n      left +=1\n\n   if right - left +1 ==k:\n       max_distinct = max(max_distinct, current_distinct)\n\nWait, that makes sense.\n\nSo for every right, after adjusting left, if the window is size k, compute the count.\n\nTesting this with the second example:\n\nnums = [1,2,3,2,1,4,5]\nk=4\n\nmax_distinct.\n\nLet's see:\n\nInitially, left=0, current_distinct=0.\n\nright=0:\n   add 1.\n   window size 0-0+1=1, which is <=4.\n\n   since window size is 1 !=4, no processing.\n\nright=1:\n   add 2. current_distinct is 2.\n   window size 2 <4.\n\nright=2:\n   add 3. current_distinct 3.\n   window size 3<4.\n\nright=3: nums[3] is 2 already in the map.\n\n   current_distinct remains 3.\n   count of 2 is now 2.\n\n   window size 4?  right-left+1=4. So yes.\n\n   compare to max, which is 0. So max is 3.\n\n   so the window is [1,2,3,2], 3 distinct elements.\n\nright=4: add 1.\n\n   Since window size is 4: right-left+1 =5>4. So we need to move left:\n\n   nums[left]=1, count decreases by 1 (from 1 to 0). So current_distinct reduces by 1 to 2.\n\n   left becomes 1.\n\n   Now, window is from 1 to 4: [2,3,2,1]. size 4.\n\n   current_distinct is 3 (because 2,3,1 are distinct).\n\n   max_distinct is now 3.\n\nright=5:\n\n   add 4. So 2->already exists, current_distinct increases to 4.\n\n   window size is 5>4.\n\n   So:\n\n   move left to 1+1=2:\n\n   nums[1] is 2. count was 2, now 1. not zero.\n\n   Still window size is 5-2+1=4? Wait, right is 5, left is 2. 5-2+1=4, which is correct.\n\n   no further movement.\n\n   So window is size 4: elements [3,2,1,4] \u2192 all distinct. current_distinct is 4. So max becomes 4.\n\nWait, wait. I think that step is correct.\n\nSo when right is at 5, after adding 4, we enter the while loop because window size is 4 +1 (right=5, left was at 1, hence window size was 5-1+1=5>4).\n\nSo while window size >4, move left:\n\n- Remove nums[left=1]: it's 2. Its count was 2, after decrement it is 1. Current distinct remains 4? Wait no:\n\n   When we removed 2, it's count was 2 \u2192 1. So it's not zero, current_distinct remains same.\n\n   So left becomes 2, window size 5-2+1=4, which is not >4. So loop ends.\n\n   Then, window size is 4, so compare: current_distinct is 4, which is higher than previous max (3). So max becomes 4.\n\nWait, but when adding 4 to the window, which is like introducing a new element. So when right is 5, the current window contains 3,2,1,4, which increases the distinct count.\n\nSo this approach should correctly track it.\n\nSo this approach should work.\n\nNow, considering that the frequency map is correctly updated, and that moving left correctly decrements counts and possibly reduces the distinct count when an element is removed with count going to zero.\n\nNow, in terms of time complexity, since each element is added once and removed once, the total operations are O(n), which is efficient.\n\nNow, coding this in Python.\n\nWe can have a dictionary called freq, defaulting to zero. Each element is added to freq, and when the window needs to shrink, the left elements are removed, reducing their freq.\n\nLet me outline the steps in code:\n\n- Initialize left=0, current_distinct=0, max_distinct=0\n- Create a frequency dictionary (defaultdict or regular dict).\n- Iterate right in range(len(nums)):\n   num = nums[right]\n   if num in freq:\n      if freq[num] == 0:\n          current_distinct +=1\n      freq[num] +=1\n   else:\n      freq[num] = 1\n      current_distinct +=1\n\n   # Now, check if window is larger than k\n   while (right - left +1) >k:\n      left_num = nums[left]\n      freq[left_num] -=1\n      if freq[left_num] ==0:\n          current_distinct -=1\n      left +=1\n\n   # Now check if the window is exactly k\n   if (right - left +1) ==k:\n       if current_distinct > max_distinct:\n           max_distinct = current_distinct\n\n- return max_distinct\n\nWait, but in Python, the initial values in the freq dictionary would be 0, right?\n\nYes.\n\nWait, no. If I use a normal dict, checking 'if num in freq' will create a key for it if it wasn't present, and assign it an initial value of 1 when added. But what about after removing it? Let's think.\n\nBut perhaps using a defaultdict from collections will make it easier, since it automatically initializes missing keys to 0.\n\nBut wait, perhaps in the code, when num is not in freq, it's set to 1.\n\nNo, wait, perhaps it's better to use a defaultdict(int) so that we can avoid checking if the key exists.\n\nAlternatively, we can use a get method.\n\nLet me write this properly.\n\nLet's think about:\n\nOn adding a new element, num = nums[right]:\n\nIf freq[num] is 0:\n\n   current_distinct +=1\n\nfreq[num] +=1\n\nBut how to check if it's zero? Because even if the element was present but its count had been decremented to zero, it's as if it's not present.\n\nAlternatively, using a defaultdict(int) and always using:\n\nif freq[num] == 0 before incrementing is correct.\n\nAlternatively, to handle this, perhaps:\n\nBut to organize:\n\n- When we add a new num:\n\n   if freq[num] was 0: it means either it's a new element, or it was present (count>0) and then removed. So whether it's a new element, or a previously present one, if the count was zero before adding, including it now increases the distinct count.\n\n   So:\n\n   Count = freq.get(num, 0)\n   if count ==0:\n       current_distinct +=1\n   freq[num] = Count +1\n\nBut wait, then in the case where the element was added, then removed (count goes to zero), adding it again would correctly increase current_distinct by 1.\n\nYes.\n\nBut using a regular dictionary, whenever a key is added, it's stored, but when it's removed, its count is zero.\n\nSo, perhaps in the code:\n\nfrom collections import defaultdict\n\ndef maximumNumberOfDistinctElements(nums, k):\n    freq = defaultdict(int)\n    left = 0\n    max_distinct = 0\n    current_distinct = 0\n\n    for right in range(len(nums)):\n        num = nums[right]\n        if freq[num] == 0:\n            current_distinct +=1\n        freq[num] +=1\n\n        # Now check if window is too big\n        while (right - left +1 ) >k:\n            left_num = nums[left]\n            freq[left_num] -=1\n            if freq[left_num] ==0:\n                current_distinct -=1\n            left +=1\n\n        # Check if current window is exactly k\n        if (right - left +1) ==k:\n            if current_distinct > max_distinct:\n                max_distinct = current_distinct\n\n    return max_distinct\n\nWait, let's test this on the earlier examples.\n\nTest case 1: nums = [1,2,3,4], k=2.\n\nPossible subarrays:\n\n[1,2] \u2192 2 distinct\n[2,3] \u2192 2\n[3,4] \u21922\nSo max is 2.\n\nLet's run the code.\n\nright starts at 0:\n\nnum is 1. freq was 0, so current_distinct=1, freq[1]=1.\n\nwindow size=1, so not equal to 2.\n\nright=1: num=2, freq[2] is 0 \u2192 current_distinct=2, freq[2]=1.\n\nwindow size=2, which is k=2. So max_distinct is 2.\n\nright=2: num=3, current_distinct becomes 3.\n\nfreq[3]=1.\n\nwindow size=3>2, enter loop:\n\nleft=0: remove 1 \u2192 freq[1]=0. current_distinct is 3\u2192 2.\n\nleft=1.\n\nwindow size 2: right=2, left=1 \u2192 2,3. current_distinct is 2.\n\nWhich is 2, which is equal to max_distinct.\n\nright=3: num=4, current_distinct becomes 3.\n\nwindow size= right-left+1=3-1+1=3>2.\n\nenter loop:\n\nremove nums[1]=2: freq[2] from 1 to 0. current_distinct becomes 2.\n\nleft becomes 2.\n\nwindow size: 3-2+1=2. So process it: current_distinct is 2 \u2192 same as max.\n\nSo the maximum obtained when the window was [1,2], with 2 as the value. So code returns 2.\n\nWhich is correct.\n\nAnother test case: earlier example where k=4: [1,2,3,2,1,4,5]. Max is 4.\n\nLet me simulate.\n\nfreq starts empty.\n\nleft=0.\n\ncurrent_distinct=0.\n\nmax_distinct=0.\n\nright=0: num=1.\n\nfreq[1]=0 before \u2192 current_distinct=1.\n\nfreq[1]=1.\n\nwindow size 0-0+1=1 <4.\n\nproceed.\n\nright=1: num=2. freq[2]=0 \u2192 current_distinct=2.\n\nfreq[2]=1.\n\nwindow size 2 <4.\n\nright=2: num=3 \u2192 current_distinct 3.\n\nwindow size 3 <4.\n\nright=3: num=2 is in freq, but freq was 1 \u2192 since it's 1, adding again freq is 2.\n\nBut since freq wasn't 0, current_distinct doesn't change (remains 3).\n\nwindow size=4 (right=3, left=0: 3-0+1=4). So it's k=4.\n\ncurrent_distinct is 3 (elements 1, 2,3).\n\nSo max_distinct is 3.\n\nright=4: num=1. freq[1] was 1 in the current window (elements 0-3).\n\nWait, window is [1,2,3,2]. current_distinct is 3.\n\nAdding 1:\n\nAt right=4, add 1 \u2192 freq after adding becomes 2 (since before it was 1 in the window 0-3. So freq[1] is 2.\n\nBut in the new window, 4 is added.\n\nWait, perhaps I'm getting confused.\n\nWait, right=3, window is 0-3 (inclusive). right=4, the steps are:\n\nAdd 1: nums[4] is 1.\n\nCheck freq[1]: it was 1 before in this window (since at right=3, left=0, the window is [1 is present twice?].\n\nWait, when right=3, freq[1] was 1 (because the window is 0-3, which includes two 1's? Wait no: [1, 2,3,2] \u2192 two 1's (nums[0]=1 and nums[4] is 1, but right is 3. So before right is 4, the current window is [0,1,2,3].\n\nLet me clarify:\n\nAfter right=3, the window is [1,2,3,2], freq is 1:2, 2:2,3:1.\n\ncurrent_distinct is 3.\n\nNow, when right=4 (num=1), what happens?\n\nAdding 1: freq[1] was 2? No, because when we processed right=0, added 1. Then, at right=3, the freq is for 1:1, because it's the earlier case.\n\nWait, perhaps my simulation is off. Alternatively, perhaps this requires a more detailed step-by-step.\n\nBut to save time, perhaps just implementing this code.\n\nAnother thing to consider is when k is zero, but the problem probably states that k is positive since a subarray can't have zero elements.\n\nWait, the function could have k being zero, but then what? But the problem says size 'k' so perhaps k is a positive integer.\n\nAnother case to think about: what if all elements are the same and k=5? Then the maximum is 1.\n\nTesting code:\n\nnums = [5,5,5,5,5], k=2.\n\nExpected output:1.\n\nLet's see.\n\nright=0: add 5, freq becomes 1 \u2192 current_distinct=1.\n\nwindow size 1. No.\n\nright=1: add 5 (count becomes 2). current_distinct remains 1.\n\nwindow size 2 \u2192 k=2.\n\nmax_distinct is 1.\n\nso correct.\n\nAnother case: k=0? Well, function as per code could return 0, but I suppose k is always>=1.\n\nSo code seems correct.\n\nThus, the code for this problem is as described.\n</think>\n\nTo solve this problem, we need to determine the maximum number of distinct elements in any continuous subarray of a given size `k` from an unsorted array of integers `nums`.\n\n### Approach\nThe approach to solving this problem efficiently involves using a sliding window technique combined with a hash map to keep track of the elements and their counts within the current window. This allows us to efficiently add and remove elements as the window slides through the array, ensuring that we only process each element a constant number of times.\n\nHere's a detailed breakdown of the approach:\n\n1. **Sliding Window Technique**: We maintain a window of size `k` that slides through the array. The window is defined by two pointers, `left` and `right`, where `right` expands the window to include new elements and `left` contracts it when the window size exceeds `k`.\n\n2. **Hash Map (Frequency Dictionary)**: We use a hash map to keep track of the frequency of each element within the current window. This helps in quickly determining the number of distinct elements in the window.\n\n3. **Counting Distinct Elements**: As we expand the window by moving the `right` pointer, we update the frequency of the elements. If an element is encountered for the first time within the current window, it increases the count of distinct elements.\n\n4. **Adjusting the Window**: Whenever the window size exceeds `k`, we move the `left` pointer to the right, removing elements from the hash map as they exit the window. This ensures the window size remains exactly `k` when we check for the maximum number of distinct elements.\n\n### Solution Code\n```python\nfrom collections import defaultdict\n\ndef maximumNumberOfDistinctElements(nums, k):\n    freq = defaultdict(int)\n    left = 0\n    max_distinct = 0\n    current_distinct = 0\n\n    for right in range(len(nums)):\n        num = nums[right]\n        if freq[num] == 0:\n            current_distinct += 1\n        freq[num] += 1\n\n        # Ensure the window size does not exceed k\n        while (right - left + 1) > k:\n            left_num = nums[left]\n            freq[left_num] -= 1\n            if freq[left_num] == 0:\n                current_distinct -= 1\n            left += 1\n\n        # Check if the window size is exactly k\n        if (right - left + 1) == k:\n            if current_distinct > max_distinct:\n                max_distinct = current_distinct\n\n    return max_distinct\n```\n\n### Explanation\n- **Initialization**: We start by initializing a hash map `freq` to keep track of the frequency of each element in the current window, and variables `left`, `max_distinct`, and `current_distinct` to track the current window's left index and the counts of distinct elements.\n\n- **Expanding the Window**: As we iterate over each element with the `right` pointer, we update its frequency in the hash map. If the element was not present before, we increment the count of distinct elements.\n\n- **Adjusting the Window**: If the window size exceeds `k`, we increment the `left` pointer, decrement the frequency of the element at the `left` index, and adjust the count of distinct elements if an element is removed completely from the window.\n\n- **Tracking Maximum Distinct Elements**: Each time the window size is exactly `k`, we check if the number of distinct elements in the current window is the highest encountered so far, updating `max_distinct` if necessary.\n\nThis approach ensures that each element is processed in constant time, leading to an overall time complexity of O(n), where n is the length of the input array. This makes the solution efficient and suitable for large input sizes.",
  "r1_solution": "from collections import defaultdict\n\ndef max_distinct_elements_in_subarray(nums, k):\n    freq = defaultdict(int)\n    left = 0\n    max_distinct = 0\n    current_distinct = 0\n\n    for right in range(len(nums)):\n        num = nums[right]\n        if freq[num] == 0:\n            current_distinct += 1\n        freq[num] += 1\n\n        # Ensure the window size does not exceed k\n        while (right - left + 1) > k:\n            left_num = nums[left]\n            freq[left_num] -= 1\n            if freq[left_num] == 0:\n                current_distinct -= 1\n            left += 1\n\n        # Check if the window size is exactly k\n        if (right - left + 1) == k:\n            if current_distinct > max_distinct:\n                max_distinct = current_distinct\n\n    return max_distinct",
  "metadata": {
    "prompt_id": "00000056",
    "row_id": 56,
    "seed_ids": [
      "230",
      "1433",
      "674"
    ],
    "mode": "leetcode",
    "original_instruction": ""
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results1.jsonl"
}