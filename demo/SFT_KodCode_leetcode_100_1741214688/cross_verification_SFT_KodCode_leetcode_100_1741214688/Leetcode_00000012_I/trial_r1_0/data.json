{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000012_I",
  "question": "Design a function `maxProfitWithTransactionFee` that calculates the maximum profit you can achieve from trading a stock given an array of daily prices and a transaction fee. You can complete as many buy-sell transactions as you like, but you need to pay the transaction fee for each transaction. A transaction consists of buying and then selling one share of the stock. You cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n### Function Signature\n```python\ndef maxProfitWithTransactionFee(prices: List[int], fee: int) -> int:\n    pass\n```\n\n### Constraints\n- `1 <= prices.length <= 5 * 10^4`\n- `0 <= prices[i] <= 10^5`\n- `0 <= fee < 10^5`",
  "solution": "def maxProfitWithTransactionFee(prices: list, fee: int) -> int:\n    \"\"\"\n    Calculate the maximum profit you can achieve from trading a stock with a transaction fee.\n    \"\"\"\n    n = len(prices)\n    if n < 2:\n        return 0\n    \n    # Initialize variables to keep track of the maximum profit when we hold and when we do not hold a stock\n    hold = -prices[0]  # Assume we buy the stock on the first day\n    not_hold = 0       # No stock in hand\n    \n    for i in range(1, n):\n        # If we decide to buy or keep the stock\n        hold = max(hold, not_hold - prices[i])\n        # If we decide to sell the stock\n        not_hold = max(not_hold, hold + prices[i] - fee)\n    \n    return not_hold",
  "test_code": "def test_maxProfitWithTransactionFee():\n    assert maxProfitWithTransactionFee([1, 3, 2, 8, 4, 9], 2) == 8, \"Test case 1 failed\"\n    assert maxProfitWithTransactionFee([1, 3, 7, 5, 10, 3], 3) == 6, \"Test case 2 failed\"\n    assert maxProfitWithTransactionFee([1], 0) == 0, \"Test case 3 failed\"\n    assert maxProfitWithTransactionFee([1, 2, 3, 4, 5], 1) == 3, \"Test case 4 failed\"\n    assert maxProfitWithTransactionFee([7, 6, 4, 3, 1], 2) == 0, \"Test case 5 failed\"\n\nif __name__ == \"__main__\":\n    import pytest\n    pytest.main([__file__])",
  "test_info": [
    {
      "function_name": "maxProfitWithTransactionFee",
      "parameter_list": "(prices, fee)",
      "function_declaration": "def maxProfitWithTransactionFee(prices, fee):",
      "docstring": "Calculate the maximum profit you can achieve from trading a stock with a transaction fee."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to solve this problem where I have to find the maximum profit from trading stock with a transaction fee. Hmm. So the problem says that each time I buy and sell, I have to pay a fee. And I can do as many transactions as I want, but I can't have multiple transactions at the same time. So I have to sell before I can buy again.\n\nLet me think about this. I remember that without a transaction fee, the maximum profit problem can be solved by summing all the consecutive increases because you just buy low and sell high every time. But with a fee, it's more complicated because each transaction incurs this fee, so not all small increases are profitable.\n\nSo, I think maybe a dynamic programming approach would work here. I need to keep track of two states for each day: one where I have the stock, and another where I don't. Let me denote these as hold and unhold.\n\nWait, right. So, for each day i:\n- The maximum profit if I hold the stock on that day (hold[i]) would be the maximum between holding it the previous day, or buying it today. But since buying today would cost me, I have to subtract the fee when I buy. Wait, no. Wait, when you buy, it's the price, but the fee is paid per transaction. So each time you buy and sell, it's a fee, right?\n\nWait, actually, each transaction (buy and sell) incurs the fee. So for each buy and sell, you pay the fee once. So, each time you do a buy followed by a sell, that's a transaction.\n\nSo, if I model it as after each step, whether I have the stock or not, the transitions would be:\n\nIf today I am holding the stock, then either I held it yesterday and did nothing, or I bought it yesterday by paying the fee, right?\n\nWait no. Let me model it different.\n\nLet me think of the states more clearly.\n\nLet me define:\n- buy[i]: the maximum profit I can have if I buy on day i. But wait, buying on day i is after selling, maybe. Or perhaps I should model two states each day: the maximum profit when holding the stock (after the buy), or not holding it (after selling).\n\nSo, maybe the states are:\n- hold: after buying, or after holding from previous days. The hold state represents the maximum profit you can have when you are holding the stock before the current day's transaction.\n- unhold: represents the maximum profit when you are not holding the stock, either because you just sold or never bought.\n\nSo, for each day, I can update these two states.\n\nLet me try to think of the transitions.\n\nOn day i, the current price is prices[i].\n\nIf I decide to buy on this day, what's the situation?\n\nWait, no. Because buying on day i and holding would mean that in the hold state, the cost includes the price of today.\n\nAlternatively, maybe I should consider each day's possible actions: for instance, I can choose to buy or sell on this day. But since I can't hold multiple stocks, I have to sell first.\n\nLet me model it as for each day, I have two options: I can either sell or hold (if I have the stock), or buy or hold (if I don't have the stock).\n\nSo:\n\nOn each day, the hold state can be updated in two ways:\n- Previously had the stock, hold again. So hold[i] = hold[i-1] (since you just hold).\nWait, prices didn't change in this case, so no action.\n\nOr, you buy the stock today. To buy, you must not have held it yesterday, so the profit if you buy is unhold[i-1] - prices[i]. Also, since buying requires a transaction fee, when you buy, you incur the fee? Or wait, each buy and sell is a transaction, so every buy must be followed by a sell, and each time you do that, you pay a fee.\n\nWait, the problem says that each transaction, which is a buy and sell, incurs a fee. So, each time you buy and sell, you pay a fee. So when you buy, you pay the transaction fee on the buy, or not? Maybe no, the fee is for each transaction (each sell, perhaps? Or each buy is part of a transaction which ends with a sell.)\n\nHmm. So maybe the fee is applied when you sell. Because a transaction is buy then sell, so fee is paid once per buy-sell pair.\n\nSo during a transaction, you buy at some time, then sell at a later time, incurring the fee.\n\nSo, in the dynamic programming approach:\n\nLet's define:\n- hold[i] represents the maximum profit after day i where you're holding the stock.\n- unhold[i] represents the maximum profit after day i where you're not holding the stock.\n\nEach day, you can choose to do nothing, or to buy/sell.\n\nThe transitions:\n\nFor hold[i]:\nYou can either hold the stock from previous day (hold[i-1]) or you buy today.\n\nBut the buy today must come from not holding it yesterday. So the new state would be unhold[i-1] - prices[i] (the price you buy). But since buying is part of a new transaction, do you pay the fee when buying? Hmm.\n\nWait, no, the fee is applied when you sell. Or perhaps each transaction is both a buy and a sell, so if I buy then sell next day, I pay a fee on the sell.\n\nWait, the problem statement says that each transaction (buy followed by sell) incurs a fee. So perhaps the fee is subtracted when you sell, not when you buy.\n\nAlternatively, maybe the fee is subtracted when you complete a transaction, i.e., each buy and sell costs a fee once.\n\nSo for each transaction (a buy followed by a sell), the profit is (sell price - buy price - fee). Because the fee is paid per transaction.\n\nSo when you sell, you subtract the fee.\n\nHmm, maybe that's the way to model it.\n\nSo in the DP approach:\n\nFor each day i:\n\nThe hold[i] is the maximum of:\n- hold[i-1] (do nothing)\n- (unhold[i-1] - prices[i]) (buy on day i without selling: but you have to pay for the transaction if you're selling. Wait, no, in this case, when you buy, you aren't selling yet, so maybe the fee is not subtracted until you sell.\n\nWait, maybe I'm thinking about it wrong.\n\nAnother way is to model each transaction as a buy followed by a sell. So when you decide to sell, you have to calculate the profit from the buy time, subtract the price to buy, add the price to sell, minus the fee.\n\nBut then, making these decisions in a dynamic programming fashion requires keeping track of the buy price and when to sell.\n\nAlternatively, in the DP approach, each state can represent whether you have the stock or not, and for each state, you can decide to buy, sell, or do nothing.\n\nWait, perhaps I should model the transitions as:\n\nHold[i] can be the maximum of (hold[i-1], unhold[i-1] - prices[i] (the cost of buying today, but without having to pay the fee until you sell). Wait no, because the fee is for the transaction, which is selling after buying.\n\nAlternatively, maybe when you decide to buy, you pay the fee immediately? Or when you sell?\n\nWait no. Let me think of an example.\n\nSuppose prices are [1, 3], fee is $1.\n\nCase 1: buy on day 1, sell on day 2.\n\nProfit is 3 -1 - fee = $1.\n\nBut according to the original problem, the transaction fee is paid for each transaction, i.e., each buy-sell counts as one, so fee just once for this.\n\nSo, in this case, the fee is $1, so the profit is 3-1 -1 = 1.\n\nAnother example: prices [1,2,4], fee 1.\n\nOption 1: buy on day 1, sell on day 2. That's a profit of 2-1 -1= 0. Then buy on day 2, sell day3: 4-2 -1=1. Total is 1 profit.\n\nOption 2: buy day 1, sell day3: 4-1 -1=2.\n\nSo total profit is 2, better.\n\nSo in this case, it's better to not make a transaction between each small gain but wait for bigger ones.\n\nSo, in the DP model, when I have the hold state, when I sell, I have to subtract the fee.\n\nSo, let me redefine my states.\n\nLet\u2019s say:\n- hold[i] is the maximum profit achievable on day i when I\u2019m holding the stock. So I could have bought it on day i, or I held it from before.\n- unhold[i] is the maximum profit when I'm not holding the stock on day i.\n\nFor each day, to compute hold[i], I can either:\n- hold the stock from the previous day (so profit remains same)\n- or buy it on this day, which would require that I wasn't holding it the previous day. So unhold[i-1] - price[i], but that's the cost to buy it today.\n\nWait, but when I buy today, I'm starting a transaction. So when I sell in the future, I have to subtract the fee.\n\nSo perhaps the hold state doesn't include the fee subtraction, only the unhold state when you sell includes the fee.\n\nSo, the transitions would be:\n\nOn day i:\n\nhold[i] = max( hold[i-1], unhold[i-1] - prices[i] )\n\nunhold[i] = max( unhold[i-1], hold[i-1] + prices[i] - fee )\n\nBecause, for hold[i], the options are to hold (from previous) or buy (from unhold) without subtracting any fee yet.\n\nFor unhold[i], either we continue not holding (so same as before), or we sell now after holding it yesterday. When selling, we add the current price and subtract the fee.\n\nSo, for each day, this is how we calculate.\n\nLet me test this with the example.\n\nExample 1: prices [1,3], fee 1.\n\nInitialization:\n\nhold[0] = unhold[0]? Wait, what's the initial state?\n\nOn day 0 (prices[0] = 1):\n\nIf you can't have bought anything before, so unhold[0] is 0 (no profit), and hold[0] would be -prices[0], because if you choose to buy on day 0, but without selling yet, so profit is -1.\n\nWait, perhaps initial conditions are:\n\nhold[0] = -prices[0] (since you can buy on day 0, but it's a cost of 1, so profit is -1)\nunhold[0] = 0 (no transaction, profit is 0)\n\nThen, on day 1 (price 3):\n\nhold[1] = max( hold[0] which is -1, unhold[0]-3 = 0-3 =-3 ) \u2192 so max is -1.\n\nunhold[1] = max( unhold[0]=0, hold[0]+3 -1 \u2192 (-1) +3=2 -1=1 \u2192 1. So the max is 1.\n\nSo unhold[1] is 1, which is correct. Because we buy on day 0 for 1, sell on day1 for 3, profit is 3 -1 -1 = 1.\n\nAnother example.\n\nExample2: prices [1,2,4], fee=1.\n\nCompute for each day.\n\nDay0: price is 1.\n\nhold[0] = -1\nunhold[0] =0\n\nDay1: price=2.\n\nhold[1] = max( hold[0] (-1), unhold[0]-2 \u2192 0-2= -2) \u2192 max is -1.\n\nunhold[1] = max(0, hold[0]+2 -1 \u2192 (-1)+2=1-1=0. So max is 0 (since 0 < unhold's previous 0 is same. So unhold[1] is 0.\n\nDay2: price is 4.\n\nhold[2] = max( hold[1] (-1), unhold[1]-4 \u21920-4=-4 \u2192 max is -1.\n\nunhold[2] = max(current unhold (0), hold[1]+4 -1 \u2192 (-1)+4=3-1=2 \u2192 so max is max(0, 2) \u2192 2.\n\nWhich is correct. Because if on day0 we buy (cost 1), on day1 do nothing, on day2 sell (price 4), profit is 4-1-1=2.\n\nSo our DP seems to model this correctly.\n\nAnother test case: trying to see multiple transactions.\n\nprices [1, 2, 1, 2], fee=1.\n\nWhat's the optimal here.\n\nOption: buy on day0, sell on day1: profit 2-1-1=0. Then buy on day2, sell on day3: 2-1-1=0. Total 0.\n\nAlternatively, buy day2, sell day3: profit 2-1-1=0. Also same.\n\nBut perhaps another option is better.\n\nWait maybe buy day0, then sell day1 (-0), then buy day3 is not possible, because after day1 sell, the next is day2, high.\n\nAlternatively, maybe no transaction is better.\n\nAnother example:\n\nprices [2, 1, 2, 0, 1], fee=1.\n\nHmm, maybe to buy at 0 and sell at 1.\n\nWait, but getting back to the main solution.\n\nSo, according to this model, the initial conditions are hold[0] = -prices[0], unhold[0] =0.\n\nThen, for each day from 1 to N-1:\n\nhold[i] = max( hold[i-1], unhold[i-1] -prices[i] )\n\nunhold[i] = max( unhold[i-1], hold[i-1] + prices[i] - fee )\n\nYes.\n\nSo, for implementing this, we can do it with O(n) time, and O(1) space since we don't need to save the entire arrays, just the previous day's hold and unhold.\n\nLet me see:\n\nWe can keep variables:\n\nprev_hold, prev_unhold.\n\nInitially, prev_hold = -prices[0], prev_unhold =0.\n\nThen, for each price in prices[1:]:\n\ncurr_hold = max( prev_hold, prev_unhold - price )\n\ncurr_unhold = max( prev_unhold, prev_hold + price - fee )\n\nthen update prev_hold and prev_unhold to curr_hold and curr_unhold.\n\nAt the end, the maximum profit is max(prev_unhold, prev_hold)\n\nWait, no. Because after the last day, you may choose to hold it, but that's profit is the negative of the price. So the maximum profit must be the maximum between unhold, which indicates that you have already sold all your transactions, and hold, but since you're forced to at least have no profit in hold, the maximum would be unhold.\n\nWait, looking back at the previous examples:\n\nIn example 1, at the end, unhold is 1, which is the maximum.\n\nIn example2, at the end, unhold is 2, which is the maximum.\n\nSo perhaps the maximum profit is completely reflected in the unhold variable. Because you can't have a profit if you're still holding the stock, since that would require you to sell after the last day, which isn't possible. So the maximum profit is unhold[N-1], which is the maximum profit if you're not holding the stock.\n\nWait, but in the case when the last day's decision is to buy and not sell.\n\nNo, because in order to have profit, you have to sell.\n\nSo at the end, you can't have the stock. So in the DP, the maximum profit is the maximum profit when you are not holding, which is the unhold value.\n\nWait, in the first instance, the profit is 1, which is unhold. So in that case, yes.\n\nSo yes, the final answer is unhold.\n\nThus, during the loop, after processing all days, the unhold holds the maximum profit.\n\nSo now, let's see the code.\n\nWe can proceed as:\n\nn = len(prices)\nif n ==0: return 0\nif n ==1: return 0 (no profit possible)\n\nprev_hold = -prices[0]\nprev_unhold =0\n\nfor i in range(1, n):\n    curr_hold = max( prev_hold, prev_unhold - prices[i] )\n    curr_unhold = max( prev_unhold, prev_hold + prices[i] - fee )\n    prev_hold, prev_unhold = curr_hold, curr_unhold\n\nreturn prev_unhold\n\nThat's the code.\n\nLet me test with the example where you have 4 days, and the prices are [1, 2, 1, 2], fee is 1.\n\nInitialize prev_hold = -1, prev_unhold=0.\n\nDay 1: price 2.\n\ncurr_hold = max(-1, 0-2=-2) \u2192 -1\ncurr_unhold = max(0, -1+2-1=0) \u2192 0. \n\nSo now, hold=-1, unhold=0.\n\nDay2: price 1.\n\ncurr_hold: max(-1, 0-1=-1) \u2192 -1\ncurr_unhold: max(0, -1 +1 -1= -1 \u2192 0 remains.\n\nDay3: price2.\n\ncurr_hold: max(-1, 0-2=-2 \u2192 -1)\ncurr_unhold: max(0, -1 +2-1=0 \u2192 so 0.\n\nSo final is 0, correct as per earlier analysis.\n\nAnother test: prices [3,2,6,5,0,3], fee is 1.\n\nLet me see:\n\nWait trying to build the DP steps.\n\nBut it's time-consuming. However, the code seems to handle the necessary cases.\n\nWhat about when fee is zero? Then, the problem reduces to the maximum profit with infinite transactions and no fee.\n\nIn that case, our code should give the same result as the standard problem.\n\nAnother example where the best is to do nothing (prices are decreasing).\n\nprices [5,4,3,2,1], fee 1.\n\nThen, it's better to do nothing. So the maximum profit is 0.\n\nTesting:\n\nInitially prev_hold=-5, unhold=0.\n\nDay1 price4:\nhold= max(-5, 0-4=-5) \u2192 -5\nunhold= max(0, (-5)+4-1= -2 \u2192 0)\n\nDay2: price3.\nhold= max(-5, 0-3= -5? So remains -5)\nunhold= max(0, prev_hold+3 -1 = -5 +3-1= -3 \u2192 0 remains.\n\nSame for all days. So unhold is 0.\n\nWhich is correct.\n\nI think this approach is correct.\n\nSo, coding that in Python:\n\nWe need to loop through the prices starting from index 1, and in each step, compute curr_hold and curr_unhold as per the transitions.\n\nBut first, I have to handle the case where the prices list is empty.\n\nSo, the function is:\n\ndef maxProfitWithTransactionFee(prices: List[int], fee: int) -> int:\n    if not prices:\n        return 0\n    n = len(prices)\n    if n == 0:\n        return 0\n    prev_hold = -prices[0]\n    prev_unhold = 0\n    for i in range(1, n):\n        price = prices[i]\n        curr_hold = max( prev_hold, prev_unhold - price )\n        curr_unhold = max( prev_unhold, prev_hold + price - fee )\n        prev_hold, prev_unhold = curr_hold, curr_unhold\n    return prev_unhold\n\nWait, but for i in range(1, n), price is prices[1], then prices[2] etc up to prices[n-1 ].\n\nYes.\n\nTesting with initial test case:\n\nprices [1,3], fee 1.\n\nAfter first iteration:\n\nprev_unhold is 0.\n\ni=1, price 3.\n\ncurr_hold: max(-1, 0-3=-3 \u2192 -1.\n\ncurr_unhold: max(0, -1+3-1=1 \u2192 1.\n\nSo return 1, correct.\n\nSecond test case, prices [1,2,4], fee1. Returns 2.\n\nAnother test case where no transactions are profitable.\n\nprices [2], returns 0.\n\nprices [2,1] with fee 1.\n\nprev_hold=-2, prev_unhold=0.\n\ni=1, price 1.\n\nhold = max(-2, 0-1 =-1) \u2192 -2.\n\nunhold= max(0, prev_hold +1 -1= -2+0= -2 \u2192 0.\n\nSo returns 0, correct.\n\nWhich is correct because you'd have to pay a fee of 1 if you buy at 2 and sell at 1, which results in 1-2 -1 =-2. That's worse than no transaction.\n\nYes.\n\nAnother test:\n\nprices [3,3,3], fee 1. Best is to buy and sell any day. For instance, buy day0, sell day1: 0 profit. Or buy day1, sell day2: 0. So no profit.\n\nSo the code should return 0.\n\nLet's see:\n\nInitial prev_hold =-3, prev_unhold=0.\n\ni=1, price3.\n\ncurr_hold = max(-3, 0-3=-3 \u2192 -3.\n\ncurr_unhold = max(0, -3 +3 -1 = -1 \u2192 0.\n\ni=2, price3.\n\ncurr_hold = max(-3, 0-3=-3).\n\ncurr_unhold = max(0, -3 +3-1= -1 \u2192 0.\n\nSo returns 0. Correct.\n\nYes, the code works.\n\nAnother test: where it's better not to buy multiple times.\n\nprices [1, 100, 2, 100], fee = 1.\n\nOn day1, you can sell for 99 profit (100-1 -1=98), then on day3, buy at 2 and sell at 100-1\u219297 profit. So total 195.\n\nBut wait:\n\nWait the actual steps would be:\n\nbuy on day0 at 1, sell on day1 at 100 \u2192 profit 98.\n\nThen buy on day2 at 2, then sell on day3 at 100 \u2192 profit 97.\n\nTotal profit is 98+97=195.\n\nWhat does the code do?\n\nLet's walk through:\n\nn=4, prices [1,100,2,100], fee=1.\n\nInitialize:\n\nprev_hold =-1.\n\nprev_unhold=0.\n\ni=1, price100:\n\ncurr_hold = max(-1, 0-100= -100 \u2192-1).\n\ncurr_unhold = max(0, (-1)+100-1=98 \u219298.\n\nSo after day1, unhold is 98.\n\ni=2, price2.\n\ncurr_hold = max(-1, 98-2=96 \u219296 is larger.\n\ncurr_unhold= max(98, (-1) + 2 -1=0 \u2192 98.\n\nSo curr_hold is 96, unhold 98.\n\ni=3, price100.\n\ncurr_hold: max(96, 98-100= -2 \u219296.\n\ncurr_unhold: max(98, 96 +100 -1=195 \u2192195.\n\nSo final unhold is 195.\n\nWhich matches the expected profit.\n\nYes.\n\nSo, now, I think the code is correct.\n</think>\n\nTo solve this problem, we need to determine the maximum profit that can be achieved by buying and selling a stock with a given transaction fee. The challenge is to account for the fee each time a transaction (buy followed by sell) is made.\n\n### Approach\nThe approach to solve this problem involves using dynamic programming to keep track of two states for each day:\n1. The maximum profit if we hold the stock at the end of the day.\n2. The maximum profit if we do not hold the stock at the end of the day.\n\nWe define two variables:\n- `hold[i]` represents the maximum profit if we hold the stock at the end of day `i`.\n- `unhold[i]` represents the maximum profit if we do not hold the stock at the end of day `i`.\n\nThe transitions between these states are as follows:\n1. `hold[i]` can either be the result of holding the stock from the previous day (`hold[i-1]`) or buying it today (`unhold[i-1] - prices[i]`).\n2. `unhold[i]` can either be the result of not holding the stock from the previous day (`unhold[i-1]`) or selling the stock today (`hold[i-1] + prices[i] - fee`).\n\nBy iterating through the prices list and updating these states each day, we can determine the maximum profit at the end of the last day.\n\n### Solution Code\n```python\nfrom typing import List\n\ndef maxProfitWithTransactionFee(prices: List[int], fee: int) -> int:\n    if not prices:\n        return 0\n    prev_hold = -prices[0]\n    prev_unhold = 0\n    for price in prices[1:]:\n        curr_hold = max(prev_hold, prev_unhold - price)\n        curr_unhold = max(prev_unhold, prev_hold + price - fee)\n        prev_hold, prev_unhold = curr_hold, curr_unhold\n    return prev_unhold\n```\n\n### Explanation\n1. **Initialization**: We start with `prev_hold` set to `-prices[0]` because if we buy the stock on the first day, our initial profit is negative the price of the stock. `prev_unhold` is initialized to 0 because if we haven't bought the stock, our profit is 0.\n\n2. **Iteration**: For each subsequent day, we calculate the current states based on the previous states:\n   - If we decide to hold the stock today, we either continue holding it from the previous day or buy it today.\n   - If we decide not to hold the stock today, we either continue not holding it from the previous day or sell it today and subtract the transaction fee.\n\n3. **Result**: After processing all days, the maximum profit is found in `prev_unhold`, as we cannot hold the stock at the end to realize a profit.\n\nThis approach efficiently computes the maximum profit with a transaction fee in O(n) time complexity, where n is the number of days, and O(1) space complexity, making it suitable for large input sizes.",
  "r1_solution": "from typing import List\n\ndef maxProfitWithTransactionFee(prices: List[int], fee: int) -> int:\n    if not prices:\n        return 0\n    prev_hold = -prices[0]\n    prev_unhold = 0\n    for price in prices[1:]:\n        curr_hold = max(prev_hold, prev_unhold - price)\n        curr_unhold = max(prev_unhold, prev_hold + price - fee)\n        prev_hold, prev_unhold = curr_hold, curr_unhold\n    return prev_unhold",
  "metadata": {
    "prompt_id": "00000012",
    "row_id": 12,
    "seed_ids": [
      "1476",
      "2214",
      "1720"
    ],
    "mode": "leetcode",
    "original_instruction": ""
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results0.jsonl"
}