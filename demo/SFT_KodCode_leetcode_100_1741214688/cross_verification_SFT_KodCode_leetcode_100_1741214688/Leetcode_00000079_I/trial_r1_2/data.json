{
  "style": "instruct",
  "subset": "Leetcode",
  "question_id": "Leetcode_00000079_I",
  "question": "Design a class `RangeFreqQuery` that supports efficient frequency queries on a given array `arr`. The goal is to implement a method that can quickly determine the frequency of any element within a specified range of the array. Specifically, implement the `RangeFreqQuery` class:\n\n- `RangeFreqQuery(int[] arr)`: Initializes the class with the given array `arr`.\n- `int query(int left, int right, int value)`: Returns the frequency of the value `value` in the subarray `arr[left...right]`.\n\nFor example, given the array `arr = [1, 2, 2, 3, 3, 3, 4]`, the query `query(0, 6, 3)` should return `3` since the value `3` appears three times in the subarray `arr[0...6]`.",
  "solution": "from collections import defaultdict\n\nclass RangeFreqQuery:\n    def __init__(self, arr):\n        \"\"\"\n        Initializes the class with the given array.\n        \"\"\"\n        self.index_map = defaultdict(list)\n        for index, value in enumerate(arr):\n            self.index_map[value].append(index)\n    \n    def query(self, left, right, value):\n        \"\"\"\n        Returns the frequency of the value in the subarray arr[left...right].\n        \"\"\"\n        if value not in self.index_map:\n            return 0\n        indices = self.index_map[value]\n        left_idx = self._binary_search(indices, left)\n        right_idx = self._binary_search(indices, right + 1) - 1\n        return right_idx - left_idx + 1 if right_idx >= left_idx else 0\n    \n    def _binary_search(self, indices, target):\n        left, right = 0, len(indices)\n        while left < right:\n            mid = (left + right) // 2\n            if indices[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left",
  "test_code": "import pytest\nfrom solution import RangeFreqQuery\n\ndef test_range_freq_query_positive():\n    arr = [1, 2, 2, 3, 3, 3, 4]\n    freq_query = RangeFreqQuery(arr)\n    assert freq_query.query(0, 6, 3) == 3\n    assert freq_query.query(0, 2, 2) == 2\n    assert freq_query.query(3, 6, 4) == 1\n\ndef test_range_freq_query_empty_subarray():\n    arr = [1, 2, 2, 3, 3, 3, 4]\n    freq_query = RangeFreqQuery(arr)\n    assert freq_query.query(4, 4, 1) == 0\n\ndef test_range_freq_query_single_value():\n    arr = [1, 1, 1, 1, 1, 1, 1]\n    freq_query = RangeFreqQuery(arr)\n    assert freq_query.query(0, 6, 1) == 7\n\ndef test_range_freq_query_no_occurrence():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    freq_query = RangeFreqQuery(arr)\n    assert freq_query.query(0, 6, 8) == 0\n\ndef test_range_freq_query_negative_numbers():\n    arr = [-1, -2, -2, -3, -3, -3, -4]\n    freq_query = RangeFreqQuery(arr)\n    assert freq_query.query(0, 6, -3) == 3",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to design a class called RangeFreqQuery that can handle efficient frequency queries on a given array. The class should have a constructor that initializes with the array, and a query method that returns the count of a specific value within a specified range.\n\nHmm, the challenge here is to make the queries efficient. If I think about the straightforward approach, each query would iterate through the subarray from left to right and count occurrences. But that's O(n) for each query, which could be slow if there are many queries or the array is large.\n\nSo I need a more efficient approach. Oh right, we can pre-process the array in a way that allows us to answer these range frequency queries quickly. One common technique for range queries is using prefix sums. But how can we apply that here for multiple values?\n\nAh, right! For each element in the array, we can create a prefix sum array. Wait, but that's not feasible if the elements can be arbitrary or very large, because we can't have a prefix array for every possible value. But since in programming problems, the elements can vary, but perhaps we can precompute for all possible values that are present in the array.\n\nWait, maybe that's not the way to go. Alternatively, for each index, we can keep a data structure that allows us to quickly find out how many times a value has appeared up to that index. Hmm, perhaps for each value that exists in the array, we can precompute a list of indices where it occurs, sorted in order. Then, for a query (left, right, value), we can perform a binary search to find how many times the value occurs in that range.\n\nYes, that makes sense. So here's the plan: during the constructor, we will build a dictionary where each key is a unique value from the array, and the value is a list of indices where this value occurs. For example, in the array [1,2,2,3,3,3,4], the dictionary would have entries like:\n- 1: [0]\n- 2: [1,2]\n- 3: [3,4,5]\n- 4: [6]\n\nThen, when a query comes in, say from left to right, for a given value, we check if the value exists in the dictionary. If not, return 0. Otherwise, get the list of indices for that value, and perform a binary search to find the first index >= left and the first index > right. The difference gives the count.\n\nBut wait, in the query, right is inclusive. So the logic is, for the list of positions for value, find the first index in the list that is >= left and <= right. So actually, using binary search, we can find the lower bound of left and the upper bound of right.\n\nFor example, to find the number of elements >= left and <= right, it's the same as finding the number of elements in the list that are within [left, right]. So the way to calculate that is:\n\nleft_rank = the first index in the list where the position is >= left.\n\nright_rank = the first index in the list where the position is > right.\n\nThe count is right_rank - left_rank.\n\nSo in the constructor, for each value, store the sorted list of its occurrence indices.\n\nSo the steps:\n\n1. In the RangeFreqQuery constructor:\n\n   - Iterate through the array arr. For each index i, element val = arr[i].\n   - Add i to the list corresponding to val in the dictionary.\n\n2. For each query(left, right, value):\n\n   - Check if the value is not in the dictionary. If not, return 0.\n   - Else, get the list of indices for this value.\n   - Use binary search to find the count of indices between left and right, inclusive.\n\nBut how to perform the binary search to find the left_rank and right_rank. Let's think in code:\n\nFor the left_rank, we can find the first position in the list that is >= left. For example, using the bisect module's bisect_left function.\n\nFor the right_rank, similarly, we can use bisect_right to find the first position > right.\n\nWait, wait. Let me think about the bisect functions.\n\nbisect_left returns the insertion point for the given value such that all elements before are <= value. So if I'm looking for elements >= left, bisect_left(list, left) gives the first index where the element is >= left. Exactly.\n\nSimilarly, bisect_right(list, right) gives the insertion point after all elements <= right. So the number of elements <= right is the result of bisect_right. But since right is inclusive, so right_rank is bisect_right(list, right). Then, the count is right_rank - left_rank.\n\nIn Python, the bisect module provides bisect.bisect_left and bisect.bisect_right functions. So I can use these.\n\nSo, let me outline the steps in code:\n\nIn the __init__ method:\n\n- Create a dictionary, say from collections import defaultdict. But I'll have to make sure that for each value in arr, we have a list of indices where it appears, in order.\n\nSo something like:\n\nfrom collections import defaultdict\nimport bisect\n\nclass RangeFreqQuery:\n    def __init__(self, nums):\n        self.value_indices = defaultdict(list)\n        for index, value in enumerate(nums):\n            self.value_indices[value].append(index)\n    \n    def query(self, left, right, value):\n        if value not in self.value_indices:\n            return 0\n        indices = self.value_indices[value]\n        # Find first index >= left\n        left_rank = bisect.bisect_left(indices, left)\n        # Find first index > right\n        right_rank = bisect.bisect_right(indices, right)\n        return right_rank - left_rank\n\nWait, let's test this logic with the example:\n\nExample:\narr = [1,2,2,3,3,3,4]\nquery(0,6,3) \u2192 should return 3.\n\nIn the dictionary, value 3 has indices [3,4,5].\n\nbisect_left for left=0: looking for index >=0. Since 3 is the first element, it's 0.\n\nbisect_right for 6: looking for the first index after 5. So bisect_right returns 3. So 3-0=3. Correct.\n\nAnother test: what about a query that includes only a part of the occurrences.\n\nE.g., query(1,2,2) \u2192 should return 1. Because in arr[1..2], the elements are 2,2. Wait wait no, indices are 1 and 2 (since left and right are between 1 and 2), so both 2's are included.\n\nWait no, no: arr is 0-based. So the elements are 0-6.\n\nWait, the example array is positions 0-6.\n\nQuery (1,2,2) \u2192 the array from 1 to 2: elements [2, 2], so count is 2.\n\nWait, our code would do:\n\nvalue is 2 \u2192 indices are [1,2].\n\nbisect_left for left=1: finds index 0 (since 1 is the first element >=1). bisect_right for right=2 would find the index where to insert 3, but since the maximum in the list is 2, it finds 2. So 2-0=2. Correct.\n\nAnother test case: left=4, right=5, value=3 \u2192 should return 2 (arr[4]=3 and arr[5]=3).\n\nIn the indices list [3,4,5], find >=4: index is 1.\n\nFind <=5: bisect_right(5) would be 3. So 3-1 = 2. Correct.\n\nYes, that seems to work.\n\nWhat about if the query's left is higher than some occurrences?\n\nFor example, value is 5, which is not present \u2192 return 0.\n\nAnother case where no occurrences in range: value is 3, query left=0, right=2 \u2192 in positions 3,4,5, all are beyond 2. So bisect_left finds 0 (since 3 >=0 is at index 0). bisect_right returns 0 (since 3 >2 is true). So the count would be 0.\n\nWhat about left=3, right=5: returns 3, because in the list [3,4,5], how many >=3 and <=5? All 3 (indices 0,1,2). So bisect_left(3) \u21920, bisect_right(5) \u21923. 3-0=3.\n\nYes, that's correct.\n\nSo the code looks solid. Wait, but what about when the element appears multiple times, but only once in the query range.\n\nI think the logic handles all these cases.\n\nSo the steps are:\n\n- Preprocess into a dictionary mapping each value to a sorted list of its indices.\n- For each query, perform binary searches to find the count in logarithmic time.\n\nThus, the solution is efficient even for large arrays.\n\nNow, what about the initial array? Since we're building these lists in order as we iterate, they are already in order, no need to sort.\n\nSo the code should be as per above.\n\nI think that's all.\n</think>\n\nTo solve this problem, we need to design a class `RangeFreqQuery` that efficiently answers frequency queries on a given array. The class should support a method to quickly determine the frequency of any specified element within a given range of the array.\n\n### Approach\nThe approach to efficiently answer range frequency queries involves preprocessing the array to create a data structure that allows quick lookups. Specifically, we use a dictionary to map each unique value in the array to a sorted list of its occurrence indices. This preprocessing step ensures that each query can be answered in logarithmic time relative to the number of occurrences of the queried value.\n\nHere's the detailed approach:\n\n1. **Preprocessing with a Dictionary:**\n   - During the initialization of the `RangeFreqQuery` class, we iterate through the array and build a dictionary where each key is a unique value from the array. The corresponding value is a list of indices where this key occurs in the array. This list of indices is maintained in sorted order.\n\n2. **Efficient Query Handling with Binary Search:**\n   - For each query, we use binary search to quickly determine the number of occurrences of the specified value within the given range. The `bisect_left` function helps find the first index in the list that is greater than or equal to the left boundary of the range. The `bisect_right` function helps find the first index in the list that is greater than the right boundary of the range. The difference between these two indices gives the count of occurrences within the specified range.\n\n### Solution Code\n```python\nimport bisect\nfrom collections import defaultdict\n\nclass RangeFreqQuery:\n    def __init__(self, arr):\n        self.value_indices = defaultdict(list)\n        for index, value in enumerate(arr):\n            self.value_indices[value].append(index)\n    \n    def query(self, left, right, value):\n        if value not in self.value_indices:\n            return 0\n        indices = self.value_indices[value]\n        left_rank = bisect.bisect_left(indices, left)\n        right_rank = bisect.bisect_right(indices, right)\n        return right_rank - left_rank\n```\n\n### Explanation\n1. **Initialization (`__init__` method):**\n   - The constructor initializes the class with the given array and builds a dictionary (`value_indices`) where each key is a unique value from the array, and the corresponding value is a list of indices where this value occurs. This list is naturally sorted as we iterate through the array from left to right.\n\n2. **Query Handling (`query` method):**\n   - The method first checks if the queried value exists in the dictionary. If not, it returns 0 as the value does not appear in the array.\n   - For existing values, it retrieves the sorted list of indices where the value occurs.\n   - Using `bisect_left`, it finds the first index in this list that is greater than or equal to the left boundary of the range.\n   - Using `bisect_right`, it finds the first index in this list that is greater than the right boundary of the range.\n   - The difference between these two indices gives the count of the value within the specified range.\n\nThis approach ensures that each query is answered efficiently in logarithmic time relative to the number of occurrences of the queried value, making it suitable for large arrays and frequent queries.",
  "r1_solution": "import bisect\nfrom collections import defaultdict\n\nclass RangeFreqQuery:\n    def __init__(self, arr):\n        self.value_indices = defaultdict(list)\n        for index, value in enumerate(arr):\n            self.value_indices[value].append(index)\n    \n    def query(self, left, right, value):\n        if value not in self.value_indices:\n            return 0\n        indices = self.value_indices[value]\n        left_rank = bisect.bisect_left(indices, left)\n        right_rank = bisect.bisect_right(indices, right)\n        return right_rank - left_rank",
  "metadata": {
    "prompt_id": "00000079",
    "row_id": 79,
    "seed_ids": [
      "1157",
      "751",
      "2288"
    ],
    "mode": "leetcode",
    "original_instruction": ""
  },
  "file_source": "KodCode_leetcode_100_1741214688_prepared_results2.jsonl"
}