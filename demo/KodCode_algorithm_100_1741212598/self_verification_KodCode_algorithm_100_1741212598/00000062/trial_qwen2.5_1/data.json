{
  "metadata": {
    "prompt_id": "00000062",
    "row_id": 62,
    "seed_ids": [
      47
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a Base85 (Ascii85) encoder and decoder implemented in Python. Your task is to optimize the existing code by reducing the time complexity and space complexity of the encoding and decoding functions. Specifically, you need to:\n- Implement optimizations to reduce the time complexity and space complexity of the encoding and decoding functions.\n- Ensure that the functions handle edge cases correctly and provide the same output as the original functions.\n\n**Input**:\n- `data`: A `bytes` object representing the binary data to be encoded or decoded.\n\n**Output**:\n- For `ascii85_encode`, return the Base85 encoded `bytes` object.\n- For `ascii85_decode`, return the original binary data as a `bytes` object.\n\n**Constraints**:\n- The input binary data length will be between 0 and 1MB.\n- The functions should handle all edge cases correctly, including null values and padding.\n\n**Example**:\n```python\n# Example usage\nencoded_data = ascii85_encode(b\"12345\")\ndecoded_data = ascii85_decode(encoded_data)\nprint(encoded_data)  # b'0etOA2#'\nprint(decoded_data)  # b'12345'\n```\n\n**Performance Requirement**:\n- The optimized functions should run within 1 second for inputs up to 1MB in size.",
  "solution_code": "def ascii85_encode(data: bytes) -> bytes:\n    \"\"\"\n    Encodes a bytes object into Base85 format.\n    \"\"\"\n    encoded_chars = []\n    chars = \" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\n    acc, count = 0, 0\n    for char in data:\n        acc = acc * 256 + char\n        count += 1\n        if count == 5:\n            encoded_chars.append(chars[(acc >> 3 * 8) & 0x1f])\n            encoded_chars.append(chars[(acc >> 2 * 8) & 0x1f])\n            encoded_chars.append(chars[(acc >> 1 * 8) & 0x1f])\n            encoded_chars.append(chars[(acc >> 0 * 8) & 0x1f])\n            acc, count = 0, 0\n    if count:\n        rem = 8 * count\n        encoded_chars.append(chars[(acc >> (rem - 8 * 2)) & 0x3f])\n        if count > 1:\n            encoded_chars.append(chars[(acc >> (rem - 8 * 1)) & 0x1f])\n        if count > 2:\n            encoded_chars.append(chars[(acc >> (rem - 8 * 0)) & 0x0f])\n    return \"\".join(encoded_chars).encode(\"ascii\")\n\ndef ascii85_decode(encoded_data: bytes) -> bytes:\n    \"\"\"\n    Decodes a Base85 encoded bytes object back to the original binary data.\n    \"\"\"\n    encoded_chars = encoded_data.decode(\"ascii\")\n    acc, count = 0, 0\n    data = bytearray()\n    for char in encoded_chars:\n        if char == chars[0]:\n            data.append(acc)\n            acc, count = 0, 0\n            continue\n        acc = acc * 85 + chars.index(char)\n        count += 1\n        if count == 5:\n            data.extend((acc >> 24).to_bytes(4, \"big\"))\n            acc, count = acc & 0xffffff, 0\n    if count:\n        rem = 85 * count\n        data.extend((acc >> (rem - 85 * 4)).to_bytes(4, \"big\"))\n    return bytes(data)",
  "test_code": "import pytest\nfrom solution import ascii85_encode, ascii85_decode\n\ndef test_ascii85_encode_decode():\n    assert ascii85_decode(ascii85_encode(b\"12345\")) == b\"12345\"\n    assert ascii85_decode(ascii85_encode(b\"onetwothree\")) == b\"onetwothree\"\n    assert ascii85_decode(ascii85_encode(b\"\")) == b\"\"\n    assert ascii85_decode(ascii85_encode(b\"hello world\")) == b\"hello world\"\n\ndef test_ascii85_decode_encode_cycle():\n    for _ in range(100):\n        original_data = bytearray(b\"\".join([bytes([i % 256]) for i in range(100000)]))\n        encoded = ascii85_encode(original_data)\n        decoded = ascii85_decode(encoded)\n        assert decoded == original_data\n\ndef test_ascii85_edge_cases():\n    assert ascii85_encode(b\"1234567890\") == b\"0etOA!-\"\n    assert ascii85_decode(b\"0etOA!-\") == b\"1234567890\"\n    assert ascii85_encode(b\"\") == b\"\"\n    assert ascii85_decode(b\"\") == b\"\"\n\ndef test_ascii85_padding():\n    assert ascii85_decode(ascii85_encode(b\"testing123\")) == b\"testing123\"\n    assert ascii85_decode(ascii85_encode(b\"123456789012345678901234567890\")) == b\"123456789012345678901234567890\"\n\ndef test_ascii85_large_data():\n    large_data = b\"\".join([bytes([i % 256]) for i in range(1000000)])\n    encoded = ascii85_encode(large_data)\n    assert len(encoded) == len(large_data) // 5 * 85 + len(large_data) % 5 * (85 // 5 + 1)\n    decoded = ascii85_decode(encoded)\n    assert decoded == large_data\n\ndef test_ascii85_decode_rejection_of_invalid_ascii85_strings():\n    with pytest.raises(Exception):\n        ascii85_decode(b\"invalid ascii85\")\n    with pytest.raises(Exception):\n        ascii85_decode(b\"123456\")\n    with pytest.raises(Exception):\n        ascii85_decode(b\"12345\")\n    with pytest.raises(Exception):\n        ascii85_decode(b\"1234567\")",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}