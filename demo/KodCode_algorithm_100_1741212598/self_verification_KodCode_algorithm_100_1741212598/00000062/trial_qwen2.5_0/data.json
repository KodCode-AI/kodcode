{
  "metadata": {
    "prompt_id": "00000062",
    "row_id": 62,
    "seed_ids": [
      47
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a Base85 (Ascii85) encoder and decoder implemented in Python. Your task is to optimize the existing code by reducing the time complexity and space complexity of the encoding and decoding functions. Specifically, you need to:\n- Implement optimizations to reduce the time complexity and space complexity of the encoding and decoding functions.\n- Ensure that the functions handle edge cases correctly and provide the same output as the original functions.\n\n**Input**:\n- `data`: A `bytes` object representing the binary data to be encoded or decoded.\n\n**Output**:\n- For `ascii85_encode`, return the Base85 encoded `bytes` object.\n- For `ascii85_decode`, return the original binary data as a `bytes` object.\n\n**Constraints**:\n- The input binary data length will be between 0 and 1MB.\n- The functions should handle all edge cases correctly, including null values and padding.\n\n**Example**:\n```python\n# Example usage\nencoded_data = ascii85_encode(b\"12345\")\ndecoded_data = ascii85_decode(encoded_data)\nprint(encoded_data)  # b'0etOA2#'\nprint(decoded_data)  # b'12345'\n```\n\n**Performance Requirement**:\n- The optimized functions should run within 1 second for inputs up to 1MB in size.",
  "solution_code": "import math\nfrom functools import reduce\n\ndef ascii85_encode(data):\n    \"\"\"\n    Encodes binary data into Base85 format (Ascii85).\n    \"\"\"\n    chunk_size = 4  # 4 bytes per chunk\n    encoded = []\n    if not data:\n        return b''\n    \n    chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]\n    \n    for chunk in chunks:\n        # Convert chunk to integer\n        chunk_int = int.from_bytes(chunk, byteorder='big')\n        \n        # Encode chunk to Base85\n        encoded_chars = []\n        while chunk_int > 0:\n            chunk_int, remainder = divmod(chunk_int, 85)\n            encoded_chars.append(chr(33 + remainder))\n        encoded.reverse()\n        \n        # Pad to 5 characters if needed\n        while len(encoded_chars) < 5:\n            encoded_chars.append('!')\n        encoded.append(''.join(encoded_chars))\n    \n    return ''.join(encoded).encode()\n\ndef ascii85_decode(data):\n    \"\"\"\n    Decodes Base85 format (Ascii85) back to binary data.\n    \"\"\"\n    data = data.decode()\n    chunks = [data[i:i+5] for i in range(0, len(data), 5)]\n    \n    decoded = []\n    for chunk in chunks:\n        chunk_int = 0\n        for i, char in enumerate(chunk):\n            if char[0] == '!':\n                break\n            chunk_int += (85 ** (4 - i)) * (ord(char) - 33)\n        \n        # Convert integer back to bytes\n        byte_ints = bytearray()\n        for _ in range(4):\n            byte_ints.insert(0, chunk_int & 0xff)\n            chunk_int >>= 8\n        \n        # Handle padding\n        while len(byte_ints) < 4:\n            byte_ints.insert(0, 0)\n        \n        decoded.extend(byte_ints)\n    \n    return bytes(decoded)",
  "test_code": "import base64\n\ndef test_ascii85_encode_decode():\n    test_bytes = b'12345'\n    encoded = ascii85_encode(test_bytes)\n    decoded = ascii85_decode(encoded)\n    assert base64.b85encode(test_bytes) == encoded\n    assert test_bytes == decoded\n\ndef test_ascii85_decode_null():\n    assert ascii85_decode(b'') == b''\n\ndef test_ascii85_encode_empty():\n    assert ascii85_encode(b'') == b''\n\ndef test_ascii85_decode_padding():\n    for padding in ['!!!!', '!']:\n        encoded = ascii85_encode(b'12345')\n        encoded = encoded.decode().replace('!etOA2#', padding)\n        decoded = ascii85_decode(encoded.encode())\n        assert b'12345' == decoded\n\ndef test_ascii85_encode_padding():\n    encoded = b'!etOA2!R@3Dfsd'\n    decoded = ascii85_decode(encoded)\n    assert b'12345' == decoded\n\ndef test_ascii85_large_data():\n    large_data = os.urandom(1024 * 1024)  # 1MB of random data\n    encoded = ascii85_encode(large_data)\n    decoded = ascii85_decode(encoded)\n    assert large_data == decoded",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}