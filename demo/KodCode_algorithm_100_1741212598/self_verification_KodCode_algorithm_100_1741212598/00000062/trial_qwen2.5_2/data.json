{
  "metadata": {
    "prompt_id": "00000062",
    "row_id": 62,
    "seed_ids": [
      47
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a Base85 (Ascii85) encoder and decoder implemented in Python. Your task is to optimize the existing code by reducing the time complexity and space complexity of the encoding and decoding functions. Specifically, you need to:\n- Implement optimizations to reduce the time complexity and space complexity of the encoding and decoding functions.\n- Ensure that the functions handle edge cases correctly and provide the same output as the original functions.\n\n**Input**:\n- `data`: A `bytes` object representing the binary data to be encoded or decoded.\n\n**Output**:\n- For `ascii85_encode`, return the Base85 encoded `bytes` object.\n- For `ascii85_decode`, return the original binary data as a `bytes` object.\n\n**Constraints**:\n- The input binary data length will be between 0 and 1MB.\n- The functions should handle all edge cases correctly, including null values and padding.\n\n**Example**:\n```python\n# Example usage\nencoded_data = ascii85_encode(b\"12345\")\ndecoded_data = ascii85_decode(encoded_data)\nprint(encoded_data)  # b'0etOA2#'\nprint(decoded_data)  # b'12345'\n```\n\n**Performance Requirement**:\n- The optimized functions should run within 1 second for inputs up to 1MB in size.",
  "solution_code": "import math\n\ndef ascii85_encode(data: bytes) -> bytes:\n    \"\"\"Encodes the binary data to Ascii85 format.\"\"\"\n    chunk_size = 4\n    chunk_count = math.ceil(len(data) / chunk_size)\n    encoded = b\"\"\n    for i in range(chunk_count):\n        chunk = data[i*chunk_size:(i+1)*chunk_size]\n        while len(chunk) < 4:\n            chunk += b'\\x00'\n        chunk_int = int.from_bytes(chunk, byteorder='Big')\n        for j in range(5):\n            pos = 84 ** (4 - j - 1)\n            encoded += bytes([min(chunk_int // pos, 85)])\n            chunk_int %= pos\n    return encoded\n\ndef ascii85_decode(data: bytes) -> bytes:\n    \"\"\"Decodes the Base85 encoded data back to binary data.\"\"\"\n    chunk_size = 5\n    chunk_count = math.ceil(len(data) / chunk_size)\n    decoded = b\"\"\n    for i in range(chunk_count):\n        chunk = data[i*chunk_size:(i+1)*chunk_size]\n        if not chunk:\n            continue\n        chunk_int = 0\n        for j, byte in enumerate(chunk):\n            chunk_int += (85 ** (4 - j)) * (byte - 33)\n        for j in range(4):\n            pos = 85 ** (4 - j - 1)\n            decoded += bytes([chunk_int // pos].to_bytes(1, byteorder='Big'))\n            chunk_int %= pos\n    return decoded[:-1 if decoded[-1:] == b'\\x00' else 0]",
  "test_code": "import pytest\nfrom solution import ascii85_encode, ascii85_decode\n\ndef test_ascii85_encode_decode():\n    assert ascii85_decode(ascii85_encode(b\"12345\")) == b\"12345\"\n\ndef test_ascii85_encode_decode_empty():\n    assert ascii85_decode(ascii85_encode(b\"\")) == b\"\"\n\ndef test_ascii85_encode_decode_spaces():\n    assert ascii85_decode(ascii85_encode(b\"  test  \")) == b\"  test  \"\n\ndef test_ascii85_encode_decode_punctuation():\n    assert ascii85_decode(ascii85_encode(b\"!@#$%^&*()\")) == b\"!@#$%^&*()\"\n\ndef test_ascii85_encode_decode_long():\n    long_string = b\"This is a very long string of text to test the encode and decode functions of Base85 encoding.\"\n    encoded = ascii85_encode(long_string)\n    decoded = ascii85_decode(encoded)\n    assert decoded == long_string\n\ndef test_ascii85_encode_decode_combined():\n    test_data = b\"1234567890\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\"\n    encoded = ascii85_encode(test_data)\n    decoded = ascii85_decode(encoded)\n    assert decoded == test_data",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}