{
  "metadata": {
    "prompt_id": "00000038",
    "row_id": 38,
    "seed_ids": [
      167
    ],
    "mode": "algorithm"
  },
  "instruction": "**Problem Statement**:\nYou are given a sequence of integers. Your task is to implement a function to generate all possible subsequences of the given sequence using a backtracking algorithm. The function should print each subsequence in a separate line.\n\n**Input**:\n- A non-empty list of integers, `sequence`, where the length of the list is between 1 and 10 (inclusive).\n\n**Output**:\n- Print all possible subsequences of the given sequence, each on a new line. Ensure that the subsequences are printed in lexicographical order.\n\n**Example**:\n```python\nsequence = [1, 2, 3]\nOutput:\n[]\n[1]\n[1, 2]\n[1, 2, 3]\n[1, 3]\n[2]\n[2, 3]\n[3]\n```\n\n**Constraints**:\n- The length of `sequence` is between 1 and 10.\n- The elements in `sequence` are integers between 1 and 100.\n\n**Performance Requirement**:\n- Your solution should run efficiently for sequences of length up to 10.\n\n**Implementation**:\nImplement the function to generate and print all possible subsequences of the given sequence.\n\n```python\ndef generate_all_subsequences(sequence: List[int]) -> None:\n    \"\"\"\n    Generates and prints all possible subsequences of the given sequence using a backtracking algorithm.\n    \n    :param sequence: A list of integers.\n    \"\"\"\n    # Your implementation here\n```",
  "solution_code": "from typing import List\n\ndef generate_all_subsequences(sequence: List[int]) -> None:\n    \"\"\"\n    Generates and prints all possible subsequences of the given sequence using a backtracking algorithm.\n    \n    :param sequence: A list of integers.\n    \"\"\"\n    def backtrack(start, current):\n        print(current)\n        for i in range(start, len(sequence)):\n            # Add the element at index i to the current subsequence\n            current.append(sequence[i])\n            # Recurse with the next element\n            backtrack(i + 1, current.copy())  # Use copy to avoid modifying the same subsequence\n            # Remove the last element to explore other subsequences\n            current.pop()\n    \n    backtrack(0, [])\n\nsequence = [1, 2, 3]\ngenerate_all_subsequences(sequence)",
  "test_code": "from solution import generate_all_subsequences\n\ndef test_generate_all_subsequences():\n    # Test with a single element\n    generate_all_subsequences([1])\n    assert True  # No assertion is needed, as the function should print the subsequence correctly\n\n    # Test with multiple elements\n    expected_output = ['[]', '[1]', '[1, 2]', '[1, 2, 3]', '[1, 3]', '[2]', '[2, 3]', '[3]']\n    sequence = [1, 2, 3]\n    captured_output = {}\n    import sys\n    original_stdout = sys.stdout\n    with open('output.txt', 'w') as f:\n        sys.stdout = f\n        generate_all_subsequences(sequence)\n    sys.stdout = original_stdout\n    with open('output.txt', 'r') as f:\n        lines = f.readlines()\n        captured_output = [line.strip() for line in lines]\n    assert captured_output == expected_output\n\ntest_generate_all_subsequences()",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}