{
  "metadata": {
    "prompt_id": "00000046",
    "row_id": 46,
    "seed_ids": [
      752
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a function `liouville_lambda` that calculates the Liouville Lambda function value for a given integer \\( n \\). Your task is to enhance this function to include a more efficient prime factorization method and to handle larger input values gracefully.\n\n**Requirements:**\n1. Implement a function `efficient_prime_factors` that takes an integer \\( n \\) and returns a list of its prime factors in ascending order.\n2. Modify the `liouville_lambda` function to use your `efficient_prime_factors` function.\n3. Ensure the function handles all edge cases correctly:\n   - Raises a `ValueError` if the input is not a positive integer.\n   - Returns 1 if \\( n \\) has an even number of prime factors.\n   - Returns -1 if \\( n \\) has an odd number of prime factors.\n\n**Input:**\n- A single integer \\( n \\) where \\( 1 \\leq n \\leq 10^6 \\).\n\n**Output:**\n- An integer, 1 if the number of prime factors is even, and -1 if it is odd.\n\n**Constraints:**\n- The input \\( n \\) will be a positive integer.\n- The input \\( n \\) will not exceed \\( 10^6 \\).\n\n**Example:**\n```python\nassert liouville_lambda(10) == 1\nassert liouville_lambda(11) == -1\nassert liouville_lambda(100) == 1\nassert liouville_lambda(30030) == -1  # 30030 = 2 * 3 * 5 * 7 * 11 * 13\n```\n\n**Note:**\nYou should focus on optimizing the prime factorization process to handle larger values efficiently.",
  "solution_code": "def efficient_prime_factors(n):\n    \"\"\"\n    Returns a list of prime factors of n in ascending order.\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef liouville_lambda(n):\n    \"\"\"\n    Returns 1 if the number of prime factors (counting multiplicity) is even,\n    -1 if it is odd.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    factors = efficient_prime_factors(n)\n    return -1 if len(factors) % 2 != 0 else 1",
  "test_code": "import pytest\n\ndef test_efficient_prime_factors():\n    assert efficient_prime_factors(1) == []\n    assert efficient_prime_factors(2) == [2]\n    assert efficient_prime_factors(3) == [3]\n    assert efficient_prime_factors(18) == [2, 3, 3]\n    assert efficient_prime_factors(100) == [2, 2, 5, 5]\n\ndef test_liouville_lambda():\n    assert liouville_lambda(1) == 1  # 1 has no prime factors\n    assert liouville_lambda(2) == -1  # 2 is a prime number\n    assert liouville_lambda(10) == 1  # 10 = 2 * 5\n    assert liouville_lambda(11) == -1  # 11 is a prime number\n    assert liouville_lambda(100) == 1  # 100 = 2 * 2 * 5 * 5\n    assert liouville_lambda(30030) == -1  # 30030 = 2 * 3 * 5 * 7 * 11 * 13\n    with pytest.raises(ValueError):\n        liouville_lambda(-1)\n    with pytest.raises(ValueError):\n        liouville_lambda(0)\n\n# Additional tests for edge cases and efficiency\ndef test_large_inputs():\n    import random\n    for _ in range(10):\n        n = random.randint(1, 10**6)\n        factors = efficient_prime_factors(n)\n        assert len(factors) % 2 == liouville_lambda(n)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}