{
  "metadata": {
    "prompt_id": "00000046",
    "row_id": 46,
    "seed_ids": [
      752
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a function `liouville_lambda` that calculates the Liouville Lambda function value for a given integer \\( n \\). Your task is to enhance this function to include a more efficient prime factorization method and to handle larger input values gracefully.\n\n**Requirements:**\n1. Implement a function `efficient_prime_factors` that takes an integer \\( n \\) and returns a list of its prime factors in ascending order.\n2. Modify the `liouville_lambda` function to use your `efficient_prime_factors` function.\n3. Ensure the function handles all edge cases correctly:\n   - Raises a `ValueError` if the input is not a positive integer.\n   - Returns 1 if \\( n \\) has an even number of prime factors.\n   - Returns -1 if \\( n \\) has an odd number of prime factors.\n\n**Input:**\n- A single integer \\( n \\) where \\( 1 \\leq n \\leq 10^6 \\).\n\n**Output:**\n- An integer, 1 if the number of prime factors is even, and -1 if it is odd.\n\n**Constraints:**\n- The input \\( n \\) will be a positive integer.\n- The input \\( n \\) will not exceed \\( 10^6 \\).\n\n**Example:**\n```python\nassert liouville_lambda(10) == 1\nassert liouville_lambda(11) == -1\nassert liouville_lambda(100) == 1\nassert liouville_lambda(30030) == -1  # 30030 = 2 * 3 * 5 * 7 * 11 * 13\n```\n\n**Note:**\nYou should focus on optimizing the prime factorization process to handle larger values efficiently.",
  "solution_code": "def efficient_prime_factors(n):\n    \"\"\"Efficiently returns prime factors of n.\"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef liouville_lambda(n):\n    \"\"\"Calculates the Liouville Lambda function value for n.\"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    factors = efficient_prime_factors(n)\n    # Since duplicates are allowed in prime factors, we need to count unique factors and their powers.\n    factor_counts = {factor: factors.count(factor) for factor in set(factors)}\n    \n    # Liouville Lambda is -1 if the number of prime factors with odd power is odd, 1 otherwise.\n    lambda_val = 1\n    for count in factor_counts.values():\n        if count % 2 != 0:\n            lambda_val *= -1\n            \n    return lambda_val",
  "test_code": "import pytest\n\ndef test_liouville_lambda():\n    assert liouville_lambda(10) == 1, \"10 has an even number of prime factors\"\n    assert liouville_lambda(11) == -1, \"11 has an odd number of prime factors\"\n    assert liouville_lambda(100) == 1, \"100 has an even number of prime factors\"\n    assert liouville_lambda(30030) == -1, \"30030 has an odd number of prime factors\"\n    with pytest.raises(ValueError, match=\"Input must be a positive integer.\"):\n        liouville_lambda(0)\n    with pytest.raises(ValueError, match=\"Input must be a positive integer.\"):\n        liouville_lambda(-3)\n    with pytest.raises(ValueError, match=\"Input must be a positive integer.\"):\n        liouville_lambda(3.14)\n    with pytest.raises(ValueError, match=\"Input must be a positive integer.\"):\n        liouville_lambda(\"string\")\n    assert liouville_lambda(2) == -1, \"2 has an odd number of prime factors\"\n    assert liouville_lambda(4) == 1, \"4 has an even number of prime factors\"\n\nif __name__ == \"__main__\":\n    pytest.main()",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}