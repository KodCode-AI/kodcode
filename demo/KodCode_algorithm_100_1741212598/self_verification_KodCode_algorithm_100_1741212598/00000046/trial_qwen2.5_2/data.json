{
  "metadata": {
    "prompt_id": "00000046",
    "row_id": 46,
    "seed_ids": [
      752
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a function `liouville_lambda` that calculates the Liouville Lambda function value for a given integer \\( n \\). Your task is to enhance this function to include a more efficient prime factorization method and to handle larger input values gracefully.\n\n**Requirements:**\n1. Implement a function `efficient_prime_factors` that takes an integer \\( n \\) and returns a list of its prime factors in ascending order.\n2. Modify the `liouville_lambda` function to use your `efficient_prime_factors` function.\n3. Ensure the function handles all edge cases correctly:\n   - Raises a `ValueError` if the input is not a positive integer.\n   - Returns 1 if \\( n \\) has an even number of prime factors.\n   - Returns -1 if \\( n \\) has an odd number of prime factors.\n\n**Input:**\n- A single integer \\( n \\) where \\( 1 \\leq n \\leq 10^6 \\).\n\n**Output:**\n- An integer, 1 if the number of prime factors is even, and -1 if it is odd.\n\n**Constraints:**\n- The input \\( n \\) will be a positive integer.\n- The input \\( n \\) will not exceed \\( 10^6 \\).\n\n**Example:**\n```python\nassert liouville_lambda(10) == 1\nassert liouville_lambda(11) == -1\nassert liouville_lambda(100) == 1\nassert liouville_lambda(30030) == -1  # 30030 = 2 * 3 * 5 * 7 * 11 * 13\n```\n\n**Note:**\nYou should focus on optimizing the prime factorization process to handle larger values efficiently.",
  "solution_code": "def efficient_prime_factors(n):\n    \"\"\"\n    Returns a list of prime factors of n in ascending order.\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef liouville_lambda(n):\n    \"\"\"\n    Returns 1 if the number of prime factors is even, and -1 if it is odd.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    factors = efficient_prime_factors(n)\n    return -1 if len(factors) % 2 else 1",
  "test_code": "import pytest\n\ndef test_efficient_prime_factors():\n    assert efficient_prime_factors(10) == [2, 5]\n    assert efficient_prime_factors(17) == [17]\n    assert efficient_prime_factors(100) == [2, 2, 5, 5]\n    assert efficient_prime_factors(30030) == [2, 3, 5, 7, 11, 13]\n\ndef test_liouville_lambda():\n    assert liouville_lambda(10) == 1\n    assert liouville_lambda(11) == -1\n    assert liouville_lambda(100) == 1\n    assert liouville_lambda(30030) == -1\n    with pytest.raises(ValueError):\n        liouville_lambda(0)\n    with pytest.raises(ValueError):\n        liouville_lambda(1.5)\n    with pytest.raises(ValueError):\n        liouville_lambda(-10)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}