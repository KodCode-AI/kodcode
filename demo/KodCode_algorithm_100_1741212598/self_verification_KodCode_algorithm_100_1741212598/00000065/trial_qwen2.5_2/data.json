{
  "metadata": {
    "prompt_id": "00000065",
    "row_id": 65,
    "seed_ids": [
      203
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question: Optimizing Odd-Even Transposition Sort\n\nYou are given a list of integers that may contain duplicates. Your task is to implement an optimized version of the Odd-Even Transposition Sort (OETS) algorithm that sorts the list in ascending order. The algorithm should be fully parallel and handle the list in a way that minimizes the number of synchronization points and communication overhead.\n\n#### Requirements:\n\n1. **Input**: A list of integers `arr` (1 \u2264 len(arr) \u2264 10^5).\n2. **Output**: Return the sorted list of integers.\n3. **Constraints**:\n   - The list can contain up to 100,000 integers.\n   - The integers can range from -10^9 to 10^9.\n4. **Performance Requirement**: The algorithm should be as efficient as possible in terms of both time and space complexity.\n\n#### Implementation Notes:\n\n- Use Python's `multiprocessing` module to implement the algorithm.\n- Ensure that the algorithm is fully parallel and minimizes synchronization points.\n- Handle edge cases such as an empty list or a list with a single element.\n\n#### Scenario:\n\nYou are part of a high-performance computing team that needs to sort large datasets efficiently. Your task is to optimize the OETS algorithm to handle these large datasets effectively.\n\n#### Example:\n\n```python\ndef optimized_odd_even_transposition(arr):\n    # Your implementation here\n    pass\n\n# Test the function\nprint(optimized_odd_even_transposition([4, 1, 3, 2]))  # Output: [1, 2, 3, 4]\nprint(optimized_odd_even_transposition([-5, 9, -2, 10, -1]))  # Output: [-5, -2, -1, 9, 10]\n```\n\n#### Additional Challenge:\n\n- Optimize the algorithm further by reducing the number of synchronization points and communication overhead.\n\n---\n\nImplement the `optimized_odd_even_transposition` function to meet the requirements.",
  "solution_code": "import multiprocessing as mp\n\ndef optimized_odd_even_transposition(arr):\n    \"\"\"\n    Returns a sorted list using the optimized odd-even transposition sort algorithm.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    # Define the number of processes\n    num_processes = mp.cpu_count()\n    chunk_size = len(arr) // num_processes\n    chunks = [arr[i:i + chunk_size] for i in range(0, len(arr), chunk_size)]\n    if len(chunks[-1]) < chunk_size:\n        chunks.pop()  # Remove the last chunk if it's smaller than the chunk size\n    \n    # Sort each chunk in parallel\n    with mp.Pool(processes=num_processes) as pool:\n        sorted_chunks = pool.map(optimized_odd_even_transposition, chunks)\n    \n    # Merge sorted chunks\n    def merge(left, right):\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n    \n    while len(sorted_chunks) > 1:\n        new_chunks = []\n        for i in range(0, len(sorted_chunks), 2):\n            if i + 1 < len(sorted_chunks):\n                new_chunks.append(merge(sorted_chunks[i], sorted_chunks[i + 1]))\n            else:\n                new_chunks.append(sorted_chunks[i])\n        sorted_chunks = new_chunks\n    \n    return sorted_chunks[0]",
  "test_code": "import pytest\nfrom solution import optimized_odd_even_transposition\n\ndef test_optimized_odd_even_transposition():\n    assert optimized_odd_even_transposition([4, 1, 3, 2]) == [1, 2, 3, 4]\n    assert optimized_odd_even_transposition([-5, 9, -2, 10, -1]) == [-5, -2, -1, 9, 10]\n    assert optimized_odd_even_transposition([7, 2, 9, 5, 4, 3, 1]) == [1, 2, 3, 4, 5, 7, 9]\n    assert optimized_odd_even_transposition([10, 20, 30, 40, 50]) == [10, 20, 30, 40, 50]\n    assert optimized_odd_even_transposition([]) == []\n    assert optimized_odd_even_transposition([5]) == [5]\n    assert optimized_odd_even_transposition([-10, -20, -30, -40, -50]) == [-50, -40, -30, -20, -10]\n\ndef test_performance():\n    # Test performance on a large dataset\n    large_dataset = list(range(100000))\n    import time\n    start_time = time.time()\n    optimized_odd_even_transposition(large_dataset)\n    end_time = time.time()\n    assert (end_time - start_time) < 10  # Assuming it should complete in less than 10 seconds\n\n    large_dataset.reverse()\n    start_time = time.time()\n    optimized_odd_even_transposition(large_dataset)\n    end_time = time.time()\n    assert (end_time - start_time) < 10  # Similarly for a reverse sorted list\n\ndef test_duplicates():\n    assert optimized_odd_even_transposition([4, 1, 3, 2, 2, 3, 4]) == [1, 2, 2, 3, 3, 4, 4]\n    assert optimized_odd_even_transposition([-5, 9, -2, 10, -1, -2, 9]) == [-5, -2, -2, -1, 9, 9, 10]",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}