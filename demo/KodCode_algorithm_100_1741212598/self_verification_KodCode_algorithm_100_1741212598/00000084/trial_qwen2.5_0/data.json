{
  "metadata": {
    "prompt_id": "00000084",
    "row_id": 84,
    "seed_ids": [
      503
    ],
    "mode": "algorithm"
  },
  "instruction": "You are tasked with implementing a function to find the value of `n` (1 < n < 10^7) for which the Euler's Totient function (`\u03c6(n)`) is a permutation of `n` and the ratio `n/\u03c6(n)` produces a minimum. The function should return this value of `n`.\n\n### Problem Description\n\nEuler's Totient function, \u03c6(n), is used to determine the number of positive integers less than or equal to n that are relatively prime to n. For example, \u03c6(9) = 6, as 1, 2, 4, 5, 7, and 8 are all relatively prime to 9.\n\nYou need to find the value of `n` in the range 1 < n < 10^7 such that `\u03c6(n)` is a permutation of `n` and the ratio `n/\u03c6(n)` is minimized. A permutation of a number means the digits of the two numbers are the same, but their order may differ.\n\n### Constraints\n\n- 1 < n < 10^7\n- You may use any efficient data structures to store and update values.\n\n### Example\n\n```python\ndef find_min_ratio():\n    # Your implementation here\n    return n\n```\n\n### Expected Functionality\n\n- The function should return the value of `n` that meets the criteria.\n- The function should handle edge cases and perform efficiently within the given constraints.\n\n### Notes\n\n- You should implement the function from scratch without referencing the provided code snippet.\n- You should also include a check function to test your implementation with provided data points.",
  "solution_code": "def prime_factors(n, primes):\n    \"\"\"\n    Returns the prime factorization of n given a list of primes.\n    \"\"\"\n    factors = []\n    for prime in primes:\n        while n % prime == 0:\n            factors.append(prime)\n            n //= prime\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef phi(n, primes):\n    \"\"\"\n    Returns Euler's Totient function value for n using prime factorization.\n    \"\"\"\n    if n == 1:\n        return 1\n    factors = prime_factors(n, primes)\n    unique_factors = sorted(set(factors))\n    phi_n = n\n    for prime in unique_factors:\n        phi_n *= (1 - 1/prime)\n    return int(phi_n)\n\ndef find_min_ratio():\n    primes = sieve_of_eratosthenes(100000)\n    best_n = None\n    min_ratio = float('inf')\n    for n in range(2, 10000000):\n        # Check if phi(n) is a permutation of n\n        if sorted(str(n)) == sorted(str(phi(n, primes))):\n            current_ratio = n / phi(n, primes)\n            if current_ratio < min_ratio:\n                min_ratio = current_ratio\n                best_n = n\n    return best_n\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"\n    Generates all prime numbers up to the limit using the Sieve of Eratosthenes.\n    \"\"\"\n    sieve = [True] * (limit + 1)\n    for num in range(2, int(limit**0.5) + 1):\n        if sieve[num]:\n            for multiple in range(num*num, limit + 1, num):\n                sieve[multiple] = False\n    return [num for num in range(2, limit) if sieve[num]]\n\ndef find_min_permutation_of_phi():\n    return find_min_ratio()",
  "test_code": "from solution import find_min_permutation_of_phi, find_min_ratio\n\ndef test_find_min_permutation_of_phi():\n    assert find_min_permutation_of_phi() == 1393331\n\ndef test_phi_with_known_values():\n    primes = find_min_ratio().prime_factors(100000)\n    assert phi(9, primes) == 6\n    assert phi(15, primes) == 8\n\ndef test_sieve_of_eratosthenes():\n    expected_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    assert find_min_ratio().sieve_of_eratosthenes(30) == expected_primes\n\ndef test_find_min_ratio():\n    assert 2 <= find_min_ratio() < 10000000\n    assert sorted(str(find_min_ratio())) == sorted(str(find_min_ratio().phi(find_min_ratio(), find_min_ratio().prime_factors(100000))))",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}