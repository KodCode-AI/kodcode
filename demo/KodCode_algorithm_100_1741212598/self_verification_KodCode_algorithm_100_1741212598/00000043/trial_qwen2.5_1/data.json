{
  "metadata": {
    "prompt_id": "00000043",
    "row_id": 43,
    "seed_ids": [
      781
    ],
    "mode": "algorithm"
  },
  "instruction": "**Scenario/Context**: \nYou are working on a project that requires a fast and efficient way to approximate \u03c0. The Leibniz formula is a simple and educational method to understand series representation of \u03c0, but it is not suitable for high-precision applications due to its slow convergence. Your task is to design a more efficient algorithm that can approximate \u03c0 with a given precision.\n\n**Task**:\nImplement a function `calculate_pi_efficient` that approximates \u03c0 to a given precision. The function should use a different series or algorithm that converges faster than the Leibniz formula. Additionally, ensure that the function can handle large values of precision efficiently and accurately.\n\n**Expected Input and Output**:\n- **Input**:\n  - `precision` (int): The number of decimal places to which \u03c0 should be approximated.\n- **Output**:\n  - A string representing \u03c0 to the specified precision.\n\n**Constraints**:\n- The function must be efficient and handle large values of precision without running into performance issues.\n\n**Performance Requirements**:\n- The function should be able to compute \u03c0 to at least 100 decimal places within a reasonable time.\n\n**Example**:\n```python\n>>> calculate_pi_efficient(50)\n'3.14159265358979323846264338327950288419716939937510582097494459230781640628620899'\n```",
  "solution_code": "from decimal import Decimal, getcontext\n\ndef calculate_pi_efficient(precision):\n    \"\"\"\n    Approximates pi to the given precision using the AGM (Arithmetic-Geometric Mean) method.\n    \"\"\"\n    getcontext().prec = precision + 2  # Set precision to be safe and add extra for accuracy\n\n    def agm(a, b, epsilon):\n        while abs(a - b) > epsilon:\n            a_next = (a + b) / 2\n            b_next = (a * b)**0.5\n            a, b = a_next, b_next\n        return a\n\n    a = Decimal(1)\n    b = Decimal(1).sqrt()\n    pi = Decimal(4) * (a + b) * (a + b) / (4 * a)\n    return str(pi.quantize(Decimal('1.' + '0' * precision)))",
  "test_code": "def test_calculate_pi_efficient():\n    precision = 50\n    expected = '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899'\n    result = calculate_pi_efficient(precision)\n    assert result == expected\n\ndef test_calculate_pi_lower_precision():\n    precision = 10\n    expected = '3.141592653589793238462643383279502884197169399375'\n    result = calculate_pi_efficient(precision)\n    assert result == expected\n\ndef test_calculate_pi_high_precision():\n    precision = 100\n    result = calculate_pi_efficient(precision)\n    # Here we can only make a partial check because the full result is very long\n    assert len(result.split('.')[-1]) == precision\n    assert float(result) == float('3.14159265358979323846264338327950288419716939937510582097494459230781640628620899')\n\ndef test_calculate_pi_zero_precision():\n    precision = 0\n    expected = '3'\n    result = calculate_pi_efficient(precision)\n    assert result == expected",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}