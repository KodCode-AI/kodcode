{
  "metadata": {
    "prompt_id": "00000043",
    "row_id": 43,
    "seed_ids": [
      781
    ],
    "mode": "algorithm"
  },
  "instruction": "**Scenario/Context**: \nYou are working on a project that requires a fast and efficient way to approximate \u03c0. The Leibniz formula is a simple and educational method to understand series representation of \u03c0, but it is not suitable for high-precision applications due to its slow convergence. Your task is to design a more efficient algorithm that can approximate \u03c0 with a given precision.\n\n**Task**:\nImplement a function `calculate_pi_efficient` that approximates \u03c0 to a given precision. The function should use a different series or algorithm that converges faster than the Leibniz formula. Additionally, ensure that the function can handle large values of precision efficiently and accurately.\n\n**Expected Input and Output**:\n- **Input**:\n  - `precision` (int): The number of decimal places to which \u03c0 should be approximated.\n- **Output**:\n  - A string representing \u03c0 to the specified precision.\n\n**Constraints**:\n- The function must be efficient and handle large values of precision without running into performance issues.\n\n**Performance Requirements**:\n- The function should be able to compute \u03c0 to at least 100 decimal places within a reasonable time.\n\n**Example**:\n```python\n>>> calculate_pi_efficient(50)\n'3.14159265358979323846264338327950288419716939937510582097494459230781640628620899'\n```",
  "solution_code": "from decimal import Decimal, getcontext\n\ndef calculate_pi_efficient(precision):\n    \"\"\"\n    Calculates \u03c0 to the given precision using the Bailey-Borwein-Plouffe (BBP) formula.\n    \"\"\"\n    def bbp_formula(k):\n        return (1 / (16**k)) * (4 / (8*k + 1) - (2 / (8*k + 4)) - (1 / (8*k + 5)) - (1 / (8*k + 6)))\n    \n    getcontext().prec = precision + 2  # Set precision to be slightly higher to account for rounding\n    pi = Decimal(0)\n    for k in range(precision):\n        pi += bbp_formula(k)\n    pi = str(pi)[:precision+2]  # Return the required number of decimal places\n    return pi.rstrip('0').rstrip('.')  # Remove trailing zeros and decimal point if necessary\n\ndef main():\n    print(calculate_pi_efficient(50))\n\nif __name__ == \"__main__\":\n    main()",
  "test_code": "import pytest\nfrom decimal import Decimal\n\ndef test_calculate_pi_efficient():\n    # Test with precision 10\n    pi_val_10 = calculate_pi_efficient(10)\n    assert pi_val_10 == '3.1415926536'\n    \n    # Test with precision 50\n    pi_val_50 = calculate_pi_efficient(50)\n    expected_pi_50 = '3.1415926535897932384626433832795028841971693993751'\n    assert pi_val_50 == expected_pi_50\n    \n    # Test with precision 100\n    pi_val_100 = calculate_pi_efficient(100)\n    expected_pi_100 = '3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067'\n    assert pi_val_100 == expected_pi_100[:102]  # Cut off at 102 to account for possible rounding\n\ndef test_with_large_values():\n    large_precision = 200\n    pi_val_200 = calculate_pi_efficient(large_precision)\n    assert len(pi_val_200) == 203  # Check if the length is correct, considering 2 extra digits for precision",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}