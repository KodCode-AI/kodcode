{
  "metadata": {
    "prompt_id": "00000043",
    "row_id": 43,
    "seed_ids": [
      781
    ],
    "mode": "algorithm"
  },
  "instruction": "**Scenario/Context**: \nYou are working on a project that requires a fast and efficient way to approximate \u03c0. The Leibniz formula is a simple and educational method to understand series representation of \u03c0, but it is not suitable for high-precision applications due to its slow convergence. Your task is to design a more efficient algorithm that can approximate \u03c0 with a given precision.\n\n**Task**:\nImplement a function `calculate_pi_efficient` that approximates \u03c0 to a given precision. The function should use a different series or algorithm that converges faster than the Leibniz formula. Additionally, ensure that the function can handle large values of precision efficiently and accurately.\n\n**Expected Input and Output**:\n- **Input**:\n  - `precision` (int): The number of decimal places to which \u03c0 should be approximated.\n- **Output**:\n  - A string representing \u03c0 to the specified precision.\n\n**Constraints**:\n- The function must be efficient and handle large values of precision without running into performance issues.\n\n**Performance Requirements**:\n- The function should be able to compute \u03c0 to at least 100 decimal places within a reasonable time.\n\n**Example**:\n```python\n>>> calculate_pi_efficient(50)\n'3.14159265358979323846264338327950288419716939937510582097494459230781640628620899'\n```",
  "solution_code": "from mpmath import mp\n\ndef calculate_pi_efficient(precision):\n    \"\"\"\n    Approximates \u03c0 to the specified precision using the mpmath library for arbitrary precision calculations.\n    \"\"\"\n    mp.dps = precision  # set the decimal precision\n    return str(mp.pi)",
  "test_code": "import mpmath\nfrom solution import calculate_pi_efficient\n\ndef test_calculate_pi_efficient():\n    precision = 50\n    expected = str(mpmath.mp/mp.pi)  # Convert mpmath.pi to string with the specified precision\n    approximation = calculate_pi_efficient(precision)\n    assert len(approximation) - approximation.rstrip('0').rfind('.') - 1 == precision  # Verify the precision\n    assert float(approximation) == float(expected)  # Verify the value\n\ndef test_calculate_pi_small_precision():\n    precision = 10\n    expected = str(mpmath.mp.mp.pi)  # Convert mpmath.pi to string with the specified precision\n    approximation = calculate_pi_efficient(precision)\n    assert len(approximation) - approximation.rstrip('0').rfind('.') - 1 == precision\n    assert float(approximation) == float(expected)\n\ndef test_calculate_pi_large_precision():\n    precision = 100\n    expected = str(mpmath.mp/mp.pi)\n    approximation = calculate_pi_efficient(precision)\n    assert len(approximation) - approximation.rstrip('0').rfind('.') - 1 == precision\n    assert float(approximation) == float(expected)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}