{
  "metadata": {
    "prompt_id": "00000044",
    "row_id": 44,
    "seed_ids": [
      224
    ],
    "mode": "algorithm"
  },
  "instruction": "### Scenario\n\nYou have been given a piece of Python code implementing the comb sort algorithm. The comb sort algorithm is a simple yet effective improvement over bubble sort, which sorts a list of elements in ascending order by comparing elements with a certain gap. The gap in comb sort starts with the length of the list and is reduced by a shrink factor until it becomes 1.\n\nHowever, the provided code has a few limitations and edge cases that need to be handled more robustly. Your task is to modify the given comb sort function to handle these issues and improve its performance.\n\n### Requirements\n\n1. **Input**: A list of integers.\n2. **Output**: The same list sorted in ascending order.\n3. **Constraints**:\n   - The list can contain up to 100,000 elements.\n   - Elements can range from -1,000,000 to 1,000,000.\n4. **Performance**: The function should be efficient, aiming for a time complexity of \\(O(n \\log n)\\) in the worst case.\n\n### Implementation\n\n1. Modify the `comb_sort` function to handle edge cases such as empty lists and single-element lists.\n2. Optimize the gap reduction strategy to improve the sorting efficiency.\n3. Ensure the function correctly handles sorting large lists with a high number of duplicates.\n\n### Example\n\n```python\n# Example usage\nunsorted = [5, 3, 8, 4, 2]\nsorted_list = comb_sort(unsorted)\nprint(sorted_list)  # Output: [2, 3, 4, 5, 8]\n```\n\n### Additional Constraints\n\n- You should not use any external libraries or built-in sorting functions.\n- The code should be clear, well-documented, and easy to understand.\n\n### Provided Code\n\n```python\ndef comb_sort(data: list) -> list:\n    # Your implementation here\n    return data\n```\n\n### Task\n\nImplement the `comb_sort` function according to the requirements and constraints provided. Make sure to handle all edge cases and optimize the sorting algorithm to perform efficiently.",
  "solution_code": "def comb_sort(data: list) -> list:\n    \"\"\"\n    Sorts a list of integers in ascending order using the comb sort algorithm.\n    \"\"\"\n    if not data:\n        return data\n\n    gap = len(data)\n    shrink_factor = 1.3\n    sorted_flag = False\n\n    while not sorted_flag:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted_flag = True\n\n        # A single \"comb\" over the input list\n        for i in range(len(data) - gap):\n            if data[i] > data[i + gap]:\n                # Swap elements\n                data[i], data[i + gap] = data[i + gap], data[i]\n                sorted_flag = False\n\n    return data",
  "test_code": "`python\nimport pytest\n\ndef test_comb_sort_empty_list():\n    assert comb_sort([]) == []\n\ndef test_comb_sort_single_element():\n    assert comb_sort([5]) == [5]\n\ndef test_comb_sort_positive_numbers():\n    assert comb_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8]\n\ndef test_comb_sort_negative_numbers():\n    assert comb_sort([-5, -3, -8, -4, -2]) == [-8, -5, -4, -3, -2]\n\ndef test_comb_sort_mixed_sign_and_duplicates():\n    assert comb_sort([5, 5, 3, 8, 4, 2, -2, -2]) == [-2, -2, 2, 3, 4, 5, 5, 8]\n\ndef test_comb_sort_large_random_list():\n    import random\n    data = [random.randint(-1000000, 1000000) for _ in range(100000)]\n    sorted_data = sorted(data)\n    assert comb_sort(data) == sorted_data\n\ndef test_comb_sort_already_sorted_list():\n    assert comb_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_comb_sort_reversed_list():\n    assert comb_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}