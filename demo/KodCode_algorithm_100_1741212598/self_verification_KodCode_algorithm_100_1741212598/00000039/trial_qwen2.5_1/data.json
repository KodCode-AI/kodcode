{
  "metadata": {
    "prompt_id": "00000039",
    "row_id": 39,
    "seed_ids": [
      729
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a Python function to check if a number is a perfect cube using binary search. Your task is to enhance the functionality to find the cube root of a given number if it is a perfect cube. If the number is not a perfect cube, return `None`.\n\n### Requirements\n- The function should accept an integer and return an integer if the input is a perfect cube, otherwise return `None`.\n- Handle edge cases such as negative numbers and non-integer inputs.\n- Ensure that the function is efficient and works well for large numbers.\n\n### Example\n```python\ndef cube_root(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError(\"cube_root() only accepts integers\")\n    if n < 0:\n        n = -n\n    left = 0\n    right = n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid * mid == n:\n            return mid\n        elif mid * mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return None\n\n# Test cases\nassert cube_root(27) == 3\nassert cube_root(64) == 4\nassert cube_root(125) == 5\nassert cube_root(28) is None\nassert cube_root(\"a\")  # Expected to raise TypeError\n```\n\n### Constraints\n- The input number `n` is an integer.\n- The solution should be efficient and have a time complexity of O(log n).\n\n### Performance Requirements\n- The function should handle numbers up to \\(10^9\\) efficiently.\n\n### Context\nYou are designing a function to process large datasets where checking for perfect cubes and finding their cube roots is necessary. The function should be robust and handle edge cases gracefully.",
  "solution_code": "def cube_root(n: int) -> int:\n    \"\"\"\n    Returns the cube root of n if n is a perfect cube, otherwise returns None.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"cube_root() only accepts integers\")\n    if n < 0:\n        n = -n\n\n    left, right = 0, n\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        cube = mid * mid * mid\n        if cube == n:\n            return mid\n        elif cube < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return None",
  "test_code": "import pytest\n\ndef test_cube_root_perfect_cubes():\n    assert cube_root(27) == 3\n    assert cube_root(64) == 4\n    assert cube_root(125) == 5\n    assert cube_root(216) == 6\n    assert cube_root(343) == 7\n    assert cube_root(729) == 9\n\ndef test_cube_root_not_a_perfect_cube():\n    assert cube_root(28) is None\n    assert cube_root(29) is None\n    assert cube_root(30) is None\n    assert cube_root(31) is None\n    assert cube_root(80) is None\n\ndef test_empty_input():\n    assert cube_root(0) is None\n\ndef test_negative_input():\n    assert cube_root(-27) is None\n\ndef test_large_input():\n    assert cube_root(1000000000) == 1000\n\ndef test_invalid_input_type():\n    with pytest.raises(TypeError):\n        cube_root(\"a\")\n    with pytest.raises(TypeError):\n        cube_root(1.5)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}