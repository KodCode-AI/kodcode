{
  "metadata": {
    "prompt_id": "00000039",
    "row_id": 39,
    "seed_ids": [
      729
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a Python function to check if a number is a perfect cube using binary search. Your task is to enhance the functionality to find the cube root of a given number if it is a perfect cube. If the number is not a perfect cube, return `None`.\n\n### Requirements\n- The function should accept an integer and return an integer if the input is a perfect cube, otherwise return `None`.\n- Handle edge cases such as negative numbers and non-integer inputs.\n- Ensure that the function is efficient and works well for large numbers.\n\n### Example\n```python\ndef cube_root(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError(\"cube_root() only accepts integers\")\n    if n < 0:\n        n = -n\n    left = 0\n    right = n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid * mid == n:\n            return mid\n        elif mid * mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return None\n\n# Test cases\nassert cube_root(27) == 3\nassert cube_root(64) == 4\nassert cube_root(125) == 5\nassert cube_root(28) is None\nassert cube_root(\"a\")  # Expected to raise TypeError\n```\n\n### Constraints\n- The input number `n` is an integer.\n- The solution should be efficient and have a time complexity of O(log n).\n\n### Performance Requirements\n- The function should handle numbers up to \\(10^9\\) efficiently.\n\n### Context\nYou are designing a function to process large datasets where checking for perfect cubes and finding their cube roots is necessary. The function should be robust and handle edge cases gracefully.",
  "solution_code": "def cube_root(n: int) -> int:\n    \"\"\"\n    Returns the cube root of n if n is a perfect cube, otherwise returns None.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"cube_root() only accepts integers\")\n    if n < 0:\n        n = -n\n\n    if n == 0:\n        return 0\n\n    left = 1\n    right = n\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        cube = mid * mid * mid\n\n        if cube == n:\n            return mid\n        elif cube < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return None",
  "test_code": "import pytest\r\n\r\ndef test_cube_root_perfect_cubes():\n    assert cube_root(27) == 3\n    assert cube_root(64) == 4\n    assert cube_root(125) == 5\n\ndef test_cube_root_non_perfect_cubes():\n    assert cube_root(28) is None\n    assert cube_root(35) is None\n    assert cube_root(1) is None\n\ndef test_cube_root_negative_numbers():\n    with pytest.raises(TypeError):\n        cube_root(-27)\n\ndef test_cube_root_zero():\n    assert cube_root(0) == 0\n\ndef test_cube_root_large_numbers():\n    assert cube_root(27 ** 3) == 27\n    assert cube_root((10**9) ** (1/3) ** 3) == 10**3\n\ndef test_cube_root_non_integers():\n    with pytest.raises(TypeError):\n        cube_root(\"27\")\n\ndef test_cube_root_edge_cases():\n    assert cube_root(8) == 2\n    assert cube_root(1) is None",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}