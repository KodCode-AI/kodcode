{
  "metadata": {
    "prompt_id": "00000039",
    "row_id": 39,
    "seed_ids": [
      729
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a Python function to check if a number is a perfect cube using binary search. Your task is to enhance the functionality to find the cube root of a given number if it is a perfect cube. If the number is not a perfect cube, return `None`.\n\n### Requirements\n- The function should accept an integer and return an integer if the input is a perfect cube, otherwise return `None`.\n- Handle edge cases such as negative numbers and non-integer inputs.\n- Ensure that the function is efficient and works well for large numbers.\n\n### Example\n```python\ndef cube_root(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError(\"cube_root() only accepts integers\")\n    if n < 0:\n        n = -n\n    left = 0\n    right = n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid * mid == n:\n            return mid\n        elif mid * mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return None\n\n# Test cases\nassert cube_root(27) == 3\nassert cube_root(64) == 4\nassert cube_root(125) == 5\nassert cube_root(28) is None\nassert cube_root(\"a\")  # Expected to raise TypeError\n```\n\n### Constraints\n- The input number `n` is an integer.\n- The solution should be efficient and have a time complexity of O(log n).\n\n### Performance Requirements\n- The function should handle numbers up to \\(10^9\\) efficiently.\n\n### Context\nYou are designing a function to process large datasets where checking for perfect cubes and finding their cube roots is necessary. The function should be robust and handle edge cases gracefully.",
  "solution_code": "def cube_root(n: int) -> int:\n    \"\"\"\n    Returns the integer cube root of n if n is a perfect cube, otherwise returns None.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"cube_root() only accepts integers\")\n    if n == 0:\n        return 0  # Handle edge case for zero\n    if n < 0:\n        n = -n\n        lower = -int(round(n ** (1/3.0)))\n        upper = -1\n    else:\n        lower = 0\n        upper = int(round(n ** (1/3.0)))\n\n    while lower <= upper:\n        mid = (lower + upper) // 2\n        if mid * mid * mid == n:\n            return mid\n        elif mid * mid * mid < n:\n            lower = mid + 1\n        else:\n            upper = mid - 1\n    return None",
  "test_code": "import pytest\nfrom solution import cube_root\n\ndef test_cube_root_positive_perfect_cubes():\n    assert cube_root(27) == 3\n    assert cube_root(64) == 4\n    assert cube_root(125) == 5\n\ndef test_cube_root_negative_perfect_cubes():\n    assert cube_root(-27) == -3\n    assert cube_root(-64) == -4\n    assert cube_root(-125) == -5\n\ndef test_cube_root_non_perfect_cubes():\n    assert cube_root(28) is None\n    assert cube_root(26) is None\n    assert cube_root(80) is None\n\ndef test_cube_root_zero():\n    assert cube_root(0) == 0\n\ndef test_cube_root_negative_zero():\n    assert cube_root(-0) == 0\n\ndef test_cube_root_non_integer():\n    with pytest.raises(TypeError):\n        cube_root(\"a\")\n    with pytest.raises(TypeError):\n        cube_root(3.5)\n\ndef test_large_numbers():\n    assert cube_root(1000000000) == 100\n    assert cube_root(-1000000000) == -100\n\ndef test_edge_cases():\n    assert cube_root(1) == 1\n    assert cube_root(-1) == -1\n    assert cube_root(2) is None\n    assert cube_root(-2) is None",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}