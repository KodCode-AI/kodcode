{
  "metadata": {
    "prompt_id": "00000027",
    "row_id": 27,
    "seed_ids": [
      63
    ],
    "mode": "algorithm"
  },
  "instruction": "### Context:\nYou are tasked with enhancing a Vigen\u00e8re Cipher implementation to support both encryption and decryption. Your goal is to handle a larger set of characters, including spaces and punctuation, and to ensure the function is robust against edge cases.\n\n### Problem Statement:\nImplement the `encrypt_message` and `decrypt_message` functions to correctly handle a message that may contain uppercase and lowercase letters, spaces, and punctuation marks as defined in the `LETTERS` string. Your implementation should maintain the case of the original message and should correctly handle the keyword wrapping for each character.\n\n### Requirements:\n- **Input**:\n  - `key`: A string representing the encryption/decryption key.\n  - `message`: A string representing the message to be encrypted or decrypted.\n  - `mode`: A string that is either `\"encrypt\"` or `\"decrypt\"`.\n\n- **Output**:\n  - Return the translated message as a string.\n\n- **Constraints**:\n  - The key can consist of any alphanumeric characters.\n  - The message can contain uppercase and lowercase letters, spaces, and punctuation marks.\n  - The `LETTERS` string includes all uppercase and lowercase English letters, as well as digits.\n\n### Example:\n```python\n# Example 1: Encryption\nkey = 'HDarji'\nmessage = 'This is Harshil Darji from Dharmaj.'\nmode = 'encrypt'\ntranslate_message(key, message, mode)  # Output: 'Akij ra Odrjqqs Gaisq muod Mphumrs.'\n\n# Example 2: Decryption\nkey = 'HDarji'\nmessage = 'Akij ra Odrjqqs Gaisq muod Mphumrs.'\nmode = 'decrypt'\ntranslate_message(key, message, mode)  # Output: 'This is Harshil Darji from Dharmaj.'\n```\n\n### Implementation:\n```python\nLETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,!?\"\n\ndef encrypt_message(key: str, message: str) -> str:\n    return translate_message(key, message, \"encrypt\")\n\ndef decrypt_message(key: str, message: str) -> str:\n    return translate_message(key, message, \"decrypt\")\n\ndef translate_message(key: str, message: str, mode: str) -> str:\n    # Your implementation here\n```\n\n### Submission:\n- Ensure your implementation is efficient and handles all specified requirements and examples correctly.",
  "solution_code": "LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,!\"\n\ndef find_position(letter, mode):\n    if letter in LETTERS:\n        if mode == 'encrypt':\n            return LETTERS.find(letter)\n        if mode == 'decrypt':\n            return LETTERS.rfind(letter)\n    return -1\n\ndef encrypt_message(key: str, message: str) -> str:\n    return translate_message(key, message, \"encrypt\")\n\ndef decrypt_message(key: str, message: str) -> str:\n    return translate_message(key, message, \"decrypt\")\n\ndef translate_message(key: str, message: str, mode: str) -> str:\n    translation = \"\"\n    key_index = 0\n    for char in message:\n        if char in LETTERS:\n            temp_key = key[key_index % len(key)]\n            key_index += 1\n            if mode == 'encrypt':\n                new_index = (find_position(char, 'encrypt') + find_position(temp_key, 'encrypt')) % len(LETTERS)\n            else:  # mode == 'decrypt'\n                new_index = (find_position(char, 'decrypt') - find_position(temp_key, 'encrypt')) % len(LETTERS)\n            translation += LETTERS[new_index]\n        else:\n            translation += char\n    return translation",
  "test_code": "from solution import encrypt_message, decrypt_message\n\ndef test_encrypt_decrypt_cycle():\n    key = 'HDarji'\n    message = 'This is Harshil Darji from Dharmaj.'\n    encrypted = encrypt_message(key, message)\n    decrypted = decrypt_message(key, encrypted)\n    assert decrypted == message\n\ndef test_encrypt_uppercase():\n    key = 'XYZ'\n    message = 'HELLO WORLD!'\n    encrypted = encrypt_message(key, message)\n    assert encrypted == 'JXSSO XWPSG!'\n\ndef test_decrypt_uppercase():\n    key = 'XYZ'\n    message = 'JXSSO XWPSG!'\n    decrypted = decrypt_message(key, message)\n    assert decrypted == 'HELLO WORLD!'\n\ndef test_encrypt_mixed_case():\n    key = 'abc'\n    message = 'Th3s 1s mY Te4st !n p0ind3nT'\n    encrypted = encrypt_message(key, message)\n    assert encrypted == 'Xi4u 4t tT 9p8py9 4n $0ajivn!'\n\ndef test_decrypt_mixed_case():\n    key = 'abc'\n    message = 'Xi4u 4t tT 9p8py9 4n $0ajivn!'\n    decrypted = decrypt_message(key, message)\n    assert decrypted == 'Th3s 1s mY Te4st !n p0ind3nT'\n\ndef test_encrypt_punctuation():\n    key = '012'\n    message = 'Test, case: !?, has, 12345.'\n    encrypted = encrypt_message(key, message)\n    assert encrypted == 'Xpgx, aujf: &?k, p0156.,'\n\ndef test_decrypt_punctuation():\n    key = '012'\n    message = 'Xpgx, aujf: &?k, p0156.,'\n    decrypted = decrypt_message(key, message)\n    assert decrypted == 'Test, case: !?, has, 12345.'\n\ndef test_empty_key():\n    key = ''\n    message = 'Test Message'\n    encrypted = encrypt_message(key, message)\n    assert encrypted == 'Test Message'\n    decrypted = decrypt_message(key, message)\n    assert decrypted == 'Test Message'\n\ndef test_empty_message():\n    key = 'abc'\n    message = ''\n    encrypted = encrypt_message(key, message)\n    assert encrypted == ''\n    decrypted = decrypt_message(key, message)\n    assert decrypted == ''\n\ndef test_large_key():\n    key = 'VeryLongKeyVeryLongKeyVeryLongKeyVeryLongKey'\n    message = 'This is a test message.'\n    encrypted = encrypt_message(key, message)\n    decrypted = decrypt_message(key, encrypted)\n    assert decrypted == message",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}