{
  "metadata": {
    "prompt_id": "00000064",
    "row_id": 64,
    "seed_ids": [
      694
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question: Enhanced Factorial Function\n\nYou are tasked with enhancing the `factorial` function to handle a broader range of inputs and provide additional utility.\n\n**Scenario**: You are developing a library that needs to compute factorials, but you want to make the function more robust and versatile. Specifically, you need to implement the following features:\n\n1. **Handle Large Inputs**: The function should be able to handle large inputs within the range of a 64-bit integer without causing overflow.\n2. **Handle Floating-Point Precision**: Implement a method to approximate the factorial of floating-point numbers using Stirling's approximation.\n3. **Return Results as a String**: The function should return the result as a string to handle very large numbers that cannot be represented as an integer.\n\nImplement the function `enhanced_factorial` that meets the above requirements.\n\n#### Function Signature\n```python\ndef enhanced_factorial(number: float) -> str:\n    pass\n```\n\n#### Constraints\n- \\(0 \\leq \\text{number} \\leq 1000\\)\n- The function should handle both integer and floating-point inputs.\n- For floating-point inputs, the result should be rounded to 3 decimal places.\n\n#### Performance Requirements\n- The function should handle large inputs efficiently and within a reasonable time limit.\n\n#### Examples\n```python\nprint(enhanced_factorial(5))  # \"120\"\nprint(enhanced_factorial(20))  # \"2432902008176640000\"\nprint(enhanced_factorial(0.5))  # \"1.128\"\nprint(enhanced_factorial(3.5))  # \"11.632\"\n```\n\n#### Notes\n- For integer inputs, the function should perform exact computation and return the result as a string.\n- For floating-point inputs, use Stirling's approximation to compute the factorial and round the result to 3 decimal places.",
  "solution_code": "import math\n\ndef enhanced_factorial(number: float) -> str:\n    \"\"\"\n    Returns the factorial of the given number as a string.\n    For integer inputs, performs exact computation.\n    For floating-point inputs, uses Stirling's approximation.\n    \"\"\"\n    if number == 0:\n        return \"1\"\n    elif number.is_integer():\n        num = int(number)\n        result = 1\n        for i in range(1, num + 1):\n            result *= i\n        return str(result)\n    else:\n        # Stirling's approximation: n! \u2248 sqrt(2 * pi * n) * (n / e) ** n\n        n = number\n        approximation = math.sqrt(2 * math.pi * n) * (n / math.e) ** n\n        return f\"{approximation:.3f}\"",
  "test_code": "``\nimport math\nfrom solution import enhanced_factorial\n\ndef test_enhanced_factorial_integers():\n    assert enhanced_factorial(0) == \"1\"\n    assert enhanced_factorial(5) == \"120\"\n    assert enhanced_factorial(20) == \"2432902008176640000\"\n    assert enhanced_factorial(1000) == \"10888869450418352160768000\"\n\ndef test_enhanced_factorial_floats():\n    assert enhanced_factorial(0.5) == \"1.128\"\n    assert enhanced_factorial(3.5) == \"11.632\"\n    assert enhanced_factorial(5.5) == \"523.428\"\n    assert enhanced_factorial(10.5) == \"371588.831\"\n\ndef test_enhanced_factorial_large_input():\n    assert enhanced_factorial(50) == \"30414093201713378043612608166064768844377641568960512000000000000\"\n\ndef test_enhanced_factorial_negative_input():\n    assert enhanced_factorial(-1) == \"1\"\n    assert enhanced_factorial(-2) == \"1\"\n    assert enhanced_factorial(-1.5) == \"1.128\"",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}