{
  "metadata": {
    "prompt_id": "00000064",
    "row_id": 64,
    "seed_ids": [
      694
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question: Enhanced Factorial Function\n\nYou are tasked with enhancing the `factorial` function to handle a broader range of inputs and provide additional utility.\n\n**Scenario**: You are developing a library that needs to compute factorials, but you want to make the function more robust and versatile. Specifically, you need to implement the following features:\n\n1. **Handle Large Inputs**: The function should be able to handle large inputs within the range of a 64-bit integer without causing overflow.\n2. **Handle Floating-Point Precision**: Implement a method to approximate the factorial of floating-point numbers using Stirling's approximation.\n3. **Return Results as a String**: The function should return the result as a string to handle very large numbers that cannot be represented as an integer.\n\nImplement the function `enhanced_factorial` that meets the above requirements.\n\n#### Function Signature\n```python\ndef enhanced_factorial(number: float) -> str:\n    pass\n```\n\n#### Constraints\n- \\(0 \\leq \\text{number} \\leq 1000\\)\n- The function should handle both integer and floating-point inputs.\n- For floating-point inputs, the result should be rounded to 3 decimal places.\n\n#### Performance Requirements\n- The function should handle large inputs efficiently and within a reasonable time limit.\n\n#### Examples\n```python\nprint(enhanced_factorial(5))  # \"120\"\nprint(enhanced_factorial(20))  # \"2432902008176640000\"\nprint(enhanced_factorial(0.5))  # \"1.128\"\nprint(enhanced_factorial(3.5))  # \"11.632\"\n```\n\n#### Notes\n- For integer inputs, the function should perform exact computation and return the result as a string.\n- For floating-point inputs, use Stirling's approximation to compute the factorial and round the result to 3 decimal places.",
  "solution_code": "import math\nfrom math import gamma\n\ndef enhanced_factorial(number: float) -> str:\n    \"\"\"\n    Returns the factorial of a number as a string. For exact integers, it uses\n    the factorial function. For floating-point numbers, it uses Stirling's\n    approximation and rounds to 3 decimal places.\n    \"\"\"\n    if number.is_integer():\n        integer_part = int(number)\n        result = math.factorial(integer_part)\n        return str(result)\n    else:\n        stirling_approximation = math.sqrt(2 * math.pi / number) * (number / math.e)**number\n        result = round(stirling_approximation, 3)\n        return \"{:.3f}\".format(result)",
  "test_code": "import math\nfrom solution import enhanced_factorial\n\ndef test_exact_integer_factorials():\n    assert enhanced_factorial(5) == \"120\"\n    assert enhanced_factorial(20) == \"2432902008176640000\"\n\ndef test_float_stirling_approximation():\n    assert enhanced_factorial(0.5) == \"1.128\"\n    assert enhanced_factorial(3.5) == \"11.632\"\n\ndef test_large_integer_upper_limit():\n    assert enhanced_factorial(1000) == \"3.0414093201713376e+2567\"\n\ndef test_edge_case_zero():\n    assert enhanced_factorial(0) == \"1\"\n    assert enhanced_factorial(0.0) == \"1.0\"\n\ndef test_edge_case_one():\n    assert enhanced_factorial(1) == \"1\"\n    assert enhanced_factorial(1.0) == \"1.0\"\n\ndef test_greater_than_100_exact():\n    for i in range(5, 101):\n        assert int(enhanced_factorial(i)) == math.factorial(i)\n\ndef test_stirling_accuracy_for_large_floats():\n    for n in range(10, 101, 10):\n        float_n = n + 0.5\n        stirling_result = enhanced_factorial(float_n)\n        stirling_approximation = math.sqrt(2 * math.pi / float_n) * (float_n / math.e)**float_n\n        assert round(float(stirling_result), 3) == round(stirling_approximation, 3)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}