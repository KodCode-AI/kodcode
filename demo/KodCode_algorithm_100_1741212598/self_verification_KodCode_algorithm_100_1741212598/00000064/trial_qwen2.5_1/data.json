{
  "metadata": {
    "prompt_id": "00000064",
    "row_id": 64,
    "seed_ids": [
      694
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question: Enhanced Factorial Function\n\nYou are tasked with enhancing the `factorial` function to handle a broader range of inputs and provide additional utility.\n\n**Scenario**: You are developing a library that needs to compute factorials, but you want to make the function more robust and versatile. Specifically, you need to implement the following features:\n\n1. **Handle Large Inputs**: The function should be able to handle large inputs within the range of a 64-bit integer without causing overflow.\n2. **Handle Floating-Point Precision**: Implement a method to approximate the factorial of floating-point numbers using Stirling's approximation.\n3. **Return Results as a String**: The function should return the result as a string to handle very large numbers that cannot be represented as an integer.\n\nImplement the function `enhanced_factorial` that meets the above requirements.\n\n#### Function Signature\n```python\ndef enhanced_factorial(number: float) -> str:\n    pass\n```\n\n#### Constraints\n- \\(0 \\leq \\text{number} \\leq 1000\\)\n- The function should handle both integer and floating-point inputs.\n- For floating-point inputs, the result should be rounded to 3 decimal places.\n\n#### Performance Requirements\n- The function should handle large inputs efficiently and within a reasonable time limit.\n\n#### Examples\n```python\nprint(enhanced_factorial(5))  # \"120\"\nprint(enhanced_factorial(20))  # \"2432902008176640000\"\nprint(enhanced_factorial(0.5))  # \"1.128\"\nprint(enhanced_factorial(3.5))  # \"11.632\"\n```\n\n#### Notes\n- For integer inputs, the function should perform exact computation and return the result as a string.\n- For floating-point inputs, use Stirling's approximation to compute the factorial and round the result to 3 decimal places.",
  "solution_code": "from math import gamma\nfrom decimal import Decimal, getcontext\n\ndef enhanced_factorial(number: float) -> str:\n    \"\"\"\n    Computes the factorial of the given number. For integer inputs, it returns the exact factorial as a string.\n    For floating-point inputs, it uses Stirling's approximation to approximate the factorial and rounds to 3 decimal places.\n    \"\"\"\n    # Set up Decimal context for handling large numbers\n    getcontext().prec = 50\n    \n    # Convert to Decimal for precision\n    number = Decimal(number)\n    \n    if number == 0:\n        return \"1\"\n    elif number.is_integer():\n        # Compute exact factorial for integer inputs\n        result = 1\n        for i in range(1, int(number) + 1):\n            result *= i\n        return str(result)\n    else:\n        # Use Stirling's approximation for non-integer inputs\n        return str(round(gamma(number + 1), 3))",
  "test_code": "import pytest\nfrom decimal import Decimal\n\ndef test_enhanced_factorial_integers():\n    assert enhanced_factorial(5) == \"120\"\n    assert enhanced_factorial(20) == \"2432902008176640000\"\n    assert enhanced_factorial(0) == \"1\"\n    assert enhanced_factorial(10) == \"3628800\"\n\ndef test_enhanced_factorial_floats():\n    assert enhanced_factorial(0.5) == \"1.128\"\n    assert enhanced_factorial(3.5) == \"11.632\"\n    assert enhanced_factorial(-0.5) == \"1.772\"\n    assert enhanced_factorial(1.1) == \"1.182\"\n\ndef test_enhanced_factorial_large_numbers():\n    assert enhanced_factorial(100) == str(gamma(101))  # Using gamma for large number comparison\n    assert enhanced_factorial(1000) == str(gamma(1001))  # Using gamma for large number comparison\n\ndef test_enhanced_factorial_zero():\n    assert enhanced_factorial(0) == \"1\"\n\ndef test_enhanced_factorial_negative_inputs():\n    with pytest.raises(ValueError):\n        enhanced_factorial(-1)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}