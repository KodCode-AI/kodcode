{
  "metadata": {
    "prompt_id": "00000015",
    "row_id": 15,
    "seed_ids": [
      386
    ],
    "mode": "algorithm"
  },
  "instruction": "### Scenario\nYou are developing a system where tasks need to be processed based on their priority and a custom scoring mechanism. You have been provided with a `FixedPriorityQueue` and an `ElementPriorityQueue`. Your task is to implement a new `CustomPriorityQueue` that combines the functionalities of both queues. The `CustomPriorityQueue` should handle tasks based on the following rules:\n\n1. Tasks are added to the queue based on a score, as in `ElementPriorityQueue`.\n2. The queue should support multiple priority levels, similar to `FixedPriorityQueue`.\n3. When a task is processed, it should follow a mixed strategy: first, tasks are processed by priority level in the order of their priority (highest to lowest), and within each priority level, tasks are processed in FIFO order.\n4. The queue should support the following operations:\n   - `enqueue(priority: int, score: int)`: Add a task to the queue with the given priority and score.\n   - `dequeue()`: Remove and return the task with the highest priority (and score if priorities are the same), following FIFO within each priority level.\n\n### Constraints\n- The queue should handle up to 100 tasks.\n- The priority levels are integers from `0` to `2`.\n- The score is an integer.\n\n### Performance Requirements\n- The `enqueue` and `dequeue` operations should run in `O(log N)` time complexity.\n\n### Expected Output\n```python\ncq = CustomPriorityQueue()\ncq.enqueue(0, 10)\ncq.enqueue(1, 15)\ncq.enqueue(2, 20)\ncq.enqueue(0, 12)\ncq.enqueue(1, 14)\ncq.enqueue(2, 22)\nprint(cq)  # Output: Priority 0: [10, 12], Priority 1: [15, 14], Priority 2: [20, 22]\nprint(cq.dequeue())  # Output: 10\nprint(cq)  # Output: Priority 0: [12], Priority 1: [15, 14], Priority 2: [20, 22]\nprint(cq.dequeue())  # Output: 12\nprint(cq)  # Output: Priority 0: [], Priority 1: [15, 14], Priority 2: [20, 22]\nprint(cq.dequeue())  # Output: 15\n```\n\n### Implementation\nWrite a class `CustomPriorityQueue` that meets the above requirements and includes methods for `enqueue` and `dequeue`.",
  "solution_code": "from heapq import heappush, heappop\n\nclass CustomPriorityQueue:\n    def __init__(self):\n        self._heap = []\n        # This dictionary will keep track of tasks per priority level\n        self._priorities = {priority: [] for priority in range(3)}\n\n    def enqueue(self, priority, score):\n        heappush(self._heap, (score, priority))\n        self._priorities[priority].append(score)\n        \n    def dequeue(self):\n        # Get the task with the highest priority\n        score, priority = heappop(self._heap)\n        # Ensure the list of tasks at the current priority is updated\n        self._priorities[priority].remove(score)\n        if not self._priorities[priority]:\n            del self._priorities[priority]\n        return score\n\n    def __str__(self):\n        return str({priority: tasks for priority, tasks in self._priorities.items()})",
  "test_code": "from custom_priority_queue import CustomPriorityQueue\n\ndef test_custom_priority_queue():\n    cq = CustomPriorityQueue()\n    cq.enqueue(0, 10)\n    cq.enqueue(1, 15)\n    cq.enqueue(2, 20)\n    cq.enqueue(0, 12)\n    cq.enqueue(1, 14)\n    cq.enqueue(2, 22)\n    assert str(cq) == \"{'0': [10, 12], '1': [15, 14], '2': [20, 22]}\"\n    assert cq.dequeue() == 10\n    assert str(cq) == \"{'0': [12], '1': [15, 14], '2': [20, 22]}\"\n    assert cq.dequeue() == 12\n    assert str(cq) == \"{'1': [15, 14], '2': [20, 22]}\"\n    assert cq.dequeue() == 15",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}