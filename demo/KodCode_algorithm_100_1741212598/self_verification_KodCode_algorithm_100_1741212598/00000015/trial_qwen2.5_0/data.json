{
  "metadata": {
    "prompt_id": "00000015",
    "row_id": 15,
    "seed_ids": [
      386
    ],
    "mode": "algorithm"
  },
  "instruction": "### Scenario\nYou are developing a system where tasks need to be processed based on their priority and a custom scoring mechanism. You have been provided with a `FixedPriorityQueue` and an `ElementPriorityQueue`. Your task is to implement a new `CustomPriorityQueue` that combines the functionalities of both queues. The `CustomPriorityQueue` should handle tasks based on the following rules:\n\n1. Tasks are added to the queue based on a score, as in `ElementPriorityQueue`.\n2. The queue should support multiple priority levels, similar to `FixedPriorityQueue`.\n3. When a task is processed, it should follow a mixed strategy: first, tasks are processed by priority level in the order of their priority (highest to lowest), and within each priority level, tasks are processed in FIFO order.\n4. The queue should support the following operations:\n   - `enqueue(priority: int, score: int)`: Add a task to the queue with the given priority and score.\n   - `dequeue()`: Remove and return the task with the highest priority (and score if priorities are the same), following FIFO within each priority level.\n\n### Constraints\n- The queue should handle up to 100 tasks.\n- The priority levels are integers from `0` to `2`.\n- The score is an integer.\n\n### Performance Requirements\n- The `enqueue` and `dequeue` operations should run in `O(log N)` time complexity.\n\n### Expected Output\n```python\ncq = CustomPriorityQueue()\ncq.enqueue(0, 10)\ncq.enqueue(1, 15)\ncq.enqueue(2, 20)\ncq.enqueue(0, 12)\ncq.enqueue(1, 14)\ncq.enqueue(2, 22)\nprint(cq)  # Output: Priority 0: [10, 12], Priority 1: [15, 14], Priority 2: [20, 22]\nprint(cq.dequeue())  # Output: 10\nprint(cq)  # Output: Priority 0: [12], Priority 1: [15, 14], Priority 2: [20, 22]\nprint(cq.dequeue())  # Output: 12\nprint(cq)  # Output: Priority 0: [], Priority 1: [15, 14], Priority 2: [20, 22]\nprint(cq.dequeue())  # Output: 15\n```\n\n### Implementation\nWrite a class `CustomPriorityQueue` that meets the above requirements and includes methods for `enqueue` and `dequeue`.",
  "solution_code": "from heapq import heappush, heappop\n\nclass CustomPriorityQueue:\n    def __init__(self):\n        self.queue = {}  # Dictionary to hold the heap for each priority level\n\n    def enqueue(self, priority, score):\n        \"\"\"\n        Add a task to the queue with the given priority and score.\n        \"\"\"\n        if priority not in self.queue:\n            self.queue[priority] = []\n        # Push the score and priority as a tuple (to support ordering by score, then priority)\n        heappush(self.queue[priority], (-score, -priority, score))  # Using negative to simulate max-heap\n\n    def dequeue(self):\n        \"\"\"\n        Remove and return the task with the highest priority (and score if priorities are the same),\n        following FIFO within each priority level.\n        \"\"\"\n        while self.queue and not self.queue[self.queue[min(self.queue, key=lambda k: (min(self.queue[k], key=lambda x: x[0])[0], -k))]]:\n            heappop(self.queue[min(self.queue, key=lambda k: (min(self.queue[k], key=lambda x: x[0])[0], -k))])\n        if not self.queue:\n            raise IndexError(\"dequeue from an empty queue\")\n        # Pop from the priority with the highest score (and highest priority if scores are equal)\n        priority, score, _ = heappop(min(self.queue, key=lambda k: (min(self.queue[k], key=lambda x: x[0])[0], -k)))\n        return score\n\n    def __str__(self):\n        \"\"\"\n        Return a string representation of the queue.\n        \"\"\"\n        result = {}\n        for priority, pq in self.queue.items():\n            result[priority] = [task[2] for task in pq]\n        return str(result)\n\n    def __len__(self):\n        \"\"\"\n        Return the number of elements in the queue.\n        \"\"\"\n        return sum(len(pq) for pq in self.queue.values())",
  "test_code": "def test_custom_priority_queue():\n    cq = CustomPriorityQueue()\n    cq.enqueue(0, 10)\n    cq.enqueue(1, 15)\n    cq.enqueue(2, 20)\n    cq.enqueue(0, 12)\n    cq.enqueue(1, 14)\n    cq.enqueue(2, 22)\n    assert str(cq) == '{0: [10, 12], 1: [15, 14], 2: [20, 22]}'\n    assert cq.dequeue() == 10\n    assert str(cq) == '{0: [12], 1: [15, 14], 2: [20, 22]}'\n    assert cq.dequeue() == 12\n    assert str(cq) == '{0: [], 1: [15, 14], 2: [20, 22]}'\n    assert cq.dequeue() == 15\n\ndef test_multiple_queues():\n    cq = CustomPriorityQueue()\n    cq.enqueue(0, 1)\n    cq.enqueue(0, 2)\n    cq.enqueue(1, 1)\n    cq.enqueue(1, 2)\n    assert str(cq) == '{0: [1, 2], 1: [1, 2]}'\n    assert cq.dequeue() == 1\n    assert str(cq) == '{0: [2], 1: [1, 2]}'\n    assert cq.dequeue() == 2\n    assert str(cq) == '{0: [], 1: [1, 2]}'\n    assert cq.dequeue() == 1\n    assert str(cq) == '{0: [], 1: [2]}'\n    assert cq.dequeue() == 2\n\ndef test_empty_queue():\n    cq = CustomPriorityQueue()\n    assert cq.dequeue() is None",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}