{
  "metadata": {
    "prompt_id": "00000058",
    "row_id": 58,
    "seed_ids": [
      586
    ],
    "mode": "algorithm"
  },
  "instruction": "### Problem Description\n\nA number is considered **semidivisible** if it is divisible by the largest prime less than or equal to its square root (lps) or the smallest prime greater than or equal to its square root (ups), but not both.\n\nFor a given integer \\( n \\geq 4 \\), the **lower prime square root** (lps) is the largest prime \\( p \\) such that \\( p \\leq \\sqrt{n} \\), and the **upper prime square root** (ups) is the smallest prime \\( p \\) such that \\( p \\geq \\sqrt{n} \\).\n\nWrite a function `semidivisible_sum` that computes the sum of all semidivisible numbers not exceeding a given limit \\( N \\).\n\n#### Function Signature\n```python\ndef semidivisible_sum(limit: int) -> int:\n    ...\n```\n\n#### Constraints\n- \\( 4 \\leq limit \\leq 999,966,663,333 \\)\n- The function should return the sum of all semidivisible numbers up to the given limit.\n\n#### Example\n```python\nassert semidivisible_sum(15) == 30  # 8, 10, and 12 are semidivisible\nassert semidivisible_sum(1000) == 34825  # Sum of semidivisible numbers up to 1000\nassert semidivisible_sum(999_966_663_333) == 2480389586872  # Compute the sum for the given limit\n```\n\n#### Performance Requirement\nThe function should be efficient and should not take more than 1 minute to compute the result for the maximum input size.\n\n### Implementation Tips\n- Use the Sieve of Eratosthenes to generate prime numbers efficiently.\n- Ensure the function handles edge cases correctly, such as when the input is a perfect square.",
  "solution_code": "from math import isqrt, sqrt\n\ndef sieve_of_eratosthenes(limit: int) -> list[bool]:\n    \"\"\"Generate a list of boolean values where the index represents\n       whether the number is prime (True) or not (False).\"\"\"\n    is_prime = [True] * (limit + 1)\n    is_prime[0], is_prime[1] = False, False\n    for i in range(2, isqrt(limit) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    return is_prime\n\ndef semidivisible_sum(limit: int) -> int:\n    \"\"\"Compute the sum of all semidivisible numbers not exceeding the given limit.\"\"\"\n    primes = sieve_of_eratosthenes(isqrt(limit) + 1)\n    semidivisible_sum = 0\n    \n    for n in range(4, limit + 1):\n        lps, ups = None, None\n        for p in range(isqrt(n), 1, -1):\n            if primes[p]:\n                lps = p\n                break\n        for p in range(isqrt(n), limit + 1):\n            if primes[p]:\n                ups = p\n                break\n        \n        if lps and n % lps == 0:\n            semidivisible_sum += n\n        elif ups and n % ups == 0:\n            semidivisible_sum += n\n        else:\n            semidivisible_sum += n\n    \n    return semidivisible_sum",
  "test_code": "``\ndef test_sieved_of_eratosthenes():\n    is_prime = sieve_of_eratosthenes(10)\n    assert is_prime == [False, False, True, True, False, True, False, True, False, False, False]\n\ndef test_semidivisible_sum():\n    assert semidivisible_sum(15) == 30\n    assert semidivisible_sum(1000) == 34825\n    assert semidivisible_sum(999_966_663_333) == 2480389586872\n\ndef test_lps_ups_case():\n    is_prime = sieve_of_eratosthenes(isqrt(25) + 1)\n    lps, ups = None, None\n    for p in range(isqrt(25), 1, -1):\n        if is_prime[p]:\n            lps = p\n            break\n    for p in range(isqrt(25), 26):\n        if is_prime[p]:\n            ups = p\n            break\n    assert lps == 5\n    assert ups == 5\n\ndef test_edge_cases():\n    assert semidivisible_sum(4) == 4\n    assert semidivisible_sum(5) == 5\n    assert semidivisible_sum(7) == 7",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}