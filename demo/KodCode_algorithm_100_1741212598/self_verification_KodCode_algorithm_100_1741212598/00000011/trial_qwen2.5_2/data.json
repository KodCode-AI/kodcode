{
  "metadata": {
    "prompt_id": "00000011",
    "row_id": 11,
    "seed_ids": [
      824
    ],
    "mode": "algorithm"
  },
  "instruction": "You are tasked with implementing a function to approximate the square root of a given number using Newton's method. The function should handle edge cases and ensure robust performance.\n\n### Function Signature\n\n```python\nfrom typing import Tuple\n\ndef square_root_approximate(\n    a: float, \n    initial_guess: float = 2.0, \n    max_iter: int = 9999, \n    tolerance: float = 1e-14\n) -> Tuple[float, int, bool]:\n    \"\"\"\n    Approximate the square root of a number using Newton's method.\n    \n    Args:\n    a (float): The number to find the square root of.\n    initial_guess (float): The initial guess for the square root. Default is 2.0.\n    max_iter (int): The maximum number of iterations to perform. Default is 9999.\n    tolerance (float): The tolerance level for the approximation. Default is 1e-14.\n    \n    Returns:\n    Tuple[float, int, bool]: \n        - The approximated square root.\n        - The number of iterations performed.\n        - A boolean indicating if the approximation converged within the tolerance.\n    \n    Raises:\n    ValueError: If the input number is negative.\n    \"\"\"\n```\n\n### Constraints\n- The function should handle both positive and negative inputs correctly.\n- `a` must be a non-negative number.\n- The function should return the best approximation within the given tolerance and iteration limit.\n\n### Performance Requirements\n- Ensure the function converges to the correct result within the specified tolerance for all valid inputs.\n- The function should perform no more than `max_iter` iterations.\n\n### Example\n```python\n# Example usage\na = 16\ninitial_guess = 2.0\nmax_iter = 1000\ntolerance = 1e-10\n\nroot, iterations, converged = square_root_approximate(a, initial_guess, max_iter, tolerance)\nprint(root)  # Output: 4.0\nprint(iterations)  # Output: 4\nprint(converged)  # Output: True\n```\n\n### Requirements\n- Implement the logic to handle edge cases and ensure robust performance.\n- Use the provided `fx` and `fx_derivative` functions for the Newton's method.\n- Ensure the function correctly handles negative inputs by raising a `ValueError`.",
  "solution_code": "from typing import Tuple\n\ndef fx(x: float, a: float) -> float:\n    \"\"\"\n    The function whose root we are trying to find.\n    \"\"\"\n    return x**2 - a\n\ndef fx_derivative(x: float) -> float:\n    \"\"\"\n    The derivative of the function fx.\n    \"\"\"\n    return 2 * x\n\ndef square_root_approximate(\n    a: float, \n    initial_guess: float = 2.0, \n    max_iter: int = 9999, \n    tolerance: float = 1e-14\n) -> Tuple[float, int, bool]:\n    \"\"\"\n    Approximate the square root of a number using Newton's method.\n    \"\"\"\n    if a < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number.\")\n    if a == 0:\n        return 0.0, 0, True\n    \n    x_prev = initial_guess\n    x_curr = x_prev - fx(x_prev, a) / fx_derivative(x_prev)\n    iterations = 1\n    \n    while abs(x_curr - x_prev) > tolerance and iterations < max_iter:\n        x_prev = x_curr\n        x_curr = x_prev - fx(x_prev, a) / fx_derivative(x_prev)\n        iterations += 1\n    \n    return x_curr, iterations, abs(x_curr - x_prev) <= tolerance",
  "test_code": "``\nimport pytest\n\ndef test_square_root_approximate():\n    a = 16\n    initial_guess = 2.0\n    max_iter = 1000\n    tolerance = 1e-10\n    \n    root, iterations, converged = square_root_approximate(a, initial_guess, max_iter, tolerance)\n    assert root == pytest.approx(4.0, abs=1e-10)\n    assert iterations == 4\n    assert converged\n\ndef test_square_root_approximate_zero():\n    a = 0\n    initial_guess = 2.0\n    max_iter = 1000\n    tolerance = 1e-10\n    \n    root, iterations, converged = square_root_approximate(a, initial_guess, max_iter, tolerance)\n    assert root == 0.0\n    assert iterations == 0\n    assert converged\n\ndef test_square_root_approximate_negative_input():\n    a = -1\n    initial_guess = 2.0\n    max_iter = 1000\n    tolerance = 1e-10\n    \n    with pytest.raises(ValueError):\n        square_root_approximate(a, initial_guess, max_iter, tolerance)\n\ndef test_square_root_approximate_tiny_tolerance():\n    a = 16\n    initial_guess = 2.0\n    max_iter = 1000\n    tolerance = 1e-20\n    \n    root, iterations, converged = square_root_approximate(a, initial_guess, max_iter, tolerance)\n    assert root == pytest.approx(4.0, abs=1e-20)\n    assert iterations >= 4\n    assert converged\n\ndef test_square_root_approximate_max_iterations():\n    a = 2\n    initial_guess = 1.0\n    max_iter = 5\n    tolerance = 1e-10\n    \n    root, iterations, converged = square_root_approximate(a, initial_guess, max_iter, tolerance)\n    assert root == pytest.approx(1.41421356237, abs=1e-10)\n    assert iterations == 5\n    assert not converged",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}