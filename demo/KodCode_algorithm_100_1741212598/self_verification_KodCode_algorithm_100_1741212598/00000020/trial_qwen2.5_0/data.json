{
  "metadata": {
    "prompt_id": "00000020",
    "row_id": 20,
    "seed_ids": [
      554
    ],
    "mode": "algorithm"
  },
  "instruction": "### Problem Description\n\nYou are provided with a piece of code that generates a list of non-trivial digit-cancelling fractions with two-digit numerators and denominators. A digit-cancelling fraction is one where a digit in the numerator and the denominator can be incorrectly cancelled, yet the resulting fraction still equals the original fraction (e.g., 49/98 = 4/8).\n\nYour task is to extend this functionality to generate a list of such non-trivial digit-cancelling fractions for fractions with three-digit numerators and denominators. Additionally, compute the product of the denominators of these fractions in their lowest terms.\n\n### Input and Output Formats\n\n- **Input**: An integer `n` (2 or 3) representing the number of digits in the numerator and denominator.\n- **Output**: A single integer representing the product of the denominators of the valid non-trivial digit-cancelling fractions, in their lowest terms.\n\n### Constraints and Limitations\n\n- The input `n` will be either 2 or 3.\n\n### Performance Requirements\n\n- The solution should be efficient and handle the specified constraints within a reasonable time frame.\n\n### Example\n\n```python\ndef solution(n: int) -> int:\n    # Your implementation here\n    pass\n\n# Example usage\nprint(solution(2))  # Output: 90\nprint(solution(3))  # Output: [Your output]\n```\n\n### Additional Instructions\n\n- Ensure the logic for digit cancellation is correct.\n- Handle edge cases such as fractions where the digit cancellation leads to zero denominators.\n- Simplify the final product of denominators to its lowest terms.",
  "solution_code": "from math import gcd\n\ndef are_digit_cancelling_fraction(numerator, denominator):\n    \"\"\"\n    Checks if the given fraction is a non-trivial digit-cancelling fraction.\n    \"\"\"\n    num_str = str(numerator)\n    den_str = str(denominator)\n    \n    if len(num_str) != 2 or len(den_str) != 2:\n        return False\n    \n    if num_str[1] == '0' and den_str[1] == '0':\n        return False\n    \n    if num_str[0] == den_str[1]:\n        if int(num_str[1]) == 0 or int(den_str[0]) * int(num_str[1]) == int(den_str[1]) * int(num_str[0]):\n            return True\n    if num_str[1] == den_str[0]:\n        if int(num_str[0]) == 0 or int(den_str[1]) * int(num_str[0]) == int(den_str[0]) * int(num_str[1]):\n            return True\n    \n    return False\n\ndef solution(n: int) -> int:\n    if n == 2:\n        result = 1\n        for num in range(10, 100):\n            for den in range(num + 1, 100):\n                if are_digit_cancelling_fraction(num, den):\n                    result *= den\n                    result //= gcd(result, den)\n        return result\n\n    elif n == 3:\n        result = 1\n        for num in range(100, 1000):\n            for den in range(num + 1, 1000):\n                if are_digit_cancelling_fraction(num, den):\n                    common_divisor = gcd(num, den)\n                    simplified_den = den // common_divisor\n                    result *= simplified_den\n                    result //= gcd(result, simplified_den)\n        return result\n\n    else:\n        raise ValueError(\"The input 'n' must be either 2 or 3.\")",
  "test_code": "import pytest\n\ndef test_solution_for_two_digits():\n    assert solution(2) == 90\n\ndef test_solution_for_three_digits():\n    assert solution(3) == 100\n\ndef test_simple_cases():\n    assert solution(2) == 90\n    assert solution(3) == 100\n\ndef test_non_trivial_cases():\n    # Testing that only the correct digit cancelling fractions are included\n    # and their denominators are correctly processed.\n    assert are_digit_cancelling_fraction(49, 98) is True\n    assert are_digit_cancelling_fraction(30, 50) is False  # This is trivial\n    assert are_digit_cancelling_fraction(40, 80) is True  # This is trivial\n    assert are_digit_cancelling_fraction(16, 64) is True\n    assert are_digit_cancelling_fraction(26, 65) is True\n\ndef test_invalid_cases():\n    assert are_digit_cancelling_fraction(0, 0) is False\n    assert are_digit_cancelling_fraction(4, 2) is False  # This simplifies to incorrect fraction",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}