{
  "metadata": {
    "prompt_id": "00000093",
    "row_id": 93,
    "seed_ids": [
      115
    ],
    "mode": "algorithm"
  },
  "instruction": "<|Analysis Begin|>\n\n### Core Identification\n**Algorithm/Data Structure**: Frequent Pattern Growth (FP-Growth) Algorithm\n- **Type**: Data Mining Technique\n- **Main Purpose**: Discovering frequent itemsets in large transaction databases.\n- **Complexity**:\n  - Time Complexity: Constructing the FP-Tree is O(T), where T is the number of transactions. Mining the tree is O(I * L * N), where I is the number of itemsets, L is the maximum length of itemsets, and N is the average number of items in a transaction.\n  - Space Complexity: O(T + I), where T is the number of transactions and I is the number of itemsets.\n\n**Principles**:\n- The FP-Growth algorithm constructs a compact data structure (FP-Tree) to efficiently find frequent itemsets without generating candidate sets.\n- It uses a header table to link nodes and a conditional pattern base to recursively mine larger itemsets.\n\n### Characteristics & Applications\n**Properties**:\n- **Memory Efficiency**: FP-Tree is more memory-efficient than the CBA (Candidate Generation and Testing) approach used in Apriori.\n- **Mining Frequent Itemsets**: It can discover all frequent itemsets without candidate generation.\n- **Traversal**: Efficiently traverses the tree to find frequent itemsets.\n\n**Common Use Cases**:\n- **Market Basket Analysis**: Identifying frequent itemsets in sales data to optimize product placements and promotions.\n- **Web Log Analysis**: Discovering frequent sequences of web pages visited by users.\n\n**Strengths/Limitations**:\n- **Strengths**:\n  - Memory-efficient for large datasets.\n  - Avoids the candidate generation step, which is computationally expensive in traditional methods.\n- **Limitations**:\n  - The effectiveness depends on the minimum support threshold (min_sup).\n  - It may not perform well if the dataset is sparse or has long transactions.\n\n### Implementation Challenges\n**Edge Cases**:\n- **Empty Transactions**: Handling transactions with no items.\n- **Items with Low Support**: Filtering out items below the specified min_sup threshold.\n\n**Performance Bottlenecks**:\n- **Memory Management**: Efficiently managing the FP-Tree and its nodes.\n- **Traversal Overhead**: Recursively mining larger itemsets can increase the overhead.\n\n**Error Scenarios**:\n- Incorrectly calculating the support of itemsets.\n- Failing to properly update node links in the header table.\n- Missing frequent itemsets due to incorrect pruning.\n\n**Optimization Points**:\n- **Early Pruning**: Prune nodes with low support early to reduce memory usage.\n- **Parallel Processing**: Utilizing multi-threading or distributed computing for large datasets.\n\n<|Analysis End|>\n\n<|Question Begin|>\n\nYou are tasked with implementing a function to mine frequent itemsets using the FP-Growth algorithm. Given a list of",
  "solution_code": "from collections import defaultdict\n\ndef create_header_table(transactions, min_sup):\n    \"\"\"\n    Create a header table for frequent items.\n    \"\"\"\n    item_freq = defaultdict(int)\n    for transaction in transactions:\n        for item in transaction:\n            item_freq[item] += 1\n    header_table = {item: (item_freq[item], None) for item in item_freq if item_freq[item] >= min_sup}\n    return header_table\n\ndef create_fp_tree(transactions, header_table):\n    \"\"\"\n    Create an FP-tree from the transactions and header table.\n    \"\"\"\n    def remove_items(transaction, header_table):\n        return [item for item in transaction if header_table.get(item) is not None]\n\n    root = {}\n    for transaction in transactions:\n        transaction = remove_items(transaction, header_table)\n        if transaction:\n            add_to_tree(root, transaction)\n\n    return root\n\ndef add_to_tree(tree, transaction):\n    \"\"\"\n    Add a transaction to the tree.\n    \"\"\"\n    if not transaction:\n        return\n    current = tree\n    for item in transaction:\n        if item not in current:\n            current[item] = {}\n        current = current[item]\n\ndef mine_frequent_itemsets(fp_tree, header_table, min_sup, prefix=[]):\n    \"\"\"\n    Recursively mine the FP-tree to find all frequent itemsets.\n    \"\"\"\n    def scan_db(node, prefix, min_sup, freq_items):\n        if node is None:\n            return\n        for item, next in node.items():\n            freq = node[item][0]\n            if freq >= min_sup:\n                freq_items[item] = freq\n                prefix_copy = prefix + [item]\n                print(\"Frequent itemset found: {} with support {}\".format(prefix_copy, freq))\n                scan_db(next, prefix_copy, min_sup, freq_items)\n            scan_db(next, prefix, min_sup, freq_items)\n\n    freq_items = defaultdict(int)\n    scan_db(fp_tree, prefix, min_sup, freq_items)\n    return freq_items\n\ndef fp_growth(transactions, min_sup):\n    \"\"\"\n    Implementation of the FP-Growth algorithm.\n    \"\"\"\n    header_table = create_header_table(transactions, min_sup)\n    if not header_table:\n        return []\n    fp_tree = create_fp_tree(transactions, header_table)\n    return mine_frequent_itemsets(fp_tree, header_table, min_sup)",
  "test_code": "``\nfrom solution import fp_growth\n\ndef test_create_header_table():\n    transactions = [\n        ['a', 'b', 'c'],\n        ['a', 'b', 'x'],\n        ['c', 'd', 'x'],\n    ]\n    header_table = create_header_table(transactions, 2)\n    assert header_table == {'a': (2, None), 'b': (2, None), 'c': (2, None), 'x': (2, None)}\n\ndef test_create_fp_tree():\n    header_table = {'a': (2, None), 'b': (2, None), 'c': (2, None), 'x': (2, None)}\n    transactions = [\n        ['a', 'b', 'c'],\n        ['a', 'b', 'x'],\n        ['c', 'd', 'x'],\n    ]\n    fp_tree = create_fp_tree(transactions, header_table)\n    assert fp_tree == {'a': {'b': {'c': {}}, 'x': {}}, 'b': {}, 'c': {}, 'x': {}}\n\ndef test_mine_frequent_itemsets():\n    transactions = [\n        ['a', 'b', 'c'],\n        ['a', 'b', 'x'],\n        ['c', 'd', 'x'],\n    ]\n    header_table = create_header_table(transactions, 2)\n    fp_tree = create_fp_tree(transactions, header_table)\n    freq_items = mine_frequent_itemsets(fp_tree, header_table, 2)\n    assert freq_items == {'a': 2, 'b': 2, 'c': 2, 'x': 2}\n\ndef test_fp_growth():\n    transactions = [\n        ['a', 'b', 'c'],\n        ['a', 'b', 'x'],\n        ['c', 'd', 'x'],\n    ]\n    min_sup = 2\n    frequent_itemsets = fp_growth(transactions, min_sup)\n    assert frequent_itemsets == {'a': 2, 'b': 2, 'c': 2, 'x': 2}\n\n# To run tests, use: pytest -v <filename>.py",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}