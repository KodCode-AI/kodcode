{
  "metadata": {
    "prompt_id": "00000093",
    "row_id": 93,
    "seed_ids": [
      115
    ],
    "mode": "algorithm"
  },
  "instruction": "<|Analysis Begin|>\n\n### Core Identification\n**Algorithm/Data Structure**: Frequent Pattern Growth (FP-Growth) Algorithm\n- **Type**: Data Mining Technique\n- **Main Purpose**: Discovering frequent itemsets in large transaction databases.\n- **Complexity**:\n  - Time Complexity: Constructing the FP-Tree is O(T), where T is the number of transactions. Mining the tree is O(I * L * N), where I is the number of itemsets, L is the maximum length of itemsets, and N is the average number of items in a transaction.\n  - Space Complexity: O(T + I), where T is the number of transactions and I is the number of itemsets.\n\n**Principles**:\n- The FP-Growth algorithm constructs a compact data structure (FP-Tree) to efficiently find frequent itemsets without generating candidate sets.\n- It uses a header table to link nodes and a conditional pattern base to recursively mine larger itemsets.\n\n### Characteristics & Applications\n**Properties**:\n- **Memory Efficiency**: FP-Tree is more memory-efficient than the CBA (Candidate Generation and Testing) approach used in Apriori.\n- **Mining Frequent Itemsets**: It can discover all frequent itemsets without candidate generation.\n- **Traversal**: Efficiently traverses the tree to find frequent itemsets.\n\n**Common Use Cases**:\n- **Market Basket Analysis**: Identifying frequent itemsets in sales data to optimize product placements and promotions.\n- **Web Log Analysis**: Discovering frequent sequences of web pages visited by users.\n\n**Strengths/Limitations**:\n- **Strengths**:\n  - Memory-efficient for large datasets.\n  - Avoids the candidate generation step, which is computationally expensive in traditional methods.\n- **Limitations**:\n  - The effectiveness depends on the minimum support threshold (min_sup).\n  - It may not perform well if the dataset is sparse or has long transactions.\n\n### Implementation Challenges\n**Edge Cases**:\n- **Empty Transactions**: Handling transactions with no items.\n- **Items with Low Support**: Filtering out items below the specified min_sup threshold.\n\n**Performance Bottlenecks**:\n- **Memory Management**: Efficiently managing the FP-Tree and its nodes.\n- **Traversal Overhead**: Recursively mining larger itemsets can increase the overhead.\n\n**Error Scenarios**:\n- Incorrectly calculating the support of itemsets.\n- Failing to properly update node links in the header table.\n- Missing frequent itemsets due to incorrect pruning.\n\n**Optimization Points**:\n- **Early Pruning**: Prune nodes with low support early to reduce memory usage.\n- **Parallel Processing**: Utilizing multi-threading or distributed computing for large datasets.\n\n<|Analysis End|>\n\n<|Question Begin|>\n\nYou are tasked with implementing a function to mine frequent itemsets using the FP-Growth algorithm. Given a list of",
  "solution_code": "from collections import defaultdict\n\nclass Node:\n    def __init__(self, item, count=1):\n        self.item = item\n        self.count = count\n        self.children = {}\n        self.parent = None\n\n    def add_child(self, child):\n        if child.item not in self.children:\n            self.children[child.item] = child\n            child.parent = self\n\ndef construct_fp_tree(transactions, min_sup):\n    item_freq = defaultdict(int)\n    # Count item frequencies\n    for transaction in transactions:\n        for item in transaction:\n            item_freq[item] += 1\n\n    # Filter items by min_sup\n    filtered_items = {item: freq for item, freq in item_freq.items() if freq >= min_sup}\n\n    if not filtered_items:\n        return None, {}\n\n    head_table = {}\n    for transaction in transactions:\n        subset = [item for item in transaction if item in filtered_items]\n        if subset:\n            head_table = update_header_table(head_table, subset, filtered_items)\n\n    # Construct FP-tree\n    root = Node(None)\n    for transaction in transactions:\n        subset = [item for item in transaction if item in filtered_items]\n        if subset:\n            pre = root\n            for item in subset:\n                if not pre.children.get(item):\n                    pre.children[item] = Node(item)\n                pre = pre.children[item]\n    return root, head_table\n\ndef update_header_table(head_table, transaction, item_freq):\n    for item in transaction:\n        if item in head_table:\n            head_table[item][1] += item_freq[item]\n        else:\n            # Create a new entry\n            head_table[item] = [None, item_freq[item], None]\n    return head_table\n\n# Example usage\ndef mine_frequent_itemsets(fp_tree, head_table, min_len=1):\n    patterns = []\n    def recurse_tree(node, prefix):\n        if node.item:\n            for next_node in node.children.values():\n                new_prefix = prefix + [node.item]\n                if len(new_prefix) >= min_len:\n                    patterns.append(new_prefix)\n                recurse_tree(next_node, new_prefix)\n    \n    if fp_tree is not None:\n        recurse_tree(fp_tree, [])\n    return patterns\n\n# Example usage (full function)\ndef frequent_itemsets(transactions, min_sup):\n    root, head_table = construct_fp_tree(transactions, min_sup)\n    return mine_frequent_itemsets(root, head_table)",
  "test_code": "def test_frequent_itemsets():\n    transactions = [\n        ['apple', 'banana', 'cherry'],\n        ['banana', 'cherry'],\n        ['apple', 'banana'],\n        ['apple', 'banana', 'cherry'],\n        ['banana', 'cherry']\n    ]\n    result = frequent_itemsets(transactions, 2)\n    assert ['banana', 'cherry'] in result, \"Missed frequent item ['banana', 'cherry']\"\n    assert ['apple', 'cherry'] in result, \"Missed frequent item ['apple', 'cherry']\"\n    assert ['apple', 'banana'] in result, \"Missed frequent item ['apple', 'banana']\"\n    assert ['banana'] in result, \"Missed frequent item ['banana']\"\n    assert ['cherry'] in result, \"Missed frequent item ['cherry']\"\n    assert ['apple'] in result, \"Missed frequent item ['apple']\"",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}