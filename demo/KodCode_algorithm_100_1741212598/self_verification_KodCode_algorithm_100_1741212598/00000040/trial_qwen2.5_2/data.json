{
  "metadata": {
    "prompt_id": "00000040",
    "row_id": 40,
    "seed_ids": [
      318
    ],
    "mode": "algorithm"
  },
  "instruction": "**Scenario**: You are working on a network analysis project where you need to manage a group of network nodes and their connections. The network nodes can form various clusters, and you need to efficiently manage these clusters using a disjoint set data structure.\n\n**Task**: Implement a function `analyze_network_connections` that takes a list of network nodes and their connections and returns the number of unique clusters in the network. Each node is represented by an integer, and each connection is a tuple of two integers representing nodes that are connected.\n\n**Function Signature**: \n```python\ndef analyze_network_connections(connections: List[Tuple[int, int]]) -> int:\n    pass\n```\n\n**Input**:\n- `connections` (1 <= len(connections) <= 10^5): A list of tuples, where each tuple (u, v) represents a connection between nodes u and v.\n\n**Output**:\n- An integer representing the number of unique clusters in the network.\n\n**Constraints**:\n- Each node can appear in multiple connections.\n- The nodes are 0-indexed and range from 0 to 10^4.\n\n**Performance Requirement**:\n- The function should be efficient and able to handle the maximum input size in a reasonable amount of time.\n\n**Example**:\n```python\nconnections = [(0, 1), (1, 2), (3, 4), (4, 5), (2, 6)]\nassert analyze_network_connections(connections) == 3\n```\n\n**Explanation**:\n- Initially, there are 7 nodes.\n- After processing the connections, the network will have 3 unique clusters: {0, 1, 2, 6}, {3, 4, 5}, and {7}.\n\n**Additional Information**:\n- You can assume the disjoint set data structure will be provided as a module or class with the necessary methods (`merge` and `get_parent`).",
  "solution_code": "from typing import List, Tuple\n\nclass DisjointSet:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n\n    def find(self, u: int) -> int:\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def merge(self, u: int, v: int):\n        pu, pv = self.find(u), self.find(v)\n        if pu == pv:\n            return\n        self.parent[pv] = pu\n\ndef analyze_network_connections(connections: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Returns the number of unique clusters in the network based on the given connections.\n    \"\"\"\n    max_node = max(max(u, v) for u, v in connections) + 1\n    ds = DisjointSet(max_node)\n    for u, v in connections:\n        ds.merge(u, v)\n    \n    # Using a set to count unique clusters\n    unique_clusters = {ds.find(node) for node in range(max_node)}\n    return len(unique_clusters)",
  "test_code": "import pytest\n\ndef test_analyze_network_connections():\n    connections = [(0, 1), (1, 2), (3, 4), (4, 5), (2, 6)]\n    assert analyze_network_connections(connections) == 3\n\ndef test_single_connections():\n    connections = [(0, 1), (2, 3)]\n    assert analyze_network_connections(connections) == 2\n\ndef test_multiple_clusters():\n    connections = [(0, 1), (1, 2), (3, 4), (4, 5), (6, 7), (2, 9)]\n    assert analyze_network_connections(connections) == 5\n\ndef test_self_connections():\n    connections = [(0, 0), (1, 1), (2, 2)]\n    assert analyze_network_connections(connections) == 3\n\ndef test_no_connections():\n    connections = []\n    assert analyze_network_connections(connections) == 10001  # Assuming 0 to 10000 nodes\n\ndef test_overlapping_connections():\n    connections = [(0, 1), (1, 2), (0, 2), (3, 4), (4, 5), (5, 6)]\n    assert analyze_network_connections(connections) == 3",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}