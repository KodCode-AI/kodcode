{
  "metadata": {
    "prompt_id": "00000099",
    "row_id": 99,
    "seed_ids": [
      259
    ],
    "mode": "algorithm"
  },
  "instruction": "**Context**: You are working on a text editor that needs to efficiently find patterns within a large document. To optimize the search process, you decide to implement the Rabin-Karp algorithm. However, you have a challenge in ensuring the algorithm's robustness against various edge cases and performance optimizations.\n\n**Task**: Enhance the Rabin-Karp algorithm to handle the following requirements and optimizations:\n\n1. **Edge Cases**:\n   - Handle cases where the pattern or text is empty.\n   - Ensure the algorithm correctly handles large alphabets (e.g., Unicode characters).\n\n2. **Performance**:\n   - Optimize the algorithm to handle large texts and patterns efficiently by reducing the number of hash comparisons.\n   - Implement a mechanism to skip unnecessary comparisons when a hash mismatch occurs.\n\n3. **Customization**:\n   - Allow the user to specify the alphabet size and modulus for the hash function.\n   - Implement a function to test the enhanced Rabin-Karp algorithm with multiple patterns and texts.\n\n**Function Implementations**:\n- **Function 1**: `enhanced_rabin_karp(pattern: str, text: str, alphabet_size: int, modulus: int) -> List[int]`\n  - **Input**: \n    - `pattern` (str): The pattern string to search for.\n    - `text` (str): The text in which to search for the pattern.\n    - `alphabet_size` (int): The size of the alphabet used in the text.\n    - `modulus` (int): The modulus value used in the hash function.\n  - **Output**: \n    - A list of starting indices where the pattern is found in the text. If the pattern is not found, return an empty list.\n\n- **Function 2**: `test_enhanced_rabin_karp()` \n  - **Input**: None\n  - **Output**: None\n  - **Description**: Test the `enhanced_rabin_karp` function with multiple patterns and texts to ensure it works correctly.\n\n**Constraints**:\n- `1 <= len(pattern) <= 1000`\n- `1 <= len(text) <= 10^6`\n- `1 <= alphabet_size <= 10^6`\n- `1 <= modulus <= 10^9 + 7`\n\n**Performance Requirements**:\n- The algorithm should handle large texts and patterns efficiently, minimizing the number of hash comparisons.\n\n**Example**:\n\n```python\npattern = \"abc1abc12\"\ntext = \"alskfjaldsabc1abc1abc12k23adsfabcabc\"\nalphabet_size = 256\nmodulus = 1000003\nprint(enhanced_rabin_karp(pattern, text, alphabet_size, modulus))\n# Output: [11, 21]\n\npattern = \"ABABX\"\ntext = \"ABABZABABYABABX\"\nalphabet_size = 256\nmodulus = 1000003\nprint(enhanced_rabin_karp(pattern, text, alphabet_size, modulus))\n# Output: [6]\n```",
  "solution_code": "from typing import List\n\ndef compute_hash(pattern: str, prime: int, modulus: int) -> int:\n    hash_value = 0\n    p = 256\n    for char in pattern:\n        hash_value = (hash_value * p + ord(char)) % modulus\n    return hash_value\n\ndef rabin_karp_search(text: str, pattern: str, alphabet_size: int, modulus: int) -> List[int]:\n    result_indices = []\n    m = len(pattern)\n    n = len(text)\n    if m > n:\n        return result_indices\n    prime = 31  # A prime number to avoid collisions\n    hash_pattern = compute_hash(pattern, prime, modulus)\n    hash_text = compute_hash(text[:m], prime, modulus)\n    \n    for i in range(n - m + 1):\n        if hash_pattern == hash_text:\n            start_index = i\n            for j in range(m):\n                if text[start_index + j] != pattern[j]:\n                    break\n            else:\n                result_indices.append(start_index)\n        if i < n - m:\n            hash_text = (hash_text - ord(text[i]) * (prime ** (m - 1))) % modulus\n            hash_text = (hash_text * prime + ord(text[i + m])) % modulus\n            if hash_text < 0:\n                hash_text += modulus\n    return result_indices\n\ndef enhanced_rabin_karp(pattern: str, text: str, alphabet_size: int, modulus: int) -> List[int]:\n    return rabin_karp_search(text, pattern, alphabet_size, modulus)\n\ndef test_enhanced_rabin_karp() -> None:\n    patterns = [\"abc1abc12\", \"ABABX\", \"ccc\"]\n    texts = [\"alskfjaldsabc1abc1abc12k23adsfabcabc\", \"ABABZABABYABABX\", \"abcabcabc\"]\n    expected_outputs = [[11, 21], [6], [0, 3, 6]]\n    for pattern, text, expected in zip(patterns, texts, expected_outputs):\n        assert enhanced_rabin_karp(pattern, text, 256, 1000003) == expected\n\n# Example Usage\ntest_enhanced_rabin_karp()",
  "test_code": "from solution import enhanced_rabin_karp\n\ndef test_enhanced_rabin_karp() -> None:\n    # Test Case 1\n    pattern = \"abc1abc12\"\n    text = \"alskfjaldsabc1abc1abc12k23adsfabcabc\"\n    alphabet_size = 256\n    modulus = 1000003\n    expected_output = [11, 21]\n    assert enhanced_rabin_karp(pattern, text, alphabet_size, modulus) == expected_output\n\n    # Test Case 2\n    pattern = \"ABABX\"\n    text = \"ABABZABABYABABX\"\n    alphabet_size = 256\n    modulus = 1000003\n    expected_output = [6]\n    assert enhanced_rabin_karp(pattern, text, alphabet_size, modulus) == expected_output\n\n    # Test Case 3\n    pattern = \"ccc\"\n    text = \"abcabcabc\"\n    alphabet_size = 256\n    modulus = 1000003\n    expected_output = [0, 3, 6]\n    assert enhanced_rabin_karp(pattern, text, alphabet_size, modulus) == expected_output\n\n    # Test Case 4 (empty pattern)\n    pattern = \"\"\n    text = \"abcabcabc\"\n    alphabet_size = 256\n    modulus = 1000003\n    expected_output = []\n    assert enhanced_rabin_karp(pattern, text, alphabet_size, modulus) == expected_output\n\n    # Test Case 5 (empty text)\n    pattern = \"ccc\"\n    text = \"\"\n    alphabet_size = 256\n    modulus = 1000003\n    expected_output = []\n    assert enhanced_rabin_karp(pattern, text, alphabet_size, modulus) == expected_output\n\n    print(\"All test cases passed!\")",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}