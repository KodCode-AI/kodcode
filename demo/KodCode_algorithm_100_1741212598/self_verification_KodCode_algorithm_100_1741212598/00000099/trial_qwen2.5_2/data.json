{
  "metadata": {
    "prompt_id": "00000099",
    "row_id": 99,
    "seed_ids": [
      259
    ],
    "mode": "algorithm"
  },
  "instruction": "**Context**: You are working on a text editor that needs to efficiently find patterns within a large document. To optimize the search process, you decide to implement the Rabin-Karp algorithm. However, you have a challenge in ensuring the algorithm's robustness against various edge cases and performance optimizations.\n\n**Task**: Enhance the Rabin-Karp algorithm to handle the following requirements and optimizations:\n\n1. **Edge Cases**:\n   - Handle cases where the pattern or text is empty.\n   - Ensure the algorithm correctly handles large alphabets (e.g., Unicode characters).\n\n2. **Performance**:\n   - Optimize the algorithm to handle large texts and patterns efficiently by reducing the number of hash comparisons.\n   - Implement a mechanism to skip unnecessary comparisons when a hash mismatch occurs.\n\n3. **Customization**:\n   - Allow the user to specify the alphabet size and modulus for the hash function.\n   - Implement a function to test the enhanced Rabin-Karp algorithm with multiple patterns and texts.\n\n**Function Implementations**:\n- **Function 1**: `enhanced_rabin_karp(pattern: str, text: str, alphabet_size: int, modulus: int) -> List[int]`\n  - **Input**: \n    - `pattern` (str): The pattern string to search for.\n    - `text` (str): The text in which to search for the pattern.\n    - `alphabet_size` (int): The size of the alphabet used in the text.\n    - `modulus` (int): The modulus value used in the hash function.\n  - **Output**: \n    - A list of starting indices where the pattern is found in the text. If the pattern is not found, return an empty list.\n\n- **Function 2**: `test_enhanced_rabin_karp()` \n  - **Input**: None\n  - **Output**: None\n  - **Description**: Test the `enhanced_rabin_karp` function with multiple patterns and texts to ensure it works correctly.\n\n**Constraints**:\n- `1 <= len(pattern) <= 1000`\n- `1 <= len(text) <= 10^6`\n- `1 <= alphabet_size <= 10^6`\n- `1 <= modulus <= 10^9 + 7`\n\n**Performance Requirements**:\n- The algorithm should handle large texts and patterns efficiently, minimizing the number of hash comparisons.\n\n**Example**:\n\n```python\npattern = \"abc1abc12\"\ntext = \"alskfjaldsabc1abc1abc12k23adsfabcabc\"\nalphabet_size = 256\nmodulus = 1000003\nprint(enhanced_rabin_karp(pattern, text, alphabet_size, modulus))\n# Output: [11, 21]\n\npattern = \"ABABX\"\ntext = \"ABABZABABYABABX\"\nalphabet_size = 256\nmodulus = 1000003\nprint(enhanced_rabin_karp(pattern, text, alphabet_size, modulus))\n# Output: [6]\n```",
  "solution_code": "def enhanced_rabin_karp(pattern: str, text: str, alphabet_size: int, modulus: int) -> List[int]:\n    if not pattern or not text:\n        return []\n    \n    result = []\n    pattern_length = len(pattern)\n    text_length = len(text)\n    pattern_hash = 0\n    text_hash = 0\n    h = 1  # The value of h would be \"pow(alphabet_size, pattern_length-1)%modulus\"\n    \n    # The initial hash values for pattern and first window of text\n    for i in range(pattern_length):\n        pattern_hash = (alphabet_size * pattern_hash + ord(pattern[i])) % modulus\n        text_hash = (alphabet_size * text_hash + ord(text[i])) % modulus\n        if i < pattern_length - 1:\n            h = (h * alphabet_size) % modulus\n    \n    # Slide the pattern over text one by one\n    for i in range(text_length - pattern_length + 1):\n        # Check the hash values of current window of text and pattern\n        # If the hash values match then only check for characters one by one\n        if pattern_hash == text_hash:\n            # Check for characters one by one\n            for j in range(pattern_length):\n                if text[i + j] != pattern[j]:\n                    break\n            else:\n                # if pattern[0...R-1] = text[L+1...L+R-1]\n                result.append(i)\n        \n        # Calculate hash value for next window of text: Remove leading digit, add trailing digit\n        if i < text_length - pattern_length:\n            text_hash = (alphabet_size * (text_hash - ord(text[i]) * h) + ord(text[i + pattern_length])) % modulus\n            # We might get negative value of text_hash, converting it to positive\n            if text_hash < 0:\n                text_hash = text_hash + modulus\n            \n    return result",
  "test_code": "`  \nimport pytest\n\ndef test_enhanced_rabin_karp():\n    assert enhanced_rabin_karp(\"abc1abc12\", \"alskfjaldsabc1abc1abc12k23adsfabcabc\", 256, 1000003) == [11, 21]\n    assert enhanced_rabin_karp(\"ABABX\", \"ABABZABABYABABX\", 256, 1000003) == [6]\n    assert enhanced_rabin_karp(\"\", \"abc\", 256, 1000003) == []\n    assert enhanced_rabin_karp(\"abc\", \"\", 256, 1000003) == []\n    assert enhanced_rabin_karp(\"a\", \"a\", 256, 1000003) == [0]\n    assert enhanced_rabin_karp(\"aa\", \"aaaaa\", 256, 1000003) == [0, 1, 2, 3]\n    assert enhanced_rabin_karp(\"test\", \"testtesttest\", 256, 1000003) == [0, 4]\n\ntest_enhanced_rabin_karp()",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}