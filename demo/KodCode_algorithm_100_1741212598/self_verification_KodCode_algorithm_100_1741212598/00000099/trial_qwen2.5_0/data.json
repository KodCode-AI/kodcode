{
  "metadata": {
    "prompt_id": "00000099",
    "row_id": 99,
    "seed_ids": [
      259
    ],
    "mode": "algorithm"
  },
  "instruction": "**Context**: You are working on a text editor that needs to efficiently find patterns within a large document. To optimize the search process, you decide to implement the Rabin-Karp algorithm. However, you have a challenge in ensuring the algorithm's robustness against various edge cases and performance optimizations.\n\n**Task**: Enhance the Rabin-Karp algorithm to handle the following requirements and optimizations:\n\n1. **Edge Cases**:\n   - Handle cases where the pattern or text is empty.\n   - Ensure the algorithm correctly handles large alphabets (e.g., Unicode characters).\n\n2. **Performance**:\n   - Optimize the algorithm to handle large texts and patterns efficiently by reducing the number of hash comparisons.\n   - Implement a mechanism to skip unnecessary comparisons when a hash mismatch occurs.\n\n3. **Customization**:\n   - Allow the user to specify the alphabet size and modulus for the hash function.\n   - Implement a function to test the enhanced Rabin-Karp algorithm with multiple patterns and texts.\n\n**Function Implementations**:\n- **Function 1**: `enhanced_rabin_karp(pattern: str, text: str, alphabet_size: int, modulus: int) -> List[int]`\n  - **Input**: \n    - `pattern` (str): The pattern string to search for.\n    - `text` (str): The text in which to search for the pattern.\n    - `alphabet_size` (int): The size of the alphabet used in the text.\n    - `modulus` (int): The modulus value used in the hash function.\n  - **Output**: \n    - A list of starting indices where the pattern is found in the text. If the pattern is not found, return an empty list.\n\n- **Function 2**: `test_enhanced_rabin_karp()` \n  - **Input**: None\n  - **Output**: None\n  - **Description**: Test the `enhanced_rabin_karp` function with multiple patterns and texts to ensure it works correctly.\n\n**Constraints**:\n- `1 <= len(pattern) <= 1000`\n- `1 <= len(text) <= 10^6`\n- `1 <= alphabet_size <= 10^6`\n- `1 <= modulus <= 10^9 + 7`\n\n**Performance Requirements**:\n- The algorithm should handle large texts and patterns efficiently, minimizing the number of hash comparisons.\n\n**Example**:\n\n```python\npattern = \"abc1abc12\"\ntext = \"alskfjaldsabc1abc1abc12k23adsfabcabc\"\nalphabet_size = 256\nmodulus = 1000003\nprint(enhanced_rabin_karp(pattern, text, alphabet_size, modulus))\n# Output: [11, 21]\n\npattern = \"ABABX\"\ntext = \"ABABZABABYABABX\"\nalphabet_size = 256\nmodulus = 1000003\nprint(enhanced_rabin_karp(pattern, text, alphabet_size, modulus))\n# Output: [6]\n```",
  "solution_code": "def enhanced_rabin_karp(pattern: str, text: str, alphabet_size: int, modulus: int) -> list:\n    if not pattern or not text:\n        return []\n\n    # Initialize the variables for the Rabin-Karp algorithm\n    pattern_length = len(pattern)\n    text_length = len(text)\n    hashes = []\n    pattern_hash = 0\n    current_hash = 0\n    h = 1  # The highest power of alphabet_size below modulus\n\n    # If pattern is empty, text is also empty (edge case handled)\n    if pattern_length == 0:\n        return list(range(pattern_length + 1, text_length + 1))\n\n    # Precompute h = (alphabet_size^(pattern_length-1)) % modulus\n    for _ in range(pattern_length - 1):\n        h = (h * alphabet_size) % modulus\n\n    # Calculate the hash of the pattern and the first window of the text\n    for i in range(pattern_length):\n        pattern_hash = (alphabet_size * pattern_hash + ord(pattern[i])) % modulus\n        current_hash = (alphabet_size * current_hash + ord(text[i])) % modulus\n\n    # Slide the pattern over text one by one\n    indices = []\n    for i in range(text_length - pattern_length + 1):\n        if pattern_hash == current_hash:\n            # Check for characters one by one\n            if text[i:i + pattern_length] == pattern:\n                indices.append(i)\n\n        # Calculate hash value for the next window of text\n        if i < text_length - pattern_length:\n            current_hash = (alphabet_size * (current_hash - ord(text[i]) * h) + ord(text[i + pattern_length])) % modulus\n            current_hash = (current_hash + modulus) % modulus  # To handle negative values\n\n    return indices",
  "test_code": "from solution import enhanced_rabin_karp\n\ndef test_enhanced_rabin_karp():\n    assert enhanced_rabin_karp(\"abc1abc12\", \"alskfjaldsabc1abc1abc12k23adsfabcabc\", 256, 1000003) == [11, 21]\n    assert enhanced_rabin_karp(\"ABABX\", \"ABABZABABYABABX\", 256, 1000003) == [6]\n    assert enhanced_rabin_karp(\"\", \"abc\", 256, 1000003) == [0, 1, 2]\n    assert enhanced_rabin_karp(\"a\", \"aaa\", 256, 1000003) == [0, 1, 2]\n    assert enhanced_rabin_karp(\"abcd\", \"abcde\", 256, 1000003) == [0]\n    assert enhanced_rabin_karp(\"xyz\", \"abcdef\", 256, 1000003) == []\n    assert enhanced_rabin_karp(\"a\", \"\", 256, 1000003) == []\n    assert enhanced_rabin_karp(\"\", \"\", 256, 1000003) == []\n\ntest_enhanced_rabin_karp()",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}