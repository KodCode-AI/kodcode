{
  "metadata": {
    "prompt_id": "00000030",
    "row_id": 30,
    "seed_ids": [
      97
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a dataset from the Iris flower classification problem. Implement a logistic regression model to classify the Iris setosa from the Iris versicolor. Use the provided `sigmoid_function` and `cost_function` implementations as a starting point, and implement the logistic regression algorithm without using any external libraries for optimization (e.g., gradient descent).\n\nThe goal is to predict the probability of an Iris flower being in the setosa class based on the sepal length and sepal width.\n\n**Input Format**:\n- A CSV file named `iris.csv` with the following columns: `sepal_length`, `sepal_width`, `class`.\n\n**Output Format**:\n- Print the weights (theta) after training the model.\n- Plot a contour plot showing the decision boundary between setosa and non-setosa flowers.\n\n**Constraints**:\n- The dataset should be normalized before training.\n- Use a learning rate of 0.1 and a maximum of 10,000 iterations.\n\n**Performance Requirements**:\n- The model should converge within the maximum number of iterations.\n\n**Scenario or Context**:\nYou are working on a project to classify Iris flowers based on their sepal length and sepal width. You need to implement a logistic regression model from scratch to predict whether an Iris flower is of the setosa variety.\n\n```python\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef sigmoid_function(z: float) -> float:\n    return 1 / (1 + np.exp(-z))\n\ndef cost_function(h: np.ndarray, y: np.ndarray) -> float:\n    return float((-y * np.log(h) - (1 - y) * np.log(1 - h)).mean())\n\ndef load_data(filepath: str) -> np.ndarray:\n    data = pd.read_csv(filepath)\n    y = data['class'].apply(lambda x: 1 if x == 'setosa' else 0).values\n    X = data[['sepal_length', 'sepal_width']].values\n    return X, y\n\ndef logistic_reg(alpha, x, y, max_iterations=10000):\n    # Implement the logistic regression algorithm here\n    # ...\n\nif __name__ == \"__main__\":\n    filepath = 'iris.csv'\n    X, y = load_data(filepath)\n    X = (X - X.mean()) / X.std()  # Normalize the data\n    alpha = 0.1\n    theta = logistic_reg(alpha, X, y, max_iterations=10000)\n    print(\"theta: \", theta)\n    # Plot the decision boundary\n    # ...\n```",
  "solution_code": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef sigmoid_function(z: float) -> float:\n    return 1 / (1 + np.exp(-z))\n\ndef cost_function(h: np.ndarray, y: np.ndarray) -> float:\n    return float((-y * np.log(h) - (1 - y) * np.log(1 - h)).mean())\n\ndef load_data(filepath: str) -> np.ndarray:\n    data = pd.read_csv(filepath)\n    y = data['class'].apply(lambda x: 1 if x == 'setosa' else 0).values\n    X = data[['sepal_length', 'sepal_width']].values\n    return X, y\n\ndef logistic_reg(alpha, x, y, max_iterations=10000):\n    \"\"\"\n    Implement the logistic regression algorithm here.\n    \"\"\"\n    m, n = x.shape\n    theta = np.zeros(n)\n\n    for i in range(max_iterations):\n        z = np.dot(x, theta)\n        h = sigmoid_function(z)\n        gradients = np.dot(x.T, (h - y)) / m\n        theta -= alpha * gradients\n\n        # Early stopping if cost is not decreasing\n        if i > 0:\n            prev_cost = prev_cost\n            current_cost = cost_function(h, y)\n            if np.abs(prev_cost - current_cost) < 1e-6:\n                break\n\n        prev_cost = current_cost\n\n    return theta\n\nif __name__ == \"__main__\":\n    filepath = 'iris.csv'\n    X, y = load_data(filepath)\n    X = (X - X.mean(axis=0)) / X.std(axis=0)  # Normalize the data\n    alpha = 0.1\n    theta = logistic_reg(alpha, X, y, max_iterations=10000)\n    print(\"theta: \", theta)\n\n    # Plot the decision boundary\n    x1 = np.linspace(X[:, 0].min(), X[:, 0].max(), 100)\n    x2 = (-theta[0] - theta[1] * x1) / theta[2]\n    plt.plot(x1, x2, '-r', label='Decision boundary')\n    plt.scatter(X[y == 0, 0], X[y == 0, 1], label='Non-setosa')\n    plt.scatter(X[y == 1, 0], X[y == 1, 1], label='Setosa')\n    plt.xlabel('Sepal length')\n    plt.ylabel('Sepal width')\n    plt.legend()\n    plt.show()",
  "test_code": "def test_logistic_regression():\n    # Create a temporary dataset for testing\n    data = {\n        'sepal_length': [5.1, 4.9, 4.7, 4.6, 5.0, 5.4],\n        'sepal_width': [3.5, 3.0, 3.2, 3.1, 3.3, 3.9],\n        'class': ['setosa', 'versicolor', 'versicolor', 'versicolor', 'setosa', 'setosa']\n    }\n    df = pd.DataFrame(data)\n    X, y = df[['sepal_length', 'sepal_width']].values, df['class'].apply(lambda x: 1 if x == 'setosa' else 0).values\n\n    X = (X - X.mean(axis=0)) / X.std(axis=0)  # Normalize the data\n    alpha = 0.1\n    \n    theta = logistic_reg(alpha, X, y, max_iterations=10000)\n    assert theta.shape == (2,)\n\ndef test_sigmoid_function():\n    assert np.isclose(sigmoid_function(0), 0.5)\n    assert np.isclose(sigmoid_function(100), 1.0)\n    assert np.isclose(sigmoid_function(-100), 0.0)\n\ndef test_cost_function():\n    h = np.array([0.8, 0.3, 0.9, 0.2])\n    y = np.array([1, 0, 1, 0])\n    cost = cost_function(h, y)\n    assert np.isclose(cost, -0.2776557852)\n\nif __name__ == \"__main__\":\n    import pytest\n    pytest.main(['-v', __file__])",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}