{
  "metadata": {
    "prompt_id": "00000050",
    "row_id": 50,
    "seed_ids": [
      1096
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question\n\nYou are given a `Matrix` class that supports basic operations on matrices, including addition, negation, scalar multiplication, and matrix multiplication. Additionally, it supports the inversion of the matrix using the Sherman-Morrison formula. However, there are some issues with the implementation that need to be addressed.\n\nYour task is to:\n\n1. Implement a method to check if a matrix is invertible before using the `sherman_morrison` method.\n2. Optimize the matrix multiplication operation to improve performance.\n3. Ensure that the `__mul__` method raises a `ValueError` if the dimensions do not match for matrix multiplication.\n\n#### Inputs\n\n- The `Matrix` class is provided in the code snippet.\n- You need to add the following methods to the `Matrix` class:\n  - `is_invertible(self) -> bool`: Returns `True` if the matrix is invertible, otherwise `False`.\n  - `multiply_optimized(self, another: Matrix) -> Matrix`: Returns the result of multiplying the current matrix with another matrix using a more efficient algorithm.\n\n#### Constraints\n\n- The `Matrix` class and the provided methods should be self-contained.\n- The `multiply_optimized` method should be more efficient than the existing `__mul__` method.\n\n#### Example\n\n```python\na = Matrix(2, 2)\na[0, 0], a[0, 1], a[1, 0], a[1, 1] = 1, 2, 3, 4\nprint(a.is_invertible())  # False\nprint(a.sherman_morrison(Matrix(2, 1, 1), Matrix(2, 1, 1)))  # None\n\nb = Matrix(2, 2)\nb[0, 0], b[0, 1], b[1, 0], b[1, 1] = 2, -1, -1, 2\nprint(b.is_invertible())  # True\nprint(b.sherman_morrison(Matrix(2, 1, 1), Matrix(2, 1, 1)))  # Matrix\n\nc = Matrix(2, 2)\nc[0, 0], c[0, 1], c[1, 0], c[1, 1] = 1, 1, 1, 1\nprint(c.is_invertible())  # False\n```\n\n#### Performance Requirements\n\n- The `multiply_optimized` method should achieve a time complexity of \\(O(n^2)\\) for multiplying two \\(n \\times n\\) matrices.\n\n#### Implementation\n\nImplement the required methods in the `Matrix` class.",
  "solution_code": "import numpy as np\n\nclass Matrix:\n    def __init__(self, *args):\n        if isinstance(args[0], int):\n            n, m = args\n            self._matrix = np.zeros((n, m))\n        else:\n            self._matrix = np.array(args)\n\n    def __getitem__(self, key):\n        return self._matrix[key]\n\n    def __setitem__(self, key, value):\n        self._matrix[key] = value\n\n    def __mul__(self, another):\n        if self.ncols != another.nrows:\n            raise ValueError(\"Matrix dimensions do not match for multiplication.\")\n        return Matrix(self._matrix.dot(another._matrix))\n\n    def is_invertible(self) -> bool:\n        return np.linalg.cond(self._matrix) < 1 / sys.float_info.epsilon\n\n    def sherman_morrison(self, u, v):\n        if not self.is_invertible():\n            return None\n        return self.inv().sherman_morrison(u, v)\n\n    def inv(self):\n        return Matrix(np.linalg.inv(self._matrix))\n\n    @property\n    def nrows(self):\n        return self._matrix.shape[0]\n\n    @property\n    def ncols(self):\n        return self._matrix.shape[1]\n\n    def multiply_optimized(self, another: 'Matrix') -> 'Matrix':\n        result = np.dot(self._matrix, another._matrix)\n        return Matrix(result)",
  "test_code": "import pytest\nimport sys\nimport numpy as np\n\ndef test_matrix_operations():\n    a = Matrix(2, 2)\n    a[0, 0], a[0, 1], a[1, 0], a[1, 1] = 1, 2, 3, 4\n    assert not a.is_invertible()\n\n    b = Matrix(2, 2)\n    b[0, 0], b[0, 1], b[1, 0], b[1, 1] = 2, -1, -1, 2\n    assert b.is_invertible()\n    assert isinstance(b.sherman_morrison(Matrix(2, 1, 1), Matrix(2, 1, 1)), Matrix)\n\n    c = Matrix(2, 2)\n    c[0, 0], c[0, 1], c[1, 0], c[1, 1] = 1, 1, 1, 1\n    assert not c.is_invertible()\n\ndef test_matrix_multiplication():\n    a = Matrix(2, 2, 1, 2, 3, 4)\n    b = Matrix(2, 2, 1, 1, 2, 2)\n    c = a * b\n    expected_result = np.array([[5, 7], [11, 15]])\n    np.testing.assert_array_equal(c._matrix, expected_result)\n\ndef test_matrix_dimensions():\n    a = Matrix(2, 2, 1, 2, 3, 4)\n    with pytest.raises(ValueError):\n        a * b.T\n\ndef test_multiply_optimized():\n    a = Matrix(2, 2, 1, 2, 3, 4)\n    b = Matrix(2, 2, 1, 1, 2, 2)\n    optimized_result = a.multiply_optimized(b)\n    expected_result = np.dot(a._matrix, b._matrix)\n    np.testing.assert_array_equal(optimized_result._matrix, expected_result)\n\ndef test_exception_on_invertible():\n    a = Matrix(2, 2, 1, 1, 1, 1)\n    with pytest.raises(np.linalg.LinAlgError):\n        a.inv()\n\ndef test_is_invertible():\n    a = Matrix(2, 2, 1, 2, 3, 4)\n    assert not a.is_invertible()\n    b = Matrix(2, 2, 1, 2, -1, 2)\n    assert b.is_invertible()",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}