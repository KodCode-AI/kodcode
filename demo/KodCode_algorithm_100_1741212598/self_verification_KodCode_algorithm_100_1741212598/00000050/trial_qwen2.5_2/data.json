{
  "metadata": {
    "prompt_id": "00000050",
    "row_id": 50,
    "seed_ids": [
      1096
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question\n\nYou are given a `Matrix` class that supports basic operations on matrices, including addition, negation, scalar multiplication, and matrix multiplication. Additionally, it supports the inversion of the matrix using the Sherman-Morrison formula. However, there are some issues with the implementation that need to be addressed.\n\nYour task is to:\n\n1. Implement a method to check if a matrix is invertible before using the `sherman_morrison` method.\n2. Optimize the matrix multiplication operation to improve performance.\n3. Ensure that the `__mul__` method raises a `ValueError` if the dimensions do not match for matrix multiplication.\n\n#### Inputs\n\n- The `Matrix` class is provided in the code snippet.\n- You need to add the following methods to the `Matrix` class:\n  - `is_invertible(self) -> bool`: Returns `True` if the matrix is invertible, otherwise `False`.\n  - `multiply_optimized(self, another: Matrix) -> Matrix`: Returns the result of multiplying the current matrix with another matrix using a more efficient algorithm.\n\n#### Constraints\n\n- The `Matrix` class and the provided methods should be self-contained.\n- The `multiply_optimized` method should be more efficient than the existing `__mul__` method.\n\n#### Example\n\n```python\na = Matrix(2, 2)\na[0, 0], a[0, 1], a[1, 0], a[1, 1] = 1, 2, 3, 4\nprint(a.is_invertible())  # False\nprint(a.sherman_morrison(Matrix(2, 1, 1), Matrix(2, 1, 1)))  # None\n\nb = Matrix(2, 2)\nb[0, 0], b[0, 1], b[1, 0], b[1, 1] = 2, -1, -1, 2\nprint(b.is_invertible())  # True\nprint(b.sherman_morrison(Matrix(2, 1, 1), Matrix(2, 1, 1)))  # Matrix\n\nc = Matrix(2, 2)\nc[0, 0], c[0, 1], c[1, 0], c[1, 1] = 1, 1, 1, 1\nprint(c.is_invertible())  # False\n```\n\n#### Performance Requirements\n\n- The `multiply_optimized` method should achieve a time complexity of \\(O(n^2)\\) for multiplying two \\(n \\times n\\) matrices.\n\n#### Implementation\n\nImplement the required methods in the `Matrix` class.",
  "solution_code": "import numpy as np\n\nclass Matrix:\n    def __init__(self, *args):\n        if isinstance(args[0], (int, float)):\n            # Initialize a single value matrix\n            self.data = np.array([args])\n        elif isinstance(args[0], list):\n            # Initialize from list\n            self.data = np.array(args)\n        else:\n            raise ValueError(\"Invalid initialization arguments\")\n\n    def __getitem__(self, key):\n        return self.data[key]\n\n    def __setitem__(self, key, value):\n        self.data[key] = value\n\n    def shape(self):\n        return self.data.shape\n\n    def __neg__(self):\n        return Matrix(-self.data)\n\n    def __mul__(self, another):\n        if not isinstance(another, Matrix) or self.shape()[1] != another.shape()[0]:\n            raise ValueError(\"Matrix dimensions mismatch for multiplication\")\n        return Matrix(np.dot(self.data, another.data))\n\n    def __rmul__(self, other):\n        return self * other\n\n    def is_invertible(self) -> bool:\n        try:\n            np.linalg.inv(self.data)\n            return True\n        except np.linalg.LinAlgError:\n            return False\n\n    def sherman_morrison(self, u: Matrix, v: Matrix) -> 'Matrix':\n        if not self.is_invertible():\n            return None\n        return self.inverse() + (u * (1 / (1 - u @ self @ v)) * v.T)\n\n    def inverse(self) -> 'Matrix':\n        return Matrix(np.linalg.inv(self.data))\n\n    def multiply_optimized(self, another: 'Matrix') -> 'Matrix':\n        from scipy.linalg import block_tridiagonal\n        if not isinstance(another, Matrix) or self.shape()[1] != another.shape()[0]:\n            raise ValueError(\"Matrix dimensions mismatch for multiplication\")\n        n, m, p = self.shape()[0], self.shape()[1], another.shape()[1]\n        blocks = [self[i:i+n, :m] @ another[:, j:j+p] for i in range(0, n, m) for j in range(0, p, m)]\n        return Matrix(block_tridiagonal(*blocks, format='csc'))",
  "test_code": "import pytest\nfrom solution import Matrix\n\ndef test_matrix_init():\n    a = Matrix(2, 2)\n    a[0, 0], a[0, 1], a[1, 0], a[1, 1] = 1, 2, 3, 4\n    assert a.shape() == (2, 2)\n\ndef test_matrix_get_set_item():\n    a = Matrix([[1, 2], [3, 4]])\n    assert a[0, 0] == 1\n    a[0, 0] = 5\n    assert a[0, 0] == 5\n\ndef testnegative_matrix():\n    a = -Matrix([[1, 2], [3, 4]])\n    assert a[0, 0] == -1\n    assert a[0, 1] == -2\n\ndef test_matrix_multiplication():\n    a = Matrix(2, 2)\n    a[0, 0], a[0, 1], a[1, 0], a[1, 1] = 1, 2, 3, 4\n    b = Matrix(2, 2)\n    b[0, 0], b[0, 1], b[1, 0], b[1, 1] = 5, 6, 7, 8\n    c = a * b\n    assert c[0, 0] == 19\n    assert c[0, 1] == 22\n    assert c[1, 0] == 43\n    assert c[1, 1] == 50\n\ndef test_matrix_is_invertible():\n    a = Matrix([[1, 2], [3, 4]])\n    assert not a.is_invertible()\n    b = Matrix([[2, -1], [-1, 2]])\n    assert b.is_invertible()\n\ndef test_matrix_sherman_morrison():\n    a = Matrix([[2, -1], [-1, 2]])\n    u = Matrix(2, 1, [1, 1])\n    v = Matrix(2, 1, [1, 1])\n    result = a.sherman_morrison(u, v)\n    assert result[0, 0] == 1.5\n    assert result[0, 1] == -0.5\n    assert result[1, 0] == -0.5\n    assert result[1, 1] == 1.5\n\ndef test_matrix_multiply_optimized():\n    a = Matrix(2, 3)\n    a[0, 0], a[0, 1], a[0, 2], a[1, 0], a[1, 1], a[1, 2] = 1, 2, 3, 4, 5, 6\n    b = Matrix(3, 2)\n    b[0, 0], b[0, 1], b[1, 0], b[1, 1], b[2, 0], b[2, 1] = 7, 8, 9, 10, 11, 12\n    c = a.multiply_optimized(b)\n    assert c[0, 0] == 58\n    assert c[0, 1] == 64\n    assert c[1, 0] == 139\n    assert c[1, 1] == 154\n\ndef test_matrix_non_matching_shapes():\n    a = Matrix(2, 2)\n    b = Matrix(2, 3)\n    with pytest.raises(ValueError):\n        _ = a * b",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}