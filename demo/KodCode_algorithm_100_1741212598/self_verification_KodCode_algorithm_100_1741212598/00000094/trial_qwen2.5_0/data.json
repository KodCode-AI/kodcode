{
  "metadata": {
    "prompt_id": "00000094",
    "row_id": 94,
    "seed_ids": [
      827
    ],
    "mode": "algorithm"
  },
  "instruction": "### Scenario\nYou are tasked with implementing a robust version of the Runge-Kutta-Fehlberg (RK45) method for solving ordinary differential equations. This version should include additional checks and optimizations to ensure the method works correctly and efficiently.\n\n### Task\nImplement the `runge_kutta_fehlberg_45` function that solves an ODE given by the function `func` using the Runge-Kutta-Fehlberg method. The function should:\n- Validate the inputs: `func`, `x_initial`, `y_initial`, `step_size`, and `x_final`.\n- Use the RK45 method to solve the ODE and return the solution `y` at each nodal point.\n- Ensure the step size is positive and the final value of `x` is greater than the initial value.\n\n### Requirements\n1. **Inputs**:\n   - `func`: A function representing the ODE, which takes two arguments `x` and `y`, and returns the derivative `dy/dx`.\n   - `x_initial`: The initial value of `x`.\n   - `y_initial`: The initial value of `y`.\n   - `step_size`: The increment value of `x`.\n   - `x_final`: The final value of `x`.\n\n2. **Output**:\n   - A NumPy array containing the solution `y` at each nodal point.\n\n3. **Constraints**:\n   - The `step_size` must be a positive number.\n   - The final value of `x` must be greater than the initial value of `x`.\n\n4. **Performance**:\n   - The function should efficiently handle the solution process and avoid unnecessary computations.\n\n### Example\n```python\ndef f(x, y):\n    return x + y\n\ny = runge_kutta_fehlberg_45(f, 0, 0, 0.1, 1)\nprint(y)\n```\n\n### Expected Output\n```\narray([ 0.00000000e+00,  1.00000000e-01,  2.05000000e-01,  3.15500000e-01,\n        4.32250000e-01,  5.56785000e-01,  6.89364500e-01,  8.29995350e-01,\n        9.78794935e-01,  1.13687443e+00,  1.30446187e+00,  1.48173531e+00,\n        1.66979727e+00,  1.86904726e+00,  2.07978369e+00,  2.29220419e+00,\n        2.51641445e+00,  2.75261038e+00,  2.99999999e+00,  3.25867937e+00,\n        3.52873731e+00,  3.80917374e+00,  4.09999999e+00,  4.39221387e+00,\n        4.68571341e+00,  4.98049310e+00,  5.27655090e+00,  5.57388469e+00,\n        5.87250319e+00,  6.17230427e+00,  6.47328584e+00,  6.77544669e+00,\n        7.07878461e+00,  7.38330738e+00,  7.68891368e+00,  8.00000000e+00])\n```\n\n### Notes\n- Ensure all edge cases are handled appropriately.\n- Use efficient computation and minimize unnecessary operations.",
  "solution_code": "import numpy as np\n\ndef runge_kutta_fehlberg_45(func, x_initial, y_initial, step_size, x_final):\n    \"\"\"\n    Solves the ordinary differential equation given by func using the Runge-Kutta-Fehlberg method.\n    \n    Parameters:\n    - func: A function representing the ODE, taking two arguments (x, y) and returning dy/dx.\n    - x_initial: The initial value of x.\n    - y_initial: The initial value of y.\n    - step_size: The increment value of x.\n    - x_final: The final value of x.\n    \n    Returns:\n    - A NumPy array containing the solution y at each nodal point.\n    \"\"\"\n    if not callable(func):\n        raise TypeError(\"func must be a callable function.\")\n    if not (isinstance(x_initial, (int, float)) and isinstance(step_size, (int, float)) and isinstance(x_final, (int, float))):\n        raise TypeError(\"x_initial, step_size, and x_final must be numeric values.\")\n    if not (isinstance(y_initial, (int, float)) or (isinstance(y_initial, np.ndarray) and y_initial.ndim == 1)):\n        raise TypeError(\"y_initial must be a numeric value or an array of initial values.\")\n    if not (step_size > 0 and x_final > x_initial):\n        raise ValueError(\"Step size must be positive and x_final must be greater than x_initial.\")\n    \n    x = x_initial\n    y = y_initial\n    if isinstance(y_initial, np.ndarray):\n        # Preserving the shape of the initial condition\n        n = y_initial.size\n        y_solution = np.zeros((n, int((x_final - x_initial) / step_size) + 1))\n        y_solution[:, 0] = y_initial\n    else:\n        y_solution = np.zeros(int((x_final - x_initial) / step_size) + 1)\n        y_solution[0] = y_initial\n    \n    for i in range(int((x_final - x_initial) / step_size)):\n        k1 = func(x, y)\n        k2 = func(x + step_size/4, y + step_size/4 * k1)\n        k3 = func(x + 3*step_size/8, y + step_size/3 * (2*k1 + 2*k2) / 3)\n        k4 = func(x + 12*step_size/13, y + step_size * (1932*k1 - 7200*k3 + 7296*k4) / 2197)\n        k5 = func(x + step_size, y + step_size * (439*k1 - 84*k3 + 800*k4 - 25*k5) / 4096)\n        k6 = func(x + step_size/2, y + step_size * (1408*k1 - 256*k3 + 1920*k4 - 124*k5) / 4275)\n        k6 = func(x + step_size/2, y - step_size * (21*k1 - 4*k3 - 5*k4 + 9*k5 + 2*k6) / 14)\n\n        y = y + step_size * (25*k1 + 1408*k4 + 21*k5 - 27*k6) / 2196\n        x = x + step_size\n        \n        y_solution[:, i+1] = y\n        \n    return y_solution",
  "test_code": "import numpy as np\nfrom solution import runge_kutta_fehlberg_45\n\ndef f1(x, y):\n    return x + y\n\n# Test case 1: Simple ODE with exponential solution\ny1 = runge_kutta_fehlberg_45(f1, 0, 0, 0.1, 1)\nexpected_y1 = np.exp(np.linspace(0, 1, len(y1)))\nassert np.allclose(y1, expected_y1)\n\n# Test case 2: ODE with initial condition as an array\ny_initial = np.array([0, 0])\ny2 = runge_kutta_fehlberg_45(f1, 0, y_initial, 0.1, 1)\nexpected_y2 = np.exp(np.linspace(0, 1, len(y2)))\nassert np.allclose(y2, np.vstack((expected_y2, expected_y2)).T)\n\n# Test case 3: ODE with negative initial condition\ny3 = runge_kutta_fehlberg_45(f1, 0, -1, 0.1, 1)\nexpected_y3 = np.exp(np.linspace(0, 1, len(y3))) - 1\nassert np.allclose(y3, expected_y3)\n\n# Test case 4: ODE with non-integer initial condition\ny4 = runge_kutta_fehlberg_45(f1, 0.5, 0, 0.1, 1)\nexpected_y4 = np.exp(np.linspace(0.5, 1, len(y4)))\nassert np.allclose(y4, expected_y4)\n\n# Test case 5: ODE with non-integer step size\ny5 = runge_kutta_fehlberg_45(f1, 0, 0, 0.25, 1)\nexpected_y5 = np.exp(np.linspace(0, 1, len(y5)))\nassert np.allclose(y5, expected_y5)\n\n# Test case 6: ODE with step size exactly reaching the final state\ny6 = runge_kutta_fehlberg_45(f1, 0, 0, 1.5, 1.5)\nexpected_y6 = np.exp(np.linspace(0, 1.5, len(y6)))\nassert np.allclose(y6, expected_y6)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}