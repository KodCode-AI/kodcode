{
  "metadata": {
    "prompt_id": "00000002",
    "row_id": 2,
    "seed_ids": [
      416
    ],
    "mode": "algorithm"
  },
  "instruction": "You are required to enhance the `StackWithQueues` class to support an additional operation: `get_min()`. This operation should return the minimum element in the stack in \\(O(1)\\) time complexity. You must implement this operation without using any additional data structures other than the two queues provided.\n\n### Input Format\n- The class will be instantiated as an object `stack`.\n- `stack.push(item)`: Pushes an integer `item` onto the stack.\n- `stack.pop()`: Removes the top element from the stack and returns it. If the stack is empty, it should raise an `IndexError`.\n- `stack.peek()`: Returns the top element of the stack without removing it. If the stack is empty, it should return `None`.\n- `stack.get_min()`: Returns the minimum element in the stack in \\(O(1)\\) time complexity.\n\n### Output Format\n- The `get_min()` method should return the minimum element in the stack.\n\n### Constraints\n- The stack can contain up to \\(10^5\\) elements.\n- The stack will only contain integer values.\n- The stack will not be empty when `get_min()` is called.\n\n### Performance Requirements\n- All operations (`push()`, `pop()`, `peek()`, and `get_min()`) must run in constant or amortized constant time.\n\n### Example\n```python\nstack = StackWithQueues()\nstack.push(5)\nstack.push(4)\nstack.push(6)\nstack.push(3)\nstack.get_min()  # Output should be 3\nstack.pop()\nstack.get_min()  # Output should be 4\n```\n\n### Context\nImplement the `get_min()` method in the `StackWithQueues` class to support the operation described above. Ensure that the implementation meets the specified time complexity requirements.",
  "solution_code": "class StackWithQueues:\n    def __init__(self):\n        self.queue1 = []\n        self.queue2 = []\n        self.min_value = None\n    \n    def push(self, item):\n        \"\"\"\n        Pushes an item onto the stack.\n        \"\"\"\n        if not self.queue1:\n            self.queue1.append(item)\n            self.min_value = item\n        else:\n            self.queue1.append(item)\n            if item <= self.min_value:\n                self.queue2.append(self.min_value)\n                self.min_value = item\n    \n    def pop(self):\n        \"\"\"\n        Removes and returns the top element from the stack.\n        \"\"\"\n        if not self.queue1:\n            raise IndexError(\"pop from an empty stack\")\n        if self.queue1[-1] == self.min_value:\n            self.queue2.pop()\n            self.min_value = self.queue2[-1] if self.queue2 else float('inf')\n        return self.queue1.pop()\n    \n    def peek(self):\n        \"\"\"\n        Returns the top element of the stack without removing it.\n        \"\"\"\n        if not self.queue1:\n            return None\n        return self.queue1[-1]\n    \n    def get_min(self):\n        \"\"\"\n        Returns the minimum element in the stack in O(1) time complexity.\n        \"\"\"\n        return self.min_value",
  "test_code": "import pytest\n\ndef test_stack_with_queues():\n    stack = StackWithQueues()\n    stack.push(5)\n    stack.push(4)\n    stack.push(6)\n    stack.push(3)\n    assert stack.get_min() == 3\n    stack.pop()\n    assert stack.get_min() == 4\n    stack.pop()\n    assert stack.get_min() == 5\n    stack.push(1)\n    assert stack.get_min() == 1\n\ndef test_stack_pop_empty():\n    stack = StackWithQueues()\n    with pytest.raises(IndexError):\n        stack.pop()\n\ndef test_stack_peek_empty():\n    stack = StackWithQueues()\n    assert stack.peek() is None\n\ndef test_stack_peek_non_empty():\n    stack = StackWithQueues()\n    stack.push(10)\n    assert stack.peek() == 10\n    stack.push(5)\n    assert stack.peek() == 5\n\ndef test_stack_push_pop_sequence():\n    stack = StackWithQueues()\n    stack.push(4)\n    stack.push(1)\n    stack.push(5)\n    assert stack.get_min() == 1\n    assert stack.pop() == 5\n    assert stack.pop() == 1\n    assert stack.pop() == 4",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}