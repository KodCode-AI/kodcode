{
  "metadata": {
    "prompt_id": "00000002",
    "row_id": 2,
    "seed_ids": [
      416
    ],
    "mode": "algorithm"
  },
  "instruction": "You are required to enhance the `StackWithQueues` class to support an additional operation: `get_min()`. This operation should return the minimum element in the stack in \\(O(1)\\) time complexity. You must implement this operation without using any additional data structures other than the two queues provided.\n\n### Input Format\n- The class will be instantiated as an object `stack`.\n- `stack.push(item)`: Pushes an integer `item` onto the stack.\n- `stack.pop()`: Removes the top element from the stack and returns it. If the stack is empty, it should raise an `IndexError`.\n- `stack.peek()`: Returns the top element of the stack without removing it. If the stack is empty, it should return `None`.\n- `stack.get_min()`: Returns the minimum element in the stack in \\(O(1)\\) time complexity.\n\n### Output Format\n- The `get_min()` method should return the minimum element in the stack.\n\n### Constraints\n- The stack can contain up to \\(10^5\\) elements.\n- The stack will only contain integer values.\n- The stack will not be empty when `get_min()` is called.\n\n### Performance Requirements\n- All operations (`push()`, `pop()`, `peek()`, and `get_min()`) must run in constant or amortized constant time.\n\n### Example\n```python\nstack = StackWithQueues()\nstack.push(5)\nstack.push(4)\nstack.push(6)\nstack.push(3)\nstack.get_min()  # Output should be 3\nstack.pop()\nstack.get_min()  # Output should be 4\n```\n\n### Context\nImplement the `get_min()` method in the `StackWithQueues` class to support the operation described above. Ensure that the implementation meets the specified time complexity requirements.",
  "solution_code": "from collections import deque\n\nclass StackWithQueues:\n    def __init__(self):\n        self.main_queue = deque()\n        self.min_queue = deque()\n        self._push_count = 0\n\n    def push(self, item):\n        \"\"\"\n        Pushes an integer item onto the stack.\n        \"\"\"\n        self.main_queue.append(item)\n        if self._push_count == 0 or item <= self.min_queue[-1]:\n            self.min_queue.append(item)\n        self._push_count += 1\n\n    def pop(self):\n        \"\"\"\n        Removes the top element from the stack and returns it. If the stack is empty, it should raise an IndexError.\n        \"\"\"\n        if not self.main_queue:\n            raise IndexError(\"pop from an empty stack\")\n\n        item = self.main_queue.popleft()\n        if item == self.min_queue[-1]:\n            self.min_queue.popleft()\n        return item\n\n    def peek(self):\n        \"\"\"\n        Returns the top element of the stack without removing it. If the stack is empty, it should return None.\n        \"\"\"\n        if not self.main_queue:\n            return None\n        return self.main_queue[0]\n\n    def get_min(self):\n        \"\"\"\n        Returns the minimum element in the stack in O(1) time complexity.\n        \"\"\"\n        if not self.min_queue:\n            return None\n        return self.min_queue[-1]",
  "test_code": "import pytest\n\ndef test_stack_with_queues():\n    stack = StackWithQueues()\n    stack.push(5)\n    stack.push(4)\n    stack.push(6)\n    stack.push(3)\n\n    # Test get_min\n    assert stack.get_min() == 3\n\n    # Test pop and get_min\n    assert stack.pop() == 3\n    assert stack.get_min() == 4\n\n    # Test push and get_min\n    stack.push(1)\n    assert stack.push(1) == 1\n    assert stack.get_min() == 1\n\n    # Test push and get_min when all elements are equal\n    stack.push(1)\n    assert stack.get_min() == 1\n\n    # Test pop multiple times and get_min\n    assert stack.pop() == 1\n    assert stack.pop() == 1\n    assert stack.get_min() == 4\n    assert stack.pop() == 6\n    assert stack.get_min() == 4\n    assert stack.pop() == 4\n    assert stack.get_min() == 5\n    with pytest.raises(IndexError):\n        stack.pop()\n\n    # Test get_min with an empty stack\n    assert stack.get_min() is None",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}