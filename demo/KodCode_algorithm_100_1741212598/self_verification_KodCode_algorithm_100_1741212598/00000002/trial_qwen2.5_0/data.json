{
  "metadata": {
    "prompt_id": "00000002",
    "row_id": 2,
    "seed_ids": [
      416
    ],
    "mode": "algorithm"
  },
  "instruction": "You are required to enhance the `StackWithQueues` class to support an additional operation: `get_min()`. This operation should return the minimum element in the stack in \\(O(1)\\) time complexity. You must implement this operation without using any additional data structures other than the two queues provided.\n\n### Input Format\n- The class will be instantiated as an object `stack`.\n- `stack.push(item)`: Pushes an integer `item` onto the stack.\n- `stack.pop()`: Removes the top element from the stack and returns it. If the stack is empty, it should raise an `IndexError`.\n- `stack.peek()`: Returns the top element of the stack without removing it. If the stack is empty, it should return `None`.\n- `stack.get_min()`: Returns the minimum element in the stack in \\(O(1)\\) time complexity.\n\n### Output Format\n- The `get_min()` method should return the minimum element in the stack.\n\n### Constraints\n- The stack can contain up to \\(10^5\\) elements.\n- The stack will only contain integer values.\n- The stack will not be empty when `get_min()` is called.\n\n### Performance Requirements\n- All operations (`push()`, `pop()`, `peek()`, and `get_min()`) must run in constant or amortized constant time.\n\n### Example\n```python\nstack = StackWithQueues()\nstack.push(5)\nstack.push(4)\nstack.push(6)\nstack.push(3)\nstack.get_min()  # Output should be 3\nstack.pop()\nstack.get_min()  # Output should be 4\n```\n\n### Context\nImplement the `get_min()` method in the `StackWithQueues` class to support the operation described above. Ensure that the implementation meets the specified time complexity requirements.",
  "solution_code": "class StackWithQueues:\n    def __init__(self):\n        self.main_queue = []\n        self.min_queue = []\n\n    def push(self, item):\n        self.main_queue.append(item)\n        if not self.min_queue or item <= self.min_queue[-1]:\n            self.min_queue.append(item)\n\n    def pop(self):\n        if not self.main_queue:\n            raise IndexError(\"pop from an empty stack\")\n        if self.main_queue[-1] == self.min_queue[-1]:\n            self.min_queue.pop()\n        return self.main_queue.pop()\n\n    def peek(self):\n        if not self.main_queue:\n            return None\n        return self.main_queue[-1]\n\n    def get_min(self):\n        if not self.min_queue:\n            raise IndexError(\"get_min from an empty stack\")\n        return self.min_queue[-1]",
  "test_code": "``\nimport pytest\n\n@pytest.fixture\ndef stack():\n    return StackWithQueues()\n\ndef test_push_and_get_min(stack):\n    stack.push(5)\n    stack.push(4)\n    stack.push(6)\n    stack.push(3)\n    assert stack.get_min() == 3\n\ndef test_pop_and_get_min(stack):\n    stack.push(5)\n    stack.push(4)\n    stack.push(6)\n    stack.push(3)\n    stack.pop()\n    assert stack.get_min() == 4\n\ndef test_push_equal_min(stack):\n    stack.push(5)\n    stack.push(5)\n    assert stack.get_min() == 5\n\ndef test_pop_multiple_times(stack):\n    stack.push(5)\n    stack.push(3)\n    stack.pop()\n    stack.pop()\n    with pytest.raises(IndexError):\n        stack.get_min()\n\ndef test_empty_stack_get_min(stack):\n    with pytest.raises(IndexError):\n        stack.get_min()\n\ndef test_peek(stack):\n    stack.push(5)\n    assert stack.peek() == 5\n    stack.pop()\n    assert stack.peek() is None",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}