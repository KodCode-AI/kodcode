{
  "metadata": {
    "prompt_id": "00000012",
    "row_id": 12,
    "seed_ids": [
      821
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question\n\nYou are given a function `f(x)` that takes a float and returns a float. Your task is to implement a numerical integration function using Simpson's method to approximate the definite integral of `f(x)` over a given interval \\([a, b]\\).\n\n#### Function Signature\n```python\ndef simpson_integration(function, a: float, b: float, precision: int) -> float:\n    pass\n```\n\n#### Constraints\n- \\(0 \\leq a \\leq b \\leq 1000\\)\n- \\(1 \\leq \\text{precision} \\leq 10\\)\n\n#### Input & Output\n- **function**: A function that takes a float and returns a float.\n- **a**: The lower limit of integration.\n- **b**: The upper limit of integration.\n- **precision**: The desired precision of the result.\n\n#### Return\nThe function should return the approximated value of the integral of `f(x)` over the interval \\([a, b]\\) with the specified precision.\n\n#### Example\n```python\nassert simpson_integration(lambda x: x * x, 1, 2, 4) == 2.333\n```\n\n#### Detailed Instructions\n1. The method should use Simpson's method to approximate the integral.\n2. Ensure that the function `f(x)` is called with valid arguments.\n3. Handle edge cases and ensure the function returns a float rounded to the specified precision.\n4. Optimize the method to handle large intervals and high precision requirements efficiently.\n\n#### Additional Notes\n- Ensure to validate the input values as shown in the provided code snippet.\n- The Simpson's method formula should be applied correctly over the interval.\n- Use a fixed number of steps (1000) in your implementation, as in the provided code snippet.",
  "solution_code": "def simpson_integration(function, a: float, b: float, precision: int) -> float:\n    \"\"\"\n    Approximates the definite integral of a function over the interval [a, b]\n    using Simpson's method.\n    \"\"\"\n    if not (0 <= a <= b <= 1000) or not (1 <= precision <= 10):\n        raise ValueError(\"Invalid input: a, b must be in [0, 1000], and precision must be in [1, 10].\")\n    \n    n = 1000  # Fixed number of steps for Simpson's method\n    h = (b - a) / n\n    result = function(a) + function(b)\n    \n    for i in range(1, n, 2):\n        xi = a + i * h\n        result += 4 * function(xi)\n    \n    for i in range(2, n-1, 2):\n        xi = a + i * h\n        result += 2 * function(xi)\n    \n    result *= h / 3\n    return round(result, precision)",
  "test_code": "import pytest\nfrom solution import simpson_integration\n\ndef test simpson_integration_positive_function():\n    assert simpson_integration(lambda x: x * x, 1, 2, 4) == 2.333\n\ndef test_simpson_integration_linear_function():\n    assert simpson_integration(lambda x: 2 * x + 1, 0, 4, 4) == 32.0\n\ndef test_simpson_integration_cosine_function():\n    assert simpson_integration(lambda x: 4 * (math.cos(x)), 0, math.pi, 4) == 8.0\n\ndef test_simpson_integration_constant_function():\n    assert simpson_integration(lambda x: 3, 1, 4, 4) == 9.0\n\ndef test_simpson_integration_edge_case():\n    with pytest.raises(ValueError):\n        simpson_integration(lambda x: x, -1, 1, 2)\n        \ndef test_simpson_integration_precision():\n    assert simpson_integration(lambda x: x * x, 1, 2, 2) == 2.33\n    assert simpson_integration(lambda x: x * x, 1, 2, 5) == 2.33333",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}