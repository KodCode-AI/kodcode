{
  "metadata": {
    "prompt_id": "00000012",
    "row_id": 12,
    "seed_ids": [
      821
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question\n\nYou are given a function `f(x)` that takes a float and returns a float. Your task is to implement a numerical integration function using Simpson's method to approximate the definite integral of `f(x)` over a given interval \\([a, b]\\).\n\n#### Function Signature\n```python\ndef simpson_integration(function, a: float, b: float, precision: int) -> float:\n    pass\n```\n\n#### Constraints\n- \\(0 \\leq a \\leq b \\leq 1000\\)\n- \\(1 \\leq \\text{precision} \\leq 10\\)\n\n#### Input & Output\n- **function**: A function that takes a float and returns a float.\n- **a**: The lower limit of integration.\n- **b**: The upper limit of integration.\n- **precision**: The desired precision of the result.\n\n#### Return\nThe function should return the approximated value of the integral of `f(x)` over the interval \\([a, b]\\) with the specified precision.\n\n#### Example\n```python\nassert simpson_integration(lambda x: x * x, 1, 2, 4) == 2.333\n```\n\n#### Detailed Instructions\n1. The method should use Simpson's method to approximate the integral.\n2. Ensure that the function `f(x)` is called with valid arguments.\n3. Handle edge cases and ensure the function returns a float rounded to the specified precision.\n4. Optimize the method to handle large intervals and high precision requirements efficiently.\n\n#### Additional Notes\n- Ensure to validate the input values as shown in the provided code snippet.\n- The Simpson's method formula should be applied correctly over the interval.\n- Use a fixed number of steps (1000) in your implementation, as in the provided code snippet.",
  "solution_code": "def simpson_integration(function, a: float, b: float, precision: int) -> float:\n    \"\"\"\n    Approximates the integral of function f(x) over the interval [a, b] using Simpson's rule.\n\n    Args:\n    function: A callable function that takes a float and returns a float.\n    a: The lower limit of integration.\n    b: The upper limit of integration.\n    precision: The desired precision of the result.\n\n    Returns:\n    The approximated value of the integral of f(x) over [a, b].\n    \"\"\"\n    if not (0 <= a <= b <= 1000 and 1 <= precision <= 10):\n        raise ValueError(\"Invalid input values. Ensure 0 <= a <= b <= 1000 and 1 <= precision <= 10.\")\n\n    n = 1000  # Fixed number of steps in the Simpson's rule\n    h = (b - a) / n\n    integral = (function(a) + function(b)) / 6.0\n    for i in range(1, n, 2):\n        x = a + i * h\n        integral += function(x) / 3.0\n    for i in range(2, n-1, 2):\n        x = a + i * h\n        integral += 2.0 * function(x) / 3.0\n\n    return round(integral * h, precision)",
  "test_code": "import pytest\n\ndef test_simpson_integration():\n    # Define a simple function for testing, e.g., f(x) = x^2\n    def f(x):\n        return x * x\n\n    # Test with a known integral, f(x) = x^2 from 1 to 2\n    approx_integral = simpson_integration(f, 1, 2, 4)\n    assert approx_integral == pytest.approx(2.3333, abs=1e-4)\n\ndef test_invalid_input():\n    # Test with invalid input\n    with pytest.raises(ValueError):\n        simps_integral = simpson_integration(lambda x: x * x, 2, 1, 4)\n\ndef test_constant_function():\n    # Test with a constant function, e.g., f(x) = 1 from 0 to 10\n    def f(x):\n        return 1.0\n\n    approx_integral = simpson_integration(f, 0, 10, 2)\n    assert approx_integral == pytest.approx(10.0, abs=1e-2)\n\ndef test_linear_function():\n    # Test with a linear function, e.g., f(x) = x from 0 to 2\n    def f(x):\n        return x\n\n    approx_integral = simpson_integration(f, 0, 2, 3)\n    assert approx_integral == pytest.approx(2.0, abs=1e-3)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}