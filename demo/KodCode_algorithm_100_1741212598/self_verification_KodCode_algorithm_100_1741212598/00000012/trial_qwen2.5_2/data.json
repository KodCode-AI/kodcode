{
  "metadata": {
    "prompt_id": "00000012",
    "row_id": 12,
    "seed_ids": [
      821
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question\n\nYou are given a function `f(x)` that takes a float and returns a float. Your task is to implement a numerical integration function using Simpson's method to approximate the definite integral of `f(x)` over a given interval \\([a, b]\\).\n\n#### Function Signature\n```python\ndef simpson_integration(function, a: float, b: float, precision: int) -> float:\n    pass\n```\n\n#### Constraints\n- \\(0 \\leq a \\leq b \\leq 1000\\)\n- \\(1 \\leq \\text{precision} \\leq 10\\)\n\n#### Input & Output\n- **function**: A function that takes a float and returns a float.\n- **a**: The lower limit of integration.\n- **b**: The upper limit of integration.\n- **precision**: The desired precision of the result.\n\n#### Return\nThe function should return the approximated value of the integral of `f(x)` over the interval \\([a, b]\\) with the specified precision.\n\n#### Example\n```python\nassert simpson_integration(lambda x: x * x, 1, 2, 4) == 2.333\n```\n\n#### Detailed Instructions\n1. The method should use Simpson's method to approximate the integral.\n2. Ensure that the function `f(x)` is called with valid arguments.\n3. Handle edge cases and ensure the function returns a float rounded to the specified precision.\n4. Optimize the method to handle large intervals and high precision requirements efficiently.\n\n#### Additional Notes\n- Ensure to validate the input values as shown in the provided code snippet.\n- The Simpson's method formula should be applied correctly over the interval.\n- Use a fixed number of steps (1000) in your implementation, as in the provided code snippet.",
  "solution_code": "def simpson_integration(function, a: float, b: float, precision: int) -> float:\n    \"\"\"\n    Returns the approximate definite integral of a function f(x) over the interval [a, b] using Simpson's method.\n    \"\"\"\n    if not (0 <= a <= b <= 1000) or not (1 <= precision <= 10):\n        raise ValueError(\"Invalid input. Ensure a, b are within [0, 1000] and precision is within [1, 10].\")\n    \n    n = 1000  # Number of steps\n    h = (b - a) / n\n    s = function(a) + function(b)\n    \n    for i in range(1, n, 2):\n        s += 4 * function(a + i * h)\n    \n    for i in range(2, n-1, 2):\n        s += 2 * function(a + i * h)\n    \n    result = s * h / 3\n    return round(result, precision)",
  "test_code": "from solution import simpson_integration\n\ndef test_simpson_integration():\n    def f1(x):\n        return x * x\n    assert abs(simpson_integration(f1, 1, 2, 4) - 2.3333) < 1e-3\n\ndef test_simpson_integration_with_log():\n    import math\n    def f2(x):\n        return math.log(x)\n    assert abs(simpson_integration(f2, 1, 3, 3) - 2.197) < 1e-3\n\ndef test_simpson_integration_with_exp():\n    import math\n    def f3(x):\n        return math.exp(x)\n    assert abs(simpson_integration(f3, 0, 1, 3) - 1.718) < 1e-3\n\ndef test_simpson_integration_edge_case():\n    def f4(x):\n        return x\n    assert abs(simpson_integration(f4, 0, 1, 4) - 0.5) < 1e-4\n\ndef test_simpson_integration_out_of_bounds():\n    import pytest\n    with pytest.raises(ValueError):\n        simpson_integration(lambda x: x, -1, 1, 2)\n    with pytest.raises(ValueError):\n        simpson_integration(lambda x: x, 1, 5001, 2)\n    with pytest.raises(ValueError):\n        simpson_integration(lambda x: x, 1, 5, 11)\n\ndef test_simpson_integration_precision():\n    def f5(x):\n        return x * x\n    assert abs(simpson_integration(f5, 1, 2, 1) - 2.3) < 1e-3",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}