{
  "metadata": {
    "prompt_id": "00000041",
    "row_id": 41,
    "seed_ids": [
      233
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a list of integers and are required to implement a quick sort algorithm. The provided code uses a simple random pivot selection and does not handle in-place sorting. Your task is to enhance the given implementation to achieve the following:\n\n1. Implement quick sort as an in-place sorting algorithm.\n2. Handle edge cases such as empty lists, single-element lists, and nearly sorted lists.\n3. Improve the pivot selection strategy to avoid worst-case performance.\n\n#### Function Signature\n\n```python\ndef quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm.\n\n    :param arr: A list of integers to be sorted.\n    \"\"\"\n```\n\n#### Constraints\n\n- \\(1 \\leq len(arr) \\leq 10^5\\)\n- Elements of `arr` are integers in the range \\([-10^3, 10^3]\\)\n\n#### Example\n\n```python\narr = [10, 5, 2, 3, 7, 6, 8, 4, 9, 1]\nquick_sort_in_place(arr)\nprint(arr)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n### Notes\n\n- You should modify the provided `quick_sort` function to work in-place.\n- Ensure that the function can handle edge cases such as already sorted or nearly sorted arrays.\n- Use a more sophisticated pivot selection strategy, such as the \"median-of-three\" pivot to improve performance.\n\n#### Performance Requirements\n\n- The algorithm should achieve an average-case time complexity of \\(O(n \\log n)\\).",
  "solution_code": "def quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm with an\n    in-place partitioning and median-of-three pivot selection to handle edge cases.\n\n    :param arr: A list of integers to be sorted.\n    \"\"\"\n    def partition(low, high):\n        # Choosing the median of the first, middle, and last elements as the pivot\n        mid = (low + high) // 2\n        pivot = sorted([arr[low], arr[mid], arr[high]])[1]\n\n        if pivot == arr[low]:\n            pivot_index = low\n        elif pivot == arr[mid]:\n            pivot_index = mid\n        else:\n            pivot_index = high\n\n        arr[low], arr[pivot_index] = arr[pivot_index], arr[low]\n        pivot = low\n\n        i = low + 1\n        for j in range(low + 1, high + 1):\n            if arr[j] < arr[pivot]:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n\n        arr[pivot], arr[i - 1] = arr[i - 1], arr[pivot]\n        return i - 1\n\n    def _quick_sort_in_place(low, high):\n        if low < high:\n            pivot_index = partition(low, high)\n            _quick_sort_in_place(low, pivot_index - 1)\n            _quick_sort_in_place(pivot_index + 1, high)\n\n    _quick_sort_in_place(0, len(arr) - 1)",
  "test_code": "import random\n\ndef quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm with an\n    in-place partitioning and median-of-three pivot selection to handle edge cases.\n    \n    :param arr: A list of integers to be sorted.\n    \"\"\"\n    def partition(low, high):\n        mid = (low + high) // 2\n        pivot = sorted([arr[low], arr[mid], arr[high]])[1]\n\n        if pivot == arr[low]:\n            pivot_index = low\n        elif pivot == arr[mid]:\n            pivot_index = mid\n        else:\n            pivot_index = high\n\n        arr[low], arr[pivot_index] = arr[pivot_index], arr[low]\n        pivot = low\n\n        i = low + 1\n        for j in range(low + 1, high + 1):\n            if arr[j] < arr[pivot]:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n\n        arr[pivot], arr[i - 1] = arr[i - 1], arr[pivot]\n        return i - 1\n\n    def _quick_sort_in_place(low, high):\n        if low < high:\n            pivot_index = partition(low, high)\n            _quick_sort_in_place(low, pivot_index - 1)\n            _quick_sort_in_place(pivot_index + 1, high)\n\n    _quick_sort_in_place(0, len(arr) - 1)\n\ndef test_quick_sort_in_place():\n    # Test with a list of positive integers\n    arr = [random.randint(1, 100) for _ in range(10)]\n    quick_sort_in_place(arr)\n    assert arr == sorted(arr)\n\n    # Test with a list of negative integers\n    arr = [-x for x in arr]\n    quick_sort_in_place(arr)\n    assert arr == sorted(arr, reverse=True)\n\n    # Test with a list of mixed integers\n    arr = [random.randint(-100, 100) for _ in range(10)]\n    quick_sort_in_place(arr)\n    assert arr == sorted(arr)\n\n    # Test with an empty list\n    arr = []\n    quick_sort_in_place(arr)\n    assert arr == []\n\n    # Test with a single-element list\n    arr = [5]\n    quick_sort_in_place(arr)\n    assert arr == [5]\n\n    # Test with a nearly sorted list\n    arr = [x for x in range(1, 10)]\n    arr[0], arr[1] = arr[1], arr[0]  # swap first two elements\n    quick_sort_in_place(arr)\n    assert arr == list(range(1, 10))\n\n    # Test with a large list of unique elements\n    arr = list(range(1, 10001))\n    random.shuffle(arr)\n    quick_sort_in_place(arr)\n    assert arr == list(range(1, 10001))\n\n    # Test with a large list of repeated elements\n    arr = [x % 100 for x in range(1, 5001)]\n    quick_sort_in_place(arr)\n    assert arr == sorted(arr)\n\ntest_quick_sort_in_place()",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}