{
  "metadata": {
    "prompt_id": "00000041",
    "row_id": 41,
    "seed_ids": [
      233
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a list of integers and are required to implement a quick sort algorithm. The provided code uses a simple random pivot selection and does not handle in-place sorting. Your task is to enhance the given implementation to achieve the following:\n\n1. Implement quick sort as an in-place sorting algorithm.\n2. Handle edge cases such as empty lists, single-element lists, and nearly sorted lists.\n3. Improve the pivot selection strategy to avoid worst-case performance.\n\n#### Function Signature\n\n```python\ndef quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm.\n\n    :param arr: A list of integers to be sorted.\n    \"\"\"\n```\n\n#### Constraints\n\n- \\(1 \\leq len(arr) \\leq 10^5\\)\n- Elements of `arr` are integers in the range \\([-10^3, 10^3]\\)\n\n#### Example\n\n```python\narr = [10, 5, 2, 3, 7, 6, 8, 4, 9, 1]\nquick_sort_in_place(arr)\nprint(arr)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n### Notes\n\n- You should modify the provided `quick_sort` function to work in-place.\n- Ensure that the function can handle edge cases such as already sorted or nearly sorted arrays.\n- Use a more sophisticated pivot selection strategy, such as the \"median-of-three\" pivot to improve performance.\n\n#### Performance Requirements\n\n- The algorithm should achieve an average-case time complexity of \\(O(n \\log n)\\).",
  "solution_code": "def quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm.\n    Implements in-place sorting and uses the median-of-three pivot selection to improve performance.\n    :param arr: A list of integers to be sorted.\n    \"\"\"\n    def _quick_sort_in_place(left, right):\n        if left >= right:\n            return\n        pivot_idx = partition(left, right)\n        _quick_sort_in_place(left, pivot_idx - 1)\n        _quick_sort_in_place(pivot_idx + 1, right)\n\n    def partition(left, right):\n        mid = (left + right) // 2\n        candidates = [left, mid, right]\n        candidates.sort(key=lambda i: arr[i])\n        pivot = arr[candidates[1]]\n        pivot_idx = candidates[1]\n        \n        arr[left], arr[pivot_idx] = arr[pivot_idx], arr[left]  # Move pivot to the first position\n        i = left + 1\n        for j in range(left + 1, right + 1):\n            if arr[j] < pivot:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n        arr[left], arr[i - 1] = arr[i - 1], arr[left]  # Move pivot to its final position\n        return i - 1\n\n    _quick_sort_in_place(0, len(arr) - 1)",
  "test_code": "def quick_sort_in_place(arr: list) -> None:\n    \"\"\"\n    Sorts the given list arr in-place using the quick sort algorithm.\n    Implements in-place sorting and uses the median-of-three pivot selection to improve performance.\n    :param arr: A list of integers to be sorted.\n    \"\"\"\n    def _quick_sort_in_place(left, right):\n        if left >= right:\n            return\n        pivot_idx = partition(left, right)\n        _quick_sort_in_place(left, pivot_idx - 1)\n        _quick_sort_in_place(pivot_idx + 1, right)\n\n    def partition(left, right):\n        mid = (left + right) // 2\n        candidates = [left, mid, right]\n        candidates.sort(key=lambda i: arr[i])\n        pivot = arr[candidates[1]]\n        pivot_idx = candidates[1]\n        \n        arr[left], arr[pivot_idx] = arr[pivot_idx], arr[left]  # Move pivot to the first position\n        i = left + 1\n        for j in range(left + 1, right + 1):\n            if arr[j] < pivot:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n        arr[left], arr[i - 1] = arr[i - 1], arr[left]  # Move pivot to its final position\n        return i - 1\n\n    _quick_sort_in_place(0, len(arr) - 1)\n\ndef test_quick_sort_in_place():\n    # Test with normal array\n    arr = [10, 5, 2, 3, 7, 6, 8, 4, 9, 1]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    # Test with empty array\n    arr = []\n    quick_sort_in_place(arr)\n    assert arr == []\n\n    # Test with a single element\n    arr = [5]\n    quick_sort_in_place(arr)\n    assert arr == [5]\n\n    # Test with reverse sorted array\n    arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    # Test with almost sorted array\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    quick_sort_in_place(arr)\n    assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    # Test with an array with negative numbers\n    arr = [5, -1, 9, -2, 6, -3, 7]\n    quick_sort_in_place(arr)\n    assert arr == [-3, -2, -1, 5, 6, 7, 9]\n\ntest_quick_sort_in_place()",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}