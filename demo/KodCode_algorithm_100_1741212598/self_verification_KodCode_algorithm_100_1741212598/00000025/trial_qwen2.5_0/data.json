{
  "metadata": {
    "prompt_id": "00000025",
    "row_id": 25,
    "seed_ids": [
      699
    ],
    "mode": "algorithm"
  },
  "instruction": "<|Analysis Begin|>\n\n### Algorithm/Data Structure\n\n**Name and Type**: The provided code snippets demonstrate the calculation of Fibonacci numbers using several methods: iteration, recursion, memoization, and a simplified form of Binet's formula. Additionally, a matrix exponentiation method is used, which is a more advanced technique.\n\n**Core Operational Steps**:\n- **Iteration**: Uses a loop to iterate and calculate the Fibonacci sequence.\n- **Recursion**: Recursively calculates the Fibonacci sequence by dividing the problem into smaller subproblems.\n- **Memoization**: Stores the results of expensive function calls and reuses them when the same inputs occur again.\n- **Binet's Formula**: Uses mathematical formulas to calculate Fibonacci numbers, which is efficient but limited by floating-point precision.\n- **Matrix Exponentiation**: Utilizes matrix multiplication to compute the Fibonacci sequence, which is highly efficient for larger values of \\( n \\).\n\n**Time Complexity**:\n- **Iteration**: \\( O(n) \\)\n- **Recursion**: \\( O(2^n) \\) (without memoization), \\( O(n) \\) (with memoization)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(\\log n) \\)\n\n**Space Complexity**:\n- **Iteration**: \\( O(1) \\) (excluding the output list)\n- **Recursion**: \\( O(n) \\) (due to the call stack)\n- **Memoization**: \\( O(n) \\) (for storing intermediate results)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(1) \\) (excluding the output)\n\n### Characteristics & Applications\n\n**Properties**:\n- **Iteration**: Simple and easy to understand, but not efficient for large \\( n \\) due to its linear time complexity.\n- **Recursion**: Can lead to stack overflow for large \\( n \\) and is inefficient, but useful for teaching recursion.\n- **Memoization**: Efficient for large \\( n \\) and avoids redundant calculations, making it a good balance between speed and memory usage.\n- **Binet's Formula**: Efficient but limited by floating-point precision, making it less accurate for large values.\n- **Matrix Exponentiation**: Extremely efficient for very large \\( n \\) but requires understanding of matrix operations and logarithmic time complexity.\n\n**Common Use Cases**:\n- **Iteration**: Useful for small values of \\( n \\) where simplicity is preferred.\n- **Recursion**: Often used in teaching recursion, but not suitable for large \\( n \\).\n- **Memoization**: Good for practical applications where performance is critical and \\( n \\) is large.\n- **Binet's Formula**: Used in contexts where a quick, approximate solution is sufficient.\n- **Matrix Exponentiation**: Ideal for large \\( n \\) in performance-critical applications.\n\n**Strengths/Limitations**:\n- **Iteration**: Simple to implement, but inefficient for large \\( n \\).\n- **Recursion**: Elegant and easy to understand, but inefficient and prone to stack overflow.\n- **Memoization**: Efficient and avoids redundant calculations, but requires additional memory.\n- **Binet's Formula**: Fast but limited by floating-point precision, making it less accurate for large \\( n \\).\n- **Matrix Exponentiation**: Highly efficient with \\( O(\\log n) \\) time complexity but requires understanding of matrix operations.\n\n### Implementation Challenges\n\n**Edge Cases**:\n- **Negative Input**: All methods except the iterative yield version raise a `ValueError` for negative inputs.\n- **Large Input**: Binet's formula and matrix exponentiation have limitations for very large inputs due to floating-point precision and time complexity, respectively.\n\n**Performance Bottlenecks**:\n- **Recursion**: High stack usage and inefficiency, leading to stack overflow for large \\( n \\).\n- **Memoization**: Requires additional memory to",
  "solution_code": "def fibonacci_iterative(n):\n    if n < 0:\n        raise ValueError(\"Input should be non-negative\")\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\ndef fibonacci_memoization(n, memo={}):\n    if n < 0:\n        raise ValueError(\"Input should be non-negative\")\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    memo[n] = fibonacci_memoization(n - 1, memo) + fibonacci_memoization(n - 2, memo)\n    return memo[n]\n\ndef fibonacci_binet(n):\n    if n < 0:\n        raise ValueError(\"Input should be non-negative\")\n    \n    sqrt_5 = 5 ** 0.5\n    phi = (1 + sqrt_5) / 2\n    return round((phi ** n - (-phi) ** (-n)) / sqrt_5)\n\ndef fibonacci_matrix(n):\n    if n < 0:\n        raise ValueError(\"Input should be non-negative\")\n    \n    matrix = [[1, 1], [1, 0]]\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    def multiply(F, M):\n        x = F[0][0] * M[0][0] + F[0][1] * M[1][0]\n        y = F[0][0] * M[0][1] + F[0][1] * M[1][1]\n        z = F[1][0] * M[0][0] + F[1][1] * M[1][0]\n        w = F[1][0] * M[0][1] + F[1][1] * M[1][1]\n        \n        F[0][0], F[0][1], F[1][0], F[1][1] = x, y, z, w\n    \n    def power(F, n):\n        if n == 0 or n == 1:\n            return\n        M = [[1, 1], [1, 0]]\n        power(F, n // 2)\n        multiply(F, F)\n        \n        if n % 2 != 0:\n            multiply(F, M)\n    \n    power(matrix, n - 1)\n    return matrix[0][0]",
  "test_code": "`python\nimport pytest\n\ndef test_fibonacci_iterative():\n    assert fibonacci_iterative(0) == 0\n    assert fibonacci_iterative(1) == 1\n    assert fibonacci_iterative(10) == 55\n    with pytest.raises(ValueError):\n        fibonacci_iterative(-1)\n\ndef test_fibonacci_memoization():\n    assert fibonacci_memoization(0) == 0\n    assert fibonacci_memoization(1) == 1\n    assert fibonacci_memoization(10) == 55\n    with pytest.raises(ValueError):\n        fibonacci_memoization(-1)\n\ndef test_fibonacci_binet():\n    assert fibonacci_binet(0) == 0\n    assert fibonacci_binet(1) == 1\n    assert fibonacci_binet(10) == 55\n    with pytest.raises(ValueError):\n        fibonacci_binet(-1)\n\ndef test_fibonacci_matrix():\n    assert fibonacci_matrix(0) == 0\n    assert fibonacci_matrix(1) == 1\n    assert fibonacci_matrix(10) == 55\n    with pytest.raises(ValueError):\n        fibonacci_matrix(-1)\n\ndef test_fibonacci_consistency():\n    for n in range(20):\n        assert fibonacci_iterative(n) == fibonacci_memoization(n) == fibonacci_binet(n) == fibonacci_matrix(n)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}