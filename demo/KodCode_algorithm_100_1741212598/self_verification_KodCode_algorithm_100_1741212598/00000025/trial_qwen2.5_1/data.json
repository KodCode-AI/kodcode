{
  "metadata": {
    "prompt_id": "00000025",
    "row_id": 25,
    "seed_ids": [
      699
    ],
    "mode": "algorithm"
  },
  "instruction": "<|Analysis Begin|>\n\n### Algorithm/Data Structure\n\n**Name and Type**: The provided code snippets demonstrate the calculation of Fibonacci numbers using several methods: iteration, recursion, memoization, and a simplified form of Binet's formula. Additionally, a matrix exponentiation method is used, which is a more advanced technique.\n\n**Core Operational Steps**:\n- **Iteration**: Uses a loop to iterate and calculate the Fibonacci sequence.\n- **Recursion**: Recursively calculates the Fibonacci sequence by dividing the problem into smaller subproblems.\n- **Memoization**: Stores the results of expensive function calls and reuses them when the same inputs occur again.\n- **Binet's Formula**: Uses mathematical formulas to calculate Fibonacci numbers, which is efficient but limited by floating-point precision.\n- **Matrix Exponentiation**: Utilizes matrix multiplication to compute the Fibonacci sequence, which is highly efficient for larger values of \\( n \\).\n\n**Time Complexity**:\n- **Iteration**: \\( O(n) \\)\n- **Recursion**: \\( O(2^n) \\) (without memoization), \\( O(n) \\) (with memoization)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(\\log n) \\)\n\n**Space Complexity**:\n- **Iteration**: \\( O(1) \\) (excluding the output list)\n- **Recursion**: \\( O(n) \\) (due to the call stack)\n- **Memoization**: \\( O(n) \\) (for storing intermediate results)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(1) \\) (excluding the output)\n\n### Characteristics & Applications\n\n**Properties**:\n- **Iteration**: Simple and easy to understand, but not efficient for large \\( n \\) due to its linear time complexity.\n- **Recursion**: Can lead to stack overflow for large \\( n \\) and is inefficient, but useful for teaching recursion.\n- **Memoization**: Efficient for large \\( n \\) and avoids redundant calculations, making it a good balance between speed and memory usage.\n- **Binet's Formula**: Efficient but limited by floating-point precision, making it less accurate for large values.\n- **Matrix Exponentiation**: Extremely efficient for very large \\( n \\) but requires understanding of matrix operations and logarithmic time complexity.\n\n**Common Use Cases**:\n- **Iteration**: Useful for small values of \\( n \\) where simplicity is preferred.\n- **Recursion**: Often used in teaching recursion, but not suitable for large \\( n \\).\n- **Memoization**: Good for practical applications where performance is critical and \\( n \\) is large.\n- **Binet's Formula**: Used in contexts where a quick, approximate solution is sufficient.\n- **Matrix Exponentiation**: Ideal for large \\( n \\) in performance-critical applications.\n\n**Strengths/Limitations**:\n- **Iteration**: Simple to implement, but inefficient for large \\( n \\).\n- **Recursion**: Elegant and easy to understand, but inefficient and prone to stack overflow.\n- **Memoization**: Efficient and avoids redundant calculations, but requires additional memory.\n- **Binet's Formula**: Fast but limited by floating-point precision, making it less accurate for large \\( n \\).\n- **Matrix Exponentiation**: Highly efficient with \\( O(\\log n) \\) time complexity but requires understanding of matrix operations.\n\n### Implementation Challenges\n\n**Edge Cases**:\n- **Negative Input**: All methods except the iterative yield version raise a `ValueError` for negative inputs.\n- **Large Input**: Binet's formula and matrix exponentiation have limitations for very large inputs due to floating-point precision and time complexity, respectively.\n\n**Performance Bottlenecks**:\n- **Recursion**: High stack usage and inefficiency, leading to stack overflow for large \\( n \\).\n- **Memoization**: Requires additional memory to",
  "solution_code": "def fibonacci_iterative(n):\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    elif n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\ndef fibonacci_recursive(n, memo={}):\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_recursive(n - 1, memo) + fibonacci_recursive(n - 2, memo)\n    return memo[n]\n\ndef fibonacci_memoization(n):\n    return fibonacci_recursive(n)\n\ndef fibonacci_binet(n):\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    sqrt_5 = 5 ** 0.5\n    phi = (1 + sqrt_5) / 2\n    return int(phi ** n / sqrt_5 + 0.5)\n\ndef fibonacci_matrix_exponentiation(n):\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    F = [[1, 1], [1, 0]]\n    result = [[1, 0], [0, 1]]\n    base = 2\n\n    while n > 0:\n        if n % 2 == 1:\n            result = [[a * b + c * d for a, b in zip(row, col)] for row, col in zip(result, matrix_multiply(result, F))]\n        n = n // 2\n        F = matrix_multiply(F, F)\n    return result[0][0]\n\ndef matrix_multiply(A, B):\n    return [[sum(a * b for a, b in zip(row, col)) for col in zip(*B)] for row in A]",
  "test_code": "import pytest\n\ndef test_fibonacci_iterative():\n    assert fibonacci_iterative(0) == 0\n    assert fibonacci_iterative(1) == 1\n    assert fibonacci_iterative(10) == 55\n    with pytest.raises(ValueError):\n        fibonacci_iterative(-1)\n\ndef test_fibonacci_recursive():\n    assert fibonacci_recursive(0) == 0\n    assert fibonacci_recursive(1) == 1\n    assert fibonacci_recursive(10) == 55\n    with pytest.raises(ValueError):\n        fibonacci_recursive(-1)\n\ndef test_fibonacci_memoization():\n    assert fibonacci_memoization(0) == 0\n    assert fibonacci_memoization(1) == 1\n    assert fibonacci_memoization(10) == 55\n    with pytest.raises(ValueError):\n        fibonacci_memoization(-1)\n\ndef test_fibonacci_binet():\n    assert fibonacci_binet(0) == 0\n    assert fibonacci_binet(1) == 1\n    assert fibonacci_binet(10) == 55\n    with pytest.raises(ValueError):\n        fibonacci_binet(-1)\n\ndef test_fibonacci_matrix_exponentiation():\n    assert fibonacci_matrix_exponentiation(0) == 0\n    assert fibonacci_matrix_exponentiation(1) == 1\n    assert fibonacci_matrix_exponentiation(10) == 55\n    with pytest.raises(ValueError):\n        fibonacci_matrix_exponentiation(-1)\n\ndef test_fibonacci_precision():\n    assert fibonacci_binet(100) == 354224848179261915075\n    assert fibonacci_matrix_exponentiation(100) == 354224848179261915075\n\ndef test_matrix_multiply():\n    A = [[1, 2], [3, 4]]\n    B = [[2, 0], [1, 2]]\n    expected = [[4, 4], [10, 8]]\n    assert matrix_multiply(A, B) == expected",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}