{
  "metadata": {
    "prompt_id": "00000025",
    "row_id": 25,
    "seed_ids": [
      699
    ],
    "mode": "algorithm"
  },
  "instruction": "<|Analysis Begin|>\n\n### Algorithm/Data Structure\n\n**Name and Type**: The provided code snippets demonstrate the calculation of Fibonacci numbers using several methods: iteration, recursion, memoization, and a simplified form of Binet's formula. Additionally, a matrix exponentiation method is used, which is a more advanced technique.\n\n**Core Operational Steps**:\n- **Iteration**: Uses a loop to iterate and calculate the Fibonacci sequence.\n- **Recursion**: Recursively calculates the Fibonacci sequence by dividing the problem into smaller subproblems.\n- **Memoization**: Stores the results of expensive function calls and reuses them when the same inputs occur again.\n- **Binet's Formula**: Uses mathematical formulas to calculate Fibonacci numbers, which is efficient but limited by floating-point precision.\n- **Matrix Exponentiation**: Utilizes matrix multiplication to compute the Fibonacci sequence, which is highly efficient for larger values of \\( n \\).\n\n**Time Complexity**:\n- **Iteration**: \\( O(n) \\)\n- **Recursion**: \\( O(2^n) \\) (without memoization), \\( O(n) \\) (with memoization)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(\\log n) \\)\n\n**Space Complexity**:\n- **Iteration**: \\( O(1) \\) (excluding the output list)\n- **Recursion**: \\( O(n) \\) (due to the call stack)\n- **Memoization**: \\( O(n) \\) (for storing intermediate results)\n- **Binet's Formula**: \\( O(1) \\)\n- **Matrix Exponentiation**: \\( O(1) \\) (excluding the output)\n\n### Characteristics & Applications\n\n**Properties**:\n- **Iteration**: Simple and easy to understand, but not efficient for large \\( n \\) due to its linear time complexity.\n- **Recursion**: Can lead to stack overflow for large \\( n \\) and is inefficient, but useful for teaching recursion.\n- **Memoization**: Efficient for large \\( n \\) and avoids redundant calculations, making it a good balance between speed and memory usage.\n- **Binet's Formula**: Efficient but limited by floating-point precision, making it less accurate for large values.\n- **Matrix Exponentiation**: Extremely efficient for very large \\( n \\) but requires understanding of matrix operations and logarithmic time complexity.\n\n**Common Use Cases**:\n- **Iteration**: Useful for small values of \\( n \\) where simplicity is preferred.\n- **Recursion**: Often used in teaching recursion, but not suitable for large \\( n \\).\n- **Memoization**: Good for practical applications where performance is critical and \\( n \\) is large.\n- **Binet's Formula**: Used in contexts where a quick, approximate solution is sufficient.\n- **Matrix Exponentiation**: Ideal for large \\( n \\) in performance-critical applications.\n\n**Strengths/Limitations**:\n- **Iteration**: Simple to implement, but inefficient for large \\( n \\).\n- **Recursion**: Elegant and easy to understand, but inefficient and prone to stack overflow.\n- **Memoization**: Efficient and avoids redundant calculations, but requires additional memory.\n- **Binet's Formula**: Fast but limited by floating-point precision, making it less accurate for large \\( n \\).\n- **Matrix Exponentiation**: Highly efficient with \\( O(\\log n) \\) time complexity but requires understanding of matrix operations.\n\n### Implementation Challenges\n\n**Edge Cases**:\n- **Negative Input**: All methods except the iterative yield version raise a `ValueError` for negative inputs.\n- **Large Input**: Binet's formula and matrix exponentiation have limitations for very large inputs due to floating-point precision and time complexity, respectively.\n\n**Performance Bottlenecks**:\n- **Recursion**: High stack usage and inefficiency, leading to stack overflow for large \\( n \\).\n- **Memoization**: Requires additional memory to",
  "solution_code": "def fibonacci_iterative(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using iteration.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\ndef fibonacci_recursive(n, memo={}):\n    \"\"\"\n    Returns the n-th Fibonacci number using recursion with memoization.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_recursive(n - 1, memo) + fibonacci_recursive(n - 2, memo)\n    return memo[n]\n\ndef fibonacci_binets(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using Binet's formula.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    phi = (1 + 5**0.5) / 2\n    return int((phi**n - (-phi)**(-n)) / 5**0.5)\n\ndef fibonacci_matrix(n):\n    \"\"\"\n    Returns the n-th Fibonacci number using matrix exponentiation.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    if n == 0:\n        return 0\n    fib_matrix = [[1, 1], [1, 0]]\n    result = matrix_pow(fib_matrix, n - 1)\n    return result[0][0]\n\ndef matrix_pow(matrix, n):\n    \"\"\"\n    Raises a 2x2 matrix to the power of n using exponentiation by squaring.\n    \"\"\"\n    result = [[1, 0], [0, 1]]  # Identity matrix\n    base = matrix\n    while n:\n        if n % 2:\n            result = matrix_multiply(result, base)\n        base = matrix_multiply(base, base)\n        n //= 2\n    return result\ndef matrix_multiply(a, b):\n    \"\"\"\n    Multiplies two 2x2 matrices.\n    \"\"\"\n    return [[a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n            [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]]]",
  "test_code": "import pytest\nfrom solution import (\n    fibonacci_iterative, \n    fibonacci_recursive, \n    fibonacci_binets, \n    fibonacci_matrix\n)\n\ndef test_fibonacci_iterative():\n    assert fibonacci_iterative(0) == 0\n    assert fibonacci_iterative(1) == 1\n    assert fibonacci_iterative(2) == 1\n    assert fibonacci_iterative(10) == 55\n    assert fibonacci_iterative(20) == 6765\n\ndef test_fibonacci_recursive():\n    assert fibonacci_recursive(0) == 0\n    assert fibonacci_recursive(1) == 1\n    assert fibonacci_recursive(2) == 1\n    assert fibonacci_recursive(10) == 55\n    assert fibonacci_recursive(20) == 6765\n\ndef test_fibonacci_binets():\n    assert fibonacci_binets(0) == 0\n    assert fibonacci_binets(1) == 1\n    assert fibonacci_binets(2) == 1\n    assert fibonacci_binets(10) == 55\n    assert fibonacci_binets(20) == 6765\n\ndef test_fibonacci_matrix():\n    assert fibonacci_matrix(0) == 0\n    assert fibonacci_matrix(1) == 1\n    assert fibonacci_matrix(2) == 1\n    assert fibonacci_matrix(10) == 55\n    assert fibonacci_matrix(20) == 6765\n\ndef test_large_input_fibonacci_matrix():\n    assert fibonacci_matrix(50) == 12586269025\n\ndef test_negative_input():\n    with pytest.raises(ValueError):\n        fibonacci_iterative(-1)\n    with pytest.raises(ValueError):\n        fibonacci_recursive(-1)\n    with pytest.raises(ValueError):\n        fibonacci_binets(-1)\n    with pytest.raises(ValueError):\n        fibonacci_matrix(-1)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}