{
  "metadata": {
    "prompt_id": "00000057",
    "row_id": 57,
    "seed_ids": [
      844
    ],
    "mode": "algorithm"
  },
  "instruction": "You are tasked with optimizing an existing Gaussian filter implementation to handle large images and large kernel sizes more efficiently. The provided code uses a straightforward approach to apply the Gaussian filter, which can be slow for large images. Your goal is to refactor the code to improve its performance without changing its functionality.\n\n**Requirements**:\n1. Modify the `gaussian_filter` function to handle images and kernels of arbitrary size.\n2. Ensure that the function correctly handles the edges of the image, producing valid results even when the kernel extends beyond the image boundaries.\n3. Optimize the code to reduce the number of operations and improve performance.\n4. Write a function `test_gaussian_filter` that reads an image, applies the Gaussian filter, and displays the original and filtered images side by side for verification.\n\n**Constraints**:\n* The input image is a grayscale image represented as a 2D NumPy array.\n* The kernel size is an odd integer, and the standard deviation is a positive float.\n* The function should handle images of any size and kernel sizes up to 21x21.\n\n**Performance**:\n* Aim to achieve a significant performance improvement over the provided code, especially for large images and larger kernel sizes.\n\n**Example**:\nGiven an input image and a kernel size of 5x5, the function should return a filtered image.\n\n```python\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n\ndef test_gaussian_filter(image_path, k_size, sigma):\n    # Read the image as grayscale\n    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n    \n    # Apply the Gaussian filter\n    filtered_image = gaussian_filter(img, k_size, sigma)\n    \n    # Display the original and filtered images\n    plt.subplot(1, 2, 1)\n    plt.imshow(img, cmap='gray')\n    plt.title('Original Image')\n    plt.axis('off')\n    \n    plt.subplot(1, 2, 2)\n    plt.imshow(filtered_image, cmap='gray')\n    plt.title('Filtered Image')\n    plt.axis('off')\n    \n    plt.show()\n\n# Example usage\ntest_gaussian_filter('path_to_image.jpg', 5, 1.0)\n```\n\n**Note**: The `gaussian_filter` function should be refactored to meet the above requirements and should not rely on the provided code snippet.",
  "solution_code": "import numpy as np\n\ndef gaussian_filter(image, k_size, sigma):\n    \"\"\"\n    Applies a Gaussian filter to the input grayscale image.\n\n    Parameters:\n    image (np.ndarray): Input grayscale image as a 2D NumPy array.\n    k_size (int): Size of the kernel. Must be an odd integer.\n    sigma (float): Standard deviation for Gaussian kernel.\n\n    Returns:\n    np.ndarray: Filtered image as a 2D NumPy array.\n    \"\"\"\n    if k_size % 2 == 0:\n        raise ValueError(\"Kernel size must be an odd integer\")\n\n    half_size = k_size // 2\n    k = np.fromfunction(lambda x, y: 1 / (2 * np.pi * sigma**2) * np.exp(-((x - half_size)**2 + (y - half_size)**2) / (2 * sigma**2)), (k_size, k_size))\n    k /= k.sum()\n\n    filtered_image = np.zeros_like(image, dtype=float)\n\n    for x in range(image.shape[0]):\n        for y in range(image.shape[1]):\n            # Determine the kernel boundaries within the image\n            start_x = max(0, x - half_size)\n            end_x = min(image.shape[0], x + half_size + 1)\n            start_y = max(0, y - half_size)\n            end_y = min(image.shape[1], y + half_size + 1)\n\n            # Extract the effective kernel and the corresponding image region\n            kernel_region = k[(start_x - x + half_size):(end_x - x + half_size), (start_y - y + half_size):(end_y - y + half_size)]\n            image_region = image[start_x:end_x, start_y:end_y]\n\n            # Compute the filtered value\n            filtered_image[x, y] = np.sum(image_region * kernel_region)\n\n    return filtered_image",
  "test_code": "import numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n\ndef test_gaussian_filter(image_path, k_size, sigma):\n    # Read the image as grayscale\n    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n    \n    # Apply the Gaussian filter\n    filtered_image = gaussian_filter(img, k_size, sigma)\n    \n    # Display the original and filtered images\n    plt.subplot(1, 2, 1)\n    plt.imshow(img, cmap='gray')\n    plt.title('Original Image')\n    plt.axis('off')\n    \n    plt.subplot(1, 2, 2)\n    plt.imshow(filtered_image, cmap='gray')\n    plt.title('Filtered Image')\n    plt.axis('off')\n    \n    plt.show()\n\n# Example test cases\ntest_gaussian_filter('test_images/sunflower.jpg', 5, 1.0)\ntest_gaussian_filter('test_images/camera.png', 3, 0.5)\ntest_gaussian_filter('test_images/peppers.png', 7, 2.0)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}