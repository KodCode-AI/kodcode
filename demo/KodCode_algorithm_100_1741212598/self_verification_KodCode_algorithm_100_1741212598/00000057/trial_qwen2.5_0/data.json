{
  "metadata": {
    "prompt_id": "00000057",
    "row_id": 57,
    "seed_ids": [
      844
    ],
    "mode": "algorithm"
  },
  "instruction": "You are tasked with optimizing an existing Gaussian filter implementation to handle large images and large kernel sizes more efficiently. The provided code uses a straightforward approach to apply the Gaussian filter, which can be slow for large images. Your goal is to refactor the code to improve its performance without changing its functionality.\n\n**Requirements**:\n1. Modify the `gaussian_filter` function to handle images and kernels of arbitrary size.\n2. Ensure that the function correctly handles the edges of the image, producing valid results even when the kernel extends beyond the image boundaries.\n3. Optimize the code to reduce the number of operations and improve performance.\n4. Write a function `test_gaussian_filter` that reads an image, applies the Gaussian filter, and displays the original and filtered images side by side for verification.\n\n**Constraints**:\n* The input image is a grayscale image represented as a 2D NumPy array.\n* The kernel size is an odd integer, and the standard deviation is a positive float.\n* The function should handle images of any size and kernel sizes up to 21x21.\n\n**Performance**:\n* Aim to achieve a significant performance improvement over the provided code, especially for large images and larger kernel sizes.\n\n**Example**:\nGiven an input image and a kernel size of 5x5, the function should return a filtered image.\n\n```python\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n\ndef test_gaussian_filter(image_path, k_size, sigma):\n    # Read the image as grayscale\n    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n    \n    # Apply the Gaussian filter\n    filtered_image = gaussian_filter(img, k_size, sigma)\n    \n    # Display the original and filtered images\n    plt.subplot(1, 2, 1)\n    plt.imshow(img, cmap='gray')\n    plt.title('Original Image')\n    plt.axis('off')\n    \n    plt.subplot(1, 2, 2)\n    plt.imshow(filtered_image, cmap='gray')\n    plt.title('Filtered Image')\n    plt.axis('off')\n    \n    plt.show()\n\n# Example usage\ntest_gaussian_filter('path_to_image.jpg', 5, 1.0)\n```\n\n**Note**: The `gaussian_filter` function should be refactored to meet the above requirements and should not rely on the provided code snippet.",
  "solution_code": "import numpy as np\nimport cv2\n\ndef create_gaussian_kernel(size, sigma):\n    \"\"\"\n    Creates a normalized Gaussian kernel of the given size and standard deviation.\n    \"\"\"\n    half_size = (size - 1) // 2\n    kernel = np.fromfunction(\n        lambda x, y: (1 / (2 * np.pi * sigma**2)) * np.exp(\n            -((x - half_size)**2 + (y - half_size)**2) / (2 * sigma**2)\n        ),\n        (size, size),\n        dtype=float\n    )\n    kernel /= np.sum(kernel)  # Normalize the kernel\n    return kernel\n\ndef apply_kernel(image, kernel):\n    \"\"\"\n    Applies a normalized kernel to the image using cross-correlation.\n    \"\"\"\n    kernel_size = kernel.shape[0]\n    half_kernel_size = kernel_size // 2\n    padded_image = np.pad(image, half_kernel_size, mode='constant')\n    filtered_image = np.zeros_like(image, dtype=float)\n\n    for i in range(image.shape[0]):\n        for j in range(image.shape[1]):\n            filtered_image[i, j] = np.sum(padded_image[i:i+kernel_size, j:j+kernel_size] * kernel)\n    return filtered_image\n\ndef gaussian_filter(image, k_size, sigma):\n    \"\"\"\n    Applies a Gaussian filter to the image using the given kernel size and standard deviation.\n    \"\"\"\n    kernel = create_gaussian_kernel(k_size, sigma)\n    return apply_kernel(image, kernel)",
  "test_code": "import numpy as np\nimport cv2\nimport pytest\nimport matplotlib.pyplot as plt\n\ndef create_gaussian_kernel_test():\n    kernel = create_gaussian_kernel(3, 1.0)\n    expected_kernel = np.array([[0.09473428, 0.12364155, 0.09473428],\n                                [0.12364155, 0.16266196, 0.12364155],\n                                [0.09473428, 0.12364155, 0.09473428]])\n    np.testing.assert_almost_equal(kernel, expected_kernel, decimal=6)\n\ndef apply_kernel_test():\n    image = np.array([[1, 2, 3],\n                      [4, 5, 6],\n                      [7, 8, 9]], dtype=float)\n    kernel = np.array([[0.09, 0.11, 0.09],\n                       [0.11, 0.12, 0.11],\n                       [0.09, 0.11, 0.09]])\n    filtered_image = apply_kernel(image, kernel)\n    expected_filtered_image = np.array([\n        [3.1400000000000007, 4.220000000000001, 4.4400000000000014],\n        [6.819999999999999, 7.629999999999999, 8.839999999999998],\n        [7.520000000000001, 8.600000000000002, 9.440000000000002]\n    ])\n    np.testing.assert_almost_equal(filtered_image, expected_filtered_image, decimal=6)\n\ndef test_gaussian_filter(image_path, k_size, sigma):\n    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n    filtered_img = gaussian_filter(img, k_size, sigma)\n    plt.subplot(1, 2, 1)\n    plt.imshow(img, cmap='gray')\n    plt.title('Original Image')\n    plt.axis('off')\n    \n    plt.subplot(1, 2, 2)\n    plt.imshow(filtered_img, cmap='gray')\n    plt.title('Filtered Image')\n    plt.axis('off')\n    \n    plt.show()\n\n# Test the Gaussian filter on an example image\ntest_gaussian_filter('path_to_image.jpg', 5, 1.0)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}