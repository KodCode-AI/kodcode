{
  "metadata": {
    "prompt_id": "00000001",
    "row_id": 1,
    "seed_ids": [
      206
    ],
    "mode": "algorithm"
  },
  "instruction": "<|Analysis Begin|>\n\n### Core Identification\n- **Algorithm/Data Structure**: Introspective Sort\n- **Complexity**: The complexity is a hybrid of Quicksort, Heapsort, and Insertion Sort. The average and best-case time complexity is \\(O(n \\log n)\\). The worst-case time complexity is \\(O(n^2)\\) if the partition function is poorly chosen.\n- **Principles**: Introspective Sort uses Quicksort, but switches to Heapsort if the depth of the recursion exceeds a certain threshold to avoid the worst-case scenario of Quicksort. Insertion Sort is used for small subarrays to optimize performance.\n\n### Characteristics & Applications\n- **Properties**: It is in-place and does not require additional space, except for the recursion stack.\n- **Common Use Cases**: Ideal for sorting large datasets that do not fit into memory or where randomness is important to avoid worst-case performance.\n- **Strengths/Limitations**: It provides good average-case performance and is stable for both large and small datasets. However, it can be less efficient for very small arrays due to the overhead of recursive calls.\n\n### Implementation Challenges\n- **Edge Cases**: Empty arrays, arrays with one element, and arrays with repeated elements.\n- **Performance Bottlenecks**: The partitioning phase can be slow if the pivot is not chosen well.\n- **Error Scenarios**: Incorrect sorting order due to poor pivot selection or incorrect recursive depth handling.\n- **Optimization Points**: Use of insertion sort for small subarrays, efficient pivot selection, and handling edge cases properly.\n\n<|Analysis End|>\n\n<|Question Begin|>\n\n**Problem Statement**:\nYou are tasked with implementing a sorting algorithm that uses Introspective Sort. Introspective Sort is a hybrid sorting algorithm that provides good average-case performance and is particularly useful for sorting large arrays. Your task is to complete the `intro_sort` function to ensure the algorithm works correctly and efficiently.\n\n**Function Signature**:\n```python\ndef intro_sort(array: list, start: int, end: int, size_threshold: int, max_depth: int) -> list:\n    \"\"\"\n    Sorts the array between indices `start` and `end` (inclusive) using Introspective Sort.\n    \n    :param array: The array to be sorted\n    :param start: The starting index of the subarray to sort\n    :param end: The ending index of the subarray to sort\n    :param size_threshold: The threshold size at which insertion sort is used\n    :param max_depth: The maximum depth of recursion before switching to Heap Sort\n    :return: The sorted subarray\n    \"\"\"\n```\n\n**Input**:\n- `array`: A list of integers to be sorted.\n- `start`: The starting index of the subarray to sort.\n- `end`: The ending index of the subarray to sort.\n- `size_threshold`: The threshold size at which insertion sort is used.\n- `max_depth`: The maximum depth of recursion before switching to Heap Sort.\n\n**Output**:\n- A sorted subarray.\n\n**Constraints**:\n- The length of `array` is between 1 and 10,000.\n- The indices `start` and `end` are valid and `start <= end`.\n\n**Examples**:\n```python\n# Example 1\narray = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79",
  "solution_code": "def intro_sort(array: list, start: int, end: int, size_threshold: int, max_depth: int) -> list:\n    \"\"\"\n    Sorts the array between indices `start` and `end` (inclusive) using Introspective Sort.\n    \n    :param array: The array to be sorted\n    :param start: The starting index of the subarray to sort\n    :param end: The ending index of the subarray to sort\n    :param size_threshold: The threshold size at which insertion sort is used\n    :param max_depth: The maximum depth of recursion before switching to Heap Sort\n    :return: The sorted subarray\n    \"\"\"\n    depth = 0\n\n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def insertion_sort(arr, low, high):\n        for i in range(low + 1, high + 1):\n            key = arr[i]\n            j = i - 1\n            while j >= low and arr[j] > key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n\n    def introsort(arr, low, high, max_depth):\n        nonlocal depth\n        if high - low < 1:\n            return\n        if depth >= max_depth:\n            heap_sort(arr, low, high)\n            return\n        depth += 1\n        size = high - low\n        if size < size_threshold:\n            insertion_sort(arr, low, high)\n        else:\n            pivot_index = partition(arr, low, high)\n            introsort(arr, low, pivot_index - 1, max_depth)\n            introsort(arr, pivot_index + 1, high, max_depth)\n        depth -= 1\n\n    def heap_sort(arr, low, high):\n        def heapify(arr, n, i):\n            largest = i\n            left = 2 * i + 1\n            right = 2 * i + 2\n            if left < n and arr[i] < arr[left]:\n                largest = left\n            if right < n and arr[largest] < arr[right]:\n                largest = right\n            if largest != i:\n                arr[i], arr[largest] = arr[largest], arr[i]\n                heapify(arr, n, largest)\n\n        n = high - low + 1\n        for i in range(n // 2 - 1, -1, -1):\n            heapify(arr, n, i)\n        for i in range(high - 1, low - 1, -1):\n            arr[i], arr[low] = arr[low], arr[i]\n            heapify(arr, i, low)\n\n    introsort(array, start, end, max_depth)\n    return array",
  "test_code": "import random\n\ndef test_intro_sort():\n    array = [random.randint(1, 100) for _ in range(100)]\n    start = random.randint(0, len(array) // 2)\n    end = random.randint(start + 1, len(array) - 1)\n    size_threshold = 16\n    max_depth = 50\n    sorted_array = sorted(array[start:end + 1])\n    assert intro_sort(array, start, end, size_threshold, max_depth) == sorted_array\n\ndef test_single_element():\n    array = [42]\n    start = 0\n    end = 0\n    size_threshold = 16\n    max_depth = 50\n    assert intro_sort(array, start, end, size_threshold, max_depth) == [42]\n\ndef test_empty_subarray():\n    array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79]\n    start = 3\n    end = 2\n    size_threshold = 16\n    max_depth = 50\n    assert intro_sort(array, start, end, size_threshold, max_depth) == []\n\ndef test_larger_arrays():\n    array = [random.randint(1, 100) for _ in range(1000)]\n    start = len(array) // 2\n    end = len(array) - 1\n    size_threshold = 16\n    max_depth = 50\n    sorted_array = sorted(array[start:end + 1])\n    assert intro_sort(array, start, end, size_threshold, max_depth) == sorted_array\n\ndef test_repeated_elements():\n    array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 79]\n    start = 0\n    end = len(array) - 1\n    size_threshold = 16\n    max_depth = 50\n    sorted_array = sorted(array[start:end + 1])\n    assert intro_sort(array, start, end, size_threshold, max_depth) == sorted_array",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}