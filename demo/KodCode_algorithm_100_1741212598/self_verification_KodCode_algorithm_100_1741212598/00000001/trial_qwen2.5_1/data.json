{
  "metadata": {
    "prompt_id": "00000001",
    "row_id": 1,
    "seed_ids": [
      206
    ],
    "mode": "algorithm"
  },
  "instruction": "<|Analysis Begin|>\n\n### Core Identification\n- **Algorithm/Data Structure**: Introspective Sort\n- **Complexity**: The complexity is a hybrid of Quicksort, Heapsort, and Insertion Sort. The average and best-case time complexity is \\(O(n \\log n)\\). The worst-case time complexity is \\(O(n^2)\\) if the partition function is poorly chosen.\n- **Principles**: Introspective Sort uses Quicksort, but switches to Heapsort if the depth of the recursion exceeds a certain threshold to avoid the worst-case scenario of Quicksort. Insertion Sort is used for small subarrays to optimize performance.\n\n### Characteristics & Applications\n- **Properties**: It is in-place and does not require additional space, except for the recursion stack.\n- **Common Use Cases**: Ideal for sorting large datasets that do not fit into memory or where randomness is important to avoid worst-case performance.\n- **Strengths/Limitations**: It provides good average-case performance and is stable for both large and small datasets. However, it can be less efficient for very small arrays due to the overhead of recursive calls.\n\n### Implementation Challenges\n- **Edge Cases**: Empty arrays, arrays with one element, and arrays with repeated elements.\n- **Performance Bottlenecks**: The partitioning phase can be slow if the pivot is not chosen well.\n- **Error Scenarios**: Incorrect sorting order due to poor pivot selection or incorrect recursive depth handling.\n- **Optimization Points**: Use of insertion sort for small subarrays, efficient pivot selection, and handling edge cases properly.\n\n<|Analysis End|>\n\n<|Question Begin|>\n\n**Problem Statement**:\nYou are tasked with implementing a sorting algorithm that uses Introspective Sort. Introspective Sort is a hybrid sorting algorithm that provides good average-case performance and is particularly useful for sorting large arrays. Your task is to complete the `intro_sort` function to ensure the algorithm works correctly and efficiently.\n\n**Function Signature**:\n```python\ndef intro_sort(array: list, start: int, end: int, size_threshold: int, max_depth: int) -> list:\n    \"\"\"\n    Sorts the array between indices `start` and `end` (inclusive) using Introspective Sort.\n    \n    :param array: The array to be sorted\n    :param start: The starting index of the subarray to sort\n    :param end: The ending index of the subarray to sort\n    :param size_threshold: The threshold size at which insertion sort is used\n    :param max_depth: The maximum depth of recursion before switching to Heap Sort\n    :return: The sorted subarray\n    \"\"\"\n```\n\n**Input**:\n- `array`: A list of integers to be sorted.\n- `start`: The starting index of the subarray to sort.\n- `end`: The ending index of the subarray to sort.\n- `size_threshold`: The threshold size at which insertion sort is used.\n- `max_depth`: The maximum depth of recursion before switching to Heap Sort.\n\n**Output**:\n- A sorted subarray.\n\n**Constraints**:\n- The length of `array` is between 1 and 10,000.\n- The indices `start` and `end` are valid and `start <= end`.\n\n**Examples**:\n```python\n# Example 1\narray = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79",
  "solution_code": "from typing import List\n\ndef insertion_sort(array: List[int], start: int, end: int):\n    \"\"\"Perform insertion sort on the array between start and end.\"\"\"\n    for i in range(start + 1, end + 1):\n        key = array[i]\n        j = i - 1\n        while j >= start and array[j] > key:\n            array[j + 1] = array[j]\n            j -= 1\n        array[j + 1] = key\n\ndef partition(array: List[int], start: int, end: int) -> int:\n    \"\"\"Partition the array using the last element as the pivot.\"\"\"\n    pivot = array[end]\n    i = start - 1\n    for j in range(start, end):\n        if array[j] <= pivot:\n            i += 1\n            array[i], array[j] = array[j], array[i]\n    array[i + 1], array[end] = array[end], array[i + 1]\n    return i + 1\n\ndef intro_sort(array: List[int], start: int, end: int, size_threshold: int, max_depth: int) -> List[int]:\n    \"\"\"\n    Sorts the array between indices `start` and `end` (inclusive) using Introspective Sort.\n    \"\"\"\n    depth = 0\n    while end - start >= size_threshold and depth < max_depth:\n        depth += 1\n        pivot_index = end\n        if end - start + 1 < 16:\n            pivot_index = (start + end) // 2\n        pivot_index = partition(array, start, end)\n        if pivot_index - start < end - pivot_index:\n            intro_sort(array, start, pivot_index - 1, size_threshold, max_depth)\n            start = pivot_index + 1\n        else:\n            intro_sort(array, pivot_index + 1, end, size_threshold, max_depth)\n            end = pivot_index - 1\n    if start < end:\n        insertion_sort(array, start, end)\n    return array",
  "test_code": "from pytest import fixture, mark\nfrom random import shuffle\n\n@fixture\ndef shuffled_list():\n    return list(range(10000))\n    shuffle(shuffled_list)\n\ndef test_introsort(shuffled_list):\n    for size_threshold in [1, 10, 100]:\n        for max_depth in [1, 10, 100]:\n            sorted_list = shuffled_list.copy()\n            sorted_list.sort()\n            assert intro_sort(sorted_list, 0, len(sorted_list) - 1, size_threshold, max_depth) == sorted_list\n\ndef test_insertion_sort():\n    array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79]\n    start = 0\n    end = len(array) - 1\n    size_threshold = 16\n    assert intro_sort(array, start, end, size_threshold, 10) == sorted(array)\n\ndef test_partition():\n    array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79]\n    end = len(array) - 1\n    pivot_index = partition(array, 0, end)\n    assert pivot_index == 6 and array == [1, 2, 4, 6, 7, 8, 8, 14, 22, 56, 27, 79]\n\ndef test_introsort_worst_case():\n    array = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    size_threshold = 1\n    max_depth = 10\n    assert intro_sort(array, 0, len(array) - 1, size_threshold, max_depth) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\ndef test_introsort_best_case():\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    size_threshold = 1\n    max_depth = 10\n    assert intro_sort(array, 0, len(array) - 1, size_threshold, max_depth) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}