{
  "metadata": {
    "prompt_id": "00000001",
    "row_id": 1,
    "seed_ids": [
      206
    ],
    "mode": "algorithm"
  },
  "instruction": "<|Analysis Begin|>\n\n### Core Identification\n- **Algorithm/Data Structure**: Introspective Sort\n- **Complexity**: The complexity is a hybrid of Quicksort, Heapsort, and Insertion Sort. The average and best-case time complexity is \\(O(n \\log n)\\). The worst-case time complexity is \\(O(n^2)\\) if the partition function is poorly chosen.\n- **Principles**: Introspective Sort uses Quicksort, but switches to Heapsort if the depth of the recursion exceeds a certain threshold to avoid the worst-case scenario of Quicksort. Insertion Sort is used for small subarrays to optimize performance.\n\n### Characteristics & Applications\n- **Properties**: It is in-place and does not require additional space, except for the recursion stack.\n- **Common Use Cases**: Ideal for sorting large datasets that do not fit into memory or where randomness is important to avoid worst-case performance.\n- **Strengths/Limitations**: It provides good average-case performance and is stable for both large and small datasets. However, it can be less efficient for very small arrays due to the overhead of recursive calls.\n\n### Implementation Challenges\n- **Edge Cases**: Empty arrays, arrays with one element, and arrays with repeated elements.\n- **Performance Bottlenecks**: The partitioning phase can be slow if the pivot is not chosen well.\n- **Error Scenarios**: Incorrect sorting order due to poor pivot selection or incorrect recursive depth handling.\n- **Optimization Points**: Use of insertion sort for small subarrays, efficient pivot selection, and handling edge cases properly.\n\n<|Analysis End|>\n\n<|Question Begin|>\n\n**Problem Statement**:\nYou are tasked with implementing a sorting algorithm that uses Introspective Sort. Introspective Sort is a hybrid sorting algorithm that provides good average-case performance and is particularly useful for sorting large arrays. Your task is to complete the `intro_sort` function to ensure the algorithm works correctly and efficiently.\n\n**Function Signature**:\n```python\ndef intro_sort(array: list, start: int, end: int, size_threshold: int, max_depth: int) -> list:\n    \"\"\"\n    Sorts the array between indices `start` and `end` (inclusive) using Introspective Sort.\n    \n    :param array: The array to be sorted\n    :param start: The starting index of the subarray to sort\n    :param end: The ending index of the subarray to sort\n    :param size_threshold: The threshold size at which insertion sort is used\n    :param max_depth: The maximum depth of recursion before switching to Heap Sort\n    :return: The sorted subarray\n    \"\"\"\n```\n\n**Input**:\n- `array`: A list of integers to be sorted.\n- `start`: The starting index of the subarray to sort.\n- `end`: The ending index of the subarray to sort.\n- `size_threshold`: The threshold size at which insertion sort is used.\n- `max_depth`: The maximum depth of recursion before switching to Heap Sort.\n\n**Output**:\n- A sorted subarray.\n\n**Constraints**:\n- The length of `array` is between 1 and 10,000.\n- The indices `start` and `end` are valid and `start <= end`.\n\n**Examples**:\n```python\n# Example 1\narray = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79",
  "solution_code": "def insertion_sort(arr, start, end):\n    for i in range(start + 1, end + 1):\n        key = arr[i]\n        j = i - 1\n        while j >= start and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\ndef intro_sort(array, start, end, size_threshold, max_depth):\n    max_depth -= 1\n    if (end - start) < 1:\n        return\n    elif (end - start) < size_threshold:\n        insertion_sort(array, start, end)\n    elif max_depth < 0:\n        from heapq import nlargest, nsmallest\n        # Convert to minheap by negating elements\n        neg_array = [-x for x in array[start:end+1]]\n        heapq.heapify(neg_array)\n        # Extract elements back to array\n        for i in range(start, end + 1):\n            array[i] = -heapq.heappop(neg_array)\n    else:\n        pivot = array[end]\n        i = start - 1\n        for j in range(start, end):\n            if array[j] < pivot:\n                i += 1\n                array[i], array[j] = array[j], array[i]\n        array[i + 1], array[end] = array[end], array[i + 1]\n        p = i + 1\n        intro_sort(array, start, p - 1, size_threshold, max_depth)\n        intro_sort(array, p + 1, end, size_threshold, max_depth)",
  "test_code": "import pytest\nfrom heapq import nlargest, nsmallest\n\ndef test_insertion_sort():\n    arr = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79]\n    insertion_sort(arr, 2, 5)\n    assert arr[2:6] == [6, 7, 8, 2, 8]  # Insertion sort from index 2 to 5\n\ndef test_intro_sort_small_size_threshold():\n    array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79]\n    intro_sort(array, 0, 5, 3, 2)\n    assert array[0:6] == [1, 2, 4, 6, 7, 8]  # Insertion sort used for small array\n\ndef test_intro_sort_switch_to_heap():\n    array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79]\n    intro_sort(array, 6, 11, 3, 1)\n    assert array[6:12] == [56, 79, 22, 14, 27, 8]  # Heapsort used due to max_depth\n\ndef test_intro_sort_comprehensive():\n    array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79]\n    intro_sort(array, 0, 11, 3, 3)\n    assert array == [1, 2, 4, 6, 7, 8, 8, 14, 22, 27, 56, 79]  # Full Introsort process\n\ndef test_empty_array():\n    array = []\n    intro_sort(array, 0, 0, 3, 3)\n    assert array == []  # Empty array check\n\ndef test_single_element_array():\n    array = [1]\n    intro_sort(array, 0, 0, 3, 3)\n    assert array == [1]  # Single element array check\n\ndef test_repeated_elements():\n    array = [2, 2, 2, 2, 2]\n    intro_sort(array, 0, 4, 3, 3)\n    assert array == [2, 2, 2, 2, 2]  # Repeated elements check",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}