{
  "metadata": {
    "prompt_id": "00000092",
    "row_id": 92,
    "seed_ids": [
      487
    ],
    "mode": "algorithm"
  },
  "instruction": "### Problem Description\nIn the context of number theory and decimal expansions, we are interested in finding the denominator \\( d \\) (where \\( d < 1000 \\)) that produces the longest recurring cycle in the decimal representation of \\( \\frac{1}{d} \\). \n\nGiven the brute-force approach implemented in the provided code, you are tasked with writing a function to find the value of \\( d \\) that yields the longest recurring cycle. \n\n### Function Signature\n```python\ndef find_longest_recurring_cycle(denominator_limit: int) -> int:\n    \"\"\"\n    Find the value of d < denominator_limit for which 1/d contains the longest recurring cycle in its decimal fraction part.\n\n    :param denominator_limit: The upper limit for the search (exclusive).\n    :return: The value of d that produces the longest recurring cycle.\n    \"\"\"\n```\n\n### Constraints\n- \\( 2 \\leq denominator_limit \\leq 1000 \\)\n\n### Examples\n```python\n# Example 1\nprint(find_longest_recurring_cycle(10))  # Output: 7\n\n# Example 2\nprint(find_longest_recurring_cycle(100))  # Output: 97\n\n# Example 3\nprint(find_longest_recurring_cycle(1000))  # Output: 983\n```\n\n### Performance Requirements\n- The function should be efficient and handle the given constraints within the required time and space limits.\n\n### Implementation\nImplement the function to find the value of \\( d \\) that produces the longest recurring cycle in the decimal representation of \\( \\frac{1}{d} \\).\n\n### Hints\n- Consider using a more efficient algorithm or number theory techniques to improve performance.\n- Ensure correct handling of remainders and edge cases.\n- Optimize the code to handle the given constraints efficiently.",
  "solution_code": "def find_longest_recurring_cycle(denominator_limit: int) -> int:\n    \"\"\"\n    Find the value of d < denominator_limit for which 1/d contains the longest recurring cycle in its decimal fraction part.\n\n    :param denominator_limit: The upper limit for the search (exclusive).\n    :return: The value of d that produces the longest recurring cycle.\n    \"\"\"\n    longest_cycle = 0\n    result_d = 0\n\n    for d in range(2, denominator_limit):\n        cycle_length = 0\n        remainder = 1\n        remainders_seen = {}\n\n        while remainder != 0:\n            if remainder in remainders_seen:\n                cycle_length = len(remainders_seen) - remainders_seen[remainder]\n                break\n            remainders_seen[remainder] = len(remainders_seen)\n            remainder = (remainder * 10) % d\n            cycle_length += 1\n\n        if cycle_length > longest_cycle:\n            longest_cycle = cycle_length\n            result_d = d\n\n    return result_d",
  "test_code": "import pytest\n\ndef test_find_longest_recurring_cycle():\n    assert find_longest_recurring_cycle(10) == 7\n    assert find_longest_recurring_cycle(100) == 97\n    assert find_longest_recurring_cycle(1000) == 983\n    assert find_longest_recurring_cycle(50) == 49\n    assert find_longest_recurring_cycle(20) == 19\n    assert find_longest_recurring_cycle(30) == 29\n    assert find_longest_recurring_cycle(70) == 67\n\npytest.main(['-v', '-s', 'test_find_longest_recurring_cycle.py'])",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}