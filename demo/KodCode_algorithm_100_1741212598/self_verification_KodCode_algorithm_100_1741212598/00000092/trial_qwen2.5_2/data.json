{
  "metadata": {
    "prompt_id": "00000092",
    "row_id": 92,
    "seed_ids": [
      487
    ],
    "mode": "algorithm"
  },
  "instruction": "### Problem Description\nIn the context of number theory and decimal expansions, we are interested in finding the denominator \\( d \\) (where \\( d < 1000 \\)) that produces the longest recurring cycle in the decimal representation of \\( \\frac{1}{d} \\). \n\nGiven the brute-force approach implemented in the provided code, you are tasked with writing a function to find the value of \\( d \\) that yields the longest recurring cycle. \n\n### Function Signature\n```python\ndef find_longest_recurring_cycle(denominator_limit: int) -> int:\n    \"\"\"\n    Find the value of d < denominator_limit for which 1/d contains the longest recurring cycle in its decimal fraction part.\n\n    :param denominator_limit: The upper limit for the search (exclusive).\n    :return: The value of d that produces the longest recurring cycle.\n    \"\"\"\n```\n\n### Constraints\n- \\( 2 \\leq denominator_limit \\leq 1000 \\)\n\n### Examples\n```python\n# Example 1\nprint(find_longest_recurring_cycle(10))  # Output: 7\n\n# Example 2\nprint(find_longest_recurring_cycle(100))  # Output: 97\n\n# Example 3\nprint(find_longest_recurring_cycle(1000))  # Output: 983\n```\n\n### Performance Requirements\n- The function should be efficient and handle the given constraints within the required time and space limits.\n\n### Implementation\nImplement the function to find the value of \\( d \\) that produces the longest recurring cycle in the decimal representation of \\( \\frac{1}{d} \\).\n\n### Hints\n- Consider using a more efficient algorithm or number theory techniques to improve performance.\n- Ensure correct handling of remainders and edge cases.\n- Optimize the code to handle the given constraints efficiently.",
  "solution_code": "def find_longest_recurring_cycle(denominator_limit: int) -> int:\n    \"\"\"\n    Find the value of d < denominator_limit for which 1/d contains the longest recurring cycle in its decimal fraction part.\n\n    :param denominator_limit: The upper limit for the search (exclusive).\n    :return: The value of d that produces the longest recurring cycle.\n    \"\"\"\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    max_cycle_length = 0\n    result_d = 0\n\n    for d in range(2, denominator_limit):\n        if d % 2 == 0 or d % 5 == 0:\n            continue  # Skip even numbers and multiples of 5\n\n        remainder_set = set()\n        remainder = 1\n        while remainder != 0:\n            if remainder in remainder_set:\n                cycle_length = len(remainder_set)\n                if cycle_length > max_cycle_length:\n                    max_cycle_length = cycle_length\n                    result_d = d\n                break\n\n            remainder_set.add(remainder)\n            remainder = (remainder * 10) % d\n\n    return result_d",
  "test_code": "import pytest\n\ndef test_find_longest_recurring_cycle():\n    assert find_longest_recurring_cycle(10) == 7\n    assert find_longest_recurring_cycle(100) == 97\n    assert find_longest_recurring_cycle(1000) == 983\n\ndef test_smaller_denominator_limit():\n    assert find_longest_recurring_cycle(1) == None  # No valid denominator in this range\n    assert find_longest_recurring_cycle(2) == 1  # Only 1 valid denominator, no recurring cycle\n\ndef test_edge_cases():\n    assert find_longest_recurring_cycle(3) == 2  # 1/2 and 1/3 are considered, 1/3 has a cycle but 2 is smaller\n\ndef test_large_denominator_limit():\n    assert find_longest_recurring_cycle(1001) == 983  # Test beyond the specified limit to ensure handling\n\ndef test_multiples_of_2_and_5():\n    assert find_longest_recurring_cycle(15) == 13  # Skip multiples of 2 and 5\n\ndef test_performance():\n    assert find_longest_recurring_cycle(1000) == 983  # Performance check, should be efficient",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}