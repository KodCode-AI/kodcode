{
  "metadata": {
    "prompt_id": "00000048",
    "row_id": 48,
    "seed_ids": [
      894
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a list of tasks, where each task is represented by a tuple `(deadline, reward)`. The goal is to select a subset of tasks that maximizes the total reward, given that the total time to complete any task is one unit and no task can be started after its deadline. Implement the function `max_tasks` to return the list of task indices that should be selected to achieve the maximum reward.\n\n### Constraints:\n- `1 <= len(tasks) <= 10^5`\n- `1 <= deadline, reward <= 10^9`\n- No task has a negative deadline or reward.\n\n### Example:\n```python\ntasks = [(4, 20), (1, 10), (1, 40), (1, 30)]\nmax_tasks(tasks)  # Returns [2, 0] because tasks 2 and 0 can be completed before their deadlines and yield a reward of 40 + 20 = 60\n```\n\n### Function Signature:\n```python\nfrom typing import List\n\ndef max_tasks(tasks: List[tuple[int, int]]) -> List[int]:\n    pass\n```\n\n### Additional Requirements:\n- The function should return a list of task indices (0-based) in the order they should be selected.\n- Ensure the solution handles edge cases where all tasks are invalid or all tasks have the same deadline.\n\n### Performance Requirements:\n- The solution should aim for a time complexity of \\(O(n \\log n)\\) or better.\n\n### Scenario:\nImagine you are a project manager tasked with selecting critical tasks from a list of tasks to complete in a time-efficient manner. Each task has a deadline by which it must be completed and a reward for completion. Your goal is to maximize the total reward while respecting the deadlines.",
  "solution_code": "from typing import List\n\ndef max_tasks(tasks: List[tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Returns a list of task indices that yield the maximum reward given the deadlines.\n    \"\"\"\n    tasks.sort(key=lambda x: x[0])  # Sort tasks by their deadline\n    max_heap = []\n    current_time = 0  # Represents the current time to schedule tasks\n    task_indices = []  # Stores the indices of selected tasks\n\n    for i, (deadline, reward) in enumerate(tasks):\n        while max_heap and current_time < deadline - 1:\n            _, task_index = heapq.heappop(max_heap)\n            task_indices.remove(task_index)  # Remove from the list if it's not used in current window\n            current_time += 1\n        if deadline > current_time:\n            heapq.heappush(max_heap, (-reward, i))  # Use negative value for max-heap behavior\n            task_indices.append(i)\n            current_time = deadline\n        else:\n            # If deadline is met, we use the most rewarding task available within the time\n            if -max_heap[0][0] > reward:\n                _, old_task_index = heapq.heappop(max_heap)\n                task_indices.remove(old_task_index)  # Remove old task from indices\n                task_indices.append(i)  # Add new task to indices\n                heapq.heappush(max_heap, (-reward, i))  # Push new task\n\n    return task_indices",
  "test_code": "import heapq\nfrom typing import List\n\ndef max_tasks(tasks: List[tuple[int, int]]) -> List[int]:\n    tasks.sort(key=lambda x: x[0])  # Sort tasks by their deadline\n    max_heap = []\n    current_time = 0  # Represents the current time to schedule tasks\n    task_indices = []  # Stores the indices of selected tasks\n\n    for i, (deadline, reward) in enumerate(tasks):\n        while max_heap and current_time < deadline - 1:\n            _, task_index = heapq.heappop(max_heap)\n            task_indices.remove(task_index)  # Remove from the list if it's not used in current window\n            current_time += 1\n        if deadline > current_time:\n            heapq.heappush(max_heap, (-reward, i))  # Use negative value for max-heap behavior\n            task_indices.append(i)\n            current_time = deadline\n        else:\n            # If deadline is met, we use the most rewarding task available within the time\n            if -max_heap[0][0] > reward:\n                _, old_task_index = heapq.heappop(max_heap)\n                task_indices.remove(old_task_index)  # Remove old task from indices\n                task_indices.append(i)  # Add new task to indices\n                heapq.heappush(max_heap, (-reward, i))  # Push new task\n\n    return task_indices\n\ndef test_max_tasks():\n    assert max_tasks([(2, 10), (1, 5), (1, 7), (1, 9)]) == [2, 0]\n    assert max_tasks([(1, 2), (2, 4), (3, 8), (1, 10)]) == [3, 2]\n    assert max_tasks([(2, 1)]) == [0]\n    assert max_tasks([(2, 2), (2, 1), (1, 1)]) == [0]\n    assert max_tasks([(1, 1), (1, 1), (1, 1)]) == [0, 1, 2]\n    assert max_tasks([]) == []\n    assert max_tasks([(1, 100), (1, 15)]) == [0]\n    print(\"All tests passed!\")\n\ntest_max_tasks()",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}