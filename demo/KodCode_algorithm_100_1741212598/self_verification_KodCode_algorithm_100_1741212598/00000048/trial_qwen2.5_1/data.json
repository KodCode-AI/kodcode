{
  "metadata": {
    "prompt_id": "00000048",
    "row_id": 48,
    "seed_ids": [
      894
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a list of tasks, where each task is represented by a tuple `(deadline, reward)`. The goal is to select a subset of tasks that maximizes the total reward, given that the total time to complete any task is one unit and no task can be started after its deadline. Implement the function `max_tasks` to return the list of task indices that should be selected to achieve the maximum reward.\n\n### Constraints:\n- `1 <= len(tasks) <= 10^5`\n- `1 <= deadline, reward <= 10^9`\n- No task has a negative deadline or reward.\n\n### Example:\n```python\ntasks = [(4, 20), (1, 10), (1, 40), (1, 30)]\nmax_tasks(tasks)  # Returns [2, 0] because tasks 2 and 0 can be completed before their deadlines and yield a reward of 40 + 20 = 60\n```\n\n### Function Signature:\n```python\nfrom typing import List\n\ndef max_tasks(tasks: List[tuple[int, int]]) -> List[int]:\n    pass\n```\n\n### Additional Requirements:\n- The function should return a list of task indices (0-based) in the order they should be selected.\n- Ensure the solution handles edge cases where all tasks are invalid or all tasks have the same deadline.\n\n### Performance Requirements:\n- The solution should aim for a time complexity of \\(O(n \\log n)\\) or better.\n\n### Scenario:\nImagine you are a project manager tasked with selecting critical tasks from a list of tasks to complete in a time-efficient manner. Each task has a deadline by which it must be completed and a reward for completion. Your goal is to maximize the total reward while respecting the deadlines.",
  "solution_code": "from typing import List\n\ndef max_tasks(tasks: List[tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Returns a list of task indices that yield the maximum reward based on their deadlines.\n    Assumes task indices are 0-based.\n    \"\"\"\n    # Sort tasks by their deadline in ascending order. If deadlines are the same, sort by reward in descending order.\n    tasks.sort(key=lambda x: (x[0], -x[1]))\n    \n    selected_tasks = []\n    for deadline, reward in tasks:\n        # Find the first position where a task with this deadline or later can be inserted.\n        pos = 0\n        while pos < len(selected_tasks) and selected_tasks[pos] < deadline:\n            pos += 1\n        \n        # If there's a valid position to insert the current task, do so.\n        if pos < len(selected_tasks):\n            selected_tasks[pos] = deadline\n        else:\n            # If no position is available, meaning we have the first deadline which can start immediately,\n            # then we add it to the beginning of the list.\n            if not selected_tasks or deadline >= selected_tasks[0]:\n                selected_tasks.insert(0, deadline)\n            else:\n                # The current task cannot be added without violating the deadline constraint, so we skip it.\n                continue\n    \n    # Extract the indices of the selected tasks.\n    return [i for i, task in enumerate(tasks) if task[0] in selected_tasks]",
  "test_code": "import pytest\n\ndef test_max_tasks():\n    # Test with tasks that have overlapping deadlines but different rewards\n    tasks = [(4, 20), (1, 10), (1, 40), (1, 30)]\n    assert max_tasks(tasks) == [2, 0]\n\n    # Test with tasks where all deadlines are the same\n    tasks = [(1, 100), (1, 100), (1, 200)]\n    assert max_tasks(tasks) == [2]\n\n    # Test with tasks where one task is invalid\n    tasks = [(1, 10), (2, 20), (1, 100)]\n    assert max_tasks(tasks) == [2]\n\n    # Test with a single task\n    tasks = [(1, 100)]\n    assert max_tasks(tasks) == [0]\n\n    # Test with an empty list\n    tasks = []\n    assert max_tasks(tasks) == []\n\n    # Test with tasks where one task deadline is in the middle of the others\n    tasks = [(2, 30), (1, 10), (3, 50)]\n    assert max_tasks(tasks) == [2, 0]\n\n    # Test with tasks where no task can be completed within its deadline\n    tasks = [(2, 10), (1, 20)]\n    assert max_tasks(tasks) == []\n\n    # Test with tasks where all deadlines are the same but there is a mix of high and low rewards\n    tasks = [(1, 50), (1, 30), (1, 100), (1, 20)]\n    assert max_tasks(tasks) == [2]\n\n# Run the tests\ntest_max_tasks()",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}