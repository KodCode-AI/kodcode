{
  "metadata": {
    "prompt_id": "00000048",
    "row_id": 48,
    "seed_ids": [
      894
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a list of tasks, where each task is represented by a tuple `(deadline, reward)`. The goal is to select a subset of tasks that maximizes the total reward, given that the total time to complete any task is one unit and no task can be started after its deadline. Implement the function `max_tasks` to return the list of task indices that should be selected to achieve the maximum reward.\n\n### Constraints:\n- `1 <= len(tasks) <= 10^5`\n- `1 <= deadline, reward <= 10^9`\n- No task has a negative deadline or reward.\n\n### Example:\n```python\ntasks = [(4, 20), (1, 10), (1, 40), (1, 30)]\nmax_tasks(tasks)  # Returns [2, 0] because tasks 2 and 0 can be completed before their deadlines and yield a reward of 40 + 20 = 60\n```\n\n### Function Signature:\n```python\nfrom typing import List\n\ndef max_tasks(tasks: List[tuple[int, int]]) -> List[int]:\n    pass\n```\n\n### Additional Requirements:\n- The function should return a list of task indices (0-based) in the order they should be selected.\n- Ensure the solution handles edge cases where all tasks are invalid or all tasks have the same deadline.\n\n### Performance Requirements:\n- The solution should aim for a time complexity of \\(O(n \\log n)\\) or better.\n\n### Scenario:\nImagine you are a project manager tasked with selecting critical tasks from a list of tasks to complete in a time-efficient manner. Each task has a deadline by which it must be completed and a reward for completion. Your goal is to maximize the total reward while respecting the deadlines.",
  "solution_code": "from typing import List\n\ndef max_tasks(tasks: List[tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Returns the list of task indices that should be selected to achieve the maximum reward.\n    \"\"\"\n    # Sort tasks based on their deadline in ascending order.\n    tasks.sort(key=lambda x: x[0])\n    \n    selected_tasks = []\n    tasks_to_select = []\n    max_time = 0\n    \n    for deadline, reward in tasks:\n        # If the current task can be completed within the max_time, add it to the selection.\n        while max_time < deadline and tasks_to_select:\n            selected_tasks.append(tasks_to_select.pop(-1)[1])\n            max_time += 1\n\n        # Add the current task to the selection if it and the next can be completed.\n        if len(tasks_to_select) == 0 or tasks_to_select[-1][1] > reward:\n            tasks_to_select.append((deadline, reward))\n            tasks_to_select = sorted(tasks_to_select, key=lambda x: x[1], reverse=True)\n            max_time = max(max_time, deadline)\n\n    # Add the last selected task if it has a valid deadline.\n    if tasks_to_select:\n        selected_tasks.append(tasks_to_select.pop(-1)[1])\n\n    # Sort the selected tasks to return them in the order of their original indices.\n    return sorted([tasks.index(task[1]) for task in [(0, idx) for idx in selected_tasks]])",
  "test_code": "def test_max_tasks():\n    assert max_tasks([(2, 10), (1, 5), (1, 7), (1, 3)]) == [0, 2, 1]\n    assert max_tasks([(1, 100), (2, 10)]) == [0]\n    assert max_tasks([(1, 1), (1, 1), (1, 1)]) == [0, 1, 2]\n    assert max_tasks([(4, 20), (1, 10), (1, 40), (1, 30)]) == [2, 0]\n    assert max_tasks([(1, 5), (2, 10), (2, 15), (1, 20)]) == [2, 1, 0]",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}