{
  "metadata": {
    "prompt_id": "00000083",
    "row_id": 83,
    "seed_ids": [
      599
    ],
    "mode": "algorithm"
  },
  "instruction": "<|Analysis Begin|>\n\n### Core Identification\n\n#### Algorithm/Data Structure\n- **Algorithm/Data Structure**: `PokerHand` Class\n- **Type**: This class implements various poker hand evaluation operations, such as checking for flushes, straights, pairs, and calculating the hand type.\n- **Main Purpose**: The class is designed to evaluate and compare poker hands based on standard poker rules.\n\n#### Characteristics & Applications\n\n##### Properties\n- The class uses the `PokerHand` constructor to parse the hand string and store the card values.\n- It includes methods for checking specific poker hand types like flush, straight, pairs, and calculating the hand type.\n- The `compare_with` method is used to compare two hands and determine the winner.\n\n##### Common Use Cases\n- The class is used in scenarios where poker hands need to be evaluated and sorted.\n- It is particularly useful in applications that involve poker games or simulations.\n\n##### Strengths/Limitations\n- **Strengths**: The class is thoroughly tested and covers a wide range of edge cases. It is flexible and can be extended to include more poker hand types.\n- **Limitations**: The implementation relies on string parsing, which can be error-prone. It does not handle invalid input robustly.\n\n#### Implementation Challenges\n\n##### Edge Cases\n- The class should handle invalid hand strings, such as those with invalid characters or incorrect card ranks.\n\n##### Performance Bottlenecks\n- The `compare_with` method may be slow if it involves multiple evaluations, especially when comparing hands with many cards.\n- The `_is_five_high_straight` method may be inefficient if it involves sorting or complex list operations",
  "solution_code": "class PokerHand:\n    def __init__(self, hand_str):\n        \"\"\"\n        Initializes the PokerHand with a string representation of the hand.\n        \"\"\"\n        self.hand_str = hand_str\n        self.hand = self.parse_hand(hand_str)\n\n    def parse_hand(self, hand_str):\n        \"\"\"\n        Parses the hand string and returns a list of the card values.\n        \"\"\"\n        return [card[:-1] for card in hand_str.split()]\n\n    def _is_flush(self):\n        \"\"\"\n        Checks if all cards in the hand are of the same suit.\n        \"\"\"\n        suits = [card[-1] for card in self.hand]\n        return len(set(suits)) == 1\n\n    def _is_straight(self):\n        \"\"\"\n        Checks if the hand is a straight.\n        \"\"\"\n        values = sorted([int(card[:-1]) for card in self.hand])\n        return len(set(values)) == 5 and max(values) - min(values) == 4\n\n    def _is_five_high_straight(self):\n        \"\"\"\n        Checks if the hand is a 5-high straight (Ace-high straight).\n        \"\"\"\n        values = sorted([int(card[:-1]) for card in self.hand])\n        return len(set(values)) == 5 and values == list(range(1, 6))\n\n    def _count_pairs(self):\n        \"\"\"\n        Counts the number of pairs in the hand.\n        \"\"\"\n        values = [int(card[:-1]) for card in self.hand]\n        value_counts = {value: values.count(value) for value in set(values)}\n        return list(value_counts.values()).count(2)\n\n    def _is_straight_flush(self):\n        \"\"\"\n        Checks if the hand is a straight flush.\n        \"\"\"\n        return self._is_five_high_straight() if max([int(card[:-1]) for card in self.hand]) == 5 else self._is_straight() and self._is_flush()\n\n    def get_hand_type(self):\n        \"\"\"\n        Determines the type of the poker hand.\n        \"\"\"\n        if self._is_straight_flush():\n            return 'straight_flush'\n        elif self._is_five_high_straight():\n            return 'five_high_straight'\n        elif self._is_flush():\n            return 'flush'\n        elif self._is_straight():\n            return 'straight'\n        elif self._count_pairs() == 4:\n            return 'four_of_a_kind'\n        elif self._count_pairs() == 2:\n            return 'full_house'\n        elif self._count_pairs() == 3:\n            return 'three_of_a_kind'\n        elif self._count_pairs() > 0:\n            return 'pair'\n        else:\n            return 'high_card'\n\n    def compare_with(self, other_hand):\n        \"\"\"\n        Compares this hand with another hand and returns the winner.\n        \"\"\"\n        hand_types = self.get_hand_type(), other_hand.get_hand_type()\n        for hand_type in ('straight_flush', 'five_high_straight', 'four_of_a_kind', 'full_house', 'flush', 'straight', 'three_of_a_kind', 'pair', 'high_card'):\n            if hand_types[0] != hand_types[1]:\n                return hand_types.index(hand_types[0]) < hand_types.index(hand_types[1])\n            elif self.get_hand_type() in ('four_of_a_kind', 'full_house', 'three_of_a_kind', 'pair'):\n                return self.get_count(self.get_hand_type()) > other_hand.get_count(other_hand.get_hand_type())\n            else:\n                return sorted([int(card[:-1]) for card in self.hand]) > sorted([int(card[:-1]) for card in other_hand.hand])\n\n    def get_count(self, hand_type):\n        \"\"\"\n        Returns the count of a specific hand type.\n        \"\"\"\n        if hand_type == 'four_of_a_kind':\n            return self._count_pairs() == 4\n        elif hand_type == 'full_house':\n            return self._count_pairs() == 2\n        elif hand_type == 'three_of_a_kind':\n            return self._count_pairs() == 3\n        else:\n            return 0",
  "test_code": "import pytest\n\n@pytest.fixture\ndef poker_hand():\n    return PokerHand\n\ndef test_init(poker_hand):\n    hand = poker_hand('2D 3D 4D 5D 6D')\n    assert hand.hand == ['2', '3', '4', '5', '6']\n    assert hand.get_hand_type() == 'flush'\n\ndef test_flush(poker_hand):\n    hand = poker_hand('2D 3D 4D 5D 6D')\n    assert hand._is_flush()\n    hand = poker_hand('2S 3H 4C 5D 6H')\n    assert not hand._is_flush()\n\ndef test_straight(poker_hand):\n    hand = poker_hand('2D 3D 4D 5D 6D')\n    assert hand._is_straight()\n    hand = poker_hand('2S 3H 4C 5D 7H')\n    assert not hand._is_straight()\n\ndef test_five_high_straight(poker_hand):\n    hand = poker_hand('AC 2C 3C 4C 5C')\n    assert hand._is_five_high_straight()\n    hand = poker_hand('2C 3C 4C 5C 6H')\n    assert not hand._is_five_high_straight()\n\ndef test_pairs(poker_hand):\n    hand = poker_hand('2D 3D 4D JD JD')\n    assert hand._count_pairs() == 2\n    hand = poker_hand('2D 3D 4D JD QD')\n    assert hand._count_pairs() == 0\n\ndef test_straight_flush(poker_hand):\n    hand = poker_hand('2D 3D 4D 5D 6D')\n    assert hand._is_straight_flush()\n    hand = poker_hand('2D 3H 4D 5D 6D')\n    assert not hand._is_straight_flush()\n\ndef test_get_hand_type(poker_hand):\n    hand = poker_hand('2D 3D 4D 5D 6D')\n    assert hand.get_hand_type() == 'flush'\n    hand = poker_hand('2D 3D 4D 5D JD')\n    assert hand.get_hand_type() == 'straight'\n\ndef test_compare_with(poker_hand):\n    hand1 = poker_hand('2D 3D 4D 5D 6H')\n    hand2 = poker_hand('3D 4D 5D JD QD')\n    assert hand2.compare_with(hand1)\n\ndef test_get_count(poker_hand):\n    hand = poker_hand('2D 3D 4D 5D JD')\n    assert hand.get_count('pair') == 0\n    hand = poker_hand('2D 3D 4D JD JD')\n    assert hand.get_count('pair') == 2",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}