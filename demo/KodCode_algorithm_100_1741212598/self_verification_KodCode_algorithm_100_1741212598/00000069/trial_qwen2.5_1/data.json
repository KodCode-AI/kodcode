{
  "metadata": {
    "prompt_id": "00000069",
    "row_id": 69,
    "seed_ids": [
      18
    ],
    "mode": "algorithm"
  },
  "instruction": "### Task: Implement a Simplified K-Means Clustering Algorithm Using TensorFlow\n\nYou are tasked with implementing a simplified version of the K-Means clustering algorithm using TensorFlow for a given dataset. The goal is to partition a set of data points into a specified number of clusters based on their proximity to the cluster centroids.\n\n#### Scenario\nYou are working on a dataset of customer transaction records and need to segment the customers into a specified number of clusters for targeted marketing campaigns. Your task is to implement the K-Means clustering algorithm to achieve this.\n\n#### Input\n- `vectors`: A 2D NumPy array of shape `(n, d)`, where `n` is the number of data points and `d` is the dimensionality of each data point.\n- `noofclusters`: An integer indicating the number of clusters to form.\n\n#### Output\n- `centroids`: A 2D NumPy array of shape `(k, d)`, where `k` is the number of clusters and `d` is the dimensionality of each centroid.\n- `assignments`: A list of integers of length `n`, where each integer represents the cluster assignment of the corresponding data point from `vectors`.\n\n#### Constraints\n- The number of clusters `noofclusters` should be less than the number of data points `n`.\n- The dimensionality `d` of the data points should be greater than 0.\n\n#### Performance Requirements\n- The implementation should be efficient and handle large datasets (e.g., `n` > 10,000 and `d` > 10).\n\n#### Implementation Guidelines\n1. Initialize the centroids randomly from the dataset.\n2. Perform the Expectation step: Assign each data point to the nearest centroid.\n3. Perform the Maximization step: Update the centroids to be the mean of the assigned data points.\n4. Repeat steps 2 and 3 for a fixed number of iterations (e.g., 100).\n5. Return the final centroids and assignments.\n\n#### Example\n```python\nimport numpy as np\nfrom sklearn.datasets import make_blobs\n\n# Generate sample data\nvectors, _ = make_blobs(n_samples=1000, centers=5, n_features=2, random_state=42)\nnoofclusters = 5\n\n# Implement the K-Means clustering algorithm\ncentroids, assignments = simplified_k_means_clustering(vectors, noofclusters)\n\nprint(\"Centroids:\", centroids)\nprint(\"Assignments:\", assignments)\n```\n\n#### Notes\n- You should not use any external packages other than TensorFlow and NumPy.\n- Ensure that your implementation is self-contained and clear.",
  "solution_code": "import numpy as np\nimport tensorflow as tf\n\ndef simplified_k_means_clustering(vectors, noofclusters, max_iterations=100):\n    \"\"\"\n    Simplified K-Means clustering algorithm implementation using TensorFlow.\n    \n    :param vectors: 2D NumPy array of shape (n, d)\n    :param noofclusters: Number of clusters to form\n    :param max_iterations: Maximum number of iterations to perform\n    \n    :return centroids: 2D NumPy array of shape (k, d)\n    :return assignments: List of integers of length n\n    \"\"\"\n    n, d = vectors.shape\n\n    # Initialize centroids randomly from the dataset\n    centroids_init = vectors[np.random.choice(n, noofclusters, replace=False)]\n\n    # Convert vectors and centroids_init to TensorFlow constants\n    vectors_tf = tf.constant(vectors, dtype=tf.float32)\n    centroids_tf = tf.constant(centroids_init, dtype=tf.float32)\n\n    # Define placeholders for distances and assignments\n    distances = tf.placeholder(tf.float32, shape=(noofclusters, n))\n    assignments_tf = tf.argmin(distances, axis=0)\n\n    for _ in range(max_iterations):\n        # Calculate distances from each point to each centroid\n        distances_tf = tf.reduce_sum(tf.square(tf.expand_dims(vectors_tf, 0) - tf.expand_dims(centroids_tf, 1)), axis=2)\n        \n        # Get the current assignments\n        with tf.Session() as sess:\n            assignments_np = sess.run(assignments_tf, feed_dict={distances: distances_tf.eval()})\n\n        # Update centroids\n        new_centroids = np.zeros((noofclusters, d))\n        counts = np.zeros((noofclusters,))\n        for i in range(n):\n            centroid_id = assignments_np[i]\n            new_centroids[centroid_id] += vectors[i]\n            counts[centroid_id] += 1\n        for i in range(noofclusters):\n            if counts[i] > 0:\n                new_centroids[i] /= counts[i]\n        \n        # Check for convergence\n        if np.allclose(new_centroids, centroids_tf.eval()):\n            break\n        \n        # Update centroids\n        centroids_tf = tf.assign(centroids_tf, new_centroids)\n    \n    with tf.Session() as sess:\n        final_centroids = sess.run(centroids_tf)\n        final_assignments = sess.run(assignments_tf, feed_dict={distances: distances_tf.eval()})\n\n    return final_centroids, final_assignments.tolist()",
  "test_code": "import numpy as np\nfrom sklearn.datasets import make_blobs\nimport tensorflow as tf\n\n# Generate sample data\ndef test_simplified_k_means_clustering():\n    vectors, _ = make_blobs(n_samples=1000, centers=5, n_features=2, random_state=42)\n    noofclusters = 5\n    \n    # Run the k-means clustering\n    centroids, assignments = simplified_k_means_clustering(vectors, noofclusters)\n    \n    # Check the shape of the centroids\n    assert centroids.shape == (noofclusters, 2), f\"Unexpected shape for centroids: {centroids.shape}\"\n    \n    # Check the length of the assignments\n    assert len(assignments) == vectors.shape[0], f\"Unexpected length of assignments: {len(assignments)}\"\n    \n    # Check for unique assignments within the expected range\n    unique_assignments = set(assignments)\n    expected_clusters = set(range(noofclusters))\n    assert unique_assignments.issubset(expected_clusters), f\"Assignments do not match expected clusters: {unique_assignments}\"\n    \n    print(\"All tests passed.\")\n\ntest_simplified_k_means_clustering()",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}