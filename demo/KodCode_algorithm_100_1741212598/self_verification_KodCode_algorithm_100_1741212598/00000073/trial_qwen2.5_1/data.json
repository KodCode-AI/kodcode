{
  "metadata": {
    "prompt_id": "00000073",
    "row_id": 73,
    "seed_ids": [
      449
    ],
    "mode": "algorithm"
  },
  "instruction": "### Scenario\nYou are developing a horoscope application that fetches daily horoscopes for users based on their zodiac sign. The application needs to be robust and handle various edge cases.\n\n### Task\nImplement a function `fetch_horoscope` that interacts with a horoscope website to fetch daily horoscopes. The function should take a zodiac sign and a day as input and return the horoscope text. Ensure the function handles invalid inputs and network-related issues gracefully.\n\n### Requirements\n1. **Input**:\n   - `zodiac_sign`: An integer representing the zodiac sign (1 for Aries, 2 for Taurus, ..., 12 for Pisces).\n   - `day`: A string representing the day for which the horoscope is requested (e.g., \"yesterday\", \"today\", \"tomorrow\").\n\n2. **Output**:\n   - A string containing the horoscope text.\n\n3. **Constraints**:\n   - The zodiac sign must be an integer between 1 and 12.\n   - The day must be one of \"yesterday\", \"today\", or \"tomorrow\".\n\n4. **Performance**:\n   - The function should handle network errors and retry once if the request fails.\n   - The function should avoid making unnecessary requests, such as requesting the same horoscope multiple times within the same day.\n\n5. **Error Handling**:\n   - If the zodiac sign is invalid, the function should return a user-friendly error message.\n   - If the day is invalid, the function should return a user-friendly error message.\n   - If the network request fails, the function should retry once and then return a generic error message if the retry fails.\n\n### Example\n```python\ndef fetch_horoscope(zodiac_sign: int, day: str) -> str:\n    # Your implementation here\n    pass\n\n# Example usage\nprint(fetch_horoscope(1, \"today\"))  # Example output: \"Your daily horoscope for today...\"\nprint(fetch_horoscope(13, \"today\"))  # Example output: \"Invalid zodiac sign.\"\nprint(fetch_horoscope(1, \"next week\"))  # Example output: \"Invalid day.\"\n```\n\n### Notes\n- You can use `requests` and `BeautifulSoup` for web scraping if needed. Ensure you handle potential exceptions and errors gracefully.",
  "solution_code": "import requests\nfrom bs4 import BeautifulSoup\nimport time\n\ndef fetch_horoscope(zodiac_sign: int, day: str) -> str:\n    # Validate inputs\n    if zodiac_sign < 1 or zodiac_sign > 12:\n        return \"Invalid zodiac sign.\"\n    valid_days = [\"yesterday\", \"today\", \"tomorrow\"]\n    if day not in valid_days:\n        return \"Invalid day.\"\n    \n    # URL template\n    base_url = \"https://example.com/horoscope\"\n    url = f\"{base_url}/{zodiac_sign}/{day}/full\"\n    \n    # Retry mechanism\n    for attempt in range(2):\n        try:\n            response = requests.get(url)\n            response.raise_for_status()  # Raise an error for bad status codes\n            soup = BeautifulSoup(response.text, 'html.parser')\n            \n            # Extract horoscope text (example extraction)\n            horoscope_text = soup.find('div', {'class': 'horoscope-text'}).text.strip()\n            return horoscope_text\n        except requests.exceptions.RequestException as e:\n            if attempt == 1:  # Only retry once\n                return \"Failed to fetch horoscope. Please try again later.\"\n            time.sleep(5)  # Wait before retrying\n    return \"Failed to fetch horoscope. Please try again later.\"",
  "test_code": "import pytest\nimport requests\nfrom unittest.mock import patch, Mock\nfrom bs4 import BeautifulSoup\nimport time\n\ndef mock_requests_get(url, **kwargs):\n    class MockResponse:\n        def __init__(self, status_code, text):\n            self.status_code = status_code\n            self.text = text\n        \n        def raise_for_status(self):\n            if self.status_code != 200:\n                raise requests.exceptions.HTTPError\n        \n    if 'horoscope' in url:\n        return MockResponse(200, '<div class=\"horoscope-text\">Your daily horoscope for today</div>')\n    elif 'invalid' in url:\n        return MockResponse(404, '')\n    else:\n        return MockResponse(500, '')\n\n@pytest.fixture(autouse=True)\ndef patch_requests_get():\n    with patch('requests.get', side_effect=mock_requests_get) as mock_get:\n        yield mock_get\n\ndef test_fetch_horoscope_valid_input():\n    assert fetch_horoscope(1, \"today\") == \"Your daily horoscope for today\"\n\ndef test_fetch_horoscope_invalid_zodiac():\n    assert fetch_horoscope(13, \"today\") == \"Invalid zodiac sign.\"\n\ndef test_fetch_horoscope_invalid_day():\n    assert fetch_horoscope(1, \"next week\") == \"Invalid day.\"\n\ndef test_fetch_horoscope_network_error():\n    with patch('requests.get', side_effect=requests.exceptions.RequestException):\n        time.sleep = Mock()  # Prevent sleep during tests\n        assert fetch_horoscope(1, \"today\") == \"Failed to fetch horoscope. Please try again later.\"\n    time.sleep = Mock()  # Cleanup\n\ndef test_fetch_horoscope_404_response():\n    with patch('requests.get') as mock_get:\n        mock_get.return_value = MockResponse(404, '')\n        assert fetch_horoscope(1, \"today\") == \"Failed to fetch horoscope. Please try again later.\"\n\ndef test_fetch_horoscope_page_not_found():\n    with patch('requests.get') as mock_get:\n        mock_get.return_value = MockResponse(200, '')\n        assert fetch_horoscope(1, \"today\") == \"Failed to fetch horoscope. Please try again later.\"",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}