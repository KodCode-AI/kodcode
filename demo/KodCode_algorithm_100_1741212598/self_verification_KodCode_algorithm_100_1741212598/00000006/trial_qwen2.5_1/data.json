{
  "metadata": {
    "prompt_id": "00000006",
    "row_id": 6,
    "seed_ids": [
      65
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question\n\nYou are given a modified version of the Playfair cipher implementation provided in the code snippets. Your task is to implement a function `advanced_encrypt` that enhances the existing encryption algorithm by adding support for handling non-alphabetic characters and improving performance. Additionally, you need to implement a function `advanced_decrypt` that decrypts the text using the same key.\n\n#### Function Specifications\n1. **advanced_encrypt(key: str, text: str) -> str**\n   - **Input**:\n     - `key`: A string representing the encryption key.\n     - `text`: A string representing the plaintext to be encrypted.\n   - **Output**:\n     - A string representing the encrypted text.\n   - **Constraints**:\n     - The key should only contain alphabetic characters.\n     - The text can contain uppercase and lowercase letters, as well as non-alphabetic characters.\n     - The text should be converted to uppercase before encryption.\n   - **Performance Requirement**: The function should handle large texts efficiently.\n\n2. **advanced_decrypt(key: str, cipher_text: str) -> str**\n   - **Input**:\n     - `key`: A string representing the decryption key.\n     - `cipher_text`: A string representing the ciphertext to be decrypted.\n   - **Output**:\n     - A string representing the decrypted text.\n   - **Constraints**:\n     - The key should only contain alphabetic characters.\n     - The `cipher_text` should already be in uppercase.\n\n#### Implementation Steps\n1. Modify the `generate_table` function to handle non-alphabetic characters in the key.\n2. Implement the `advanced_encrypt` and `advanced_decrypt` functions to handle non-alphabetic characters and improve performance.\n3. Ensure that the functions are efficient and handle large inputs effectively.\n\n#### Example\n```python\nkey = \"marvin\"\ntext = \"jessica!123\"\n\n# Encrypted text\nencrypted_text = advanced_encrypt(key, text)\n# Decrypted text\ndecrypted_text = advanced_decrypt(key, encrypted_text)\n\nprint(f\"Encrypted: {encrypted_text}\")\nprint(f\"Decrypted: {decrypted_text}\")\n```\n\n#### Expected Output\n```\nEncrypted: QRACRWU!123\nDecrypted: JESSICA!123\n```\n\n#### Note\n- Make sure to handle all possible edge cases, such as empty strings or keys with non-alphabetic characters.\n- Optimize the code to handle large texts efficiently.",
  "solution_code": "def generate_table(key: str) -> list:\n    \"\"\"\n    Generates a 5x5 matrix (Playfair cipher table) from the given key.\n    Non-alphabetic characters in the key are ignored.\n    \"\"\"\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    key = key.upper().replace('J', 'I')  # Convert to uppercase and replace J with I\n    key = ''.join(sorted(set(key), key=key.index))  # Remove duplicates and maintain order\n    table = [list(key[i:i+5]) for i in range(0, len(key), 5)]\n    for letter in alphabet:\n        if letter not in key:\n            if letter == 'J':\n                continue\n            table[int(len(table) - 1)].append(letter)\n    return table\n\ndef find_position(table: list, letter: str) -> tuple:\n    \"\"\"\n    Finds the position (row, col) of a letter in the table.\n    \"\"\"\n    for i in range(5):\n        for j in range(5):\n            if table[i][j] == letter:\n                return i, j\n\ndef advanced_encrypt(key: str, text: str) -> str:\n    \"\"\"\n    Encrypts the text using the Playfair cipher with the given key.\n    \"\"\"\n    table = generate_table(key)\n    text = text.upper().replace('J', 'I')  # Convert to uppercase and replace J with I\n    text = ''.join(filter(str.isalpha, text))  # Remove non-alphabetic characters\n    encrypted = \"\"\n    for i in range(0, len(text), 2):\n        if i + 1 == len(text):\n            encrypted += text[i] + 'X'\n        else:\n            first, second = text[i], text[i + 1]\n            pos1, pos2 = find_position(table, first), find_position(table, second)\n            if pos1[0] == pos2[0]:  # Same row\n                encrypted += table[pos1[0]][(pos1[1] + 1) % 5] + table[pos2[0]][(pos2[1] + 1) % 5]\n            elif pos1[1] == pos2[1]:  # Same column\n                encrypted += table[(pos1[0] + 1) % 5][pos1[1]] + table[(pos2[0] + 1) % 5][pos2[1]]\n            else:  # Different row and column\n                encrypted += table[pos1[0]][pos2[1]] + table[pos2[0]][pos1[1]]\n    return encrypted\n\ndef advanced_decrypt(key: str, cipher_text: str) -> str:\n    \"\"\"\n    Decrypts the cipher text using the Playfair cipher with the given key.\n    \"\"\"\n    table = generate_table(key)\n    cipher_text = cipher_text.upper().replace('J', 'I')  # Convert to uppercase and replace J with I\n    decrypted = \"\"\n    for i in range(0, len(cipher_text), 2):\n        first, second = cipher_text[i], cipher_text[i + 1]\n        pos1, pos2 = find_position(table, first), find_position(table, second)\n        if pos1[0] == pos2[0]:  # Same row\n            decrypted += table[pos1[0]][(pos1[1] - 1) % 5] + table[pos2[0]][(pos2[1] - 1) % 5]\n        elif pos1[1] == pos2[1]:  # Same column\n            decrypted += table[(pos1[0] - 1) % 5][pos1[1]] + table[(pos2[0] - 1) % 5][pos2[1]]\n        else:  # Different row and column\n            decrypted += table[pos1[0]][pos2[1]] + table[pos2[0]][pos1[1]]\n    return decrypted[:-1]  # Remove the last character (X) if present",
  "test_code": "import pytest\n\nkey = \"marvin\"\ntext = \"jessica!123\"\ncipher_text = \"QRACRWU!123\"\n\ndef test_advanced_encrypt_decrypt():\n    encrypted = advanced_encrypt(key, text)\n    assert encrypted == cipher_text\n    decrypted = advanced_decrypt(key, encrypted)\n    assert decrypted == text.upper().replace('J', 'I')\n\ndef test_non_alphabetic_chars():\n    text = \"test-123&*()\"\n    encrypted = advanced_encrypt(key, text)\n    assert encrypted == \"AIFQH\"\n    decrypted = advanced_decrypt(key, encrypted)\n    assert decrypted == \"TEST\"\n\ndef test_empty_text():\n    text = \"\"\n    assert advanced_encrypt(key, text) == \"\"\n    assert advanced_decrypt(key, \"\") == \"\"\n\ndef test_single_character():\n    text = \"a\"\n    encrypted = advanced_encrypt(key, text)\n    assert encrypted == \"AN\"\n    decrypted = advanced_decrypt(key, encrypted)\n    assert decrypted == \"A\"\n\ndef test_large_text():\n    text = \"This is a sample text to test the encryption and decryption functionality with a large input. J\"\n    encrypted = advanced_encrypt(key, text)\n    assert len(encrypted) == 92  # Expected length of the encrypted text\n    decrypted = advanced_decrypt(key, encrypted)\n    assert decrypted == text.upper().replace('J', 'I')",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}