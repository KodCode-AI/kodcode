{
  "metadata": {
    "prompt_id": "00000006",
    "row_id": 6,
    "seed_ids": [
      65
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question\n\nYou are given a modified version of the Playfair cipher implementation provided in the code snippets. Your task is to implement a function `advanced_encrypt` that enhances the existing encryption algorithm by adding support for handling non-alphabetic characters and improving performance. Additionally, you need to implement a function `advanced_decrypt` that decrypts the text using the same key.\n\n#### Function Specifications\n1. **advanced_encrypt(key: str, text: str) -> str**\n   - **Input**:\n     - `key`: A string representing the encryption key.\n     - `text`: A string representing the plaintext to be encrypted.\n   - **Output**:\n     - A string representing the encrypted text.\n   - **Constraints**:\n     - The key should only contain alphabetic characters.\n     - The text can contain uppercase and lowercase letters, as well as non-alphabetic characters.\n     - The text should be converted to uppercase before encryption.\n   - **Performance Requirement**: The function should handle large texts efficiently.\n\n2. **advanced_decrypt(key: str, cipher_text: str) -> str**\n   - **Input**:\n     - `key`: A string representing the decryption key.\n     - `cipher_text`: A string representing the ciphertext to be decrypted.\n   - **Output**:\n     - A string representing the decrypted text.\n   - **Constraints**:\n     - The key should only contain alphabetic characters.\n     - The `cipher_text` should already be in uppercase.\n\n#### Implementation Steps\n1. Modify the `generate_table` function to handle non-alphabetic characters in the key.\n2. Implement the `advanced_encrypt` and `advanced_decrypt` functions to handle non-alphabetic characters and improve performance.\n3. Ensure that the functions are efficient and handle large inputs effectively.\n\n#### Example\n```python\nkey = \"marvin\"\ntext = \"jessica!123\"\n\n# Encrypted text\nencrypted_text = advanced_encrypt(key, text)\n# Decrypted text\ndecrypted_text = advanced_decrypt(key, encrypted_text)\n\nprint(f\"Encrypted: {encrypted_text}\")\nprint(f\"Decrypted: {decrypted_text}\")\n```\n\n#### Expected Output\n```\nEncrypted: QRACRWU!123\nDecrypted: JESSICA!123\n```\n\n#### Note\n- Make sure to handle all possible edge cases, such as empty strings or keys with non-alphabetic characters.\n- Optimize the code to handle large texts efficiently.",
  "solution_code": "def generate_table(key):\n    \"\"\"\n    Generates a 5x5 matrix for the Playfair cipher using the given key.\n    \"\"\"\n    letters = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"  # Excluding 'J' as it is combined with 'I'\n    key = key.upper().replace(\"J\", \"I\")  # Replace 'J' with 'I' and convert to uppercase\n\n    table = []\n    for char in key:\n        if char not in letters:\n            continue\n        if char not in table:\n            table.append(char)\n    for char in letters:\n        if char not in table:\n            table.append(char)\n\n    # Reshape into a 5x5 matrix\n    return [table[i:i+5] for i in range(0, 25, 5)]\n\ndef advanced_encrypt(key, text):\n    \"\"\"\n    Encrypts the given text using the Playfair cipher with the provided key.\n    \"\"\"\n    table = generate_table(key)\n    text = text.upper().replace(\"J\", \"I\").replace(\" \", \"\")  # Convert to uppercase and remove spaces\n\n    i, j = 0, 0\n    pairs = []\n    while i < len(text):\n        c1, c2 = text[i], text[i+1] if i+1 < len(text) else 'X'  # Use 'X' as filler if needed\n        i1, j1 = -1, -1\n        i2, j2 = -1, -1\n\n        for r in range(5):\n            for c in range(5):\n                if table[r][c] == c1:\n                    i1, j1 = r, c\n                if table[r][c] == c2:\n                    i2, j2 = r, c\n\n        if i1 == j1:  # Same row\n            i1, i2 = (i1 + 1) % 5, (i2 + 1) % 5\n        elif i2 == j2:  # Same column\n            i1, i2 = (i1 + 1) % 5, (i2 + 1) % 5\n        else:  # Different row and column\n            i1, j1, i2, j2 = i2, j1, i1, j2\n\n        pairs.append(table[i1][j1] + table[i2][j2])\n        i += 2\n\n    return ''.join(pairs)\n\ndef advanced_decrypt(key, cipher_text):\n    \"\"\"\n    Decrypts the given text using the Playfair cipher with the provided key.\n    \"\"\"\n    table = generate_table(key)\n    cipher_text = cipher_text.upper().replace(\"J\", \"I\")  # Convert to uppercase and replace 'J' with 'I'\n\n    i, j = 0, 0\n    pairs = []\n    while i < len(cipher_text):\n        c1, c2 = cipher_text[i], cipher_text[i+1] if i+1 < len(cipher_text) else 'X'  # Use 'X' as filler if needed\n        i1, j1 = -1, -1\n        i2, j2 = -1, -1\n\n        for r in range(5):\n            for c in range(5):\n                if table[r][c] == c1:\n                    i1, j1 = r, c\n                if table[r][c] == c2:\n                    i2, j2 = r, c\n\n        if i1 == j1:  # Same row\n            i1, i2 = (i1 - 1) % 5, (i2 - 1) % 5\n        elif i2 == j2:  # Same column\n            i1, i2 = (i1 - 1) % 5, (i2 - 1) % 5\n        else:  # Different row and column\n            i1, j1, i2, j2 = i2, j1, i1, j2\n\n        pairs.append(table[i1][j1] + table[i2][j2])\n        i += 2\n\n    return ''.join(pairs).replace(\"XX\", \"X\").replace(\"X\", \" \")  # Restore spaces and remove double 'X'",
  "test_code": "from solution import generate_table, advanced_encrypt, advanced_decrypt\n\ndef test_generate_table():\n    key = \"MCRY\"\n    table = generate_table(key)\n    expected_table = [\n        ['M', 'C', 'R', 'Y', 'B'],\n        ['A', 'D', 'E', 'F', 'G'],\n        ['H', 'I', 'K', 'L', 'N'],\n        ['O', 'P', 'Q', 'S', 'T'],\n        ['U', 'V', 'W', 'X', 'Z']\n    ]\n    assert table == expected_table\n\ndef test_advanced_encrypt():\n    key = \"MCRY\"\n    text = \"jessica!123\"\n    encrypted_text = advanced_encrypt(key, text)\n    assert encrypted_text == \"QRACRWU!123\"\n\ndef test_advanced_decrypt():\n    key = \"MCRY\"\n    text = \"QRACRWU!123\"\n    decrypted_text = advanced_decrypt(key, text)\n    assert decrypted_text == \"JESSICA!123\"\n\ndef test_advanced_encrypt_empty_string():\n    key = \"MCRY\"\n    text = \"\"\n    encrypted_text = advanced_encrypt(key, text)\n    assert encrypted_text == \"\"\n\ndef test_advanced_decrypt_empty_string():\n    key = \"MCRY\"\n    text = \"\"\n    decrypted_text = advanced_decrypt(key, text)\n    assert decrypted_text == \"\"\n\ndef test_advanced_encrypt_with_non_alpha_chars():\n    key = \"MCRY\"\n    text = \"j3ss1c4!\"\n    encrypted_text = advanced_encrypt(key, text)\n    assert encrypted_text == \"QRA3RWU!\"\n\ndef test_advanced_decrypt_with_non_alpha_chars():\n    key = \"MCRY\"\n    text = \"QRA3RWU!\"\n    decrypted_text = advanced_decrypt(key, text)\n    assert decrypted_text == \"J3SS1C4!\"\n\ndef test_advanced_encrypt_with_key_containing_non_alpha_chars():\n    key = \"M2CRY\"\n    text = \"j3ss1c4!\"\n    encrypted_text = advanced_encrypt(key, \"Z\" + text)  # Adding 'Z' to ensure key validity\n    assert encrypted_text == \"QRA3RWU!\"\n\ndef test_advanced_decrypt_with_key_containing_non_alpha_chars():\n    key = \"M2CRY\"\n    text = \"QRA3RWU!\"\n    decrypted_text = advanced_decrypt(key, \"Z\" + text)  # Adding 'Z' to ensure key validity\n    assert decrypted_text == \"J3SS1C4!\"",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}