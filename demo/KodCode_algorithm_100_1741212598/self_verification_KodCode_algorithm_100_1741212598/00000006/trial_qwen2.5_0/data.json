{
  "metadata": {
    "prompt_id": "00000006",
    "row_id": 6,
    "seed_ids": [
      65
    ],
    "mode": "algorithm"
  },
  "instruction": "### Question\n\nYou are given a modified version of the Playfair cipher implementation provided in the code snippets. Your task is to implement a function `advanced_encrypt` that enhances the existing encryption algorithm by adding support for handling non-alphabetic characters and improving performance. Additionally, you need to implement a function `advanced_decrypt` that decrypts the text using the same key.\n\n#### Function Specifications\n1. **advanced_encrypt(key: str, text: str) -> str**\n   - **Input**:\n     - `key`: A string representing the encryption key.\n     - `text`: A string representing the plaintext to be encrypted.\n   - **Output**:\n     - A string representing the encrypted text.\n   - **Constraints**:\n     - The key should only contain alphabetic characters.\n     - The text can contain uppercase and lowercase letters, as well as non-alphabetic characters.\n     - The text should be converted to uppercase before encryption.\n   - **Performance Requirement**: The function should handle large texts efficiently.\n\n2. **advanced_decrypt(key: str, cipher_text: str) -> str**\n   - **Input**:\n     - `key`: A string representing the decryption key.\n     - `cipher_text`: A string representing the ciphertext to be decrypted.\n   - **Output**:\n     - A string representing the decrypted text.\n   - **Constraints**:\n     - The key should only contain alphabetic characters.\n     - The `cipher_text` should already be in uppercase.\n\n#### Implementation Steps\n1. Modify the `generate_table` function to handle non-alphabetic characters in the key.\n2. Implement the `advanced_encrypt` and `advanced_decrypt` functions to handle non-alphabetic characters and improve performance.\n3. Ensure that the functions are efficient and handle large inputs effectively.\n\n#### Example\n```python\nkey = \"marvin\"\ntext = \"jessica!123\"\n\n# Encrypted text\nencrypted_text = advanced_encrypt(key, text)\n# Decrypted text\ndecrypted_text = advanced_decrypt(key, encrypted_text)\n\nprint(f\"Encrypted: {encrypted_text}\")\nprint(f\"Decrypted: {decrypted_text}\")\n```\n\n#### Expected Output\n```\nEncrypted: QRACRWU!123\nDecrypted: JESSICA!123\n```\n\n#### Note\n- Make sure to handle all possible edge cases, such as empty strings or keys with non-alphabetic characters.\n- Optimize the code to handle large texts efficiently.",
  "solution_code": "def generate_table(key: str) -> list:\n    \"\"\"\n    Generates a 5x5 Playfair matrix using the given key and removing non-alphabetic characters.\n    \"\"\"\n    key = ''.join(filter(str.isalpha, key.upper()))\n    key = key.replace(\"J\", \"I\")  # Replace J with I as both are represented by I in the Playfair cipher\n    table = []\n\n    for char in key:\n        if char not in ''.join(table):\n            table.append(char)\n\n    for char in 'ABCDEFGHIKLMNOPQRSTUVWXYZ':  # Skip 'J' as it's covered by 'I'\n        if char not in table:\n            table.append(char)\n\n    return [table[i:i+5] for i in range(0, 25, 5)]\n\n\ndef find_position(table: list, char: str) -> tuple:\n    \"\"\"\n    Finds the position (row, col) of a character in the Playfair matrix.\n    \"\"\"\n    for i, row in enumerate(table):\n        for j, val in enumerate(row):\n            if val == char:\n                return i, j\n\n\ndef advanced_encrypt(key: str, text: str) -> str:\n    \"\"\"\n    Encrypts the text using the Playfair cipher with the given key.\n    \"\"\"\n    table = generate_table(key)\n    text = text.upper()\n    text = text.replace(\"J\", \"I\")  # Replace J with I\n    spaced_text = [''.join(text[i:i+2]) for i in range(0, len(text), 2)]\n\n    for i, pair in enumerate(spaced_text):\n        if len(pair) < 2:\n            spaced_text[i] += 'X'  # Fill missing character with 'X'\n\n    cipher_text = ''.join([table[row1][col1] + table[row2][col2] if row1 == row2 or col1 == col2 else table[row1][col2] + table[row2][col1] for (row1, col1), (row2, col2) in [(find_position(table, char1), find_position(table, char2)) for char1, char2 in zip(*[iter(spaced_text)]*2)]])\n\n    return cipher_text\n\n\ndef advanced_decrypt(key: str, cipher_text: str) -> str:\n    \"\"\"\n    Decrypts the text using the Playfair cipher with the given key.\n    \"\"\"\n    table = generate_table(key)\n    cipher_text = cipher_text.upper()\n    cipher_text = cipher_text.replace(\"J\", \"I\")  # Replace J with I\n    cipher_text = ''.join([cipher_text[i:i+2] for i in range(0, len(cipher_text), 2)])\n\n    plain_text = ''.join([table[row1][col1] + table[row2][col2] if row1 == row2 or col1 == col2 else table[row2][col1] + table[row1][col2] for (row1, col1), (row2, col2) in [(find_position(table, char1), find_position(table, char2)) for char1, char2 in zip(cipher_text[::2], cipher_text[1::2])]])\n\n    # Remove added 'X' characters\n    returned_text = []\n    i = 0\n    while i < len(plain_text):\n        if plain_text[i] == plain_text[i+1]:\n            returned_text.append(plain_text[i])\n            i += 1\n        else:\n            returned_text.append(plain_text[i:i+2])\n            i += 2\n\n    return ''.join(returned_text)\n\n\nkey = \"MARVIN\"\ntext = \"jessica!123\"\n\nencrypted_text = advanced_encrypt(key, text)\ndecrypted_text = advanced_decrypt(key, encrypted_text)\n\nprint(f\"Encrypted: {encrypted_text}\")\nprint(f\"Decrypted: {decrypted_text}\")",
  "test_code": "import pytest\n\ndef test_generate_table():\n    key = \"playfair\"\n    expected_table = [\n        ['P', 'L', 'A', 'I', 'R'],\n        ['F', 'B', 'C', 'D', 'E'],\n        ['G', 'H', 'K', 'M', 'N'],\n        ['O', 'Q', 'S', 'T', 'U'],\n        ['V', 'W', 'X', 'Y', 'Z']\n    ]\n    assert generate_table(key) == expected_table\n\ndef test_find_position():\n    table = generate_table(\"MARVIN\")\n    assert find_position(table, 'A') == (0, 1)\n    assert find_position(table, 'Z') == (4, 4)\n\ndef test_encryption():\n    key = \"MARVIN\"\n    text = \"jessica!123\"\n    encrypted_text = \"QRACRWU!123\"\n    assert advanced_encrypt(key, text) == encrypted_text\n\ndef test_decryption():\n    key = \"MARVIN\"\n    text = \"jessica!123\"\n    encrypted_text = advanced_encrypt(key, text)\n    decrypted_text = \"JESSICA!123\"\n    assert advanced_decrypt(key, encrypted_text) == decrypted_text\n\ndef test_edge_cases():\n    key = \"PLAYFAIR\"\n    text = \"\"\n    encrypted_text = advanced_encrypt(key, text)\n    decrypted_text = advanced_decrypt(key, encrypted_text)\n    assert encrypted_text == \"\"\n    assert decrypted_text == \"\"\n\n    key = \"PLAYFAIR\"\n    text = \"A\"\n    encrypted_text = advanced_encrypt(key, text)\n    decrypted_text = advanced_decrypt(key, encrypted_text)\n    assert encrypted_text == \"AE\"\n    assert decrypted_text == \"A\"\n\n    key = \"PLAYFAIR\"\n    text = \"AB\"\n    encrypted_text = advanced_encrypt(key, text)\n    decrypted_text = advanced_decrypt(key, encrypted_text)\n    assert encrypted_text == \"AE\"\n    assert decrypted_text == \"AB\"\n\n    key = \"PLAYFAIR\"\n    text = \"AX\"\n    encrypted_text = advanced_encrypt(key, text)\n    decrypted_text = advanced_decrypt(key, encrypted_text)\n    assert encrypted_text == \"AEC\"\n    assert decrypted_text == \"AX\"",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}