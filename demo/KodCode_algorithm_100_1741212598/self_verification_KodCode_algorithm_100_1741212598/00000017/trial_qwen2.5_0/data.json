{
  "metadata": {
    "prompt_id": "00000017",
    "row_id": 17,
    "seed_ids": [
      609
    ],
    "mode": "algorithm"
  },
  "instruction": "You are given a problem to find the first Fibonacci number that is pandigital (contains all digits 1 to 9) both in the first nine digits and the last nine digits. The sequence is defined as:\n\n\\[\nF_n = F_{n-1} + F_{n-2}\n\\]\n\nwith initial conditions \\(F_1 = 1\\) and \\(F_2 = 1\\).\n\n**Task**:\nImplement a function `find_pandigital_fibonacci` that returns the index of the first Fibonacci number that meets the criteria. If no such number exists within the first 1,000,000 Fibonacci numbers, return -1.\n\n#### Constraints:\n- The function should handle large numbers efficiently.\n- The function should be optimized for performance.\n\n#### Input and Output:\n- **Input**: None (the function should use predefined variables and constants).\n- **Output**: An integer representing the index of the first pandigital Fibonacci number.\n\n#### Example:\n```python\n# Example input (no explicit input needed, use predefined values)\nprint(find_pandigital_fibonacci())  # Output: 329468\n```\n\n#### Helper Functions:\nYou are allowed to use helper functions if needed. The provided `check` and `check1` functions can be used but are not mandatory.\n\n#### Implementation:\n```python\ndef find_pandigital_fibonacci() -> int:\n    # Your implementation here\n    pass\n\ndef check(number: int) -> bool:\n    # Check function for pandigital properties\n    pass\n\ndef check1(number: int) -> bool:\n    # Check function for pandigital properties from end\n    pass\n```\n\n### Requirements:\n- The function `find_pandigital_fibonacci` should be efficient and optimized for large inputs.\n- Use modulo arithmetic to handle large numbers.\n- The solution should be able to handle the large number of Fibonacci numbers specified.\n\n### Scoring:\n- Correct implementation and performance: 100 points.\n- Partial implementation: Partial points based on correctness and efficiency.\n- Incorrect or inefficient implementation: 0 points.",
  "solution_code": "def find_pandigital_fibonacci() -> int:\n    def check(number: int) -> bool:\n        s = str(number)\n        return ''.join(sorted(s)) == '123456789'\n\n    def check1(number: int) -> bool:\n        s = str(number)\n        return ''.join(sorted(s[:9])) == '123456789' and ''.join(sorted(s[-9:])) == '123456789'\n\n    F1, F2 = 0, 1\n    index = 2\n    while index < 1000000:\n        F1, F2 = F2, (F1 + F2) % 1000000000000000000  # To handle large numbers\n        if check(F2) and check1(F2):\n            return index\n        index += 1\n    return -1",
  "test_code": "python\r\ndef test_find_pandigital_fibonacci():\r\n    assert find_pandigital_fibonacci() == 329468\r\n\r\ndef test_check():\r\n    assert check(123456789) is True\r\n    assert check(987654321) is True\r\n    assert check(12345) is False\r\n\r\ndef test_check1():\r\n    assert check1(123456789) is True\r\n    assert check1(987654321) is True\r\n    assert check1(12345) is False\r\n    assert check1(123456789987654321) is True\r\n    assert check1(1234567890123456789) is True\r\n    assert check1(1234567899999999999) is True\r\n    assert check1(1234567899999999990) is False\r\n\r\ndef test_small_numbers():\r\n    assert find_pandigital_fibonacci(1, 2, 2, 4, 8, 13, 21, 34, 55, 89) == 10  # Using smaller set of numbers for testing",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}