{
  "metadata": {
    "prompt_id": "00000045",
    "row_id": 45,
    "seed_ids": [
      75
    ],
    "mode": "algorithm"
  },
  "instruction": "**Scenario:** You are working on a cryptographic application that involves finding the modular inverse of a number. The application needs to handle large numbers efficiently without causing performance issues.\n\n**Task:** Implement a function `find_mod_inverse` that computes the modular inverse of a given integer \\(a\\) modulo \\(m\\). The function should use the Extended Euclidean Algorithm to find the modular inverse and raise a `ValueError` if the modular inverse does not exist.\n\n**Input:**\n- Two integers \\(a\\) and \\(m\\) where \\(1 \\leq a, m \\leq 10^9\\).\n\n**Output:**\n- The modular inverse of \\(a\\) modulo \\(m\\) if it exists. If it does not exist, raise a `ValueError` with an appropriate error message.\n\n**Constraints:**\n- \\(1 \\leq a, m \\leq 10^9\\)\n- \\(m > 0\\)\n\n**Example:**\n```python\n# Example 1\na = 3\nm = 11\nfind_mod_inverse(a, m)  # Output: 4\n\n# Example 2\na = 10\nm = 20\nfind_mod_inverse(a, m)  # Raises ValueError: mod inverse of 10 and 20 does not exist\n\n# Example 3\na = 17\nm = 3120\nfind_mod_inverse(a, m)  # Output: 2753\n```\n\n**Note:**\n- Use the provided `gcd_by_iterative` function to find the greatest common divisor.\n- Ensure that the function is efficient and handles large values of \\(a\\) and \\(m\\).",
  "solution_code": "def gcd_by_iterative(a, b):\n    \"\"\"\n    Returns the greatest common divisor of a and b using Euclidean algorithm.\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef extended_gcd(a, b):\n    \"\"\"\n    Returns (gcd, x, y) where gcd is the greatest common divisor of a and b,\n    and x, y are the coefficients such that gcd = ax + by.\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n\ndef find_mod_inverse(a, m):\n    \"\"\"\n    Returns the modular inverse of a modulo m if it exists.\n    \"\"\"\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd != 1:\n        raise ValueError(f\"mod inverse of {a} and {m} does not exist\")\n    else:\n        return x % m",
  "test_code": "from solution import find_mod_inverse, gcd_by_iterative\n\ndef test_find_mod_inverse():\n    assert find_mod_inverse(3, 11) == 4\n    assert find_mod_inverse(17, 3120) == 2753\n    assert find_mod_inverse(25, 18) == 11  # Example given in modular inverse tutorial\n    assert find_mod_inverse(10, 20) == -1  # This should raise ValueError\n    \ndef test_extended_gcd():\n    # Check if the extended_gcd function returns the correct result\n    gcd, x, y = extended_gcd(35, 15)\n    assert gcd == 5 and x == 1 and y == -2\n    \ndef test_gcd_by_iterative():\n    # Check if the gcd_by_iterative function returns the correct result\n    assert gcd_by_iterative(35, 15) == 5\n    assert gcd_by_iterative(101, 10) == 1\n\n# Testing with different scenarios\ndef test_case_insensitivity():\n    # Should pass without raising ValueError\n    assert find_mod_inverse(7, 12) == 7\n    assert find_mod_inverse(1107, 2017) == 801\n\n# Handling edge cases\ndef test_small_modulus():\n    # Should handle small modulus correctly\n    assert find_mod_inverse(5, 11) == 9\n\n# Testing with known failure case\ndef test_faulty_input():\n    # Raises ValueError as expected\n    with pytest.raises(ValueError):\n        find_mod_inverse(10, 20)",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results1.jsonl"
}