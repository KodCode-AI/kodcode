{
  "metadata": {
    "prompt_id": "00000045",
    "row_id": 45,
    "seed_ids": [
      75
    ],
    "mode": "algorithm"
  },
  "instruction": "**Scenario:** You are working on a cryptographic application that involves finding the modular inverse of a number. The application needs to handle large numbers efficiently without causing performance issues.\n\n**Task:** Implement a function `find_mod_inverse` that computes the modular inverse of a given integer \\(a\\) modulo \\(m\\). The function should use the Extended Euclidean Algorithm to find the modular inverse and raise a `ValueError` if the modular inverse does not exist.\n\n**Input:**\n- Two integers \\(a\\) and \\(m\\) where \\(1 \\leq a, m \\leq 10^9\\).\n\n**Output:**\n- The modular inverse of \\(a\\) modulo \\(m\\) if it exists. If it does not exist, raise a `ValueError` with an appropriate error message.\n\n**Constraints:**\n- \\(1 \\leq a, m \\leq 10^9\\)\n- \\(m > 0\\)\n\n**Example:**\n```python\n# Example 1\na = 3\nm = 11\nfind_mod_inverse(a, m)  # Output: 4\n\n# Example 2\na = 10\nm = 20\nfind_mod_inverse(a, m)  # Raises ValueError: mod inverse of 10 and 20 does not exist\n\n# Example 3\na = 17\nm = 3120\nfind_mod_inverse(a, m)  # Output: 2753\n```\n\n**Note:**\n- Use the provided `gcd_by_iterative` function to find the greatest common divisor.\n- Ensure that the function is efficient and handles large values of \\(a\\) and \\(m\\).",
  "solution_code": "def gcd_by_iterative(a, b):\n    \"\"\"\n    Returns the greatest common divisor of a and b using the iterative version of the Euclidean algorithm.\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_mod_inverse(a, m):\n    \"\"\"\n    Returns the modular inverse of a modulo m using the Extended Euclidean Algorithm.\n    \n    Raises ValueError if the modular inverse does not exist.\n    \"\"\"\n    if gcd_by_iterative(a, m) != 1:\n        raise ValueError(f\"mod inverse of {a} and {m} does not exist\")\n    \n    u1, u2, u3 = 1, 0, a\n    v1, v2, v3 = 0, 1, m\n    \n    while v3 != 0:\n        q = u3 // v3\n        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3\n    \n    return u1 % m",
  "test_code": "import pytest\n\ndef test_find_mod_inverse():\n    assert find_mod_inverse(3, 11) == 4\n    assert find_mod_inverse(17, 3120) == 2753\n    with pytest.raises(ValueError):\n        find_mod_inverse(10, 20)\n    with pytest.raises(ValueError):\n        find_mod_inverse(25, 100)\n\ndef test_mod_inverse.mul_behavior():\n    a = 3\n    m = 11\n    inv = find_mod_inverse(a, m)\n    assert (a * inv) % m == 1\n\ndef test_gcd_aliasing():\n    assert gcd_by_iterative(3, 11) == 1\n    assert gcd_by_iterative(17, 3120) == 1\n    assert gcd_by_iterative(10, 20) == 10",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}