{
  "metadata": {
    "prompt_id": "00000051",
    "row_id": 51,
    "seed_ids": [
      358
    ],
    "mode": "algorithm"
  },
  "instruction": "### Scenario\nYou are working on a project where you need to efficiently traverse a large Binary Search Tree (BST) and output the values in sorted order. Given the provided code snippet, you have been tasked with implementing an enhanced version of the inorder traversal.\n\n### Requirements\n1. **Function Specification**:\n    - Implement a function `enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]` that performs an inorder traversal on a given BST.\n    - The function should return a list of integers representing the values of the nodes in sorted order.\n2. **Input**:\n    - `root: BinaryTreeNode | None`: The root node of a BST. If `None`, the function should return an empty list.\n3. **Output**:\n    - A list of integers representing the values of the nodes in sorted order.\n4. **Constraints**:\n    - The maximum number of nodes in the tree is \\(10^5\\).\n    - The value of each node is an integer within the range \\([-10^9, 10^9]\\).\n5. **Optimization**:\n    - Use an iterative approach to avoid potential stack overflow issues with deep trees.\n    - Ensure the solution is efficient and handles edge cases properly.\n\n### Example\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\n# Function to test the solution\ndef check_solution(func):\n    tree = make_tree()\n    result = func(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n    print(\"Solution is correct.\")\n\n# Test the function\ncheck_solution(enhanced_inorder_traversal)\n```\n\n### Note\nEnsure your implementation is efficient and handles edge cases such as an empty tree or very deep trees. Use an iterative approach to avoid stack overflow issues.",
  "solution_code": "def enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]:\n    \"\"\"\n    Returns the values of the nodes in a BST in sorted order using an iterative inorder traversal.\n    \"\"\"\n    if not root:\n        return []\n    \n    stack, result = [], []\n    current = root\n    \n    while True:\n        # Traverse to the leftmost node\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        if not stack:\n            break\n        \n        # Process the node\n        node = stack.pop()\n        result.append(node.data)\n        \n        # Move to the right subtree\n        current = node.right_child\n    \n    return result",
  "test_code": "import pytest\nfrom solution import BinaryTreeNode, enhanced_inorder_traversal, make_tree\n\ndef test_enhanced_inorder_traversal_with_example():\n    tree = make_tree()\n    result = enhanced_inorder_traversal(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n\ndef test_enhanced_inorder_traversal_with_empty_tree():\n    result = enhanced_inorder_traversal(None)\n    expected = []\n    assert result == expected, \"The result does not match the expected output for an empty tree.\"\n\ndef test_enhanced_inorder_traversal_with_single_node():\n    root = BinaryTreeNode(15)\n    result = enhanced_inorder_traversal(root)\n    expected = [15]\n    assert result == expected, \"The result does not match the expected output for a single node tree.\"\n\ndef test_enhanced_inorder_traversal_with_deeper_left_subtree():\n    root = BinaryTreeNode(1)\n    root.left_child = BinaryTreeNode(2)\n    root.left_child.left_child = BinaryTreeNode(3)\n    root.left_child.left_child.left_child = BinaryTreeNode(4)\n    result = enhanced_inorder_traversal(root)\n    expected = [4, 3, 2, 1]\n    assert result == expected, \"The result does not match the expected output for a deeper left subtree.\"\n\ndef test_enhanced_inorder_traversal_with_deeper_right_subtree():\n    root = BinaryTreeNode(1)\n    root.right_child = BinaryTreeNode(2)\n    root.right_child.right_child = BinaryTreeNode(3)\n    root.right_child.right_child.right_child = BinaryTreeNode(4)\n    result = enhanced_inorder_traversal(root)\n    expected = [1, 2, 3, 4]\n    assert result == expected, \"The result does not match the expected output for a deeper right subtree.\"\n\ndef test_enhanced_inorder_traversal_with_non_balanced_tree():\n    root = BinaryTreeNode(10)\n    root.left_child = BinaryTreeNode(5)\n    root.right_child = BinaryTreeNode(15)\n    root.left_child.left_child = BinaryTreeNode(3)\n    root.left_child.right_child = BinaryTreeNode(7)\n    root.right_child.left_child = BinaryTreeNode(12)\n    root.right_child.right_child = BinaryTreeNode(18)\n    result = enhanced_inorder_traversal(root)\n    expected = [3, 5, 7, 10, 12, 15, 18]\n    assert result == expected, \"The result does not match the expected output for a non-balanced tree.\"",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}