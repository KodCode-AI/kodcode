{
  "metadata": {
    "prompt_id": "00000051",
    "row_id": 51,
    "seed_ids": [
      358
    ],
    "mode": "algorithm"
  },
  "instruction": "### Scenario\nYou are working on a project where you need to efficiently traverse a large Binary Search Tree (BST) and output the values in sorted order. Given the provided code snippet, you have been tasked with implementing an enhanced version of the inorder traversal.\n\n### Requirements\n1. **Function Specification**:\n    - Implement a function `enhanced_inorder_traversal(root: BinaryTreeNode | None) -> list[int]` that performs an inorder traversal on a given BST.\n    - The function should return a list of integers representing the values of the nodes in sorted order.\n2. **Input**:\n    - `root: BinaryTreeNode | None`: The root node of a BST. If `None`, the function should return an empty list.\n3. **Output**:\n    - A list of integers representing the values of the nodes in sorted order.\n4. **Constraints**:\n    - The maximum number of nodes in the tree is \\(10^5\\).\n    - The value of each node is an integer within the range \\([-10^9, 10^9]\\).\n5. **Optimization**:\n    - Use an iterative approach to avoid potential stack overflow issues with deep trees.\n    - Ensure the solution is efficient and handles edge cases properly.\n\n### Example\n\n```python\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: BinaryTreeNode | None = None\n        self.right_child: BinaryTreeNode | None = None\n\ndef make_tree() -> BinaryTreeNode | None:\n    root = BinaryTreeNode(15)\n    root.left_child = BinaryTreeNode(10)\n    root.right_child = BinaryTreeNode(25)\n    root.left_child.left_child = BinaryTreeNode(6)\n    root.left_child.right_child = BinaryTreeNode(14)\n    root.right_child.left_child = BinaryTreeNode(20)\n    root.right_child.right_child = BinaryTreeNode(60)\n    return root\n\n# Function to test the solution\ndef check_solution(func):\n    tree = make_tree()\n    result = func(tree)\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n    print(\"Solution is correct.\")\n\n# Test the function\ncheck_solution(enhanced_inorder_traversal)\n```\n\n### Note\nEnsure your implementation is efficient and handles edge cases such as an empty tree or very deep trees. Use an iterative approach to avoid stack overflow issues.",
  "solution_code": "from typing import List, Optional\n\nclass BinaryTreeNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left_child: Optional[BinaryTreeNode] = None\n        self.right_child: Optional[BinaryTreeNode] = None\n\ndef enhanced_inorder_traversal(root: Optional[BinaryTreeNode]) -> List[int]:\n    \"\"\"\n    Perform an inorder traversal of a BST iteratively and return the sorted list of node values.\n    \"\"\"\n    if root is None:\n        return []\n    \n    stack = []\n    current = root\n    result = []\n    \n    while stack or current:\n        # Reach the left most Node of the current Node\n        while current:\n            stack.append(current)\n            current = current.left_child\n        \n        # Current must be None at this point\n        current = stack.pop()\n        result.append(current.data)\n        \n        # We have visited the node and its left subtree. Now, it's right subtree's turn\n        current = current.right_child\n    \n    return result",
  "test_code": "import pytest\n\ndef test_enhanced_inorder_traversal():\n    class BinaryTreeNode:\n        def __init__(self, data: int) -> None:\n            self.data = data\n            self.left_child: Optional[BinaryTreeNode] = None\n            self.right_child: Optional[BinaryTreeNode] = None\n\n    def make_tree() -> BinaryTreeNode:\n        root = BinaryTreeNode(15)\n        root.left_child = BinaryTreeNode(10)\n        root.right_child = BinaryTreeNode(25)\n        root.left_child.left_child = BinaryTreeNode(6)\n        root.left_child.right_child = BinaryTreeNode(14)\n        root.right_child.left_child = BinaryTreeNode(20)\n        root.right_child.right_child = BinaryTreeNode(60)\n        return root\n\n    result = enhanced_inorder_traversal(make_tree())\n    expected = [6, 10, 14, 15, 20, 25, 60]\n    assert result == expected, \"The result does not match the expected output.\"\n\ndef test_enhanced_inorder_traversal_empty_tree():\n    result = enhanced_inorder_traversal(None)\n    expected = []\n    assert result == expected, \"The result does not match the expected output for an empty tree.\"\n\ndef test_enhanced_inorder_traversal_single_node():\n    root = BinaryTreeNode(10)\n    result = enhanced_inorder_traversal(root)\n    expected = [10]\n    assert result == expected, \"The result does not match the expected output for a single node tree.\"\n\ndef test_enhanced_inorder_traversal_deeper_tree():\n    class BinaryTreeNode:\n        def __init__(self, data: int) -> None:\n            self.data = data\n            self.left_child: Optional[BinaryTreeNode] = None\n            self.right_child: Optional[BinaryTreeNode] = None\n\n    def make_deep_tree() -> BinaryTreeNode:\n        root = BinaryTreeNode(15)\n        root.left_child = BinaryTreeNode(10)\n        for i in range(50, 90, 10):  # Add nodes from 50 to 80 in steps of 10\n            current = root.left_child\n            while current.right_child:\n                current = current.right_child\n            current.right_child = BinaryTreeNode(i)\n        return root\n\n    result = enhanced_inorder_traversal(make_deep_tree())\n    expected = [50, 60, 70, 80, 90, 10, 15]\n    assert result == expected, \"The result does not match the expected output for a deeper tree.\"",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results0.jsonl"
}