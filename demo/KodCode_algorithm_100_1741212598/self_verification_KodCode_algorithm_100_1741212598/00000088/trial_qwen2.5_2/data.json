{
  "metadata": {
    "prompt_id": "00000088",
    "row_id": 88,
    "seed_ids": [
      61
    ],
    "mode": "algorithm"
  },
  "instruction": "### Analysis Begin\n\n#### Core Identification\n- **Algorithm/Data Structure**: Running Key Cipher.\n- **Complexity**: O(n), where n is the length of the plaintext/ciphertext.\n- **Principles**: The cipher encrypts each character of the plaintext by adding its corresponding character in the running key modulo 26. Decryption reverses this process by subtracting.\n\n#### Characteristics & Applications\n- **Properties**: \n  - Non-interchangeable: Characters depend on the running key and cannot be swapped independently.\n  - Case-sensitive: The cipher does not change case, maintaining uppercase for encrypted text.\n- **Common Use Cases**:\n  - Simple manual encryption/decryption for short messages.\n  - Educational purposes to understand basic encryption principles.\n- **Strengths/Limitations**:\n  - **Strengths**: Simple to implement, provides some level of security compared to plain substitution ciphers.\n  - **Limitations**: Weak against frequency analysis and susceptible to length extension attacks.\n\n#### Implementation Challenges\n- **Edge Cases**:\n  - Key and plaintext/ciphertext must be upper-case and without spaces.\n  - Plaintext and ciphertext can be very long, so performance needs to be efficient.\n- **Performance Bottlenecks**:\n  - Repeated modulo operation can be slow for large inputs.\n- **Error Scenarios**:\n  - Incorrect handling of edge cases like key length being shorter than plaintext.\n- **Optimization Points**:\n  - Use of string methods and modulo operation can be optimized for better performance.\n\n### Question Begin\n\nA student is asked to implement a Running Key Cipher for a text-based communication system. The cipher encrypts and decrypts messages using a running key, which is a long piece of text. Your task is to enhance the functionality of the provided `running_key_encrypt` and `running_key_decrypt` functions and add a new feature to the system.\n\n#### Function Specifications\n- **running_key_encrypt(key: str, plaintext: str) -> str**\n  - Encrypts the plaintext using the Running Key Cipher.\n  - :param key: The running key (long piece of text).\n  - :param plaintext: The plaintext to be encrypted.\n  - :return: The ciphertext.\n- **running_key_decrypt(key: str, ciphertext: str) -> str**\n  - Decrypts the ciphertext using the Running Key Cipher.\n  - :param key: The running key (long piece of text).\n  - :param ciphertext: The ciphertext to be decrypted.\n  - :return: The plaintext.\n- **running_key_encrypt_and_decrypt(key: str, message: str) -> (str, str)**\n  - Encrypts and then decrypts the message to ensure the original message is recovered.\n  - :param key: The running key (long piece of text).\n  - :param message: The message to be encrypted and then decrypted.\n  - :return: A tuple containing the ciphertext and the decrypted plaintext.\n\n#### Constraints and Limitations\n- The `key` and `message` strings are case-sensitive and can contain only uppercase letters.\n- The length of the `key` is at least as long as the `message`.\n- The `message` can be up to 1000 characters long.\n\n#### Example\n```python\nkey = \"How does the duck know that? said Victor\"\nplaintext = \"DEFEND THIS\"\nciphertext, decrypted_text = running_key_encrypt_and_decrypt(key, plaintext)\nprint(f\"Ciphertext: {ciphertext}\")\nprint(f\"Decrypted Text: {decrypted_text}\")\n```\n\n#### Expected Output\n```\nCiphertext: FUGQHUBKH\nDecrypted Text: DEFEND THIS\n```\n\n### Question End\n\n### Analysis End",
  "solution_code": "def running_key_cipher(key: str, message: str, encrypt=True) -> str:\n    \"\"\"\n    Encrypts or decrypts the message using the Running Key Cipher.\n    \"\"\"\n    key = key.upper()\n    message = message.upper()\n    result = \"\"\n    key_index = 0\n    \n    for char in message:\n        if char.isalpha():\n            shift = ord(key[key_index]) - ord('A')\n            if encrypt:\n                result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            else:\n                result += chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n            key_index = (key_index + 1) % len(key)\n        else:\n            result += char\n    \n    return result\n\ndef running_key_encrypt(key: str, plaintext: str) -> str:\n    \"\"\"\n    Encrypts the plaintext using the Running Key Cipher.\n    \"\"\"\n    return running_key_cipher(key, plaintext, encrypt=True)\n\ndef running_key_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts the ciphertext using the Running Key Cipher.\n    \"\"\"\n    return running_key_cipher(key, ciphertext, encrypt=False)\n\ndef running_key_encrypt_and_decrypt(key: str, message: str) -> (str, str):\n    \"\"\"\n    Encrypts and then decrypts the message to ensure the original message is recovered.\n    \"\"\"\n    ciphertext = running_key_encrypt(key, message)\n    decrypted_text = running_key_decrypt(key, ciphertext)\n    return ciphertext, decrypted_text",
  "test_code": "from solution import running_key_encrypt, running_key_decrypt, running_key_encrypt_and_decrypt\n\ndef test_running_key_cipher():\n    assert running_key_cipher(\"HOW\", \"defend\", encrypt=True) == \"fugqh\"\n    assert running_key_cipher(\"HOW\", \"fugqh\", encrypt=False) == \"DEFEND\"\n\ndef test_running_key_encrypt():\n    key = \"HOW DOES THE DUCK KNOW THAT? SAID VICTOR\"\n    plaintext = \"DEFEND THIS\"\n    ciphertext = running_key_encrypt(key, plaintext)\n    assert ciphertext == \"FUGQHUBKH\"\n\ndef test_running_key_decrypt():\n    key = \"HOW DOES THE DUCK KNOW THAT? SAID VICTOR\"\n    ciphertext = \"FUGQHUBKH\"\n    plaintext = running_key_decrypt(key, ciphertext)\n    assert plaintext == \"DEFEND THIS\"\n\ndef test_running_key_encrypt_and_decrypt():\n    key = \"HOW DOES THE DUCK KNOW THAT? SAID VICTOR\"\n    message = \"DEFEND THIS\"\n    ciphertext, decrypted_text = running_key_encrypt_and_decrypt(key, message)\n    assert ciphertext == \"FUGQHUBKH\"\n    assert decrypted_text == \"DEFEND THIS\"\n\ndef test_edge_cases():\n    key = \"A A A A A\"\n    plaintext = \"TEXT\"\n    ciphertext, decrypted_text = running_key_encrypt_and_decrypt(key, plaintext)\n    assert ciphertext == \"UVWX\"\n    assert decrypted_text == \"TEXT\"\n\n    key = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    plaintext = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    ciphertext, decrypted_text = running_key_encrypt_and_decrypt(key, plaintext)\n    assert ciphertext == \"ZABCDEFGHIJKLMNOPQRSTUVWXY\"\n    assert decrypted_text == \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    key = \"\"\n    plaintext = \"A\"\n    assert running_key_encrypt(key, plaintext) == \"A\"\n    assert running_key_decrypt(key, \"A\") == \"A\"",
  "file_source": "KodCode_questions2sv_algorithm_100_1741212598_sanitized_prepared_results2.jsonl"
}