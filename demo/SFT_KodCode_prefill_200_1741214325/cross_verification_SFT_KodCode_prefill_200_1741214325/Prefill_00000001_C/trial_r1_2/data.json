{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000001_C",
  "question": "def selection_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    >>> selection_sort([64, 25, 12, 22, 11])\n    [11, 12, 22, 25, 64]\n    >>> selection_sort([-64, -25, -12, -22, -11])\n    [-64, -25, -22, -12, -11]\n    >>> selection_sort([-1, 5, -7, 8, 0, 12, 10])\n    [-7, -1, 0, 5, 8, 10, 12]\n    >>> selection_sort([5])\n    [5]\n    >>> selection_sort([])\n    []\n    \"\"\"",
  "solution": "def selection_sort(arr):\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum element in remaining unsorted array\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Swap the found minimum element with the first element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
  "test_code": "from solution import selection_sort\n\ndef test_selection_sort_with_positive_numbers():\n    assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]\n\ndef test_selection_sort_with_negative_numbers():\n    assert selection_sort([-64, -25, -12, -22, -11]) == [-64, -25, -22, -12, -11]\n\ndef test_selection_sort_with_mixed_numbers():\n    assert selection_sort([-1, 5, -7, 8, 0, 12, 10]) == [-7, -1, 0, 5, 8, 10, 12]\n\ndef test_selection_sort_with_single_element():\n    assert selection_sort([5]) == [5]\n\ndef test_selection_sort_with_empty_list():\n    assert selection_sort([]) == []",
  "test_info": [
    {
      "function_name": "selection_sort",
      "parameter_list": "(arr)",
      "function_declaration": "def selection_sort(arr):",
      "docstring": "Sorts an array using the selection sort algorithm.\n:param arr: List of integers to be sorted\n:return: Sorted list of integers"
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, I need to write a selection sort function in Python. Wait, selection sort is one of those sorting algorithms I've heard about. Let me think about how it works.\n\nSo, selection sort works by selecting the smallest element from the unsorted part of the array and putting it at the beginning of the unsorted part. Then, it's kind of like building the sorted array one element at a time.\n\nLet me visualize this. Suppose I have an array like [64, 25, 12, 22, 11]. The first step is to find the smallest element in the array, which is 11, and swap it with the first element. So the array becomes [11, 25, 12, 22, 64]. \n\nThen, I move to the next position. I look for the smallest element in the remaining part, which is from index 1 onwards. The smallest is 12, so I swap it with the element at index 1. Now it's [11, 12, 25, 22, 64].\n\nI repeat this process: each time, I look at the next unsorted section, find the smallest, bring it to the front of the unsorted part, and so on until the array is fully sorted.\n\nSo, for the implementation, I'll need a loop that goes through each position in the array. For each position, I'll find the minimum value in the remaining unsorted part and swap it into place.\n\nHmm, how do I structure this in code? Let's think.\n\nI can iterate through the array from 0 to len(arr) - 1. For each i, I need to find the index of the minimum element in the subarray arr[i:]. Once I find that index, say j, I swap arr[i] and arr[j].\n\nWait, but wait: after each swap, the portion before i is already sorted, right? So, I don't need to check that again.\n\nLet me outline the steps with the example [64,25,12,22,11]. \n\ni starts at 0:\n- Look for min in [64,25,12,22,11]. Min is 11 at index 4.\n- Swap 64 and 11: [11,25,12,22,64]\n\ni is 1:\n- Look for min in [25,12,22,64]. Min is 12 at index 2.\n- Swap 25 and 12: [11,12,25,22,64]\n\ni is 2:\n- Look for min in [25,22,64]. Min is 22 at index 3.\n- Swap 25 and 22: [11,12,22,25,64]\n\ni is 3:\n- Look for min in [25,64]. Min is 25, swap with itself, no change.\n\ni is 4, loop ends.\n\nSo, that gives the sorted array.\n\nSo, in code, for each i from 0 to len(arr)-1:\n\n- Find the index j where arr[j] is the minimum in arr[i...end]\n- Swap arr[i] and arr[j]\n\nHow to implement this in Python.\n\nSo, the function definition is given as def selection_sort(arr: List[int]) -> List[int]:\n\nWait, but wait: do I modify the original array or create a new one? In the examples, it seems like the function returns the sorted array, so it's probably a new array or a sorted version, not in-place. Or wait, wait\u2014selection sort as taught is usually an in-place algorithm. Hmm, but since lists are mutable in Python, but when we call the function, it's given as an argument\u2014so modifying it would change the original. But perhaps, to avoid side effects, it's better to create a copy.\n\nBut let's see the examples:\n\nOne of the test cases is selection_sort([5]) which returns [5]. If I create a copy, that might be better. Or, perhaps in the code, we don't worry because the function is written to return the sorted version, and the original arr is not modified. Hmm, but wait, in the third test case, selection_sort([-1,5,-7,8,0,12,10]) returns [-7,-1,0,5,8,10,12], which seems like a new array.\n\nSo, perhaps in the implementation, I should create a copy of the array to avoid modifying the original. Alternatively, I can work on a copy.\n\nWait, let me think: if in the selection_sort function, I do a deepcopy at the beginning, then work on that, that way the original array is not modified.\n\nBut alternatively, if I'm supposed to sort the array in-place, then no. But the test cases seem to just return the sorted array.\n\nWait, looking at the first test case, the input is [64,25,12,22,11], and the output is [11,12,22,25,64]. So the function needs to return the sorted list.\n\nTherefore, in the code, perhaps we create a copy of arr, then apply the selection sort on that copy, then return the sorted copy. Or perhaps we don't create a copy, and in-place sort the original arr.\n\nBut to avoid side effects, perhaps it's better to create a copy.\n\nWait, but wait: in the sample inputs, the function is called with certain lists, and the output is the sorted version. So, as the function is written, perhaps it's acceptable to modify the input array, since in a function call, when you pass a list, you're not required to keep it unchanged unless specified.\n\nAlternatively, perhaps the function can sort a copy of the array without modifying the original.\n\nHmm, but for the purpose of this problem, perhaps it's better to just proceed as if the array is mutable, and we work on it in place, as implementing it that way would be more straightforward. Because making a copy would require adding a line like arr = arr.copy(), or similar.\n\nSo, for the code, let's proceed under the assumption that we can modify the input array, but in any case, since it's a function that returns the sorted array, perhaps it's acceptable.\n\nSo, let's think about the code.\n\nInitialize n as the length of the array.\n\nLoop for i from 0 to n-1:\n\n   Find the minimum element in the subarray starting from i to end.\n\n   Let j be the index of that minimum.\n\n   Swap arr[i] with arr[j].\n\nSo, in Python, code:\n\nn = len(arr)\nfor i in range(n):\n    # Find the index of the min in arr[i:]\n    j = i\n    min_val = arr[i]\n    for k in range(i+1, n):\n        if arr[k] < min_val:\n            min_val = arr[k]\n            j = k\n    # Now, swap arr[i] and arr[j]\n    arr[i], arr[j] = arr[j], arr[i]\n\nWait, no. Wait, wait\u2014that inner loop finds the minimum value and its index correctly?\n\nWait: initially, min_val is arr[i], and j is i. Then, for each k from i+1 to n-1, if arr[k] is less than min_val, then update min_val and j.\n\nYes, that will correctly find the minimum in the subarray arr[i...n-1].\n\nSo, after that, swap.\n\nYes.\n\nSo, putting this into code.\n\nWait, but I should also handle empty list, which is one of the test cases, and single-element list. But the code as written will handle them. Because if n = 0, the loop doesn't run; if n=1, i=0, the inner loop runs from i+1=1, which is beyond, so no problem.\n\nSo, putting it together.\n\nWait, but wait\u2014 the sample input includes a case with negative numbers, like [-64, -25, -12, -22, -11]. I think the code handles that correctly, as the comparison is correct.\n\nSo the code as written should handle all cases.\n\nWait, but wait again: does the function expect to return a new list, leaving the original unmodified? Or does it sort in place?\n\nBecause the code as written modifies the original list.\n\nIn the first sample input, the function is called as selection_sort([64,25,12,22,11]), and the test expects [11, 12, 22, 25, 64]. So if the function modifies the input list, that's acceptable as long as the returned value is correct.\n\nWait, but the code as written is modifying the array that is passed into the function because lists are mutable. So the function will change the original arr. But in the test cases, when it calls the function, the arguments are literals, so perhaps it's acceptable.\n\nWait, but perhaps to make it more standard, the function should create a copy of the array and sort the copy, leaving the original array unmodified. So, to avoid in-place modification.\n\nYes, perhaps that's better. So, in the function, the first step is to create a copy of the array.\n\nLike this:\n\ndef selection_sort(arr: List[int]) -> List[int]:\n    arr_copy = arr.copy()  # Or arr[:] to make a shallow copy\n    n = len(arr_copy)\n    # Then proceed with the sorting as before.\n\nWait, but wait\u2014 I can just make a new list, like new_arr = list(arr), then proceed to sort new_arr. So yes.\n\nLet me rewrite the code:\n\ndef selection_sort(arr: List[int]) -> List[int]:\n    arr = list(arr)  # Creates a new list, copying elements\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum in arr[i...n-1]\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        # Swap the found minimum with arr[i]\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n\nYes, that should do it. Let me test it with the sample inputs.\n\nSample 1: [64,25,12,22,11]\n\nThe code will loop i from 0 to 4.\n\ni=0: min is at index 4 (11), swap 0 and 4 \u2192 [11,25,12,22,64]\n\ni=1: look from 1 to end. The min is 12 at index 2 \u2192 swap 1 and 2 \u2192 [11,12,25,22,64]\n\ni=2: look from 2 \u2192 arr[2]=25, min is 22 at index 3 \u2192 swap \u2192 [11,12,22,25,64]\n\ni=3 \u2192 look from 3: min is 25 and 64, so remains at 3.\n\ni=4: nothing to do.\n\nSo the output is as expected.\n\nAnother test case: [-64, -25, -12, -22, -11]\n\ni=0: the min is -64? Wait, wait, wait: wait, because in that array, the elements are -64, -25, -12, -22, -11. Wait, the min is -64, but then for i=0, the min is at 0, so no swap.\n\nWait, no, wait: the list is [ -64, -25, -12, -22, -11 ]\n\nWait, wait: no, the sample expects the sorted array as [-64, -25, -22, -12, -11]. Or wait, wait the sample input is [-64, -25, -12, -22, -11], expected output is [-64, -25, -22, -12, -11]. So let's see.\n\nWait wait no, wait the sample:\n\nSample input 2: selection_sort([-64, -25, -12, -22, -11]) \u2192 expected output is [-64, -25, -22, -12, -11].\n\nWait wait no: looking back, sample input 2 is [ -64, -25, -12, -22, -11 ].\n\nWait no: sample input 2 is [-64, -25, -12, -22, -11], and the expected output is [-64, -25, -22, -12, -11].\n\nWait wait that can't be correct, because the original array is [ -64, -25, -12, -22, -11 ].\n\nThe correct sorted order is [-64, -25, -22, -12, -11 ]? Wait no, that's not correct because -64 is the smallest, but -25 is larger than -64, -12 is larger, -22 is larger than -25?\n\nWait wait no\u2014 wait the numerical order is:\n\n-64 \u2192 -25 \u2192 -22 \u2192 -12 \u2192 -11.\n\nWait no: in integers, -12 is larger than -22.\n\nSo, for the sample input [-64, -25, -12, -22, -11], the sorted order should be [-64, -25, -22, -12, -11], right?\n\nWait: wait, selecting the elements numerically from smallest to largest:\n\n-64 is the smallest. Then, among the rest, the next smallest is -25. Then, next is -22 (since -22 is greater than -25), then -12 is next (since it's greater than -22), then -11.\n\nSo the sample expects that.\n\nWait wait in the code, for i=0, the minimum is -64.\n\nSo in this case, the code leaves [ -64, then from i=1 onward.\n\nThen for i=1, looking for min in [ -25, -12, -22, -11 ] \u2192 the min is -25. So no swap needed.\n\nWait, no: when i=1, the subarray is starting from index 1. The arr is [ -64, -25, -12, -22, -11 ]\n\nWait, after i=0, the array remains as [-64, -25, -12, -22, -11], but wait no, because during i=0, in the first iteration, the code would have found the minimum in the whole array which is -64, which is at 0, so no swap.\n\nThen, for i=1, the subarray is arr[1:] \u2192 [-25, -12, -22, -11]. The min is -25, so no swap.\n\nWait, but that's not correct. Because in that case, the subarray includes -25 as the first element. Wait, but wait no\u2014 the subarray starts at i=1, which is -25, then the elements are -12, -22, -11.\n\nWait wait, -25 is the starting point. The min in the subarray is -25, because among -25, -12, -22, -11, the smallest is -25?\n\nWait, wait no: no. Because -25 is larger than all the other elements in the subarray.\n\nWait, wait wait\u2014 wait no: in the subarray [-25, -12, -22, -11], the elements are all in [i=1's subarray].\n\nThe min is the smallest among those elements. So comparing:\n\n-25 is -25.\n\n-12 is -12, which is larger than -25.\n\n-22 is -22, which is smaller than -25.\n\nWait that's right, because -22 is less than -25? Wait no: wait -25 is -25, which is less than -22.\n\nWait wait no: Wait, numerically, -22 is larger than -25. So as numbers, -22 is greater than -25. So in this subarray, -25 is the smallest.\n\nTherefore, for i=1, the min remains at index 1, so no swap.\n\nSo in the code, the array after i=1 remains as [-64, -25, -12, -22, -11].\n\nThen, for i=2:\n\nThe subarray is from index 2: [-12, -22, -11].\n\nThe minimum is -22, which is at index 3.\n\nSo in the code, j is found as 3.\n\nSwap arr[2] (which is -12) with arr[3] (which is -22). So after swap, the array becomes:\n\n[-64, -25, -22, -12, -11]. \n\nWhich is correct.\n\nBut wait, that's because the code swaps correctly.\n\nSo the code should produce the correct output.\n\nSo after that, the loop continues. Another test case shows that the code works for negative numbers as well.\n\nAnother sample input: [-1,5,-7,8,0,12,10]\n\nThe expected output is [-7,-1,0,5,8,10,12].\n\nLet me see what the code does.\n\nThe initial array is [ -1, 5, -7, 8, 0, 12, 10 ].\n\ni=0:\n\nfind min from [ -1,5,-7,8,0,12,10 ].\n\nThe min is -7 at index 2.\n\nSwap with i=0 \u2192 array becomes [ -7,5,-1,8,0,12,10 ]\n\ni=1:\n\nfind min in [5,-1,8,0,12,10] \u2192 the min is -1 at index 2.\n\nSwap 5 and -1 \u2192 [ -7,-1,5,8,0,12,10 ]\n\ni=2:\n\nfind min in 5,8,0,12,10 \u2192 the min is 0 at index 4.\n\nSwap 5 and 0 \u2192 [ -7,-1,0,8,5,12,10 ]\n\nWait, but wait, after i=2 (which is the third element position, zero-based), i=2 is the index where we place the next sorted element.\n\nSo during i=2, the code is looking for the minimum from arr[2], which is 5, then 8, 0, etc. The minimum is 0 at j=4.\n\nSwapping 0 and the current element (5) gives:\n\nAfter swap: [ -7, -1, 0,8,5,12,10 ]\n\nContinue:\n\ni=3:\n\nLooking from index 3, which is 8. subarray is [8,5,12,10]. The min is 5 at index 4.\n\nSwap 8 and 5 \u2192 [ -7, -1, 0,5,8,12,10 ]\n\ni=4: look from index 4, the subarray is [8,12,10]. The min is 8 at 4; no swap.\n\ni=5: look at [12,10]. Min is 10 at 6. Swap 12 and 10 \u2192 [ -7,-1,0,5,8,10,12 ]\n\ni=6: nothing to do.\n\nSo the final array is as expected: [ -7,-1,0,5,8,10,12 ].\n\nWait, but the expected output is [ -7, -1, 0, 5, 8, 10, 12 ] which matches.\n\nSo, the code works.\n\nBut wait, in the code we made a copy of the array at the beginning. So the code is not modifying the original array; it's making a copy and sorting the copy.\n\nTherefore, the code should return the correct sorted array.\n\nSo, I think this code should pass all the sample test cases.\n</think>\n\nTo solve this problem, we need to implement the selection sort algorithm to sort an array of integers in ascending order. The selection sort algorithm works by repeatedly finding the minimum element from the unsorted part of the array and swapping it with the first element of the unsorted part. This process is repeated until the entire array is sorted.\n\n### Approach\n1. **Initialization**: Create a copy of the input array to avoid modifying the original array. This is done using `list(arr)` which creates a shallow copy of the list.\n2. **Iterate through the array**: For each element starting from the first to the second last element, find the minimum element in the unsorted part of the array.\n3. **Find the minimum element**: For each starting index of the unsorted part, iterate through the rest of the array to find the minimum element and its index.\n4. **Swap elements**: Once the minimum element in the unsorted part is found, swap it with the first element of the unsorted part.\n5. **Repeat**: Continue this process until the entire array is sorted.\n\n### Solution Code\n\n```python\nfrom typing import List\n\ndef selection_sort(arr: List[int]) -> List[int]:\n    arr = list(arr)  # Create a copy of the input list\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n```\n\n### Explanation\n- **Initialization**: The function starts by creating a copy of the input list to ensure the original list remains unchanged.\n- **Outer Loop**: The outer loop runs from the start of the list to the second last element. This loop iterates over each element that will eventually be placed in its sorted position.\n- **Inner Loop**: The inner loop finds the minimum element in the unsorted part of the list starting from the current position of the outer loop.\n- **Swapping**: Once the minimum element is found, it is swapped with the element at the current position of the outer loop, effectively moving the smallest unsorted element to its correct position in the sorted part of the list.\n- **Efficiency**: The algorithm has a time complexity of O(n^2), which is efficient for small lists but not optimal for large datasets. However, it is simple to implement and works well for educational purposes.\n\nThis approach ensures that the list is sorted in ascending order while maintaining clarity and simplicity in the implementation.",
  "r1_solution": "from typing import List\n\ndef selection_sort(arr: List[int]) -> List[int]:\n    arr = list(arr)  # Create a copy of the input list\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
  "metadata": {
    "prompt_id": "00000001",
    "row_id": 1,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to sort an array using the selection sort algorithm."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results2.jsonl"
}