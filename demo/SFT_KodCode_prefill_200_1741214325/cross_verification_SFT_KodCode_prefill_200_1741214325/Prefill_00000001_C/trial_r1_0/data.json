{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000001_C",
  "question": "def selection_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    >>> selection_sort([64, 25, 12, 22, 11])\n    [11, 12, 22, 25, 64]\n    >>> selection_sort([-64, -25, -12, -22, -11])\n    [-64, -25, -22, -12, -11]\n    >>> selection_sort([-1, 5, -7, 8, 0, 12, 10])\n    [-7, -1, 0, 5, 8, 10, 12]\n    >>> selection_sort([5])\n    [5]\n    >>> selection_sort([])\n    []\n    \"\"\"",
  "solution": "def selection_sort(arr):\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum element in remaining unsorted array\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Swap the found minimum element with the first element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
  "test_code": "from solution import selection_sort\n\ndef test_selection_sort_with_positive_numbers():\n    assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]\n\ndef test_selection_sort_with_negative_numbers():\n    assert selection_sort([-64, -25, -12, -22, -11]) == [-64, -25, -22, -12, -11]\n\ndef test_selection_sort_with_mixed_numbers():\n    assert selection_sort([-1, 5, -7, 8, 0, 12, 10]) == [-7, -1, 0, 5, 8, 10, 12]\n\ndef test_selection_sort_with_single_element():\n    assert selection_sort([5]) == [5]\n\ndef test_selection_sort_with_empty_list():\n    assert selection_sort([]) == []",
  "test_info": [
    {
      "function_name": "selection_sort",
      "parameter_list": "(arr)",
      "function_declaration": "def selection_sort(arr):",
      "docstring": "Sorts an array using the selection sort algorithm.\n:param arr: List of integers to be sorted\n:return: Sorted list of integers"
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, I need to write a selection sort function in Python. Hmm, selection sort works by repeatedly finding the minimum element from the unsorted part and swapping it to the beginning of the unsorted part. Right.\n\nLet me think about the steps. So for each iteration, I find the smallest element in the array starting from the current position. Once I find that, I swap it with the current element.\n\nSo the array can be divided into two parts: the sorted part at the beginning and the unsorted part. Initially, the sorted part is empty, and the unsorted part is the entire array.\n\nHow do I loop through this? I guess for each i from 0 to len(arr)-1. For each i, I find the minimum in the subarray from i to end, then swap arr[i] with that min.\n\nWait, but actually, in selection sort, in each pass, I look for the minimum of the unsorted subarray and swap it into place.\n\nLet me outline this. I'll have a variable min_pos which will track the position of the minimum element in the unsorted part. Initially, for each i, the unsorted part starts at i, so I set min_pos to i.\n\nThen I loop from j = i+1 to len(arr), comparing each element to see if I can find a smaller one. If I do, min_pos is updated.\n\nOnce I've scanned the entire unsorted part, I swap arr[i] with arr[min_pos].\n\nBut wait, what about handling duplicates? Well, selection sort will work correctly regardless, since if a duplicate is found, it'll just have the same value and doesn't affect the order.\n\nWhat about the edge cases? Like when the array is empty or has one element, then the function should return immediately without any changes. That's handled by the default loop, as it won't execute when len(arr) is 0 or 1.\n\nOkay, so I'll write a loop for i in range(len(arr)), then within that, find the min in arr[i:len(arr)].\n\nLet me sketch this with code.\n\nInitialize the loop for i in range(len(arr)):\n\nThen, set min_pos = i.\n\nThen for j in range(i+1, len(arr)):\n\nIf arr[j] < arr[min_pos], then min_pos = j.\n\nAfter finding the min_pos, swap the values.\n\nWait, but in the examples provided, when the array has negative numbers, selection sort correctly arranges them. So my code shouldn't have any issues with negatives.\n\nWait, no, in the second example, [-64, -25, -12, -22, -11], the sorted order is [-64, -25, -22, -12, -11], which is correct. So comparing with < should handle it because -22 is less than -12, so it will be swapped correctly.\n\nTesting the functions:\n\nWait, in the first test case selection_sort([64,25,12,22,11]) returns [11,12,22,25,64], which happens after each minimum is selected and moved to the front.\n\nLet me test the code step by step on that test case.\n\nOriginal array: [64,25,12,22,11]\n\ni = 0:\n\nfind min in [64,25,12,22,11] which is 11 at position 4. Swap with index 0: array becomes [11,25,12,22,64]\n\ni=1:\n\nSubarray is [25,12,22,64]. Min is 12 at position 2. Swap 25 and 12: array is [11,12,25,22,64]\n\ni=2:\n\nSubarray [25,22,64]. Min is 22 at position 3. Swap 25 and 22: array becomes [11,12,22,25,64]\n\ni=3:\n\nSubarray [25,64]. Min is 25, which is current position, so no swap.\n\ni=4: nothing left.\n\nSo the final array is correct.\n\nAnother test case selection_sort([-1,5,-7,8,0,12,10]):\n\nAfter sorting, it should be [-7, -1, 0,5,8,10,12].\n\nLet's see how the algorithm would process this.\n\nBut perhaps it's better to rely on the code to correctly handle it.\n\nSo writing the code.\n\nWait, in Python, I can have the function take a list of integers and return the sorted list.\n\nFirst, I need to make a copy of the array to avoid modifying the original, or perhaps just process it in-place. However, looking at the examples, it looks like the function returns the sorted list, but the original is not modified (since the function is a selection_sort function). So I can create a new list, but if the input is a list, perhaps just sort it in-place.\n\nWait, in Python, list assignments modify the list itself. So if the function is given an argument arr, and we modify it, the original will change. However, the function is supposed to return the sorted list, but perhaps it's better not to modify the input.\n\nWait, the examples don't show whether the function is modifying the original. Well, perhaps it's intended to not modify the input, like sorted() function, so better to create a copy.\n\nWait, but looking at the function definition:\n\nIn the examples, they call selection_sort with a list and it returns a new sorted list, but it's unclear whether the original list is changed. So perhaps better to create a copy at the beginning.\n\nAlternatively, since selection sort is in-place, but for the function's purpose, perhaps it's acceptable to change the list in-place and return it.\n\nEither way, the code can proceed.\n\nSo code sketch:\n\ndef selection_sort(arr: List[int]) -> List[int]:\n    # make a copy of arr to avoid modifying the original\n    # Or, perhaps not? Since in the first sample input, the argument is [64,..], but the same list is not used elsewhere. It's better to avoid side effects, so perhaps the function should create a copy and sort that.\n\n    # so, creating a new list.\n    sorted_arr = list(arr)\n    \n    for i in range(len(sorted_arr)):\n        min_pos = i\n        for j in range(i+1, len(sorted_arr)):\n            if sorted_arr[j] < sorted_arr[min_pos]:\n                min_pos = j\n        # swap the found min with index i\n        sorted_arr[i], sorted_arr[min_pos] = sorted_arr[min_pos], sorted_arr[i]\n    return sorted_arr\n\nWait, but wait, what if the array is empty? Then the loop doesn't run. So the code is safe.\n\nTesting the code with the examples:\n\nFirst example: [64,25,12,22,11] \u2192 after the loops, it becomes [11,12,22,25,64]. Which is correct.\n\nSecond example: [-64, -25, -12, -22, -11]. Let's see.\n\ni=0:\n\nSubarray from 0 is all, min is -64 at 0? Wait, no: the elements are [-64, -25, -12, -22, -11]. The min is -64, nothing to do.\n\ni=1:\n\nSubarray [-25, -12, -22, -11]. Min is -25 is at 1.\n\nNo, wait no:\n\nWait, the subarray for i=1 is starting from index 1. So in this case, the elements are: -25, -12, -22, -11.\n\nThe min is -25 at position 1? Because -25 is larger than -12 and so on. Wait, wait no. Wait, the array for i=1 is the subarray [ -25, -12, -22, -11]. The smallest element is -25? No, because -25 is larger than -11, which is smaller.\n\nWait no:\n\nWait, the elements in positions 1 to 4 are [-25, -12, -22, -11]. Which is smaller: comparing all of them, the smallest is -25? No, wait -25 is -25. The next elements are -12, which is larger than -25, then -224? No, wait no. Wait wait, I think I'm mixing numbers.\n\nWait no, in the array [-64 is fixed, then] for i=1, the subarray is [-25, -12, -22, -11]. So in this subarray, the elements are -25, -12, -22, -11.\n\nWhich is the smallest? Let's compare:\n\n-25 is at index 1.\n\nCompare with index 2: -12 is larger.\n\nindex 3: -22 is larger than -25? No, because -22 is -22 which is larger than -25? Wait no. Oh wait, no: numbers are negative. So -25 is less than -22. So the smallest in the subarray is -25, at index 1.\n\nWait no. Because between -25 and the rest, which is smaller?\n\nWait the elements in the subarray are -25, -12, -22, -11.\n\nWait, for each element:\n\n-25 < -12? Yes, because -25 is further to the left on the number line.\n\nBut then comparing to -22: wait, no, because -25 < -22? No: -25 is less than -22? Because it's more negative. So yes, -25 < -22. Similarly, -25 < -11.\n\nSo the minimum in the subarray is -25, at index 1. So no swap needed.\n\nBut the expected output after sorting is [ -64, -25, -22, -12, -11 ].\n\nWait wait, what's the correct sorted version. The second example expects [-64, -25, -22, -12, -11].\n\nWait that's not the correct sorted order. Because the expected output in the example is [-64, -25, -22, -12, -11], but arranging them from low to high, all are -64 < -25, then comes which is the next smallest. Let's arrange the array: -64 is the smallest, then looking for the next in [-25, -12, -22, -11].\n\nWait that subarray after -64 is fixed. The min in the subarray is -25, which is correct. Then i=2, searching from 2 to end. The elements are -12, -22, -11.\n\nThe min is -22, which is at position 3. So we swap with index 2: exchanging -12 and -22.\n\nSo after that, the array becomes [ -64, -25, -22, -12, -11 ].\n\nWhich matches the expected output.\n\nBut according to the code, when i=2, the code will scan from 3 and 4 for j.\n\nWait wait, wait. For i=2, the code is looking for the minimum starting from j=i+1 (which is 3) to end.\n\nIn the subarray [ -12, -22, -11 ]:\n\nWait, in the loop, j starts at i+1=3, then up to 4.\n\nThe initial min_pos is i=2 (value -12).\n\nAt j=3, the value is -22, which is less than -12, so min_pos is 3.\n\nThen j=4: value is -11, which is larger than -22, so min_pos remains 3.\n\nSo after the loop, we swap index 2 and 3: -12 and -22, resulting in the element at 2 being -22 and 3 being -12.\n\nSo the code will correctly generate the expected output.\n\nAnother test case: [5], returns [5]. The code handles that.\n\nEmpty array: returns empty.\n\nThird example: [-1,5,-7,8,0,12,10]. Expected output [-7, -1, 0,5,8,10,12] when sorted.\n\nLet me see how the code would process this.\n\ni=0:\n\nsubarray [-1,5,-7,8,0,12,10]\n\nmin is in this entire array: -7 at index 2. So swap with index 0.\n\nResult: [-7,5,-1,8,0,12,10 ]\n\ni=1:\n\nsubarray [5,-1,8,0,12,10]. Min is -1 at index 2. swap with 1.\n\nResult: [-7,-1,5,8,0,12,10 ]\n\ni=2:\n\nsubarray [5,8,0,12,10]\n\nmin is 5? Wait no, looking at j=3 (0) which is less than 5. Wait wait, j starts from 3, which is 2+1=3.\n\nSo subarray for i=2 is [5,8,0,12,10]. So elements are 5,8,0, etc.\n\nStarting with min_pos=2 (element 5). j runs from 3 to 6.\n\nAt j=3: 0 <5 \u2192 min_pos becomes 3.\n\nCheck j=4: 12 no.\n\nj=5: 10 <5? No.\n\nSo min is position 3 (0). So swap 5 and 0.\n\nArray becomes: [-7,-1,0,8,5,12,10 ]\n\ni=3:\n\nsubarray [8,5,12,10]\n\nmin is 5 at index 4. swap with i=3.\n\nArray becomes: [-7,-1,0,5,8,12,10 ]\n\ni=4:\n\nsubarray [8,12,10]. Min is 8? No, wait j=5 and 6: 12 and 10.\n\nWait i=4: j ranges 5 and 6.\n\nWait the subarray is [8,12,10].\n\nmin_pos is 4 (8). j=5:12>8 \u2192 no change.\n\nj=6:10>8? No. 10 is bigger than 8? No, 10 is bigger than 8, so 8 is still smaller.\n\nSo min_pos remains 4. No swap.\n\ni=4 completes.\n\ni=5:\n\nsubarray [12,10]. min is 10 at j=6. Swap i=5 (12) with j=6 (10). Now array has [...11,12] \u2192 so elements become [ ..5,8,10,12 ]\n\ni=6: no more elements.\n\nSo the final array is [-7,-1,0,5,8,10,12], which is correct.\n\nThus, the code seems to work.\n\nWait but in the third example, after i=2, the array is [-7,-1,0,8,5,12,10]?\n\nWait let's redo the third example:\n\nTest Case: [-1,5,-7,8,0,12,10]\n\nExpected after selection_sort: [-7,-1,0,5,8,10,12].\n\nLet me track step by step with the code.\n\nInitial sorted_arr is a copy: [-1,5,-7,8,0,12,10].\n\ni=0:\n\nmin_pos=0.\n\nCheck j from 1 to 6:\n\nj=1: 5> -1? No, 5 is >, else j=1 not less.\n\nj=2: -7 < -1 \u2192 yes. min_pos becomes 2.\n\nj=3: 8 not less.\n\nj=4:0 not less than -7.\n\nj=5:12> -7.\n\nj=6:10> -7.\n\nSo after all, min_pos is 2. Swap sorted_arr[0] and [2]. So array becomes:\n\n[-7, 5, -1,8,0,12,10]\n\ni=1:\n\nmin_pos starts at 1 (5).\n\nj=2: -1 <5 \u2192 yes, min_pos becomes 2.\n\nj=3:8>5.\n\nj=4:0>5? No \u2192 wait 0 <5 \u2192 0 is less than 5, so min_pos becomes 4.\n\nj=5:12>0? No, 12>0 is true, but 12>0 is 12 is larger than 0 \u2192 no change.\n\nj=6:10>0 \u2192 no change.\n\nSo min_pos is 4.\n\nSwap sorted_arr[1] (5) with sorted_arr[4] (0). So the array becomes:\n\n[-7,0,-1,8,5,12,10]\n\ni=2:\n\nmin_pos=2 (value -1).\n\nj runs from 3 to 6.\n\nelements: -1,8,5,12,10.\n\nWait, is -1 the minimum? Let's see.\n\nj=3: 8> -1. No change.\n\nj=4:5> -1. No change.\n\nj=5:12> -1. No change.\n\nj=6:10> -1. No change.\n\nSo no swap. Wait, but in the array at this point, the subarray starting at index 2 is [ -1, 8,5,12,10 ].\n\nYes, the min is -1, so no swap needed.\n\nWait but the expected is that after i=2, the array is [ -7,0, -1, 8,5,12,10 ]? Or am I misunderstanding.\n\nWait no, for i=2, the third element is -1. The code will look for the minimum in the subarray from index 3 onwards? No, wait i=2, so the subarray is from index 2 to end. But then, the code is looking for min starting from index 2, because for j=i+1.\n\nWait wait, wait correction: for each i, the code is scanning the entire array from i onwards. Oh, right! Because in the code, the inner loop runs j from i+1 to len(arr)-1. So min_pos could change.\n\nWait, for i=2, j runs from 3 to 6. So min_pos is 2 (value -1). Then, comparing with j=3, 4,5,6.\n\nIn the third test case, at i=2, the code will see that sorted_arr[j] for j=3 is 8, which is higher than sorted_arr[min_pos] (which is -1). So no change. So min remains 2.\n\nThus, no swap occurs. So after i=2, the array remains [ -7,0,-1,8,5,12,10 ].\n\nBut wait the expected is a 0 in position 1, but -1 in position 2, 0 comes before -1. Wait no, in the second pass of the outer loop, i=1, 0 has been swapped into position 1. Then in i=2, the code takes subarray [ -1, 8,5,12,10 ].\n\nSo swap occurs only if a smaller element is found in the unsorted part beyond i. Since none is found, the array remains as is.\n\nSo i=3:\n\nNow, the code loops to i=3.\n\nThe subarray is [8,5,12,10]. min_pos=3 (element8).\n\nj runs from 4,5,6.\n\nAt j=4: 5 <8 \u2192 min_pos=4.\n\nj=5:12>5 \u2192 no change.\n\nj=6:10>5 \u2192 no change.\n\nSo min_pos=4, which is element 5. So swap with i=3 (8) \u2192 becomes 5, and the swapped array is [ -7,0,-1,5,8,12,10 ].\n\nYes, this step correctly brings 5 before 8.\n\nThen i=4.\n\nSubarray starts at i=4: [8,12,10].\n\nmin is 8.\n\nBut looking for j=5 and j=6: 12 and 10.\n\nWait, j=5 is 12, not less than 8.\n\nj=6 is 10, which is less than 8 \u2192 min_pos=6.\n\nSo swap sorted_arr[4] (8) with sorted_arr[6] (10). Wait, so the array becomes [ -7,0,-1,5,10,12,8 ].\n\nWait that's worse. Did I make a mistake?\n\nWait no. Wait, subarray for i=4 is [8,12,10]. We need the minimum of this subarray. The elements are 8,12,10. The minimum is 8.\n\nSo min_pos is 4. Because for j=5, 12>8 \u2192 no change. j=6, 10>8? Yes, because 10>8 \u2192 8 is the minimum. So min_pos remains 4, so swap isn't done. So the array remains as at i=3.\n\nWait wait, what is sorted_arr[6]:10 <8? Yes, wait 10 is greater than 8? Wait 10 is larger than 8. So it's not less than.\n\nSo min_pos remains 4.\n\nSo no swap.\n\nThus, the subarray for i=4 remains [8,12,10], and the code doesn't swap.\n\nThen, moving to i=5.\n\nSubarray is [12,10].\n\nFind min.\n\nj runs from 6.\n\nsorted_arr[6] (10) is less than sorted_arr[5] (12). So min_pos=6.\n\nSwap sorted_arr[5] and [6], so the array becomes [ -7,0,-1,5,8,10,12 ].\n\nWhich is the expected output.\n\nSo the code is correct.\n\nTherefore, the code seems to handle all cases properly.\n\nThus, the final code should be:\n\ndef selection_sort(arr: List[int]) -> List[int]:\n    sorted_arr = list(arr)\n    for i in range(len(sorted_arr)):\n        min_pos = i\n        for j in range(i+1, len(sorted_arr)):\n            if sorted_arr[j] < sorted_arr[min_pos]:\n                min_pos = j\n        sorted_arr[i], sorted_arr[min_pos] = sorted_arr[min_pos], sorted_arr[i]\n    return sorted_arr\n</think>\n\nTo solve this problem, we need to implement the selection sort algorithm to sort an array in ascending order. Selection sort is an in-place comparison-based sorting algorithm that works by dividing the array into two parts: the sorted part and the unsorted part. Initially, the sorted part is empty, and the unsorted part is the entire array. For each iteration, the algorithm finds the minimum element from the unsorted part and swaps it to the beginning of the unsorted part, thus adding it to the sorted part.\n\n### Approach\n\n1. **Initialization**: Start by making a copy of the input array to avoid modifying the original array.\n2. **Outer Loop**: Iterate over each element of the array using an outer loop. This loop tracks the end of the sorted portion.\n3. **Inner Loop**: For each element in the outer loop, use an inner loop to find the minimum element in the unsorted portion (from the current position to the end of the array).\n4. **Comparison and Swap**: During the inner loop, compare each element to find the minimum. Once the minimum is found, swap it with the current element in the outer loop.\n5. **Iteration**: Continue this process until the entire array is sorted.\n\n### Solution Code\n\n```python\nfrom typing import List\n\ndef selection_sort(arr: List[int]) -> List[int]:\n    sorted_arr = list(arr)\n    for i in range(len(sorted_arr)):\n        min_pos = i\n        for j in range(i + 1, len(sorted_arr)):\n            if sorted_arr[j] < sorted_arr[min_pos]:\n                min_pos = j\n        # Swap the found minimum element to the current position\n        sorted_arr[i], sorted_arr[min_pos] = sorted_arr[min_pos], sorted_arr[i]\n    return sorted_arr\n```\n\n### Explanation\n\n- **Initialization**: The function starts by creating a copy of the input array to keep the original array unchanged.\n- **Outer Loop**: The outer loop runs from the start of the array to the end. For each index `i`, it considers the subarray starting from `i` to the end as the unsorted portion.\n- **Inner Loop**: The inner loop scans through the unsorted portion to find the smallest element. It updates the position of the minimum element found during this scan.\n- **Swapping**: After identifying the minimum element, it is swapped with the element at the current position `i`, effectively moving the minimum element to the sorted portion.\n- **Termination**: This process continues until all elements are sorted.\n\nThis approach ensures that each element is moved to its correct position in the sorted array, resulting in an overall time complexity of O(n^2), where n is the number of elements in the array. Although this is not the most efficient sorting algorithm, it is simple to implement and works well for small datasets.",
  "r1_solution": "from typing import List\n\ndef selection_sort(arr: List[int]) -> List[int]:\n    sorted_arr = list(arr)\n    for i in range(len(sorted_arr)):\n        min_pos = i\n        for j in range(i + 1, len(sorted_arr)):\n            if sorted_arr[j] < sorted_arr[min_pos]:\n                min_pos = j\n        # Swap the found minimum element to the current position\n        sorted_arr[i], sorted_arr[min_pos] = sorted_arr[min_pos], sorted_arr[i]\n    return sorted_arr",
  "metadata": {
    "prompt_id": "00000001",
    "row_id": 1,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to sort an array using the selection sort algorithm."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}