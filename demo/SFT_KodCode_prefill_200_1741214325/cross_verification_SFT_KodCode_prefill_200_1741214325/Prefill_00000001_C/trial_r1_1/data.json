{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000001_C",
  "question": "def selection_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    >>> selection_sort([64, 25, 12, 22, 11])\n    [11, 12, 22, 25, 64]\n    >>> selection_sort([-64, -25, -12, -22, -11])\n    [-64, -25, -22, -12, -11]\n    >>> selection_sort([-1, 5, -7, 8, 0, 12, 10])\n    [-7, -1, 0, 5, 8, 10, 12]\n    >>> selection_sort([5])\n    [5]\n    >>> selection_sort([])\n    []\n    \"\"\"",
  "solution": "def selection_sort(arr):\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum element in remaining unsorted array\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Swap the found minimum element with the first element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
  "test_code": "from solution import selection_sort\n\ndef test_selection_sort_with_positive_numbers():\n    assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]\n\ndef test_selection_sort_with_negative_numbers():\n    assert selection_sort([-64, -25, -12, -22, -11]) == [-64, -25, -22, -12, -11]\n\ndef test_selection_sort_with_mixed_numbers():\n    assert selection_sort([-1, 5, -7, 8, 0, 12, 10]) == [-7, -1, 0, 5, 8, 10, 12]\n\ndef test_selection_sort_with_single_element():\n    assert selection_sort([5]) == [5]\n\ndef test_selection_sort_with_empty_list():\n    assert selection_sort([]) == []",
  "test_info": [
    {
      "function_name": "selection_sort",
      "parameter_list": "(arr)",
      "function_declaration": "def selection_sort(arr):",
      "docstring": "Sorts an array using the selection sort algorithm.\n:param arr: List of integers to be sorted\n:return: Sorted list of integers"
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, so I have to write a Python function called selection_sort that takes a list of integers and returns the sorted list using the selection sort algorithm. Hmm, I remember that selection sort is a simple sorting algorithm where you build the sorted array one item at a time by selecting the smallest (or largest) element from the unsorted portion and putting it at the beginning. \n\nWait, right, the general approach is to:\n\n1. Find the minimum element in the unsorted part of the list.\n2. Swap it with the first element of the unsorted part.\n3. Move the boundary of the unsorted part one step to the right.\n4. Repeat until the entire list is sorted.\n\nSo, how do I implement this in Python?\n\nLet me think about how the function will work step by step.\n\nLet's start with an empty function definition. The setup is given in the problem, so I just need to fill in the code.\n\nFor each iteration, I'll need to look at the unsorted part of the array. The unsorted part starts at index 0 initially and with each step, it grows by one. Wait no\u2014actually, no. After each swap, the first element of the unsorted part is placed in its correct position, so the unsorted part begins at the next index. So for each i from 0 to len(arr)-1:\n\n- Find the minimum element in arr[i:] (so starting at i and going to the end)\n- Find the index of that minimum element in the subarray\n- Swap arr[i] with arr[min_index]\n- Repeat\n\nSo now I need to translate that into code.\n\nWait, but in some cases, maybe the same elements or handling the index correctly.\n\nLet me try to write pseudocode for this:\n\ndef selection_sort(arr):\n    for i in range(len(arr)):\n        # Find the minimum in the unsorted subarray starting at i\n        min_val = arr[i]\n        min_index = i\n        for j in range(i+1, len(arr)):\n            if arr[j] < min_val:\n                min_val = arr[j]\n                min_index = j\n        # Swap the found minimum with the first element of the unsorted part\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr\n\nWait, but wait, in the initial step, for the first pass\u2014i=0, j goes from 1 to the end, looking for the minimum. Then swaps arr[0] with the position of the minimum.\n\nYes, that should work. Let's test it with an example.\n\nTake the first test case: [64, 25, 12, 22, 11].\n\ni starts at 0:\nCompare 64,25: 25 is smaller \u2192 min_val=25, index=1.\nThen compare with 12: 12 is smaller \u2192 min_val=12, index=2.\nCompare with 22: no change.\nCompare with 11: 11 is smaller \u2192 min_val=11, index=4.\nSwap arr[0] with arr[4] \u2192 [11,25,12,22,64].\n\ni increments to 1:\nNow look at 25,12,22,64.\nMinimum is 12 at index 2. Swap with 25. Now the array is [11,12,25,22,64].\n\ni=2:\nLook at 25, 22, 64. Min is 22 at index3. Swap, array becomes [11,12,22,25,64].\n\ni=3: Check 25 and 64, min is 25, already in place. So nothing changes.\ni=4: nothing to do.\nFinal array is [11,12,22,25,64]. Correct.\n\nAnother test case: let's see the second one, [-64, -25, -12, -22, -11].\n\ni=0:\nLooking in [-64,-25,-12,-22,-11]. Wait, no, min is -64? Wait, wait, no, because -64 is at index 0. When i=0, j runs from 1 to end. So comparing each element to find if something is smaller than current min (which starts as -64). -25 is larger, -12 larger, -22 larger, -11 larger. So no swap needed.\n\ni increments to 1, subarray starts at 1: [-25, -12, -22, -11]. Find the minimum here. The minimum is -12, index=2. Swap with arr[1], so now array becomes [-64, -12, -25, -22, -11].\n\ni=2, now subarray is [-25, -22, -11]. Min is -25? No, comparing. Let's see:\n\nCurrent min_val is arr[2] = -25.\n\nj runs from 3 to 4:\n\nAt j=3: -22 is larger than -25? No, larger (-22 > -25, as it's more to the right on the number line). So min_val remains.\n\nj=4: -11 is larger than -25.\n\nSo at i=2, min_index stays 2, nothing changes.\n\ni=3: Subarray is [-22, -11]. Find min\u2014arr[3] is -22. Then j=4: -11 is less than -22, so min_val becomes -11, index=4. Swap with arr[3], so list becomes [-64,-12,-25,-11,-22].\n\nWait, but the expected output is [-64, -25, -22, -12, -11]. Wait, does this mean the function is doing something wrong?\n\nWait, perhaps I made a mistake in the sample. Let me see:\n\nWait the sample input is [-64, -25, -12, -22, -11].\n\nLet's see how the algorithm would process it, step by step.\n\nInitial array: [-64, -25, -12, -22, -11]\n\ni=0: The entire array is considered. min is -64, already in position. So no swap.\n\ni=1: subarray is [-25, -12, -22, -11]. Looking for the smallest. Starting with -25.\n\nCheck j=2: -12 is bigger than -25? No, because -12 > -25, so -25 is smaller. So min remains. j=3: -22 is larger than -25. j=4: -11> -25. So min is -25 at index1. So no swap.\n\nWait then, at i=2: subarray is [-12, -22, -11]. So arr[i] is -12. Compare with -22 (j=3): -22 is smaller. So min_val is -22, index3. So swap arr[2] (-12) with arr[3] (-22). Now array is [-64, -25, -22, -12, -11].\n\ni=3: subarray is arr[3:] \u2192 [-12, -11]. min is -12. Swap with itself\u2014nothing happens.\n\ni=4: nothing to sort.\n\nSo the final array is [-64, -25, -22, -12, -11], which matches the sample.\n\nWait, that contradicts my earlier walkthrough. So why was I getting a different result earlier.\n\nWait, when i=1, the min is -25. So no swap. So at i=2, the subarray is [-12, -22, -11]. The min is -22. So swap, as above. So the code should be correct.\n\nAnother test case is when the array is empty. Well, len(arr) is 0, so the loop doesn't run. It returns the same array, which is correct.\n\nAnother test case is when all elements are positive, single element, etc.\n\nSo the code should work. Wait, but let's see another way: perhaps there is an issue with the subarray. For i, in each iteration, the code finds the min in arr[i...n-1], and swaps to the current position.\n\nYes.\n\nBut perhaps writing the code in a slightly better way.\n\nWait, perhaps the inner loop should consider j starting from i, not i+1. Because when initializing min_val to arr[i], and then j from i, perhaps it will pick that as a possibility.\n\nWait in the code, j starts at i, and runs to the end.\n\nWait no, in the current code, j starts at i+1. So it's considering all elements from i+1 onwards. Because, initially, the min is set to arr[i], and j runs after that. So for j in range(i+1, ...) makes sense.\n\nYes, that's correct. Because j needs to check elements beyond i.\n\nI think the setup is correct.\n\nSo, according to this, the function should work correctly for all cases.\n\nTesting the third sample input: [-1,5,-7,8,0,12,10].\n\nLet's step through the code:\n\ni=0: Find min from 0 to 6.\n\nElements are -1,5,-7,8,0,12,10.\n\nAt j=2, -7 is the smallest. So min_index is 2.\n\nSwap arr[0] and arr[2], array becomes [-7,-1,5,8,0,12,10].\n\ni=1: check -1,5,8,0,12,10.\n\nMin is -1 (at i=1). Wait no.\n\nWait, i is 1.\n\nThe subarray is from index 1 onwards: -1,5,8,0,12,10,12? Wait no, wait in the third example, the input after first swap is [-7, -1,5,8,0,12,10], then i=1.\n\nSo the subarray is from index1: -1,5,8,0,12,10.\n\nSo for j starts from i+1=2 to 6.\n\nCheck each element:\n\nelement at j=2:5> -1.\n\nj=3:8> -1.\n\nj=4:0> -1.\n\nj=5:12> -1.\n\nj=6:10> -1.\n\nSo the min is -1, already at index1. So no swap.\n\ni=2: subarray is 5,8,0,12,10.\n\nFind the min.\n\nAt i=2, min_val is 5.\n\nCheck j=3:8>5.\n\nj=4:0<5 \u2192 min_val=0, min_index=4.\n\nj=5:12>0.\n\nj=6:10>0.\n\nSo swap arr[2] (5) with arr[4] (0). Now array is [-7,-1,0,8,5,12,10].\n\ni=3: subarray is 8,5,12,10.\n\nMin_val starts as 8.\n\nj=4:5<8 \u2192 min_val=5, index=4.\n\nj=5:12>5.\n\nj=6:10>5.\n\nSo swap arr[3] (8) with arr[4] (5). Now array is [-7,-1,0,5,8,12,10].\n\ni=4: subarray is 8,12,10.\n\nMin_val is 8; check j=5:12>8.\n\nj=6:10>8.\n\nNo swap.\n\ni=5: subarray is 12,10. Min is 10 at j=6. Swap arr[5] with arr[6], array becomes [-7,-1,0,5,8,10,12].\n\ni=6: no change.\n\nSo the final array is [-7,-1,0,5,8,10,12], which matches the sample.\n\nAnother test case is [5]. It just returns [5], which is correct.\n\nAnother case is empty list\u2014returns empty.\n\nSo, the code should work. So why the sample's code is given in blank function.\n\nSo putting it all together, that's the code.\n\nNow, thinking about possible issues.\n\nEdge Cases:\n\n1. When the array has duplicates. For example, [2, 1, 2, 3, 1]. Let's see:\n\ni=0: find min in [2,1,2,3,1]. j starts from 1. 1 is at index1; then j=4: 1 is same as min, but index4 is after. So min_index becomes 4. But wait, is 4 the correct position or index1? Because 1 is the minimum.\n\nHmm, let's see:\n\nThe code would choose the last occurrence of the min or the first?\n\nWait, when min_val is 2 at i=0.\n\nj=1: 1<2, so min_val becomes 1, min_index=1.\n\nj=2: 2>1, no change.\n\nj=3:3>1, no change.\n\nj=4:1 == min_val, but since 1 == 1, and in the code it only updates if arr[j] < min_val. So min_index remains 1.\n\nSo, the code will swap arr[0] with arr[1]. So the array becomes [1,2,2,3,1].\n\nSo, after that, the array is [1,2,2,3,1].\n\ni=1: check from index1 to end: 2,2,3,1. The min is 1 at index4. So swap arr[1] (2) with arr[4] (1). Now array is [1,1,2,3,2].\n\ni=2: subarray is 2,3,2. Find min: 2. Currently, i=2, j starts at3. arr[3]=3 not smaller than 2.\n\nj=4: 2 is equal to min_val. So no change. So min_index remains 2.\n\nNo swap happens.\n\ni=3: subarray is 3,2. min is 2 at j=4. Swap arr[3] (3) with arr[4] (2). Array becomes [1,1,2,2,3].\n\ni=4: nothing.\n\nSo the sorted array is [1,1,2,2,3]. Correct.\n\nSo in cases of duplicates, the code handles it correctly, though in this example, there might be some talk about stability, but selection sort is not a stable sort.\n\nOther test case: a mix of positive and negative and zero. Like [ -3, 0,5,-1, etc.\n\nBut, the code should handle it.\n\nSo, the code seems solid.\n\nAnother point to consider is whether to modify the list in place. But the function is supposed to return the sorted list. So it should create a new list or sort the existing one.\n\nLooking at the samples, it seems that the function modifies the original list. For example, in the first sample, when called as selection_sort([64,25,...]), returns the sorted list. Whether it's a new list or same object.\n\nBut for function correctness, it's better to create a new list and not modify the input.\n\nWait, but in the code as written, we're modifying the array itself. So any original array passed in will be modified. For example:\n\na = [3,2,1]\nselection_sort(a)\nprint(a) \u2192 [1,2,3]\n\nSo the function changes the list in place. Maybe that's acceptable since it's more efficient, but depending on what's needed.\n\nBut given that the function is specified to return the sorted list, and according to the samples, the function behaves correctly.\n\nBut perhaps in some cases, if the list contains unsortable elements, but the function is defined for List[int], that's fine.\n\nThus, the code is solid.\n\nSo in conclusion, the code will implement selection sort as described, with two loops: an outer loop for each position, and an inner loop to find the min and swap.\n</think>\n\nTo solve this problem, we need to sort an array using the selection sort algorithm. Selection sort is a simple sorting algorithm that builds the sorted array one item at a time by selecting the smallest (or largest) element from the unsorted portion and putting it at the beginning. The process is repeated until the entire array is sorted.\n\n### Approach\nThe approach involves the following steps:\n1. Iterate over each element of the array using an outer loop. For each element, consider the subarray starting from the current element to the end of the array.\n2. For each subarray, find the minimum element and its index.\n3. Swap the current element (starting position of the subarray) with the found minimum element.\n4. Move to the next element and repeat the process until the entire array is sorted.\n\n### Solution Code\n```python\nfrom typing import List\n\ndef selection_sort(arr: List[int]) -> List[int]:\n    for i in range(len(arr)):\n        min_index = i\n        min_val = arr[i]\n        for j in range(i + 1, len(arr)):\n            if arr[j] < min_val:\n                min_val = arr[j]\n                min_index = j\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr\n```\n\n### Explanation\n1. **Outer Loop**: The outer loop runs from the start of the array to the second-to-last element. For each iteration, it marks the start of a new subarray that needs to be sorted.\n2. **Finding Minimum**: The inner loop searches through the subarray starting from the current position of the outer loop. It finds the minimum element and its index within this subarray.\n3. **Swapping**: After identifying the minimum element, it is swapped with the element at the current position of the outer loop. This ensures that the smallest element is moved to its correct position in the sorted portion of the array.\n4. **Progressive Sorting**: With each iteration of the outer loop, the sorted portion of the array grows by one element, and the process continues until the entire array is sorted.\n\nThis approach ensures that each element is placed in its correct position, resulting in a fully sorted array by the end of the iterations. The algorithm has a time complexity of O(n^2), making it suitable for small datasets due to its simplicity and low overhead.",
  "r1_solution": "from typing import List\n\ndef selection_sort(arr: List[int]) -> List[int]:\n    for i in range(len(arr)):\n        min_index = i\n        min_val = arr[i]\n        for j in range(i + 1, len(arr)):\n            if arr[j] < min_val:\n                min_val = arr[j]\n                min_index = j\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr",
  "metadata": {
    "prompt_id": "00000001",
    "row_id": 1,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to sort an array using the selection sort algorithm."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}