{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000028_C",
  "question": "def is_valid_double(s: str) -> bool:\n    \"\"\"\n    Returns True if the given string is a valid double, False otherwise.\n    \"\"\"\n    pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\n    return bool(re.match(pattern, s))",
  "solution": "import re\n\ndef is_valid_double(s):\n    \"\"\"\n    Returns True if the given string is a valid double, False otherwise.\n    \"\"\"\n    pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\n    return bool(re.match(pattern, s))",
  "test_code": "import re\nfrom solution import is_valid_double\n\ndef test_is_valid_double_positive_numbers():\n    assert is_valid_double(\"123.456\") == True\n\ndef test_is_valid_double_negative_numbers():\n    assert is_valid_double(\"-123.456\") == True\n\ndef test_is_valid_double_numbers_with_exponent():\n    assert is_valid_double(\"123.456e-2\") == True\n    assert is_valid_double(\"-123.456E+2\") == True\n\ndef test_is_valid_double_invalid_exponent():\n    assert is_valid_double(\"123.e.2\") == False\n\ndef test_is_valid_double_additional_characters():\n    assert is_valid_double(\".123\") == True\n    assert is_valid_double(\"123.\") == True\n    assert is_valid_double(\"123.0\") == True\n    assert is_valid_double(\"123e\") == False\n    assert is_valid_double(\"abc123.456\") == False\n    assert is_valid_double(\"123.456abc\") == False\n\ndef test_is_valid_double_edge_cases():\n    assert is_valid_double(\"\") == False\n    assert is_valid_double(\"e123\") == False\n    assert is_valid_double(\".e123\") == False\n    assert is_valid_double(\"123.e\") == False\n    assert is_valid_double(\"123e.\") == False\n    assert is_valid_double(\"+123.456\") == True\n    assert is_valid_double(\"-.456\") == True\n    assert is_valid_double(\".\") == False",
  "test_info": [
    {
      "function_name": "is_valid_double",
      "parameter_list": "(s)",
      "function_declaration": "def is_valid_double(s):",
      "docstring": "Returns True if the given string is a valid double, False otherwise."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, so I need to write a Python function called is_valid_double that takes a string and returns True if it's a valid double, and False otherwise. Hmm, I remember that doubles can have decimal points, exponents, and optional signs. But I'm not entirely sure about all the edge cases, so I should think carefully.\n\nWait, the user also provided a regex pattern. Let me look at that. The pattern is r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'. I should break this down to understand what it's doing.\n\nThe string starts with an optional '+' or '-' sign. That makes sense for numbers. Then there's a group that matches either digits followed by an optional decimal and more digits, or a decimal followed by digits. So like, 123, 123.45, or .45 are all valid. But wait, does that cover all cases? Like, is 123. allowed? Because \\d+ would require at least one digit before the decimal, so 123. would be \\d+ followed by \\.\\d*, which could be zero digits after. So 123. would be allowed. But maybe the standard double doesn't allow that; I'm not sure.\n\nThen there's an optional exponent part, which starts with e or E, followed by an optional '+' or '-', and then at least one digit. So it can handle numbers like 123e5 or 123E-5, and even 123e+5.\n\nSo putting it all together, the regex seems to match valid double formats, but I need to test some examples to see if it works as intended.\n\nWait, but does it cover all cases? Let me think. What about numbers like \"123\"? Without a decimal or exponent, is that allowed? Yes, because the first part is \\d+ followed by optional .\\d*, so 123 would match.\n\nHow about \"123.\"? That would have \\d+ followed by a dot and then zero digits, which is allowed by the regex because the second part is (\\.\\d*), wait no, the group is (\\d+(\\.\\d*)?|\\.\\d+). So the first option is digits followed by optional . and zero or more digits, which allows 123., but also 123.45. The second option in the group is .\\d+, which ensures that if it starts with a dot, there are digits after.\n\nWait, but I'm not sure if 123. is considered a valid double. For example, in some programming languages, that's allowed as 123.0, but maybe in others, it's not. So do I need to allow 123.? Or should numbers without any digits after the decimal be invalid?\n\nHmm, that's a good point. So, for example, should \"123.\" be considered a valid double? In Python, the float(\"123.\") works and gives 123.0. So I guess it's valid.\n\nWhat about a single dot, like \".\"? The regex has \\.\\d+ as one option, which would require at least one digit after the dot, so a lone \".\" would not match, which is correct because it's not a number.\n\nAlso, what about exponents? For example, \"123e\" wouldn't match because after e, it requires at least one digit. Similarly, \"123e+\" would not match because after the +, it needs digits. So that's correct.\n\nNow, testing edge cases:\n\n- \"123\" -> should return True\n- \"123.45\" -> True\n- \".45\" -> True\n- \"123.\" -> True (if we consider it valid)\n- \"+\" -> False (alone, without digits)\n- \"-\" -> False\n- \"e\" -> False\n- \"1e3\" -> True\n- \"-1.2e-3\" -> True\n- \"12e\" -> False\n- \"12e+\" -> False\n- \"12e+3\" -> True\n\nWait, how does the regex handle cases where there's a sign after the exponent? Let me see, the exponent part is [eE][+-]?\\d+ so yes, it can have + or - and then digits.\n\nSo the regex seems solid. But perhaps it's worth testing it against some examples.\n\nAnother consideration: what about numbers like \"1.2.3\"? The regex would not match that because after the first decimal and digits, it doesn't allow another dot. So that's correct.\n\nWhat about leading or trailing whitespace? The regex starts with ^ and ends with $, so any extra spaces would cause it to fail, which is correct as the input is the entire string.\n\nWait, but in the function, we're using re.match, which matches from the start but not necessarily the end unless we have the $ anchor. Looking back, yes, the pattern starts with ^ and ends with $, so re.match should correctly match the entire string.\n\nSo, the function is_valid_double uses this pattern and returns a boolean if the match is found.\n\nSo in conclusion, the provided code should correctly check if a string is a valid double based on the regex pattern.\n</think>\n\nThe function `is_valid_double` checks whether a given string `s` represents a valid double using a regular expression pattern. Here's a detailed explanation of how it works.\n\n### Approach\nThe function uses a regular expression to match patterns that are valid representations of double-precision floating-point numbers. The regex pattern considers the following components:\n\n1. **Optional Sign**: The number can start with an optional '+' or '-'.\n2. **Digits and Decimal Points**: The number must have at least one digit either before or after the decimal point. For example, `123`, `123.45`, `.45`, and `123.` are valid.\n3. **Exponential Notation**: The number can include an exponent part starting with 'e' or 'E', followed by an optional sign and at least one digit. For example, `123e5`, `123E-5`, and `123e+5` are valid.\n\n### Solution Code\n```python\nimport re\n\ndef is_valid_double(s: str) -> bool:\n    \"\"\"\n    Returns True if the given string is a valid double, False otherwise.\n    \"\"\"\n    pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\n    return bool(re.match(pattern, s))\n```\n\n### Explanation\n- **Regex Breakdown**:\n  - `^[-+]?`: Matches an optional leading '+' or '-'.\n  - `(\\d+(\\.\\d*)?|\\.\\d+)`: Matches a number with optional decimal part, ensuring at least one digit appears either before or after the decimal point.\n  - `([eE][-+]?\\d+)?$`: Matches an optional exponent part, which includes 'e' or 'E', an optional sign, and at least one digit.\n\n- **Function Logic**:\n  - The `re.match` function attempts to match the regex pattern at the beginning of the string. Since the pattern ends with `$`, it ensures the entire string is checked.\n  - If the string matches the pattern, `re.match` returns a match object, which is truthy. Otherwise, it returns `None`, which is falsy. The function converts this to a boolean and returns it.\n\nThis approach efficiently verifies whether the input string conforms to the structure of a valid double, covering all edge cases such as numbers with or without decimal points, exponents, and signs.",
  "r1_solution": "import re\n\ndef is_valid_double(s: str) -> bool:\n    \"\"\"\n    Returns True if the given string is a valid double, False otherwise.\n    \"\"\"\n    pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\n    return bool(re.match(pattern, s))",
  "metadata": {
    "prompt_id": "00000028",
    "row_id": 28,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to check if a given string is a valid double (a number with a decimal point)."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results2.jsonl"
}