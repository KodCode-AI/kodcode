{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000055_I",
  "question": "Write a python function to identify if two string s1 and s2 are isomorphic. Two strings are isomorphic if the characters in s1 can be replaced to get s2. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.",
  "solution": "def is_isomorphic(s1, s2):\n    \"\"\"\n    Checks if two strings are isomorphic. Two strings are isomorphic if the characters in s1 can be replaced to get s2.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    s1_to_s2_map = {}\n    s2_to_s1_map = {}\n    \n    for char_from_s1, char_from_s2 in zip(s1, s2):\n        if char_from_s1 in s1_to_s2_map:\n            if s1_to_s2_map[char_from_s1] != char_from_s2:\n                return False\n        else:\n            s1_to_s2_map[char_from_s1] = char_from_s2\n        \n        if char_from_s2 in s2_to_s1_map:\n            if s2_to_s1_map[char_from_s2] != char_from_s1:\n                return False\n        else:\n            s2_to_s1_map[char_from_s2] = char_from_s1\n    \n    return True",
  "test_code": "from solution import is_isomorphic\n\ndef test_isomorphic_example1():\n    assert is_isomorphic(\"egg\", \"add\") == True\n\ndef test_isomorphic_example2():\n    assert is_isomorphic(\"foo\", \"bar\") == False\n\ndef test_isomorphic_example3():\n    assert is_isomorphic(\"paper\", \"title\") == True\n\ndef test_isomorphic_identical_strings():\n    assert is_isomorphic(\"abc\", \"abc\") == True\n\ndef test_isomorphic_empty_strings():\n    assert is_isomorphic(\"\", \"\") == True\n\ndef test_isomorphic_no_characters():\n    assert is_isomorphic(\"a\", \"a\") == True\n\ndef test_isomorphic_mismatched_characters():\n    assert is_isomorphic(\"aabb\", \"ccdd\") == True\n\ndef test_isomorphic_non_unique_replacement():\n    assert is_isomorphic(\"ab\", \"aa\") == False",
  "test_info": [
    {
      "function_name": "is_isomorphic",
      "parameter_list": "(s1, s2)",
      "function_declaration": "def is_isomorphic(s1, s2):",
      "docstring": "Checks if two strings are isomorphic. Two strings are isomorphic if the characters in s1 can be replaced to get s2."
    }
  ],
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, so I need to write a Python function to determine if two strings s1 and s2 are isomorphic. Hmm, let me think about what isomorphic means here. From what I remember, two strings are isomorphic if there's a one-to-one mapping between the characters of s1 and s2 such that replacing each character in s1 with its corresponding character in s2 gives the exact string s2. And importantly, this mapping has to preserve the order of the characters.\n\nWait, so it's not just any mapping, but each character in s1 must consistently map to the same character in s2, and vice versa. Also, no two different characters in s1 can map to the same character in s2. Otherwise, it wouldn't be a one-to-one mapping.\n\nLet me break this down. For example, if s1 is \"egg\" and s2 is \"add\", they are isomorphic because 'e' maps to 'a' and 'g' maps to 'd'. Each occurrence is replaced consistently. But if s1 is \"foo\" and s2 is \"bar\", is that isomorphic? 'f' maps to 'b', 'o' maps to 'a', but then 'o' would have to map to 'r' as well, which isn't consistent. So that would not be isomorphic.\n\nSo the function needs to check two things: first, that each character in s1 maps uniquely to a character in s2, and second, that the structure of the two strings is the same. Meaning, the pattern of replacement is consistent throughout.\n\nHow can I approach this? Well, maybe I can use dictionaries to map each character from s1 to s2 and vice versa. For each character in s1, I'll check if it's already in the mapping. If it is, I'll see if it maps to the current character in s2. If not, I'll add it to the mapping. Similarly, I'll need to ensure that each character in s2 is not already mapped by a different character from s1.\n\nWait, let me think: maybe two mappings are needed. One from s1 to s2 (let's call it s1_map) and another from s2 to s1 (s2_map). As I iterate through each pair of characters from s1 and s2, I need to check both ways.\n\nSo for each i-th character in s1 and s2:\n\n1. If the s1 character is already in s1_map, check if it's mapped to the current s2 character. If not, return False.\n2. If the s2 character is already in s2_map, check if it's mapped to the current s1 character. If not, return False.\n3. If both are available, add them to the respective maps.\n\nBut wait, what about the reverse mapping? Oh right, because if a character in s2 is already mapped by a different character in s1, that would break the isomorphism. So we need to check both ways.\n\nAnother thought: What if the two strings are of different lengths? In that case, they can't be isomorphic. So the first thing the function should check is whether len(s1) equals len(s2). If not, immediately return False.\n\nOkay, so the steps for the function could be:\n\n1. Check if the lengths of s1 and s2 are equal. If not, return False.\n2. Initialize two empty dictionaries: s1_map for mapping characters from s1 to s2, and s2_map for mapping from s2 to s1.\n3. Iterate over each pair of characters (c1, c2) from s1 and s2:\n   a. If c1 is in s1_map, then c2 must be equal to s1_map[c1]. Otherwise, return False.\n   b. If c2 is in s2_map, then c1 must be equal to s2_map[c2]. Otherwise, return False.\n   c. If neither is present, add c1 -> c2 to s1_map and c2 -> c1 to s2_map.\n4. If all pairs are checked without issues, return True.\n\nWait, but let me think about an example. Suppose s1 is \"ab\" and s2 is \"aa\". So for the first pair 'a' and 'a', it's fine. s1_map becomes {'a':'a'}, s2_map becomes {'a':'a'}. Next pair is 'b' and 'a'. Now, 'b' isn't in s1_map, so check s2_map. 'a' is already mapped to 'a', so trying to map 'b' to 'a' would conflict because 'a' is already mapped from 'a' to 'a'. So step 3b would catch this because s2_map[c2] exists as 'a', but c1 is 'b', not 'a', so it returns False. Which is correct because \"ab\" and \"aa\" are not isomorphic.\n\nWait, no. Wait, s1 is \"ab\" and s2 is \"aa\". So for the first character, 'a' maps to 'a'. Then the second character 'b' maps to 'a' as well. But since 'a' in s2 is already mapped to 'a' in s1, but now we want 'b' to map to 'a' which would mean that s2's 'a' is mapped to both 'a' and 'b' in s1. That's a problem because each s2 character can only be mapped by one s1 character. So the function correctly returns False.\n\nAnother example: s1 = \"paper\", s2 = \"title\". Let me see: 'p' -> 't', 'a'->'i', 'e'->'l', etc. It should be isomorphic. Let me see:\n\np -> t\na -> i\np -> t (same as before)\ne -> l\nr -> e\n\nThen, looking at the reverse mapping:\n\nt -> p\ni -> a\nl -> e\ne -> r\n\nThis should work without conflicts. So the function should return True.\n\nAlright, so the logic seems solid. Now, how to implement this in Python.\n\nFirst, check the length:\n\nif len(s1) != len(s2):\n    return False\n\nThen, initialize the two maps:\n\ns1_map = {}\ns2_map = {}\n\nThen, iterate over the two strings as pairs:\n\nfor c1, c2 in zip(s1, s2):\n    if c1 in s1_map:\n        if s1_map[c1] != c2:\n            return False\n    else:\n        s1_map[c1] = c2\n\n    if c2 in s2_map:\n        if s2_map[c2] != c1:\n            return False\n    else:\n        s2_map[c2] = c1\n\nWait, is that sufficient? Let's test with the example where s1 = \"foo\" and s2 = \"bar\". 'f' maps to 'b', 'o' maps to 'a'. Then, the third character is 'o' and should map to 'r'. So in the third iteration, c1 is 'o' which is in s1_map as 'a'. So it checks if s1_map['o'] is equal to c2 'r'. 'a' != 'r', so returns False.\n\nYes, that works. So the function correctly identifies that \"foo\" and \"bar\" are not isomorphic.\n\nBut wait, looking at the order: in the code, the s1 condition is checked first, then the s2. So perhaps, the else clause adds the mappings. But in the example where s1 is \"ab\" and s2 is \"ba\", should be isomorphic because 'a' -> 'b', 'b'->'a'. Let's see:\n\nFirst iteration: c1 = 'a', c2 = 'b'. s1_map is empty, so set s1_map['a'] = 'b'. Then check s2_map for 'b': not present, so set s2_map['b'] = 'a'.\n\nSecond iteration: c1 = 'b', c2 = 'a'. Check s1_map['b'] is 'a'? Wait, no, because in the first iteration, s1_map['a'] was set to 'b'. Now, in the second iteration, s1_map doesn't have 'b' yet. So set s1_map['b'] = 'a'. Then check s2_map for 'a': not present, so set s2_map['a'] = 'b'.\n\nSo s1_map becomes {'a':'b', 'b':'a'}, and s2_map {'b':'a', 'a':'b'}. So returns True, which is correct.\n\nAnother example: s1 = \"egg\", s2 = \"add\". 'e'->'a', 'g'->'d', 'g' again so check s1_map for 'g' should be 'd' which matches. And s2_map: 'a'->'e', 'd'->'g'. So it works.\n\nWhat about the case where s1 = \"a\", s2 = \"a\"? Should return True. The code would add to both maps and return True.\n\nWhat about a case where two different characters in s1 map to the same in s2? Like s1 = \"ab\", s2 = \"aa\". As I thought earlier, the function would catch it.\n\nAnother edge case: one of the strings is empty. If both are empty, should return True. If one is empty and the other isn't, return False.\n\nSo the code seems to handle that with the initial length check.\n\nSo I think the function is correct.\n\nI think that's the approach. Now, time to write the function.\n</think>\n\nTo determine if two strings s1 and s2 are isomorphic, we need to verify that there exists a one-to-one mapping between the characters of s1 and s2 such that replacing each character in s1 with its corresponding character in s2 yields s2. This mapping must be consistent and bijective.\n\n### Approach\nThe approach involves the following steps:\n\n1. **Check Lengths**: If the lengths of the two strings are not equal, they cannot be isomorphic, so we return False immediately.\n2. **Mapping Dictionaries**: Use two dictionaries to maintain the mappings from s1 to s2 and from s2 to s1.\n3. **Iterate Through Pairs**: For each character pair (c1 from s1, c2 from s2):\n   - Check if c1 is already mapped to a different character in s2.\n   - Check if c2 is already mapped from a different character in s1.\n   - If both checks pass, add the mappings to the dictionaries.\n4. **Return Result**: If all checks are passed, the strings are isomorphic.\n\n### Solution Code\n\n```python\ndef is_isomorphic(s1: str, s2: str) -> bool:\n    if len(s1) != len(s2):\n        return False\n    \n    s1_map = {}\n    s2_map = {}\n    \n    for c1, c2 in zip(s1, s2):\n        if c1 in s1_map:\n            if s1_map[c1] != c2:\n                return False\n        else:\n            s1_map[c1] = c2\n        \n        if c2 in s2_map:\n            if s2_map[c2] != c1:\n                return False\n        else:\n            s2_map[c2] = c1\n    \n    return True\n```\n\n### Explanation\n- **Length Check**: Ensures that both strings have the same length, a necessary condition for isomorphism.\n- **Mapping Dictionaries**: `s1_map` tracks each character from s1 to its corresponding character in s2, while `s2_map` ensures that each character in s2 is mapped back correctly to s1.\n- **Character Mapping Check**: For each character pair, the function ensures that the mapping is consistent in both directions, preventing any two characters from s1 mapping to the same character in s2 and vice versa.\n\nThis approach efficiently verifies the isomorphic property in linear time, making it suitable for strings of varying lengths.",
  "r1_solution": "def is_isomorphic(s1: str, s2: str) -> bool:\n    if len(s1) != len(s2):\n        return False\n    \n    s1_map = {}\n    s2_map = {}\n    \n    for c1, c2 in zip(s1, s2):\n        if c1 in s1_map:\n            if s1_map[c1] != c2:\n                return False\n        else:\n            s1_map[c1] = c2\n        \n        if c2 in s2_map:\n            if s2_map[c2] != c1:\n                return False\n        else:\n            s2_map[c2] = c1\n    \n    return True",
  "metadata": {
    "prompt_id": "00000055",
    "row_id": 55,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}