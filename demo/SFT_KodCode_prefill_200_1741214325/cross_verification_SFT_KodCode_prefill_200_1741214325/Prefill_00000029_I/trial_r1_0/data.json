{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000029_I",
  "question": "Write a python function to implement a simple bubble sort algorithm.",
  "solution": "def bubble_sort(arr):\n    \"\"\"\n    Sorts an array using the bubble sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Flag to detect any swap\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                # Swap arr[j] and arr[j+1]\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        # If no two elements were swapped by inner loop, then break\n        if not swapped:\n            break\n    return arr",
  "test_code": "import pytest\nfrom solution import bubble_sort\n\ndef test_bubble_sort_positive_numbers():\n    assert bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]\n\ndef test_bubble_sort_negative_numbers():\n    assert bubble_sort([-2, -34, -60, -1, -50]) == [-60, -50, -34, -2, -1]\n\ndef test_bubble_sort_mixed_sign_numbers():\n    assert bubble_sort([-2, 34, -60, 12, -50, 72]) == [-60, -50, -2, 12, 34, 72]\n\ndef test_bubble_sort_single_element():\n    assert bubble_sort([5]) == [5]\n\ndef test_bubble_sort_empty_list():\n    assert bubble_sort([]) == []\n\ndef test_bubble_sort_already_sorted():\n    assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_duplicate_elements():\n    assert bubble_sort([4, 2, 1, 2, 3, 4]) == [1, 2, 2, 3, 4, 4]",
  "test_info": [
    {
      "function_name": "bubble_sort",
      "parameter_list": "(arr)",
      "function_declaration": "def bubble_sort(arr):",
      "docstring": "Sorts an array using the bubble sort algorithm.\n\nParameters:\narr (list): The list of elements to be sorted.\n\nReturns:\nlist: The sorted list."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to write a Python function for a simple bubble sort. Hmm, I remember bubble sort works by comparing adjacent elements and swapping them if they're in the wrong order. It keeps doing this until no swaps are needed, meaning the list is sorted.\n\nLet me think about the steps. So, the function should take a list as input. I'll call it bubble_sort and the parameter is arr.\n\nFirst, I need to make a copy of the list so I don't modify the original. Oh right, so I can do something like n = len(arr) and create a copy with arr.copy().\n\nThen, I think I need a loop that runs until no swaps happen. So I'll have a variable swapped set to True. There will be a while loop that continues as long as swapped is True. Inside the loop, I reset swapped to False each time.\n\nNow, for each element except the last one, since the largest element bubbles up each pass. So I loop from 0 to n-1, or maybe n-2? Wait, let me think. If I have 5 elements, the indices are 0-4. Comparing 0-1, 1-2, etc., up to 3-4. So the range should be from 0 to n-1, exclusive, so range(len(arr) - 1).\n\nFor each i in that range, I compare arr[i] and arr[i+1]. If arr[i] is greater, swap them and set swapped to True.\n\nWait, but each pass places the next largest element in its place, so the next pass can ignore the last element each time. Oh right, so after the first pass, the last element is correct, the second pass leaves the second last, etc.\n\nSo I should also adjust the range in the inner loop. So, maybe for each pass, the inner loop goes up to (n - 1) - j, where j is the pass number. Hmm, but I'm not sure how to implement that. Maybe in the outer loop, for j in range(n), and the inner loop goes up to (n - j - 1). Because each time, the last j elements are already sorted.\n\nWait, let me think again. Let's say in the first iteration, j=0, so inner loop goes to n-0-1 = n-1, which is correct. The second iteration, j=1, inner loop goes to n-2, meaning it stops at the second last element, which is correct because the last is sorted. So yes, the inner loop should run for i in range(0, n - j - 1).\n\nWait, but in the code I wrote earlier, I didn't adjust the inner loop. I might have made a mistake there. Oh right, in the initial code, after each pass, the inner loop still runs up to the original length, but that's not efficient. So perhaps I should adjust it.\n\nSo inside the while loop, I have a for loop: for i in range(0, n - j - 1). But wait, I can't use j in a while loop. Hmm, perhaps better to switch to a for loop for the passes.\n\nAlternatively, perhaps it's better to structure it with nested loops where the outer loop runs for each element, and the inner loop goes up to (n - 1 - outer_loop_index). That might be more efficient.\n\nWait, maybe it's easier to start with the while loop and then in each pass, go through all the elements, but then the inner loop will still do unnecessary comparisons. But for the purposes of a simple implementation, maybe that's okay.\n\nI think I need to adjust the range in the inner loop based on the number of passes. So, perhaps I should have an outer loop that counts the number of passes, and each time, the inner loop goes up to (n - passes - 1). Wait, but I'm using a while loop, not a for loop. So maybe I should restructure to a for loop for the passes.\n\nAlternatively, perhaps I'm complicating things. Let me see. The initial code I wrote may not have that optimization, but it's still correct, just less efficient. So maybe it's better to implement the optimized version with the inner loop being adjusted each time.\n\nWait, perhaps I can make the inner loop with a variable that reduces each time. Let me try writing this:\n\nn = len(arr)\nfor i in range(n):\n    swapped = False\n    for j in range(0, n-i-1):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\n            swapped = True\n    if not swapped:\n        break\n\nThat way, each pass reduces the inner loop range by one each time. This is more efficient. So I should implement it that way.\n\nSo putting it all together, the function would create a copy of the input list, then perform the nested loops as described, swapping elements as needed. Then return the sorted copy.\n\nLet me test with an example. Suppose arr = [64, 34, 25, 12, 22, 11, 90]. The function should sort it in ascending order.\n\nFirst pass, i=0: inner loop runs from 0 to 5 (since n=7, 7-0-1=6). Compare and swap each pair.\n\nI think with that logic, the code should work correctly.\n\nSo the function starts by copying the input list to avoid modifying it. Then uses the optimized nested loops with the reduced inner range. If no swaps occur, it breaks early, which is good.\n\nSo that's how I should write the function.\n</think>\n\nTo implement a simple bubble sort algorithm, we'll create a function called `bubble_sort` that takes a list as input and returns a new sorted list. Here's how you can do it step-by-step:\n\n1. **Copy the Input List**: To avoid modifying the original list, we'll create a copy of it.\n2. **Initialize Variables**: Determine the length of the list and set up a variable to track whether any swaps occurred during a pass through the list.\n3. **Optimized Bubble Sort**: Use a nested loop structure where the outer loop runs for each element in the list, and the inner loop iterates through the list, comparing each element with its neighbor and swapping them if they are in the wrong order. After each complete pass through the list, the inner loop range is reduced by one since the largest element has bubbled up to its correct position at the end of the list.\n4. **Early Termination**: If a complete pass through the list results in no swaps, the list is already sorted, and we can terminate the sorting process early.\n\nHere is the Python function that implements these steps:\n\n```python\ndef bubble_sort(arr):\n    arr = arr.copy()\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr\n```\n\n**Example Usage:**\n\n```python\narr = [64, 34, 25, 12, 22, 11, 90]\nsorted_arr = bubble_sort(arr)\nprint(\"Sorted array:\", sorted_arr)\n```\n\n**Output:**\n\n```\nSorted array: [11, 12, 22, 25, 34, 64, 90]\n```\n\nThis implementation ensures that the algorithm is both efficient and easy to understand, leveraging the bubble sort algorithm's capability to terminate early when the list becomes sorted.",
  "r1_solution": "def bubble_sort(arr):\n    arr = arr.copy()\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr",
  "metadata": {
    "prompt_id": "00000029",
    "row_id": 29,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}