{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000074_I",
  "question": "Write a python function to check if a given number is perfect square or not. The function should take an integer as input and return True if the number is a perfect square, False otherwise.",
  "solution": "def is_perfect_square(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect square.\n    \n    Args:\n    num (int): The number to check\n    \n    Returns:\n    bool: True if num is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    root = int(num ** 0.5)\n    return root * root == num",
  "test_code": "import pytest\nfrom solution import is_perfect_square\n\ndef test_is_perfect_square_positive_perfect_square():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(9) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n\ndef test_is_perfect_square_negative_number():\n    assert is_perfect_square(-4) == False\n\ndef test_is_perfect_square_non_perfect_square():\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(5) == False\n    assert is_perfect_square(6) == False\n    assert is_perfect_square(7) == False\n\ndef test_is_perfect_square_zero():\n    assert is_perfect_square(0) == True\n\ndef test_is_perfect_square_large_number():\n    assert is_perfect_square(15625) == True\n    assert is_perfect_square(15626) == False",
  "test_info": [
    {
      "function_name": "is_perfect_square",
      "parameter_list": "(num)",
      "function_declaration": "def is_perfect_square(num):",
      "docstring": "Checks if the given number is a perfect square.\n\nArgs:\nnum (int): The number to check\n\nReturns:\nbool: True if num is a perfect square, False otherwise."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, so I need to write a Python function to check if a given number is a perfect square. Hmm, let's think about this. \n\nFirst, what's a perfect square? Oh right, it's a number that's the square of an integer. So, for example, 16 is a perfect square because it's 4 squared. But 20 isn't because there's no integer that you can square to get 20.\n\nWait, but what about negative numbers? Oh, right, the square of any real number is non-negative, so negative numbers can't be perfect squares. So if the input is negative, the function should immediately return False.\n\nAlright, so step one is to handle that case. So if the number is less than zero, return False.\n\nNext, for non-negative numbers. I need to find out if there's an integer n such that n squared equals the input number. How can I check that in Python?\n\nOne approach is to take the square root of the number, round it to the nearest integer, and then square it again to see if it gives back the original number. \n\nWait, how accurate is the square root function? Because due to floating point precision, sometimes rounding could give the wrong result. Like, for very large numbers, floating point might not represent the square root accurately. So maybe we need a more precise way.\n\nAnother idea: use integer square roots. So for a given number, compute the integer square root, then see if its square equals the original number.\n\nPython has math.isqrt in version 3.8 and above, which returns the integer square root. So, for example, math.isqrt(16) returns 4. Math.isqrt(17) returns 4 because it's the floor of the exact square root.\n\nSo the plan is: take the input number. If it's negative, return False. Else, compute the integer square root, then square it and see if it equals the original number.\n\nLet me draft this:\n\ndef is_perfect_square(n):\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n\n\nThat seems straightforward. Let me test this logic with some examples.\n\nTest case 1: n = 16. The function should return True. math.isqrt(16) is 4, 4*4 =16, so yes.\n\nTest case 2: n=20. Math.isqrt(20)=4, 4*4=16 !=20. So return False.\n\nTest case 3: n=1. Math.isqrt(1)=1, so 1*1=1, return True.\n\nTest case 4: n=0. Hmm, 0 is a perfect square because 0 squared is 0. So math.isqrt(0)=0, returns True.\n\nTest case 5: n=2. Math.isqrt(2)=1, 1*1=1 !=2, returns False.\n\nWhat about a very large number, say 10^18 +1. Let's compute n=1000000000000000001. The square root should be 1000000000.000... Something. Wait, no, 1000000000 squared is 1e18. So n=1e18 +1 is not a perfect square. So our function would return False.\n\nIf n is a very large perfect square, say (10^9)^2=1e18, then isqrt(n) would be 1e9, and squaring it would correctly give n.\n\nAnother edge case: n=2^60. The square root is 2^30, so (2^30)^2=2^60=n, so function returns True.\n\nWait, what about n= -4? The function correctly returns False because n <0.\n\nSeems like this logic should handle all cases. So I think this function is correct.\n\nI need to make sure to import math, else math.isqrt will cause an error.\n\nSo, the function will start by importing math.\n\nPutting it all together, the function is written.\n</think>\n\nTo determine if a given number is a perfect square, we can follow a straightforward approach that leverages mathematical properties and efficient computation.\n\n### Approach\nThe approach involves the following steps:\n1. **Check for Negative Numbers**: Since a perfect square cannot be negative, any negative input should immediately result in returning `False`.\n2. **Compute Integer Square Root**: For non-negative numbers, compute the integer square root using Python's `math.isqrt` function, which accurately handles large integers by providing the floor value of the exact square root.\n3. **Square the Root and Compare**: Square the computed integer square root and check if it equals the original number. If it does, the number is a perfect square; otherwise, it is not.\n\nThis method efficiently handles both small and very large numbers, ensuring accuracy and performance.\n\n### Solution Code\n\n```python\nimport math\n\ndef is_perfect_square(n):\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n\n```\n\n### Explanation\n- **Negative Check**: The function first checks if the input is negative. If so, it returns `False` because negative numbers cannot be perfect squares.\n- **Integer Square Root Calculation**: Using `math.isqrt`, the function computes the integer square root of the input number. This function is efficient and avoids floating-point inaccuracies.\n- **Square and Compare**: The function then squares the computed integer square root and checks if it equals the original input. If it does, the number is a perfect square, and the function returns `True`; otherwise, it returns `False`.\n\nThis approach ensures that the function is both efficient and accurate, handling all edge cases including very large numbers and zero.",
  "r1_solution": "import math\n\ndef is_perfect_square(n):\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n",
  "metadata": {
    "prompt_id": "00000074",
    "row_id": 74,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}