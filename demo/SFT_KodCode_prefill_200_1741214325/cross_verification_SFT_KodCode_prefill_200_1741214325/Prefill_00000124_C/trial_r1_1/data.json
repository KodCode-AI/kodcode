{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000124_C",
  "question": "def single_number(nums: List[int]) -> int:\n    \"\"\" Find the single number in a list where every other number appears exactly twice.\n    Assumes one and only one number appears once and all others appear twice.\n    Returns the number that appears exactly once.\n\n    >>> single_number([2, 2, 1]) 1\n    >>> single_number([4, 1, 2, 1, 2]) 4\n    >>> single_number([8]) 8\n    >>> single_number([7, 3, 5, 3, 7, 5, 6]) 6\n    \"\"\"",
  "solution": "def single_number(nums):\n    \"\"\"\n    Find the single number in a list where every other number appears exactly twice.\n    Assumes one and only one number appears once and all others appear twice.\n    Returns the number that appears exactly once.\n\n    Args:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The integer that appears exactly once.\n    \"\"\"\n    unique = 0\n    for num in nums:\n        unique ^= num\n    return unique",
  "test_code": "from solution import single_number\n\ndef test_single_number():\n    assert single_number([2, 2, 1]) == 1\n    assert single_number([4, 1, 2, 1, 2]) == 4\n    assert single_number([8]) == 8\n    assert single_number([7, 3, 5, 3, 7, 5, 6]) == 6",
  "test_info": [
    {
      "function_name": "single_number",
      "parameter_list": "(nums)",
      "function_declaration": "def single_number(nums):",
      "docstring": "Find the single number in a list where every other number appears exactly twice.\nAssumes one and only one number appears once and all others appear twice.\nReturns the number that appears exactly once.\n\nArgs:\nnums (List[int]): A list of integers.\n\nReturns:\nint: The integer that appears exactly once."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.5,
  "r1_response": "<think>\nOkay, I have to solve this problem where I need to find the single number in a list. All other numbers appear exactly twice, except this one which appears once. Hmm, how do I approach this?\n\nWait, so for example, in [2, 2, 1], the single number is 1. And in [4, 1, 2, 1, 2], it's 4. So the function should return that number.\n\nI remember there's a way to use XOR for this problem. Because when you XOR a number with itself, it gives 0, and XOR with 0 leaves the number as is. So if we XOR all the numbers, maybe the result will be the single number.\n\nLet me think: suppose the list is [a, a, b]. XORing all three gives a ^ a ^ b which is 0 ^ b which is b. That's the single number.\n\nAnother example: [4, 1, 2, 1, 2]. XOR all: 4 ^1^2^1^2 -> group as (4) then (1^1), (2^2) which are 4^0^0 =4. So yes.\n\nSo the plan is to compute the XOR of all the numbers. The result will be the single number.\n\nBut wait, what about when the list is empty or has one element? Oh, according to the examples, when the list has only [8], it returns 8. XOR is 8, correct.\n\nSo the approach is to compute the cumulative XOR of all elements. That should give the single number.\n\nLet me think about the steps.\n\nIn Python, I can initialize a result variable as 0. Then, loop through each number in the list, XORing each to result.\n\nSo something like:\n\ndef single_number(nums):\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n\nTesting this with the examples:\n\nTest case 1: nums = [2,2,1]. Res starts as 0.\n\n0^2=2, then 2^2=0, then 0^1=1. So returns 1. Correct.\n\nTest case 2: [4,1,2,1,2]. 4 ^1 is 5, ^2=7, ^1 is 6, ^2 is 4. Correct.\n\nTest case 3: [8]. Returns 8, yes.\n\nAnother test case: [7,3,5,3,7,5,6]. Let's compute XOR:\n\nLet me do it manually:\n\n7 ^3=4 ^5=1 ^3=2 ^7=5 ^5=0 ^6=6. Then the result is 6. Correct.\n\nSo this approach seems to work.\n\nIs there any edge case where this would fail? Well, suppose the list is empty. But according to the problem statement, the function expects one number, so perhaps the list is non-empty. Also, what if numbers are negative? But in Python, bitwise operations with negative numbers are handled as if they're in two's complement, and same logic applies since every time the same number is XORed, it cancels out. So negative numbers shouldn't be a problem.\n\nWait, let's see. Suppose nums = [-2, 2]. Then the XOR is (-2) ^2 = -4. But according to this, if the list is [-2, 2, 3], then 3 appears once.\n\nWait no, [-2, 2] list has all numbers except none single, because both appear once each, but the problem says exactly one number appears once and others appear twice. But in this example, each number appears once.\n\nWait, but the function isn't handling that because it's given in the problem statement that we can assume there's one and only one number that appears once. So the function doesn't need to handle cases where multiple numbers appear once.\n\nSo the code shouldn't have to check for that, just compute the XOR.\n\nTherefore, the code is simple: compute XOR of all numbers.\n\nAnother thought: using bit manipulation. The XOR will effectively cancel all the pairs, leaving the single number.\n\nYes, that makes sense. So I think this solution is correct.\n</think>\n\nTo solve this problem, we need to identify the single number in a list where every other number appears exactly twice. The solution leverages the properties of the XOR operation to efficiently find the single number.\n\n### Approach\nThe XOR operation has a useful property where a number XORed with itself results in zero, and any number XORed with zero results in the number itself. By XORing all numbers in the list, pairs of identical numbers will cancel each other out, leaving only the single number that appears once.\n\nHere's the step-by-step approach:\n\n1. **Initialize Result Variable**: Start with a result variable set to zero.\n2. **Iterate Through List**: Loop through each number in the list, XORing each number with the result variable.\n3. **Return Result**: After processing all numbers, the result variable will hold the value of the single number that appears exactly once.\n\n### Solution Code\n\n```python\nfrom typing import List\n\ndef single_number(nums: List[int]) -> int:\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n```\n\n### Explanation\n- **Initialization**: `res` is initialized to zero to start the XOR operation from a neutral value.\n- **XOR Operation**: As we iterate through each number in the list, XORing each number with `res` ensures that any number appearing twice will be canceled out (since `num ^ num = 0`).\n- **Result**: After processing all elements, `res` contains the XOR of all numbers, which effectively isolates the single number that appears once.\n\nThis approach efficiently solves the problem in linear time, O(n), where n is the number of elements in the list, leveraging the properties of the XOR operation to avoid additional space complexity.",
  "r1_solution": "from typing import List\n\ndef single_number(nums: List[int]) -> int:\n    res = 0\n    for num in nums:\n        res ^= num\n    return res",
  "metadata": {
    "prompt_id": "00000124",
    "row_id": 124,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to find the single number in a list where every other number appears exactly twice. The function should have a linear time complexity and use constant space."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}