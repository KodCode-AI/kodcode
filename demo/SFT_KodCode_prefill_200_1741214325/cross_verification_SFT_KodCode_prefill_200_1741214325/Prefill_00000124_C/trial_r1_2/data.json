{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000124_C",
  "question": "def single_number(nums: List[int]) -> int:\n    \"\"\" Find the single number in a list where every other number appears exactly twice.\n    Assumes one and only one number appears once and all others appear twice.\n    Returns the number that appears exactly once.\n\n    >>> single_number([2, 2, 1]) 1\n    >>> single_number([4, 1, 2, 1, 2]) 4\n    >>> single_number([8]) 8\n    >>> single_number([7, 3, 5, 3, 7, 5, 6]) 6\n    \"\"\"",
  "solution": "def single_number(nums):\n    \"\"\"\n    Find the single number in a list where every other number appears exactly twice.\n    Assumes one and only one number appears once and all others appear twice.\n    Returns the number that appears exactly once.\n\n    Args:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The integer that appears exactly once.\n    \"\"\"\n    unique = 0\n    for num in nums:\n        unique ^= num\n    return unique",
  "test_code": "from solution import single_number\n\ndef test_single_number():\n    assert single_number([2, 2, 1]) == 1\n    assert single_number([4, 1, 2, 1, 2]) == 4\n    assert single_number([8]) == 8\n    assert single_number([7, 3, 5, 3, 7, 5, 6]) == 6",
  "test_info": [
    {
      "function_name": "single_number",
      "parameter_list": "(nums)",
      "function_declaration": "def single_number(nums):",
      "docstring": "Find the single number in a list where every other number appears exactly twice.\nAssumes one and only one number appears once and all others appear twice.\nReturns the number that appears exactly once.\n\nArgs:\nnums (List[int]): A list of integers.\n\nReturns:\nint: The integer that appears exactly once."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.5,
  "r1_response": "<think>\nOkay, so I need to find the single number in a list where every other number appears exactly twice. Hmm, the function is called single_number and it takes nums as a List[int]. The examples show that it returns the number that appears once.\n\nLet me think about how to approach this. I remember that there's a bitwise XOR approach for this problem. Oh right! Because XOR has this property where if you XOR a number with itself, it gives zero, and XOR with zero leaves the number unchanged. So, if I XOR all the numbers together, the numbers that appear twice will cancel each other out, and the one that appears once remains.\n\nWait, let's think through that. For example, take [2,2,1]. XOR of 2 and 2 is 0. Then XOR 0 with 1 gives 1, which is the single number. That works. Another example: [4,1,2,1,2]. XOR all together: 4 XOR1 is 5, then XOR 2 is 7, then 1 XOR 1 is 0, then 2 XOR 2 is 0. So that correctly gives 4^1^2^1^2. That becomes 4^(1^1) ^(2^2) which is 4^0^0=4.\n\nSo this approach seems solid. So the plan is to iterate through each number in the list and compute the cumulative XOR. The result will be the single number.\n\nBut wait, what about the case where there's only one number in the list, like [8]? Well, the cumulative XOR would just be 8, which is correct.\n\nAnother test case: [7,3,5,3,7,5,6]. Let's compute:\n\nStart with 7.\n7 XOR3 = 4.\n4 XOR5 = 1.\n1 XOR3 = 2.\n2 XOR7=5.\n5 XOR5=0.\n0 XOR6=6.\nWhich is correct.\n\nSo the logic seems to hold.\n\nSo, to implement this in Python:\n\nInitialize a result variable to 0. Then loop through each number in nums, XORing each to result. After processing all, return result.\n\nLet's write the function.\n\nWait, in code: def single_number(nums: List[int]) -> int:\n\nThen, result =0.\n\nFor num in nums: result ^= num\n\nThen return result.\n\nThat seems straightforward.\n\nTesting the examples.\n\nFirst example: single_number([2,2,1]):\n\nLet's compute. result starts at 0.\n\n0 XOR2 \u2192 2.\n\nThen 2 XOR2 \u21920.\n\nThen 0 XOR1 \u21921.\n\nSo returns 1, correct.\n\nSecond example: [4,1,2,1,2]. Let's compute.\n\n0 XOR4 \u21924.\n\n4 XOR1 \u21925.\n\n5 XOR2 \u21927.\n\n7 XOR1 \u21926.\n\n6 XOR2 \u21924.\n\nSo returns 4, which is correct.\n\nThird case: [8], returns 8.\n\nFourth case: the numbers compute to 6.\n\nYes, so the code should work.\n\nWait, what about when the single number is, like, not the last element? Like [3,5,3].\n\n3^5=6, then 6^3=5, so returns 5, which is correct.\n\nSo overall, the approach is correct.\n\nThus, the code should be as follows.\n</think>\n\nTo solve this problem, we need to identify the single number in a list where every other number appears exactly twice. The solution leverages the properties of the XOR bitwise operation to efficiently determine the unique number.\n\n### Approach\nThe XOR operation has a useful property where a number XORed with itself results in zero, and a number XORed with zero results in the number itself. By applying this property, we can find the single number in the list by XORing all the numbers together. The numbers that appear twice will cancel each other out, leaving only the unique number that appears once.\n\n1. **Initialize a Result Variable**: Start with a result variable set to 0.\n2. **Iterate Through Each Number**: For each number in the list, XOR it with the result variable.\n3. **Return the Result**: After processing all numbers, the result will be the unique number that appears once.\n\nThis approach efficiently handles the problem in linear time, O(n), where n is the number of elements in the list, making it optimal for large datasets.\n\n### Solution Code\n\n```python\nfrom typing import List\n\ndef single_number(nums: List[int]) -> int:\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\n# Example usage:\n# print(single_number([2, 2, 1]))          # Output: 1\n# print(single_number([4, 1, 2, 1, 2]))    # Output: 4\n# print(single_number([8]))                # Output: 8\n# print(single_number([7, 3, 5, 3, 7, 5, 6]))  # Output: 6\n```\n\n### Explanation\nThe function `single_number` initializes `result` to 0 and iterates through each number in the input list. For each number, it updates `result` by XORing the number with `result`. Due to the properties of XOR, all numbers that appear twice cancel each other out (since any number XORed with itself is zero), leaving only the number that appears once. This approach ensures that we find the unique number efficiently with a time complexity of O(n) and a space complexity of O(1).",
  "r1_solution": "from typing import List\n\ndef single_number(nums: List[int]) -> int:\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\n# Example usage:\n# print(single_number([2, 2, 1]))          # Output: 1\n# print(single_number([4, 1, 2, 1, 2]))    # Output: 4\n# print(single_number([8]))                # Output: 8\n# print(single_number([7, 3, 5, 3, 7, 5, 6]))  # Output: 6",
  "metadata": {
    "prompt_id": "00000124",
    "row_id": 124,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to find the single number in a list where every other number appears exactly twice. The function should have a linear time complexity and use constant space."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results2.jsonl"
}