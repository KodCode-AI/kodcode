{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000073_I",
  "question": "Write a python function to perform a binary search on a sorted list of integers. The function should return the index of the target value if it is found, or -1 if it is not found. The list may not be empty.",
  "solution": "def binary_search(arr, target):\n    \"\"\"\n    Perform a binary search on a sorted list of integers.\n    Returns the index of the target value if found, otherwise -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
  "test_code": "from solution import binary_search\n\ndef test_binary_search_positive():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([10, 20, 30, 40, 50], 40) == 3\n\ndef test_binary_search_not_found():\n    assert binary_search([1, 2, 3, 4, 5], 6) == -1\n    assert binary_search([10, 20, 30, 40, 50], 7) == -1\n\ndef test_binary_search_single_element():\n    assert binary_search([5], 5) == 0\n    assert binary_search([5], 4) == -1\n\ndef test_binary_search_empty_list():\n    assert binary_search([], 1) == -1\n    assert binary_search([], 2) == -1\n\ndef test_binary_search_edge_cases():\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 9",
  "test_info": [
    {
      "function_name": "binary_search",
      "parameter_list": "(arr, target)",
      "function_declaration": "def binary_search(arr, target):",
      "docstring": "Perform a binary search on a sorted list of integers.\nReturns the index of the target value if found, otherwise -1."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function to perform a binary search on a sorted list of integers. The function should return the index of the target if found, otherwise -1. Hmm, let me think about how to approach this.\n\nFirst, I remember that binary search works by repeatedly dividing the search interval in half. It starts with the whole list and compares the target with the middle element. If the target is equal to the middle, we return that index. If the target is less than the middle, we search the left half; otherwise, we search the right half. This process continues until the target is found or the sublists are empty.\n\nSo, the function will take in parameters: the sorted list and the target value. Let's call them 'sorted_list' and 'target'.\n\nI need to initialize two pointers, low and high. Low will start at 0, the beginning of the list, and high will start at the last index, which is len(sorted_list) - 1.\n\nWait, or is it better to have high as len(sorted_list)? Because sometimes in binary search, people set high to len(sorted_list) so that when you calculate mid, you can handle the range without worrying about index issues. I need to make sure my implementation is correct.\n\nLet me outline the steps:\n\n1. Initialize low to 0 and high to len(sorted_list) - 1.\n2. While low is less than or equal to high:\n   a. Calculate mid as (low + high) // 2.\n   b. Compare the target with sorted_list[mid].\n   c. If they are equal, return mid as the index.\n   d. If target is less than sorted_list[mid], set high to mid - 1.\n   e. If target is greater, set low to mid + 1.\n3. If the loop exits without finding the target, return -1.\n\nWait, but that's the basic binary search. But I should make sure about handling all cases, like when the list has an even number of elements or when the target is at the ends.\n\nLet me test the logic with an example. Suppose the list is [2,4,6,8,10], target is 6.\n\nlow = 0, high =4\nmid = 2, which is 6. So return 2. That works.\n\nAnother example: target is 5 in the same list. The steps:\n\nlow=0, high=4.\n\nmid=2 (6), 5 is less than 6, so high=1.\n\nNow low=0, high=1.\n\nmid=(0+1)//2=0. sorted_list[0]=2 <5. So low becomes 1.\n\nNow low=1, high=1.\n\nmid is 1 (4). 5>4, so low becomes 2.\n\nNow low=2, high=1: loop ends. Return -1. Correct.\n\nWhat if the list is empty? Oh, the question says the list may not be empty, so I don't need to handle that case.\n\nAnother edge case: list with one element. If the target is that element, returns 0. If not, returns -1.\n\nOkay, the logic seems solid. Now, how to code it.\n\nThe function definition will be:\n\ndef binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mid_val = sorted_list[mid]\n        if mid_val == target:\n            return mid\n        elif mid_val < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nWait, let me check that the conditions are correct. If mid_val is less than target, since the list is sorted in ascending order, the target must be in the right half. So set low to mid +1.\n\nYes, that's correct.\n\nTesting another case where the list is [1,3,5,7], target is 3.\n\nlow=0, high=3. mid=1.5 -> 1 as integer division. sorted_list[1]=3, so return 1.\n\nAnother test: target is 7.\n\nFirst mid is 1 (3 <7, so low=2). Next loop: low=2, high=3.\n\nmid is (2+3)//2 = 2.5\u21922. sorted_list[2] is 5 <7. So low=3.\n\nLoop again: low=3, high=3. mid=3. sorted_list[3]=7 \u2192 return 3.\n\nWhat about target is 8, in the same list. So:\n\nlow=0, high=3.\n\nmid=1:3<8 \u2192 low=2.\n\nmid=2:5<8 \u2192 low=3.\n\nmid=3:7 <8 \u2192 low=4. Now low>high, loop ends. Return -1.\n\nAll makes sense.\n\nSo I think this function should work.\n</think>\n\nTo solve this problem, we need to perform a binary search on a sorted list of integers to find the index of a target value. If the target is found, we return its index; otherwise, we return -1. Binary search is an efficient algorithm that works by repeatedly dividing the search interval in half, making it much faster than a linear search, especially for large lists.\n\n### Approach\n1. **Initialize Pointers**: We start by initializing two pointers, `low` and `high`. The `low` pointer begins at the start of the list (index 0), and the `high` pointer begins at the end of the list (index `len(sorted_list) - 1`).\n2. **Binary Search Loop**: While `low` is less than or equal to `high`, we calculate the middle index (`mid`) of the current search interval.\n3. **Compare Target with Middle Element**: \n   - If the middle element is equal to the target, we return the middle index.\n   - If the middle element is less than the target, we adjust the `low` pointer to search the right half of the list.\n   - If the middle element is greater than the target, we adjust the `high` pointer to search the left half of the list.\n4. **Termination**: If the loop exits without finding the target, we return -1, indicating the target is not in the list.\n\n### Solution Code\n\n```python\ndef binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mid_val = sorted_list[mid]\n        if mid_val == target:\n            return mid\n        elif mid_val < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n```\n\n### Explanation\n- **Initialization**: `low` is set to 0 and `high` to the last index of the list.\n- **Loop Execution**: The loop continues until `low` exceeds `high`, ensuring all elements are checked efficiently.\n- **Middle Index Calculation**: The middle index is calculated using integer division of the sum of `low` and `high`.\n- **Comparison Logic**: Depending on whether the middle element is less than or greater than the target, the search interval is halved, adjusting the `low` or `high` pointer accordingly.\n- **Return Values**: If the target is found, its index is returned; otherwise, -1 is returned after the loop terminates.\n\nThis approach ensures that the binary search operates in O(log n) time complexity, making it highly efficient for large datasets.",
  "r1_solution": "def binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mid_val = sorted_list[mid]\n        if mid_val == target:\n            return mid\n        elif mid_val < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1",
  "metadata": {
    "prompt_id": "00000073",
    "row_id": 73,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}