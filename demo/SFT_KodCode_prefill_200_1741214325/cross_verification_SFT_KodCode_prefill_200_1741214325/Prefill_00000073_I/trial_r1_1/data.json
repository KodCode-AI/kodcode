{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000073_I",
  "question": "Write a python function to perform a binary search on a sorted list of integers. The function should return the index of the target value if it is found, or -1 if it is not found. The list may not be empty.",
  "solution": "def binary_search(arr, target):\n    \"\"\"\n    Perform a binary search on a sorted list of integers.\n    Returns the index of the target value if found, otherwise -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
  "test_code": "from solution import binary_search\n\ndef test_binary_search_positive():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([10, 20, 30, 40, 50], 40) == 3\n\ndef test_binary_search_not_found():\n    assert binary_search([1, 2, 3, 4, 5], 6) == -1\n    assert binary_search([10, 20, 30, 40, 50], 7) == -1\n\ndef test_binary_search_single_element():\n    assert binary_search([5], 5) == 0\n    assert binary_search([5], 4) == -1\n\ndef test_binary_search_empty_list():\n    assert binary_search([], 1) == -1\n    assert binary_search([], 2) == -1\n\ndef test_binary_search_edge_cases():\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 9",
  "test_info": [
    {
      "function_name": "binary_search",
      "parameter_list": "(arr, target)",
      "function_declaration": "def binary_search(arr, target):",
      "docstring": "Perform a binary search on a sorted list of integers.\nReturns the index of the target value if found, otherwise -1."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function called binary_search that takes a sorted list of integers and a target value. The function should return the index of the target if found, else -1. Hmm.\n\nFirst, I remember binary search works by repeatedly dividing the list in half. So I need two pointers, low and high. Low starts at 0, high at the last index of the list. While low is less than or equal to high, I calculate the middle index.\n\nWait, how to calculate mid? Oh right, mid = (low + high) // 2. That gives the middle index. Then I check if the element at mid is equal to the target. If yes, return mid. If not, decide whether to go left or right.\n\nIf the target is less than the element at mid, then the target must be in the left half. So I set high to mid -1. Otherwise, the target is in the right half, so set low to mid +1.\n\nIf the loop ends without finding the target, return -1.\n\nWait, but what about if there are duplicate elements? Does it matter? The problem doesn't specify, so I think just return any index where the target is found. For now, the standard approach should work.\n\nLet me outline the steps:\n\nInitialize low to 0, high to len(list) -1.\n\nWhile low <= high:\n    mid = (low + high) // 2\n    if list[mid] == target:\n        return mid\n    elif target < list[mid]:\n        high = mid -1\n    else:\n        low = mid +1\n\nIf exit loop, return -1.\n\nNow, let me test this logic with an example. Suppose list is [1,3,5,7,9], target is 3. low is 0, high is 4.\n\nMid is 2, list[2] is 5. Since 3 <5, set high to 1. Now mid is (0+1)//2 =0. list[0]=1 <3, so set low=1.\n\nNow mid is (1+1)//2 =1. list[1] is 3, found it, return 1. Correct.\n\nAnother test: target is 6. After initial steps, maybe it's not found. Let's see.\n\nList is [1,3,5,7,9], target 6.\n\nlow=0, high=4. mid=2 (5). 6>5, so low=3.\n\nNow low=3, high=4. mid=(3+4)//2=3. list[3]=7>6. So set high=2. Now low=3>high=2, loop ends. Return -1.\n\nThat works.\n\nAnother edge case: target is the first element. Say list [2,4,6,8], target 2.\n\nlow=0, high=3. mid is 1 (list[1]=4). 2<4, so high=0. Now mid is 0, list[0]=2. Found, return 0.\n\nWhat if target is the last element? Let's say list is [1,2,3,4], target 4. mid is 1, then 3, and found.\n\nWhat about a single element list? If [5], target 5, returns 0. Target 6, returns -1.\n\nOkay, seems solid. So now write the function.\n\nWait, the parameters: the function is called binary_search, takes in a sorted_list and a target. But wait, sorted in which order? Ascending or descending? The problem says it's a sorted list, so I'll assume it's sorted in ascending order.\n\nNow code:\n\ndef binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) -1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif target < sorted_list[mid]:\n            high = mid -1\n        else:\n            low = mid +1\n    return -1\n\nThat should do it.\n\nWait, let me test some more. What if list is empty? Oh, problem says the list may not be empty, so no problem.\n\nI think this should handle all cases.\n</think>\n\nTo solve this problem, we need to perform a binary search on a sorted list of integers to find the index of a target value. If the target value is found, we return its index; otherwise, we return -1. The list provided is guaranteed to be sorted in ascending order and not empty.\n\n### Approach\n\nBinary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item, until you've narrowed down the possible locations to just one.\n\nHere\u2019s a step-by-step breakdown of the approach:\n\n1. **Initialize Pointers**: Start with two pointers, `low` set to 0 (the start of the list) and `high` set to the last index of the list.\n2. **Calculate Midpoint**: While `low` is less than or equal to `high`, calculate the midpoint `mid` of the current range.\n3. **Compare Values**: \n   - If the value at the midpoint is equal to the target, return the midpoint index.\n   - If the target is less than the value at the midpoint, adjust the `high` pointer to `mid - 1` to search the left half of the list.\n   - If the target is greater than the value at the midpoint, adjust the `low` pointer to `mid + 1` to search the right half of the list.\n4. **Termination**: If the loop terminates without finding the target, return -1 indicating the target is not present in the list.\n\nThis approach ensures that we efficiently narrow down the search space, making the algorithm very fast with a time complexity of O(log n), where n is the number of elements in the list.\n\n### Solution Code\n\n```python\ndef binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif target < sorted_list[mid]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n```\n\n### Explanation\n\nThe provided code implements the binary search algorithm as described:\n\n1. **Initialization**: `low` is set to 0 and `high` to the last index of the list.\n2. **Midpoint Calculation**: In each iteration, `mid` is calculated as the average of `low` and `high`, using integer division.\n3. **Comparison and Adjustment**: Depending on whether the target is less than or greater than the midpoint value, the search range is adjusted by moving the `low` or `high` pointer.\n4. **Termination Check**: If the target is found, its index is returned immediately. If the loop exits without finding the target, -1 is returned.\n\nThis solution efficiently handles the search in logarithmic time, making it suitable for large datasets.",
  "r1_solution": "def binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif target < sorted_list[mid]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1",
  "metadata": {
    "prompt_id": "00000073",
    "row_id": 73,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}