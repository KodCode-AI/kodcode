{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000073_I",
  "question": "Write a python function to perform a binary search on a sorted list of integers. The function should return the index of the target value if it is found, or -1 if it is not found. The list may not be empty.",
  "solution": "def binary_search(arr, target):\n    \"\"\"\n    Perform a binary search on a sorted list of integers.\n    Returns the index of the target value if found, otherwise -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
  "test_code": "from solution import binary_search\n\ndef test_binary_search_positive():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([10, 20, 30, 40, 50], 40) == 3\n\ndef test_binary_search_not_found():\n    assert binary_search([1, 2, 3, 4, 5], 6) == -1\n    assert binary_search([10, 20, 30, 40, 50], 7) == -1\n\ndef test_binary_search_single_element():\n    assert binary_search([5], 5) == 0\n    assert binary_search([5], 4) == -1\n\ndef test_binary_search_empty_list():\n    assert binary_search([], 1) == -1\n    assert binary_search([], 2) == -1\n\ndef test_binary_search_edge_cases():\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 9",
  "test_info": [
    {
      "function_name": "binary_search",
      "parameter_list": "(arr, target)",
      "function_declaration": "def binary_search(arr, target):",
      "docstring": "Perform a binary search on a sorted list of integers.\nReturns the index of the target value if found, otherwise -1."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function to perform a binary search on a sorted list of integers. The function should return the index of the target if found, else -1. Hmm, binary search works by repeatedly dividing the search interval in half. So, first, I should think about the steps involved.\n\nWait, the list is sorted. So, I don't have to sort it myself. That's good. Binary search requires the list to be ordered. So, the function can assume the input list is already sorted. But wait, the problem statement says it's a sorted list, so I don't need to handle that case.\n\nThe function signature will probably be something like binary_search(sorted_list, target). It takes two arguments.\n\nNow, how does binary search work? I remember the steps: find the middle element, compare it with the target. If the target is smaller, search the left half; if larger, search the right half. Repeat until the element is found or the sublists are empty.\n\nSo, I'll need to initialize two pointers, low and high. Low starts at 0, high at the last index of the list. While low is less than or equal to high, we calculate mid as the average of low and high. But wait, in Python, integer division can be done with //.\n\nWait, maybe using (low + high) // 2 gives the mid index. That's better for avoiding overflow issues, though in Python, that's not a problem.\n\nOnce I have mid, I compare the value at mid with the target. If it's equal, return mid as the index. If the target is less than the value at mid, then the target must be in the left half, so set high to mid - 1. Otherwise, set low to mid + 1.\n\nWait, but I remember sometimes when handling binary search, people make off-by-one errors. I need to be careful with the loop condition and updating the pointers.\n\nWait, initially, low is 0, high is len(list) - 1. Let me think about an example. Suppose the list has 5 elements: indexes 0,1,2,3,4. Mid is 2. If target is smaller, we set high to 1 (mid-1), else set low to 3 (mid+1).\n\nIf the target isn't found after the loop, return -1.\n\nLet me think about the loop condition. It should continue while low <= high? Or maybe low < high? Hmm, perhaps I should stick with low <= high, because when low equals high, it's the last element.\n\nSo, the algorithm steps are:\n\nInitialize low = 0, high = len(list) -1.\n\nWhile low <= high:\n    mid = (low + high) // 2\n    if list[mid] == target:\n        return mid\n    elif list[mid] < target:\n        low = mid +1\n    else:\n        high = mid -1\n\nAfter the loop, return -1.\n\nWait, but what if there are multiple instances of the target? Well, the function should return the first occurrence? Or any occurrence? The problem says to return the index of the target. Hmm, the problem probably allows returning any index where the target is found, but binary search as I'm implementing it will find the correct index regardless.\n\nWait, no\u2014 if there are duplicates, my algorithm might return any one of them. But since the problem just asks for an index where the target is found, that's acceptable.\n\nTesting this logic with some examples.\n\nExample 1:\nList = [1,3,5,7,9], target =5.\nlow=0, high=4.\nmid=2. List[mid] is 5, so return 2. Correct.\n\nExample 2:\nList = [1,2,3,4,5,6], target=4.\nlow=0, high=5. mid=2, list[2]=3<4. So low=3. Next iteration, low=3, high=5. mid=4, list[4]=5>4. So high=3. Wait, but then low becomes 3 and high is 3, next mid is 3. list[3] is 4, so return 3. Correct.\n\nExample 3:\nList = [1,2,3,4], target=5.\nlow=0, high=3. mid=1, list[mid]=2 <5, so low=2. mid=(2+3)//2=2.5 becomes 2. list[2]=3 <5, low=3. Now low=3<=high=3. mid=3. list[3]=4 <5. Low becomes 4. Now loop condition is 4 <=3? No, so loop ends. Return -1. Correct.\n\nAnother test case: empty list. But the problem says the list may not be empty, so I don't need to handle that.\n\nLet me see another example where the target is not present: list is [2,4,6,8], target is 5.\n\nlow=0, high=3. mid=1 (4<5), low becomes 2. mid is (2+3)//2=2.5 becomes 2. list[2]=6>5, set high=1. Now low=2, high=1, loop ends. Return -1.\n\nYes, that works.\n\nWait, another test case where target is the first element: list is [10,20,30], target=10.\n\nmid is (0+2)//2=1. list[1]=20>10, so high=0. Now mid=(0+0)//2=0. list[0]=10, return 0. Correct.\n\nWhat if the target is the last element: same list, target=30. mid is 1, list[mid]=20<30, low becomes 2. mid=2, list[mid]=30, return 2. Correct.\n\nSo the logic seems solid.\n\nNow, I need to translate this into Python.\n\nFunction:\n\ndef binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            low = mid +1\n        else:\n            high = mid -1\n    return -1\n\nWait, but what if the list is empty? The problem says it may not be empty, so we don't have to handle that.\n\nTesting this function.\n\nTest 1: [1,3,5,7,9], 5 \u2192 returns 2.\n\nTest 2: [1,2,3,4,5,6],4\u2192 returns 3.\n\nTest3: [1,2,3,4],5\u2192 returns -1.\n\nTest4: [2,4,6,8],5\u2192 -1.\n\nTest5: [10,20,30],10\u21920.\n\nTest6: [10,20,30],30\u21922.\n\nYes, seems correct.\n\nBut wait, what if the list has only one element? Like [5], and target is 5. Then low=0, high=0\u2192 mid=0, returns 0. Correct.\n\nIf target is not in a single element list, like [5], target=3. Then mid=0, list[mid]=5>3, high = -1. So loop condition is 0 <=-1 \u2192 false, returns -1.\n\nYes, correct.\n\nSo I think this should work.\n</think>\n\nTo solve this problem, we need to perform a binary search on a sorted list of integers to find the index of a target value. If the target is found, we return its index; otherwise, we return -1. Binary search is efficient for this task as it works in O(log n) time complexity.\n\n### Approach\n1. **Initialize Pointers**: Start with two pointers, `low` set to 0 (the beginning of the list) and `high` set to the last index of the list.\n2. **Loop Until Pointers Converge**: Continue the search while `low` is less than or equal to `high`.\n3. **Calculate Midpoint**: Compute the middle index `mid` as the average of `low` and `high`, using integer division to ensure it's an integer.\n4. **Compare Values**:\n   - If the value at `mid` is equal to the target, return `mid`.\n   - If the value at `mid` is less than the target, adjust `low` to `mid + 1` to search the right half.\n   - If the value at `mid` is greater than the target, adjust `high` to `mid - 1` to search the left half.\n5. **Return -1 if Target Not Found**: If the loop exits without finding the target, return -1.\n\n### Solution Code\n```python\ndef binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n```\n\n### Explanation\n- **Initialization**: `low` is initialized to 0 and `high` to the last index of the list to cover the entire search range.\n- **Midpoint Calculation**: The midpoint `mid` is calculated to divide the search range roughly in half.\n- **Comparison and Adjustment**: By comparing the middle element with the target, the search range is efficiently halved each iteration, ensuring the algorithm quickly narrows down the possible locations of the target.\n- **Termination**: The loop terminates either when the target is found or the search range is exhausted, ensuring the function returns the correct index or -1 if the target is not present.\n\nThis approach efficiently narrows down the search space, making it much faster than a linear search, especially for large lists.",
  "r1_solution": "def binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1",
  "metadata": {
    "prompt_id": "00000073",
    "row_id": 73,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results2.jsonl"
}