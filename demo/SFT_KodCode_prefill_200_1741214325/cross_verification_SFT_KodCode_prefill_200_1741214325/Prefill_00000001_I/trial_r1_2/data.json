{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000001_I",
  "question": "Write a python function to sort an array using the selection sort algorithm.",
  "solution": "def selection_sort(arr):\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum element in remaining unsorted array\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Swap the found minimum element with the first element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
  "test_code": "from solution import selection_sort\n\ndef test_selection_sort_with_positive_numbers():\n    assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]\n\ndef test_selection_sort_with_negative_numbers():\n    assert selection_sort([-64, -25, -12, -22, -11]) == [-64, -25, -22, -12, -11]\n\ndef test_selection_sort_with_mixed_numbers():\n    assert selection_sort([-1, 5, -7, 8, 0, 12, 10]) == [-7, -1, 0, 5, 8, 10, 12]\n\ndef test_selection_sort_with_single_element():\n    assert selection_sort([5]) == [5]\n\ndef test_selection_sort_with_empty_list():\n    assert selection_sort([]) == []",
  "test_info": [
    {
      "function_name": "selection_sort",
      "parameter_list": "(arr)",
      "function_declaration": "def selection_sort(arr):",
      "docstring": "Sorts an array using the selection sort algorithm.\n:param arr: List of integers to be sorted\n:return: Sorted list of integers"
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, so I need to write a Python function to sort an array using the selection sort algorithm. Hmm, let me think about how selection sort works. From what I remember, selection sort is an in-place algorithm that works by dividing the array into a sorted and an unsorted portion. \n\nWait, right. The idea is that in each iteration, we find the smallest element from the unsorted part and swap it with the first element of the unsorted part. So the sorted portion gradually grows by one element each time.\n\nLet me break it down step by step. Suppose the array has n elements. We'll start by considering each position from 0 to n-1. For each position i, we need to find the minimum value in the subarray starting from i to the end. Once we find that minimum, we swap it with the element at position i.\n\nSo, in code terms, I'll need two loops. The outer loop will run from i=0 to i=n-1. The inner loop will find the minimum in the subarray from i onwards.\n\nWait, but what about variables? Let me think. I'll need a variable to track the index of the minimum element in the current subarray. Let's call it min_index. Initially, it can be set to i because the minimum could be at the current position.\n\nThen, for j in range from i+1 to n-1, compare each element. If arr[j] is smaller than the current minimum, update min_index to j.\n\nAfter finding the minimum, swap the elements at positions i and min_index.\n\nLet me consider an example to make sure I'm on the right track. Suppose the array is [64, 34, 25, 12, 22]. The first iteration (i=0) finds 12 as the minimum, swaps it with 64, so the array becomes [12, 34, 25, 22, 64]. Then i=1, the subarray is [34,25,22,64]. The minimum is 22, so swap with 34: [12,22,25,34,64]. And so on until the array is sorted.\n\nThat seems correct. Now, how to implement this in Python.\n\nThe function will take an array as input. We'll iterate over each position i from 0 to len(arr)-1. Then for each i, find the minimum element in arr[i:]. Wait, no, because in code, finding the minimum can be done, but for efficiency, since we're swapping, we can track the index.\n\nSo in the function:\n\ndef selection_sort(arr):\n\nFirst, get the length of the array, n = len(arr).\n\nFor i in range(n):\n\nThen, for each j starting from i+1 to n-1:\n\nWait, wait, no. The inner loop should find the minimum index. So inside the outer loop:\n\nmin_index = i\n\nThen, loop j from i+1 to n-1:\n\nif arr[j] < arr[min_index], then min_index = j.\n\nOnce the inner loop finishes, swap arr[i] and arr[min_index].\n\nThat's the core of it.\n\nSo putting it together:\n\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum element in the unsorted part\n        min_index = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        # Swap the found minimum element with the first element of the unsorted part\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr\n\nWait, but what about if the array is empty or has one element? Well, the outer loop won't run, and the function will return the array as is, which is correct.\n\nLet me test this code with the example I had earlier.\n\nTest case: [64, 34, 25, 12, 22]\n\nAfter i=0:\n\nj runs from 1 to 4. Compare 34, then 25 is smaller, then 12 is even smaller, then 22 is larger. So min_index becomes 3. Swap 64 and 12. Array becomes [12,34,25,22,64].\n\nThen i=1.\n\nj runs from 2 to 4.\n\nCompare 25: 22 is smaller. So min_index becomes 3. Swap 34 and 22: array becomes [12,22,25,34,64].\n\ni=2:\n\nj runs from 3 to 4. Current element is 25. Next elements are 34 and 64. So no change. Swap 25 with itself.\n\ni=3:\n\nj runs from 4, which is 4 <4? No. So no change, swap 34 with itself.\n\nSo the sorted array is [12,22,25,34,64], which is correct.\n\nAnother test case: empty list? Let's say arr is empty. The function returns it, which is correct.\n\nAnother test case: single element, should return as is.\n\nAnother test case: all elements same. No swaps, but the array is sorted.\n\nOkay, I think this should work. So the function is correctly implemented.\n\nI think that's all. The code should handle all cases.\n\nWait, another edge case: negative numbers.\n\nTest case: [ -5, 3, 0, -2]\n\ni=0:\n\nFind the minimum of [-5,3,0,-2]. The minimum is -5, at index 0. No swap.\n\ni=1:\n\nSubarray [3,0,-2]. The min is -2 at index 3. Swap 3 and -2. Array becomes [-5,-2,0,3].\n\ni=2:\n\nSubarray [0,3]. Min is 0, no swap.\n\ni=3: no loop runs. So the sorted array is [-5,-2,0,3], which is correct.\n\nLooks good.\n\nSo I think the code is correct.\n</think>\n\nTo implement the selection sort algorithm, we follow these steps:\n\n1. **Outer Loop**: Iterate over each element in the array, treating it as the start of the unsorted portion.\n2. **Inner Loop**: For each element identified in the outer loop, find the minimum element in the unsorted portion.\n3. **Swap**: Swap the identified minimum element with the current element in the outer loop.\n\nThe algorithm works by gradually building the sorted portion of the array by repeatedly finding the minimum element from the unsorted part and placing it at the beginning of the unsorted part.\n\nHere's the Python function that implements the selection sort algorithm:\n\n```python\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum element in the unsorted part\n        min_index = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        # Swap the found minimum element with the element at position i\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr\n```\n\n**Example Usage:**\n\n```python\n# Example 1\narr = [64, 34, 25, 12, 22]\nprint(\"Original array:\", arr)\nprint(\"Sorted array:\", selection_sort(arr))\n# Output should be: [12, 22, 25, 34, 64]\n\n# Example 2 (Edge Case: Negative Numbers)\narr = [-5, 3, 0, -2]\nprint(\"Original array:\", arr)\nprint(\"Sorted array:\", selection_sort(arr))\n# Output should be: [-5, -2, 0, 3]\n```\n\nThis function sorts an array in place in \\(O(n^2)\\) time complexity, making it less efficient on large datasets compared to other sorting algorithms like quicksort or mergesort. However, it has the advantage of minimizing the number of swaps, which can be beneficial in certain scenarios.",
  "r1_solution": "def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum element in the unsorted part\n        min_index = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        # Swap the found minimum element with the element at position i\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr",
  "metadata": {
    "prompt_id": "00000001",
    "row_id": 1,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results2.jsonl"
}