{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000001_I",
  "question": "Write a python function to sort an array using the selection sort algorithm.",
  "solution": "def selection_sort(arr):\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum element in remaining unsorted array\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Swap the found minimum element with the first element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
  "test_code": "from solution import selection_sort\n\ndef test_selection_sort_with_positive_numbers():\n    assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]\n\ndef test_selection_sort_with_negative_numbers():\n    assert selection_sort([-64, -25, -12, -22, -11]) == [-64, -25, -22, -12, -11]\n\ndef test_selection_sort_with_mixed_numbers():\n    assert selection_sort([-1, 5, -7, 8, 0, 12, 10]) == [-7, -1, 0, 5, 8, 10, 12]\n\ndef test_selection_sort_with_single_element():\n    assert selection_sort([5]) == [5]\n\ndef test_selection_sort_with_empty_list():\n    assert selection_sort([]) == []",
  "test_info": [
    {
      "function_name": "selection_sort",
      "parameter_list": "(arr)",
      "function_declaration": "def selection_sort(arr):",
      "docstring": "Sorts an array using the selection sort algorithm.\n:param arr: List of integers to be sorted\n:return: Sorted list of integers"
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, I need to write a Python function to sort an array using the selection sort algorithm. Let me think about how selection sort works. \n\nFrom what I remember, selection sort is an in-place comparison-based algorithm. It divides the array into a sorted part and an unsorted part. Each time, it selects the smallest element from the unsorted part and swaps it with the first element of the unsorted part. This process repeats until the array is fully sorted.\n\nSo, how do I implement this in Python? Let me outline the steps.\n\nFirst, I'll need a loop that goes through each position in the array. For each position, I'll find the smallest element in the remaining unsorted part. Once I find the smallest, I'll swap it with the current position.\n\nWait, how does the unsorted part shrink? Oh right, with each pass, the sorted portion increases from the start, while the unsorted starts right after the last sorted element.\n\nLet me think about the variables I'll need. Maybe have a variable for the current minimum value and its index. Also, I'll loop through each index starting from 0 to n-2, where n is the length of the array.\n\nLet's sketch this out:\n\n1. Iterate over each index i from 0 to len(arr)-1.\n2. For each i, find the minimum element between index i and the end of the array.\n3. Swap the found minimum element with the element at index i.\n\nThat sounds right. So, in code, the function will take an array as input and modify it in place. Or should I return a new array? Probably, I'll have the function modify the array and return it.\n\nWait, in Python, lists are mutable, so changes will affect the original array. But for good practice, maybe create a copy to avoid altering the input. Hmm, but the problem doesn't specify, so perhaps it's acceptable to sort the list in place.\n\nNow, writing the code step by step.\n\nFirst, I'll get the length of the array. Then loop through i from 0 to n-1.\n\nInside the loop, I'll set min_index to i. Then, for each j from i+1 to n-1, compare arr[j] with arr[min_index]. If it's smaller, update min_index.\n\nAfter finding the min_index for this i, swap arr[i] and arr[min_index].\n\nYes, that makes sense.\n\nLet me think about an example. Suppose the array is [64, 25, 12, 22, 11]. \n\nFirst i=0, min_index=0. Check j=1: 25 <64, so min_index becomes 1. j=2: 12 <25, min_index=2. j=3: 22>12, no change. j=4:11<12, so min_index=4. Swap arr[0] and arr[4], now array becomes [11,25,12,22,64].\n\nNext i=1. min_index=1. j=2:12<25, min_index=2. j=3:22>12, no change. j=4:64>12. So swap arr[1] and arr[2], array becomes [11,12,25,22,64].\n\ni=2. Now check j=3 and 4. 22<25, so min_index becomes3. Then j=4, 64>22. So swap arr[2] and arr[3], so array becomes [11,12,22,25,64].\n\ni=3. Check j=4, 64>25, so min_index stays 3. Swap does nothing.\n\nSo now the array is sorted.\n\nTesting with this example should be done in code, but for now, the logic seems correct.\n\nNow, about the function parameters. The function will take arr as an argument. So:\n\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_index = i\n        # find the minimum element in the unsorted portion\n        for j in range(i+1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        # swap the found minimum element with the first element of unsorted\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr\n\nWait, but what if the array is empty or has only one element? The function should handle it, but since in such cases the loops won't run, it's fine.\n\nLet me test another case, like [5,3,8,2]. \n\nInitial array: [5,3,8,2]\ni=0, min_index starts at 0. j=1: 3<5, min_index=1. j=2:8>3, no. j=3:2<3, min_index=3. Swap 0 and 3: [2,3,8,5]\ni=1. min_index=1. j=2:8>3, no. j=3:5>3 no. So swap nothing.\ni=2. Check j=3:5<8, min_index=3. Swap 2 and 3: [2,3,5,8]\ni=3: no further steps.\n\nSo it works.\n\nWhat about duplication? Like [5,3,3,2]. \n\ni=0, find min index which is 3. Swap 0 and 3: [2,3,3,5]\ni=1, find min in j=2 and 3: both 3 equals. So min index is 1. No swap, since it's same as original.\ni=2, compare j=3: 5>3, no change. Swap nothing.\nSo array becomes [2,3,3,5], correct.\n\nWhat about negative numbers? [ -5, -2, -8]. \n\ni=0, find min. j=1, -2 > -5, no change. j=2, -8 < -5, min_index becomes 2. Swap: so array becomes [-8,-2,-5]\ni=1. j=2, -5> -2, so no change. Swap nothing.\ni=2. Nothing.\n\nSo function handles negatives correctly.\n\nPotential issues: if the list is modified, but I think the code is correct.\n\nEdge cases: empty list returns the same, single element remains same.\n\nSo the function should be correct.\n</think>\n\nTo solve this problem, we need to implement the selection sort algorithm to sort an array in ascending order. The selection sort algorithm works by continuously finding the minimum element from the unsorted part of the array and swapping it with the first unsorted element.\n\n### Approach\nThe selection sort algorithm can be broken down into the following steps:\n\n1. **Initialize**: Start with the entire array as the unsorted portion.\n2. **Iterate**: Loop through each element in the array one by one.\n3. **Find Minimum**: For each element, find the minimum value in the remaining unsorted portion of the array.\n4. **Swap**: Swap the found minimum value with the current element.\n5. **Repeat**: Continue this process until the entire array is sorted.\n\nThe algorithm maintains two subarrays within the given array:\n- A sorted subarray (starting from the beginning of the array).\n- An unsorted subarray (containing the remaining elements).\n\nBy repeating the process of finding the minimum element and swapping it into the correct position, the sorted subarray gradually expands to cover the entire array.\n\n### Solution Code\n```python\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_index = i\n        # Traverse the array to find the minimum element in the unsorted portion\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        # Swap the found minimum element with the first element of the unsorted portion\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr\n```\n\n### Explanation\n1. **Initialization**: The function takes an array `arr` as input and determines its length `n`.\n2. **Outer Loop**: The outer loop runs from the first element to the second-to-last element (`i` from 0 to `n-1`).\n3. **Finding Minimum**: For each `i`, the inner loop searches for the minimum element in the subarray starting from `i` to the end of the array. The index of this minimum element is stored in `min_index`.\n4. **Swapping**: Once the minimum element is found, it is swapped with the element at index `i`.\n5. **Result**: After all iterations, the array is sorted in ascending order and returned.\n\nThis approach ensures that by the end of each iteration, the next smallest element is placed in its correct position, gradually building up the sorted portion of the array. The time complexity of this algorithm is O(n\u00b2), making it suitable for small datasets due to its simplicity and in-place sorting capability.",
  "r1_solution": "def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_index = i\n        # Traverse the array to find the minimum element in the unsorted portion\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        # Swap the found minimum element with the first element of the unsorted portion\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr",
  "metadata": {
    "prompt_id": "00000001",
    "row_id": 1,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}