{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000189_C",
  "question": "def is_fibonacci_number(n: int) -> bool:\n    \"\"\"Returns True if n is a Fibonacci number, False otherwise.\"\"\"\n    # A number is Fibonacci if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square\n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)\n    \ndef is_perfect_square(x: int) -> bool:\n    s = int(x ** 0.5)\n    return s * s == x",
  "solution": "def is_perfect_square(x):\n    s = int(x ** 0.5)\n    return s * s == x\n\ndef is_fibonacci_number(n):\n    \"\"\"\n    Returns True if n is a Fibonacci number, False otherwise.\n    \"\"\"\n    # A number is Fibonacci if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square\n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)",
  "test_code": "from solution import is_fibonacci_number, is_perfect_square\n\ndef test_is_perfect_square():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(9) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(17) == False\n\ndef test_is_fibonacci_number():\n    assert is_fibonacci_number(0) == True\n    assert is_fibonacci_number(1) == True\n    assert is_fibonacci_number(5) == True\n    assert is_fibonacci_number(8) == True\n    assert is_fibonacci_number(13) == True\n    assert is_fibonacci_number(21) == True\n    assert is_fibonacci_number(34) == True\n    assert is_fibonacci_number(55) == True\n    assert is_fibonacci_number(6) == False\n    assert is_fibonacci_number(-4) == False\n    assert is_fibonacci_number(20) == False",
  "test_info": [
    {
      "function_name": "is_perfect_square",
      "parameter_list": "(x)",
      "function_declaration": "def is_perfect_square(x):",
      "docstring": null
    },
    {
      "function_name": "is_fibonacci_number",
      "parameter_list": "(n)",
      "function_declaration": "def is_fibonacci_number(n):",
      "docstring": "Returns True if n is a Fibonacci number, False otherwise."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function called is_fibonacci_number that takes an integer n and returns True if it's a Fibonacci number, otherwise False. Hmm, I remember there's a mathematical way to check if a number is a Fibonacci number without generating the entire sequence. Oh right, I think it has something to do with perfect squares. \n\nWait, the explanation said that a number n is Fibonacci if either 5n\u00b2 + 4 or 5n\u00b2 -4 is a perfect square. So the function can calculate both of these values for a given n and check if either is a perfect square.\n\nSo first, I need to implement the check for perfect squares. That makes sense. I'll create a helper function called is_perfect_square which takes an integer x and returns whether x is a perfect square. \n\nFor the is_perfect_square function, the way to check is to compute the square root of x, round it down to the nearest integer, then square that integer and see if it equals x. Yeah, that's a standard method. So I'll compute s as the integer part of sqrt(x), then check s squared equals x.\n\nThen, in the main function, is_fibonacci_number, I'll compute both 5n\u00b2 +4 and 5n\u00b2 -4 and pass each to is_perfect_square. If either returns True, the function returns True. Otherwise, False. I should make sure that n is not a negative number because Fibonacci numbers are non-negative. Wait, but according to the definition, the helper function is_perfect_square will handle cases where x could be zero, including negative x, but since in is_fibonacci_number we'll compute 5n\u00b2+/-4, which are non-negative as n is squared.\n\nWait a second, what if n is zero? Let me think about the Fibonacci sequence. Well, sometimes the sequence starts with 0, 1, 1... so 0 is a Fibonacci number. Let me test n=0. Plugging into 5*0 + 4 is 4, which is 2 squared, so yes, 0 is Fibonacci. \n\nWhat about n=1? 5*1 +4=9, sqrt(9) is 3. 5-4=1, sqrt is 1. So yes, 1 is Fibonacci. Good.\n\nWhat about n=2? Let's see: 5*(2^2) = 20, plus 4 is 24, minus 4 is 16 (which is 4 squared). So 16 is a perfect square, so 2 is a Fibonacci. Yes, it is.\n\nSo the function should handle all these cases correctly.\n\nI also need to consider edge cases, like n being negative. Since the function's parameter is an integer, but the Fibonacci sequence isn't defined for negatives in the standard sense, should I handle that? Looking at the problem statement: the function should return False if the number isn't Fibonacci. So if n is negative, neither 5n\u00b2+4 nor -4 would change the fact because n squared is positive. However, n could be negative, but the function's logic would still check if those terms are perfect squares. But let's think: Is -1 a Fibonacci number? In the standard sequence, the Fibonacci numbers are 0,1,1,2,3,5... so negatives aren't part of the sequence. Therefore, if n is negative, the function should return False. But wait, let's compute for n negative. For example, n=-1: 5*(-1)^2 is 5, +4 is 9 which is perfect square. So according to our function, it would return True.\n\nBut that's incorrect because -1 isn't part of the Fibonacci sequence. Hmm, that's an issue. So I think we need to add a condition that n must be a non-negative integer.\n\nSo the is_fibonacci_number function should probably first check if n is non-negative. So, in the code, the very first step would be: if n < 0, return False. Because in mathematics, Fibonacci numbers are a sequence of non-negative integers.\n\nSo I need to adjust the function to include that condition.\n\nLet me think about the steps:\n\ndef is_fibonacci_number(n: int) -> bool:\n    if n < 0:\n        return False\n    # compute if 5n^2 \u00b14 is perfect square\n    return is_perfect_square(5 * n * n +4) or is_perfect_square(5 * n * n -4)\n\nWait wait, but wait for n=0: 5*0 +4 =4 (sqrt 2), 5*0 -4= -4, which can't be a perfect square, but the helper function would compute sqrt(-4), which is a float, and casting it to int would result in some number, say, s=2 when x is 4, but when x is negative, in is_perfect_square, s would be a complex number because x is negative. Wait no, in Python, the ** operator for a negative base and fractional exponent raises a ValueError. Hmm, but the input x is an integer, and for is_perfect_square I have x as 5*n^2 + something. For n negative, 5n^2 is positive. So when n is negative, 5n^2 is same as positive n, so adding or subtracting 4, the results are same. But I should reject n being negative because Fibonacci numbers are non-negative.\n\nSo the first check in the function must be: if n is negative, return False. That's necessary.\n\nSo in code: add that condition at the top of the function.\n\nSo, putting it together:\n\nFunction is_perfect_square(x). Compute s, which is the integer part of sqrt(x). If s squared equals x, return True, else False. But also, we need to handle x < 0. But in the context, since x is either 0 or positive, because it's either 5n\u00b2 +4 or 5n\u00b2 -4, and n is non-negative, 5n\u00b2 is non-negative. So, 5n\u00b2 -4 can be negative when n is 0 or 1. For example, n=0: 5*0*0 -4 =-4. So is_perfect_square might get negative numbers.\n\nBut wait, let's think about n being 1: 5*1*1=5, 5 +4=9, 5-4=1. For n=1, both are perfect squares. So in that case, it's correct.\n\nBut n=0: 5*0^2 =0. So 0 +4=4 (perfect square), 0-4=-4 (negative). So is_perfect_square would receive x=-4. Computing s as sqrt(-4), but in Python, you can't, except x is integer.\n\nWait, let me see. What does int(x ** 0.5) do when x is negative?\n\nIn Python, if x is negative, x ** 0.5 returns a complex number, but when you take int(), perhaps it's an error? Or would it compute the magnitude?\n\nNo, let me test. Wait, in Python:\n\nIf x is negative, x ** 0.5 raises ValueError when using pow with fractional exponents? Or is it handled in the math module?\n\nWait, in the helper function is_perfect_square, when x is negative, s = int(x ** 0.5) would raise a ValueError? Because for example, (-4) ** 0.5 is a complex number.\n\nWait no, wait: in the code I have, perhaps I'm using math.sqrt or just using **0.5. The code in the function is:\n\ns = int(x ** 0.5)\n\nBut wait, in Python, x can be negative here? Because when n is 0, x becomes -4 in the check for 5n\u00b2 -4.\n\nSo, perhaps for x negative, s will be int of a complex number, which will raise an error or something. Or wait, no. Because in Python, if you raise a negative number to the 0.5 power with **, like (-4)**0.5, it returns a complex number.\n\nSo, trying to compute s = int((-4)**0.5) would result in s being the integer of (2j), which is '2j' as a complex number, but when you do int(2j) in Python, it throws an error. Thus, trying that function would crash the program if x is negative, which can happen for n=0, 1, and maybe other small values.\n\nWait no, when n is 1: 5*(1)^2 +4=9, 5-4=1. Both are perfect squares. So when n=0, 5*0*0 +4 is 4, which is a perfect square. So is_fibonacci_number(0) returns True. But the other part would compute x= -4. So, for n=0, 5n\u00b2+4 is 4 (perfect square), so the function returns True. So in that case, the other part (5n\u00b2-4=-4) is irrelevant. But the helper function might receive x=-4 and then when computing x**0.5, that's a problem.\n\nSo for the helper function, I need to handle x negative. Maybe first check if x is negative, and then return False immediately.\n\nBecause negative numbers can't be perfect squares, right? So in is_perfect_square, first check if x < 0: return False.\n\nYes, that's an important step. So I'll modify the helper function to handle x negative.\n\nSo the helper function becomes:\n\ndef is_perfect_square(x: int) -> bool:\n    if x < 0:\n        return False\n    s = int(x ** 0.5)\n    return s * s == x\n\nThat way, any negative x will immediately return False. That's better.\n\nSo now, the code is:\n\ndef is_fibonacci_number(n: int) -> bool:\n    if n < 0:\n        return False\n    return is_perfect_square(5 * n * n +4) or is_perfect_square(5 * n * n -4)\n\ndef is_perfect_square(x: int) -> bool:\n    if x <0:\n        return False\n    s = int(x**0.5)\n    return s * s == x\n\nTesting for n=0: \n\n5*0^2 +4=4 (s is 2, 2\u00b2=4 \u2192 True). So the function returns True.\n\nn=1: 5*1+4=9 (3\u00b2) and 5-4=1, so both squares, but only one needs to be. So returns True.\n\nn=2: 5*4 +4=24 (no), 5*4-4=16 (4\u00b2, yes). So returns True.\n\nn=3: 5*9=45. +4 is 49 (7\u00b2), yes \u2192 returns True.\n\nn=4: 5*16=80+4=84, 80-4=76. Are either perfect squares? 84 is not, 76 is not (sqrt 76 is around 8.717, so 8\u00b2 is 64,9\u00b2 81, nothing. So function returns False.)\n\nWait wait, but 4 is a Fibonacci number.\n\nWait wait, wait. The Fibonacci sequence is: 0,1,1,2,3,5,8,13, etc. So 4 is not in the sequence. So function correctly returns False for n=4.\n\nAnother test: n=5.\n\n5*25=125. +4=129, -4=121 (11\u00b2 \u2192 yes). So function returns True. Correct because 5 is a Fibonacci.\n\nWhat about n=6:\n\n5*36=180. +4=184, -4=176. 184 and 176's square roots are about 13.56 and 13.26, which are not integer. So function returns False, correct because 6 is not in the Fibonacci sequence.\n\nAnother test, n=8: 5*64=320. +4=324 (18\u00b2), so yes. So function returns True.\n\nBut wait, in the Fibonacci sequence, 8 is a Fibonacci number (sequence: 0,1,1,2,3,5,8,13, etc.) So function returns correctly.\n\nWhat about n=13: 5*169=845. +4=849, not a square; -4=841, which is 29\u00b2, because 29\u00b2 is 841. So yes. So function returns True.\n\nSo these tests seem to work.\n\nWhat about n=2: 5*4=20, plus 4=24, minus 4=16. 16 is perfect square. So correctly returns True.\n\nSo the code seems correct.\n\nI think that's solid. So the helper function first checks for negative, then computes s as sqrt(x), and then tests s squared equals x.\n</think>\n\nTo determine whether a given integer \\( n \\) is a Fibonacci number, we can use a mathematical property: a number \\( n \\) is a Fibonacci number if and only if at least one of \\( 5n^2 + 4 \\) or \\( 5n^2 - 4 \\) is a perfect square. \n\n### Approach\n1. **Check for Non-Negative Input**: Since Fibonacci numbers are non-negative, we immediately return `False` if \\( n \\) is negative.\n2. **Perfect Square Check**: For a given number to be a perfect square, we compute the integer square root and verify if squaring it gives back the original number.\n3. **Mathematical Property**: Compute both \\( 5n^2 + 4 \\) and \\( 5n^2 - 4 \\) and check if either of these values is a perfect square using the helper function.\n\n### Solution Code\n```python\ndef is_fibonacci_number(n: int) -> bool:\n    \"\"\"Returns True if n is a Fibonacci number, False otherwise.\"\"\"\n    if n < 0:\n        return False\n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)\n\ndef is_perfect_square(x: int) -> bool:\n    if x < 0:\n        return False\n    s = int(x ** 0.5)\n    return s * s == x\n```\n\n### Explanation\n- **Non-Negative Check**: The function starts by checking if \\( n \\) is negative and returns `False` if it is.\n- **Perfect Square Helper Function**: This function checks if a number is a perfect square by computing its integer square root and verifying the square.\n- **Mathematical Check**: The main function uses the property that if either \\( 5n^2 + 4 \\) or \\( 5n^2 - 4 \\) is a perfect square, then \\( n \\) must be a Fibonacci number.\n\nThis approach efficiently determines if \\( n \\) is part of the Fibonacci sequence without generating the entire sequence, making it both time and space efficient.",
  "r1_solution": "def is_fibonacci_number(n: int) -> bool:\n    \"\"\"Returns True if n is a Fibonacci number, False otherwise.\"\"\"\n    if n < 0:\n        return False\n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)\n\ndef is_perfect_square(x: int) -> bool:\n    if x < 0:\n        return False\n    s = int(x ** 0.5)\n    return s * s == x",
  "metadata": {
    "prompt_id": "00000189",
    "row_id": 189,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to check if a given number is a Fibonacci number or not."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}