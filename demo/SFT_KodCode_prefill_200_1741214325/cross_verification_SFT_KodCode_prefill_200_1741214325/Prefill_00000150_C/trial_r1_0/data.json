{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000150_C",
  "question": "def is_power_of_two(n: int) -> bool:\n    \"\"\" Determine if a given number is a power of two.\n    >>> is_power_of_two(-4)\n    False\n    >>> is_power_of_two(0)\n    False\n    >>> is_power_of_two(1)\n    True\n    >>> is_power_of_two(2)\n    True\n    >>> is_power_of_two(4)\n    True\n    >>> is_power_of_two(3)\n    False\n    >>> is_power_of_two(8)\n    True\n    >>> is_power_of_two(15)\n    False\n    >>> is_power_of_two(16)\n    True\n    >>> is_power_of_two(32)\n    True\n    \"\"\"",
  "solution": "def is_power_of_two(n):\n    \"\"\"\n    Returns True if n is a power of two, otherwise False.\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0",
  "test_code": "def test_is_power_of_two():\n    assert not is_power_of_two(-4)\n    assert not is_power_of_two(0)\n    assert is_power_of_two(1)\n    assert is_power_of_two(2)\n    assert is_power_of_two(4)\n    assert not is_power_of_two(3)\n    assert is_power_of_two(8)\n    assert not is_power_of_two(15)\n    assert is_power_of_two(16)\n    assert is_power_of_two(32)",
  "test_info": [
    {
      "function_name": "is_power_of_two",
      "parameter_list": "(n)",
      "function_declaration": "def is_power_of_two(n):",
      "docstring": "Returns True if n is a power of two, otherwise False."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to figure out how to write a function called is_power_of_two that takes an integer n and returns a boolean. The function should return True only if n is a power of two; otherwise, it returns False. \n\nLet me think about what a power of two is. A power of two means the number is 2 raised to some integer exponent. So numbers like 1 (2^0), 2 (2^1), 4 (2^2), 8 (2^3), 16 (2^4), etc., are powers of two. Negative numbers can't be powers of two because any power of two is positive. Also, zero isn't a positive number, so it should return False.\n\nSo the steps are:\n1. Check if n is less than 1. If yes, return False because negative numbers and zero aren't powers of two.\n2. For positive numbers, check if n is a power of two.\n\nBut wait, n can be 1, which is 2^0. So for n=1, return True.\n\nHow do I check if a positive number is a power of two? Well, a number that is a power of two has exactly one bit set in its binary representation. For example, 2 is 10, 4 is 100, 8 is 1000, etc. So if I can determine if there's exactly one 1 in the binary form of n, then it's a power of two.\n\nAnother way is using bitwise operations. For a number n, if it's a power of two, then n & (n - 1) should be zero but n itself shouldn't be zero. Wait, let me think: Because for 2^x, subtracting 1 will flip all the lower bits. For example, 8 (1000) minus 1 is 7 (0111). ANDing 8 & 7 gives 0000. But wait, what about n=1: 1 is 1 in binary. n-1 is 0, so 1 & 0 = 0, which is correct.\n\nSo the condition can be: n > 0 and (n & (n - 1)) == 0.\n\nLet me test this condition:\n\nn=1: 1>0 is True, 1 & 0 = 0 \u2192 True.\nn=2: 2>0, 2&1 = 0 \u2192 True.\nn=4:4>0, 4&3= 0 \u2192 True.\nn=3: 3>0, 3&2= 2 \u2192 not 0 \u2192 False.\nn=0: 0>0? No \u2192 False.\nn=-4: Also false because n>0 is false.\n\nThis seems to cover all cases. So the function can be written as checking if n is > 0 and n & (n-1) equals 0.\n\nWait, but what about n=0? It's covered because it's not >0, returns False.\n\nSo putting it all together, the function returns True only when n is a positive integer and after the bitwise AND operation between n and (n-1) equals zero.\n\nWait, but another way is that a power of two also satisfies the condition that it's a positive integer, and when you divide it by two repeatedly, you eventually reach 1, without any remainders. But using bitwise operations is more efficient.\n\nSo I think using the bitwise method is the way to go.\n\nLet me see the test cases:\n\nTest case 1: is_power_of_two(-4) should return False. Our code will return False because n is less than 1.\n\nTest case 2: is_power_of_two(0) returns False. Correct.\n\nTest case 3: is_power_of_two(1) returns True. Correct.\n\nTest case 4: is_power_of_two(2) is True. Correct.\n\nTest case 5: is_power_of_two(4): True.\n\nTest case 6: is_power_of_two(3): False. Correct.\n\nTest case 7: is_power_of_two(8): True.\n\nTest case 8: is_power_of_two(15): False.\n\nTest case9: is_power_of_two(16): True.\n\nTest case10: is_power_of_two(32): True.\n\nAll of these should be correctly handled by the condition.\n\nBut wait: What about n=0? Yeah, n>0 is false, returns False.\n\nWhat about when n is 1? n>0 is True, 1 & 0 is 0, so returns True.\n\nSo the code will be:\n\ndef is_power_of_two(n: int) -> bool:\n    return n > 0 and (n & (n - 1)) == 0\n\nWait, but wait another test. For n=1, yes correct. What about for n=2, correct.\n\nWait another thought: Is there any number that is a power of two but n & (n -1) is not zero? I think not.\n\nAnother approach: Let's write a few test cases manually.\n\nn=1: 1&0=0 \u2192 True.\n\nn=2: 10, n-1 is 1 \u2192 10 & 01 = 0.\n\nn=3: 10 & 01 is 10, which is not zero \u2192 correct.\n\nn=4:100, n-1=011 \u2192 & is 0.\n\nSo yes, the bitwise approach works.\n\nI think that's the way to go.\n\nSo the function can be written concisely.\n\nLooking back at the problem statement, just implementing this condition should solve the problem.\n\nAnother thing to consider: Does this handle large numbers, say n=2^30? Yes, because Python handles big integers.\n\nSo I'm confident with this approach.\n</think>\n\nTo determine if a given integer is a power of two, we can leverage the properties of binary numbers. A number is a power of two if it has exactly one bit set in its binary representation. This means that for such a number `n`, the bitwise operation `n & (n - 1)` will result in zero because subtracting one from a power of two flips all the lower bits. Additionally, the number must be positive since powers of two are always positive.\n\nHere is the step-by-step approach:\n1. Check if the number is positive. If not, it's not a power of two.\n2. Use the bitwise operation `n & (n - 1)`. If the result is zero, the number is a power of two.\n\nThe function is implemented as follows:\n\n```python\ndef is_power_of_two(n: int) -> bool:\n    return n > 0 and (n & (n - 1)) == 0\n```\n\n### Explanation\n- The function first checks if `n` is greater than zero to ensure we are dealing with a positive number.\n- It then checks if `n` is a power of two by using the bitwise operation `n & (n - 1)`. If this operation results in zero, `n` is a power of two because it has exactly one bit set in its binary form.\n\nThis method efficiently and correctly identifies whether a number is a power of two with constant time complexity O(1).",
  "r1_solution": "def is_power_of_two(n: int) -> bool:\n    return n > 0 and (n & (n - 1)) == 0",
  "metadata": {
    "prompt_id": "00000150",
    "row_id": 150,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to determine if a given number is a power of two. A number is a power of two if it can be represented as 2^k where k is a non-negative integer. Assume the input is always a valid integer, both positive and negative, but negative numbers should be immediately determined as not powers of two."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}