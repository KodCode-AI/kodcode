{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000150_C",
  "question": "def is_power_of_two(n: int) -> bool:\n    \"\"\" Determine if a given number is a power of two.\n    >>> is_power_of_two(-4)\n    False\n    >>> is_power_of_two(0)\n    False\n    >>> is_power_of_two(1)\n    True\n    >>> is_power_of_two(2)\n    True\n    >>> is_power_of_two(4)\n    True\n    >>> is_power_of_two(3)\n    False\n    >>> is_power_of_two(8)\n    True\n    >>> is_power_of_two(15)\n    False\n    >>> is_power_of_two(16)\n    True\n    >>> is_power_of_two(32)\n    True\n    \"\"\"",
  "solution": "def is_power_of_two(n):\n    \"\"\"\n    Returns True if n is a power of two, otherwise False.\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0",
  "test_code": "def test_is_power_of_two():\n    assert not is_power_of_two(-4)\n    assert not is_power_of_two(0)\n    assert is_power_of_two(1)\n    assert is_power_of_two(2)\n    assert is_power_of_two(4)\n    assert not is_power_of_two(3)\n    assert is_power_of_two(8)\n    assert not is_power_of_two(15)\n    assert is_power_of_two(16)\n    assert is_power_of_two(32)",
  "test_info": [
    {
      "function_name": "is_power_of_two",
      "parameter_list": "(n)",
      "function_declaration": "def is_power_of_two(n):",
      "docstring": "Returns True if n is a power of two, otherwise False."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, I need to write a function called is_power_of_two which determines if a given integer n is a power of two. Hmm, so what's a power of two? Well, numbers like 1, 2, 4, 8, 16, etc. They can be expressed as 2^k where k is a non-negative integer.\n\nWait, but wait. Looking at the examples, when n is 0, it returns False. That makes sense because 0 can't be represented as a power of 2 in this context\u2014like 2 to the power of a negative number is fractional, but n has to be a positive integer. So n must be greater than 0.\n\nSimilarly, negative numbers like -4 return False. So first thing, I should check if n is less than or equal to 0. If so, return False immediately.\n\nNow, for positive n. How do I check if it's a power of two? One method is to use bitwise operations since powers of two have a specific binary form.\n\nI remember that a number that's a power of two has exactly one bit set in its binary representation. For example, 2 is 10, 4 is 100, 8 is 1000, etc. So if I can check if n has only one bit set, that would solve the problem.\n\nHow do I check if a number has only one bit set? Well, in programming, a common trick is to use the bitwise AND operator. If I take n & (n-1), that should give me zero if n is a power of two. Because for example, 4 is 100, subtracting 1 gives 011. ANDing them gives 000, which is zero. But what happens for numbers that aren't a power of two? Like 3, which is 11 in binary. Subtracting 1 gives 10. 3 & 2 is 2, which isn't zero.\n\nSo the test is: if (n & (n - 1)) == 0, then it's a power of two, else not. But wait, I also need to remember that n must be positive. So putting it all together:\n\nThe function should return True if n is greater than 0 and (n & (n-1)) is zero.\n\nLet's test this logic against the examples given.\n\nTest case 1: is_power_of_two(-4) should return False. n is negative, so correct.\n\nTest case 2: is_power_of_two(0) is False. Correct, since 0 isn't positive.\n\nTest case 3: is_power_of_two(1). n >0, and 1 & 0 is 0, so True. Correct.\n\nTest case 4: is_power_of_two(2): 2 & 1 is 0, so True.\n\nTest case 5: is_power_of_two(4): same logic as above. So True.\n\nTest case 6: is_power_of_two(3): 3 in binary is 11. 3 & 2 is 2, not zero. So returns False. Correct.\n\nTest case 7: 8: returns True.\n\nn=15: 15 in binary is 1111. n-1 is 14 (1110). 15 &14 is 14 (1110), which is non-zero, so returns False.\n\nn=16: binary 10000. n-1=15 which is 01111. AND is zero. True.\n\nn=32: same logic, returns True.\n\nSo this logic seems to cover all the cases.\n\nWait, wait! What about n=1? Because 1 is 2^0, which is a power of two, so it should return True. So yes, the logic works.\n\nWhat about n=2^31? For example, 2147483648, that's 2^31, so that should return True.\n\nWhat about numbers like 64, which is 2^6, it should return True.\n\nAnother test case not in the examples: n=64 -> True. n=65: 64 is 1000000, 65 is 1000001. 65 &64 is 64, which is not zero. So returns False.\n\nSo the algorithm is: if n <=0, return False; else, check if (n & (n-1)) equals zero.\n\nNow, to implement this.\n\nBut wait, what about n=0: covered by the first condition.\n\nLet me write the function.\n\nSo the function can be:\n\ndef is_power_of_two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\nWait a second, but what about n=1? 1-1 is 0. 1 & 0 is 0, so returns True. Correct.\n\nI think this should handle all cases. But are there any edge cases where this might fail?\n\nWait, no. Because for the number 1: 2^0 is allowed. And for larger exponents, the function correctly identifies it.\n\nAnother test: n=2^30 is 1073741824, which should return True.\n\nSo yes, this should handle all cases.\n\nLet me recheck the examples:\n\n- -4: False. Correct.\n\n- 0: False. Correct.\n\n- 1: True.\n\n- 2: True.\n\n-3: 3-1 is 2. 3 &2 is 2, which is not zero. So return False.\n\nEverything matches the expected outputs.\n\nSo the function should be as written above.\n</think>\n\nTo determine if a given number is a power of two, we can leverage the properties of binary numbers. A power of two has exactly one bit set in its binary representation. Using bitwise operations, we can efficiently check for this condition.\n\n### Approach\nThe approach involves two main steps:\n1. Check if the number is less than or equal to zero, in which case it cannot be a power of two.\n2. Use a bitwise operation to determine if the number has exactly one bit set. Specifically, for a power of two, performing a bitwise AND of the number with itself minus one will result in zero (since subtracting one from a number that is a power of two flips all the bits after the single set bit).\n\n### Solution Code\n\n```python\ndef is_power_of_two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n```\n\n### Explanation\n1. **Check for Non-Positive Numbers**: The function first checks if the input `n` is less than or equal to zero. Negative numbers and zero cannot be powers of two, so the function returns `False` immediately in such cases.\n2. **Bitwise Check for Single Set Bit**: For positive numbers, the function then checks if `n & (n - 1) == 0`. This operation effectively determines if there is only one bit set in the binary representation of `n`. If the result is zero, `n` is a power of two; otherwise, it is not.\n\nThis approach ensures that the solution is both efficient and concise, leveraging bitwise operations to quickly determine the result.",
  "r1_solution": "def is_power_of_two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0",
  "metadata": {
    "prompt_id": "00000150",
    "row_id": 150,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to determine if a given number is a power of two. A number is a power of two if it can be represented as 2^k where k is a non-negative integer. Assume the input is always a valid integer, both positive and negative, but negative numbers should be immediately determined as not powers of two."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results2.jsonl"
}