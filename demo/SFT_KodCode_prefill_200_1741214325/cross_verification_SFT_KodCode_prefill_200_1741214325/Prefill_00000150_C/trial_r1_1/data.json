{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000150_C",
  "question": "def is_power_of_two(n: int) -> bool:\n    \"\"\" Determine if a given number is a power of two.\n    >>> is_power_of_two(-4)\n    False\n    >>> is_power_of_two(0)\n    False\n    >>> is_power_of_two(1)\n    True\n    >>> is_power_of_two(2)\n    True\n    >>> is_power_of_two(4)\n    True\n    >>> is_power_of_two(3)\n    False\n    >>> is_power_of_two(8)\n    True\n    >>> is_power_of_two(15)\n    False\n    >>> is_power_of_two(16)\n    True\n    >>> is_power_of_two(32)\n    True\n    \"\"\"",
  "solution": "def is_power_of_two(n):\n    \"\"\"\n    Returns True if n is a power of two, otherwise False.\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0",
  "test_code": "def test_is_power_of_two():\n    assert not is_power_of_two(-4)\n    assert not is_power_of_two(0)\n    assert is_power_of_two(1)\n    assert is_power_of_two(2)\n    assert is_power_of_two(4)\n    assert not is_power_of_two(3)\n    assert is_power_of_two(8)\n    assert not is_power_of_two(15)\n    assert is_power_of_two(16)\n    assert is_power_of_two(32)",
  "test_info": [
    {
      "function_name": "is_power_of_two",
      "parameter_list": "(n)",
      "function_declaration": "def is_power_of_two(n):",
      "docstring": "Returns True if n is a power of two, otherwise False."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    0
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nAlright, I need to write a function called is_power_of_two that determines if a given integer is a power of two. Hmm, okay, let's think about what a power of two means. \n\nA power of two is any number that can be expressed as 2 raised to an integer exponent. Like 1 is 2^0, 2 is 2^1, 4 is 2^2, 8 is 2^3, and so on. But wait, what about negative numbers? Oh right, negative numbers can't be powers of two because 2 to any integer power is positive. So if n is negative, we immediately return False.\n\nAlso, what about zero? Hmm, 0 isn't a power of two because 2 can't be raised to any exponent to get zero. So 0 should return False.\n\nSo first, I need to handle the cases where n is less than or equal to zero. So in the function, if n <= 0, return False.\n\nNow, for positive n: how do I check if it's a power of two. Well, I remember that a number that's a power of two has exactly one bit set in its binary representation. So for example, 4 is 100 in binary, 8 is 1000, etc.\n\nSo, how can I check if a number has only one '1' bit. One method is to use bitwise operations. Like, if a number is a power of two, then n & (n-1) should be zero. Because subtracting 1 from a number like 4 (100) gives 3 (011). And when you perform a bitwise AND between 4 and 3, it's 000, which is zero.\n\nWait, let me test that with other numbers. Take 2: subtract 1 gives 1. 2 is 10, 1 is 01. AND is 00, which is zero. For 1: subtracting 1 gives 0. 1 & 0 is 0. So that works.\n\nBut wait, what about numbers that aren't powers of two, like 3. 3 in binary is 11. Subtract 1 gives 2 (10). 3 & 2 is 10, which is 2, not zero. So that correctly returns False.\n\nSo the condition is: after handling n <=0, check whether (n & (n-1)) == 0. If yes, return True, else False.\n\nWait a second, but when n is 1, which is 2^0, our condition (n & (n-1)) would do 1 & 0 which is 0, so it would return True. That's correct.\n\nSo putting it all together, the function should:\n\n- Check if n is less than or equal to 0. If yes, return False.\n- Else, check if n & (n-1) equals zero. If yes, return True, else False.\n\nLet me think about test cases.\n\nTest case 1: n=-4 --> should return False.\nIs -4 a power of two? No, so correct.\n\nTest case 2: n=0 --> returns False. Correct.\n\nTest case3: n=1 \u2192 True. Yes.\n\nTest case4: n=2 \u2192 True. Yes.\n\nTest case5: n=3 \u2192 False. Correct.\n\nTest case6: n=4 \u2192 True. Correct.\n\nn=15 is 1111 in binary, so n-1 is 14 (1110), and 15 &14 is14, not zero. So returns False.\n\nn=16: 10000, n-1=15 which is 01111. 10000 & 01111 is 00000. So returns True.\n\nWhat about n=32? 32 is 100000. 32-1=31 (011111). 32 & 31 is 0. So return True.\n\nOk, that seems to cover all cases.\n\nBut wait, in Python, negative numbers are represented in two's complement. So when we do n & (n-1) for a negative n, it might give different results. But since we've already handled n<=0, we don't need to worry. For any n <=0, return False.\n\nWait, in the function, we have n as an integer. So for negative n, the condition is already handled in the first step. So our code will cover all cases.\n\nSo let's write the function.\n\nFirst, check if n <=0: return False.\nElse, check if (n & (n-1)) == 0: if yes, return True, else False.\n\nWait, but what about very large numbers? Does this bitwise method work for those? Well, in Python, integers can be arbitrarily large, and the bitwise operators should handle it without any issues.\n\nWait another edge case: n=1 (2^0). Yes, it's handled correctly.\n\nAnother thing to think about: What if n is 0? Well, the first condition returns False, as expected.\n\nAnother possible edge case: what about n is a floating point number that's a power of two but given as integer? Wait, but the function specifies n is an int. So that's okay.\n\nSo, implement this logic.\n\nLet me try writing the code.\n\nFirst, the function signature is given.\n\nInside the function:\nif n <= 0:\n    return False\nelse:\n    return (n & (n-1)) == 0\n\nWait, but this may not work correctly for n=1. Let me calculate.\n\nn=1: 1 in binary is 1. n-1 is 0, so 1 & 0 is 0. So returns True, which is correct.\n\nAnother test: n=5. 5 is 101. 5-1 is4:100. 5&4=4, which is not zero. So returns False. Correct.\n\nWait, yeah. So the function should handle all these cases.\n\nWait, let me test for n=1:\n\nis_power_of_two(1) \u2192 True. Yes.\n\nN=2: 10 and 01. 2&1 is 0, correct.\n\nSo this should work.\n\nWait, but what about when n is a very large number that's a power of two, like 2^100. I think the bitwise operation should still work, because Python handles large integers.\n\nSo, the function is straightforward.\n\nSo, putting it all together, the code can be written concisely as:\n\ndef is_power_of_two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\nI think that's correct.\n</think>\n\nTo determine if a given integer is a power of two, we can leverage the properties of binary numbers. A number that is a power of two has exactly one bit set to 1 in its binary representation. For example, numbers like 1 (2^0), 2 (2^1), 4 (2^2), 8 (2^3), etc., all have a single '1' bit in their binary form.\n\n### Approach\n1. **Handle Non-Positive Numbers**: Any number that is less than or equal to zero cannot be a power of two. Thus, we immediately return `False` for such cases.\n2. **Check for Power of Two**: For positive numbers, we use a bitwise operation. Specifically, a number `n` that is a power of two will have the property that `n & (n - 1) == 0`. This works because subtracting 1 from a number that is a power of two flips all the bits after the single '1' bit, making the bitwise AND operation result in zero.\n\n### Solution Code\n```python\ndef is_power_of_two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n```\n\n### Explanation\n- **Non-positive Check**: The function first checks if the input `n` is less than or equal to zero. If it is, the function returns `False` because negative numbers and zero cannot be powers of two.\n- **Bitwise Operation**: For positive `n`, the function checks if `n & (n - 1) == 0`. This operation effectively checks if `n` has exactly one bit set in its binary representation, confirming it as a power of two.\n\nThis approach efficiently determines if a number is a power of two using constant time and space, making it both optimal and easy to understand.",
  "r1_solution": "def is_power_of_two(n: int) -> bool:\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0",
  "metadata": {
    "prompt_id": "00000150",
    "row_id": 150,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to determine if a given number is a power of two. A number is a power of two if it can be represented as 2^k where k is a non-negative integer. Assume the input is always a valid integer, both positive and negative, but negative numbers should be immediately determined as not powers of two."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}