{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000106_C",
  "question": "def insertion_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sorts a list of integers using the insertion sort algorithm.\n    \n    This algorithm iterates through the list, and for each element, it finds the correct\n    position within the sorted portion of the list and inserts it there. The algorithm\n    keeps growing the sorted portion of the list until the entire list is sorted.\n    \n    Args:\n        arr (list of int): The list of integers to sort.\n    \n    Returns:\n        list of int: The sorted list of integers.\n    \"\"\"",
  "solution": "def insertion_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the insertion sort algorithm.\n    \n    This algorithm iterates through the list, and for each element, it finds the correct\n    position within the sorted portion of the list and inserts it there. The algorithm\n    keeps growing the sorted portion of the list until the entire list is sorted.\n    \n    Args:\n        arr (list of int): The list of integers to sort.\n    \n    Returns:\n        list of int: The sorted list of integers.\n    \"\"\"\n    # Traverse through 1 to len(arr)\n    for i in range(1, len(arr)):\n        \n        # Store the current element\n        current_value = arr[i]\n        \n        # Initialize the position where the current element needs to be inserted\n        position = i\n        \n        # Move elements of arr[0..i-1], that are greater than current_value,\n        # to one position ahead of their current position\n        while position > 0 and arr[position - 1] > current_value:\n            arr[position] = arr[position - 1]\n            position -= 1\n        \n        # Insert the current element into its correct position\n        arr[position] = current_value\n    \n    return arr",
  "test_code": "from solution import insertion_sort\n\ndef test_insertion_sort_positive_numbers():\n    arr = [9, 5, 1, 4, 3]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [1, 3, 4, 5, 9]\n\ndef test_insertion_sort_negative_numbers():\n    arr = [-5, -9, -3, -4]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [-9, -5, -4, -3]\n\ndef test_insertion_sort_mixed_numbers():\n    arr = [0, -1, 5, -2, 3]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [-2, -1, 0, 3, 5]\n\ndef test_insertion_sort_empty_list():\n    arr = []\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == []\n\ndef test_insertion_sort_already_sorted():\n    arr = [1, 2, 3, 4, 5]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [1, 2, 3, 4, 5]",
  "test_info": [
    {
      "function_name": "insertion_sort",
      "parameter_list": "(arr)",
      "function_declaration": "def insertion_sort(arr):",
      "docstring": "Sorts a list of integers using the insertion sort algorithm.\n\nThis algorithm iterates through the list, and for each element, it finds the correct\nposition within the sorted portion of the list and inserts it there. The algorithm\nkeeps growing the sorted portion of the list until the entire list is sorted.\n\nArgs:\n    arr (list of int): The list of integers to sort.\n\nReturns:\n    list of int: The sorted list of integers."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, I need to write an insertion sort function. Hmm, let me think about how insertion sort works. So insertion sort is a simple algorithm that builds the sorted array one item at a time. It's like how you sort playing cards in your hands.\n\nAlright, the function is called insertion_sort and it takes a list of integers as input. So I'll start by considering each element in the array, starting from the second one, and insert them into their correct position in the sorted part of the array.\n\nWait, how do I handle the sorted portion? I think the algorithm maintains a sorted subarray starting from the beginning. For each new element, it shifts elements in the sorted part to make room for it.\n\nLet me outline the steps in my mind. The outer loop starts from index 1 to the end. For each element at index i, I need to compare it with the elements before it and find where it belongs.\n\nSo for i from 1 to len(arr), I take arr[i] as the current element. Then I have a variable j, which starts at i-1. I'll compare arr[j] with the current element. If arr[j] is greater, I shift it to the right. I do this until j is less than 0 or the current element is larger than arr[j].\n\nWait, no, initially j starts at i. Or maybe it's i-1. Let me think. Yeah, the current key is arr[i]. So I move j back from i-1 down to 0 and check if arr[j] is larger than the key. Each time it is, I shift arr[j] to the next position, and decrement j. Once I find a position where arr[j] is less than or equal to the key, I insert the key there.\n\nSo in code terms, for each i from 1 to n-1 (since in 0-based indexing), the key is arr[i]. Then j = i-1. While j >=0 and arr[j] > key, then arr[j+1] = arr[j], j decreases by 1. Then, when the condition fails, I place the key at j+1.\n\nSo I'll need nested loops. The outer loop starts at 1 and goes up. For each iteration of the outer loop, the inner loop moves elements to the right.\n\nWait, let me think about an example. Suppose the array is [3, 1, 2, 4]. Let's see how it would sort.\n\ni starts at 1: key is 1. j is 0. arr[0] is 3, which is >1. So we move 3 to index 1, then j becomes -1. So we insert 1 at j+1 (which is 0). So array becomes [1,3,2,4].\n\nNext, i=2. Key is 2. j=1. arr[1]=3>2. So move 3 to index 2, j=0. arr[0]=1 <2, so stop. Insert 2 at j+1=1. Now array is [1,2,3,4]. So it's sorted.\n\nYes, that makes sense.\n\nSo back to the code. I'll loop from i=1 to len(arr)-1:\n\nfor i in range(1, len(arr)):\n    key = arr[i]\n    j = i-1\n    while j >=0 and arr[j] > key:\n        arr[j+1] = arr[j]\n        j -= 1\n    arr[j+1] = key\n\nWait, that should do it. But wait, arr is the list passed into the function. So I modify it in place, but the function is supposed to return a new sorted list. Or wait, no, in Python lists are mutable, but sometimes it's better to create a copy.\n\nLooking at the initial code, the function is supposed to take arr as input and return the sorted list. So maybe the initial code modifies the input array. But perhaps I should make a copy first to avoid modifying the original.\n\nSo perhaps inside the function, I make a copy of the input array, like arr = arr.copy(), or create a new list and then sort it.\n\nNo, in the given function definition, the function is supposed to return the sorted list, but I can modify the input since it's a list. However, it's better practice not to modify the input. So perhaps I should make a copy inside the function.\n\nWait, looking at the function, the parameter is 'arr: List[int]', and it's returned after sorting. So perhaps the function does modify the original list, or perhaps it's a new list. Let's think: if the input list is passed, in-place sorting is done. So in the code, would that affect the original list outside the function?\n\nYes, since lists are mutable and passed by reference. But in the problem statement, the function needs to return a sorted list, but perhaps the intended behavior is to create a sorted copy, keeping the original unchanged. Or perhaps the original is to be modified. Hmm.\n\nWell, depending on the standard implementation. In any case, for the insertion sort function, I think it's better to copy the array to avoid modifying the input. So I can start with something like:\n\ndef insertion_sort(arr: List[int]) -> List[int]:\n    # Create a copy to avoid modifying the original list\n    sorted_arr = arr.copy()\n    for i in range(1, len(sorted_arr)):\n        key = sorted_arr[i]\n        j = i -1\n        while j >=0 and sorted_arr[j] > key:\n            sorted_arr[j+1] = sorted_arr[j]\n            j -= 1\n        sorted_arr[j+1] = key\n    return sorted_arr\n\nYes, that makes sense. Now, let me test this logic with the example I had before. Take arr = [3,1,2,4]. The function will create sorted_arr as [3,1,2,4].\n\nIn the first iteration, i=1: key=1. j=0. sorted_arr[j]=3>1. So sorted_arr[j+1] becomes 3, j becomes -1. So in the while loop, j was 0 and key is 1. So 3 is moved to position 1, and j=-1, so we exit. then insert key at j+1=0. So sorted_arr becomes [1,3,2,4].\n\nNext, i=2: key=2. j=1. sorted_arr[j] is 3>2. So move 3 to position 2, sorted_arr is [1,3,3,4], j becomes 0. Then j=0: sorted_arr[j]=1<2. So insert key at 1. So sorted_arr becomes [1,2,3,4].\n\ni=3: key is 4. j=2. sorted_arr[j]=3<4. So insert 4 at position3. So no changes.\n\nSo that works.\n\nAnother test case: arr = [4,3,2,1]. After first iteration, 3 is compared to 4. So 4 shifts right, and 3 is inserted. Then 2: goes to position 0 after shifting 3 and 4. Then 1 does the same.\n\nLet's step through:\n\ni=1, key=3:\nj=0, sorted_arr[j]=4>3. So sorted_arr becomes [4,4,2,1]. j=0 -> j-1 is -1. Insert 3 at 0.\n\nWait, wait, perhaps step-by-step with code.\n\nNo, sorted_arr starts as [4,3,2,1].\n\ni=1, key=3, j=0: while 4>3, so sorted_arr[1] =4, j becomes -1. Insert key (3) at 0: sorted_arr becomes [3,4,2,1].\n\ni=2, key=2. j=1: sorted_arr[1]=4>2. Shift to sorted_arr[2] becomes 4. j becomes0. sorted_arr[0] is 3>2: shift to sorted_arr[1] becomes3. j becomes-1. So insert 2 at 0: sorted_arr becomes [2,3,4,1].\n\nWait wait, not sure. Wait, current key is 2.\n\nInitial state: [3,4,2,1].\n\ni=2 (third element, which is 2). j starts at 1. sorted_arr[j] is 4>2.\n\nSo sorted_arr[j+1] becomes4 (so index2 becomes4; the array is [3,4,4,1]. j becomes0.\n\nNow, j is 0. sorted_arr[j] is3>2: so sorted_arr[j+1] =3, array becomes [3,3,4,1]. j becomes-1. So insert at j+1=0: place 2 there. So array becomes [2,3,4,1].\n\nThen i=3: key is1.\n\nj=2. sorted_arr[2] is4>1: shift right, sorted_arr[3]=4, array becomes [2,3,4,4]. j=1.\n\nsorted_arr[1]=3>1: shift to sorted_arr[2]=3, array [2,3,3,4]. j=0.\n\nsorted_arr[0]=2>1: shift to sorted_arr[1]=2, array becomes [2,2,3,4]. j=-1.\n\nInsert key (1) at position 0, so array becomes [1,2,3,4].\n\nWhich is correct.\n\nSo that works.\n\nWhat about if the array is empty? Well, the function would just return an empty list since the loop doesn't run.\n\nWhat about a single-element list? Same, no loop runs, return the same.\n\nWhat if the list has duplicates? Let's take [2, 2, 1]. Let's see:\n\ni=1: key=2. Wait no, wait the list is [2,2,1], len is3.\n\nWait i=1: key is2. j=0. arr[j] is2>2? No, 2 is not > 2, so condition is false. So we insert 2 at j+1=1. So no change, since it's already in the correct spot?\n\nWait, but [2,2,1] will be sorted as [1,2,2].\n\nWait, let's step through:\n\ni starts at 1, key is2. The initial sorted_arr is [2,2,1].\n\nFor i=1, key=2:\n\nj=0: sorted_arr[j]=2>key (2>2 is false. So the while loop doesn't execute. So we insert key at j+1=1. So position doesn't change. So sorted_arr remains [2,2,1].\n\nWait wait, that can't be right. Because then when i=2 (third element), key is1.\n\nj is1. sorted_arr[j] =2>1: shift to j+1 (2 becomes2). Then j=0: sorted_arr[0] is2>1: shift to j+1, and so on.\n\nWait let's see:\n\nWait sorted_arr at this point is [2,2,1].\n\ni=2: key=1.\n\nj=1: sorted_arr[j]=2>1. So set sorted_arr[j+1] = sorted_arr[j] (2). So sorted_arr is [2,2,2], j becomes0.\n\nNow, j=0: sorted_arr[j]=2>1. Set sorted_arr[j+1] =2. Now sorted_arr is [2,2,2], j becomes-1.\n\nInsert key at j+1=0: so sorted_arr becomes [1,2,2,2] wait, no, because the original array was [2,2,1], which when copied is also [2,2,1]. So with i=2, the key is1.\n\nWait, but len is3. So for i=2, which is index 2, the processing should be correct.\n\nWait, the initial j=1, sorted_arr[j] is 2>1: set sorted_arr[2] =2, j decreases to0.\n\nThen j=0: sorted_arr[0]=2>1: set sorted_arr[1]=2, j decreases to-1. Then insert 1 at j+1=0. So now sorted_arr is [1,2,2].\n\nWait that's correct.\n\nBut wait during i=2:\n\nOriginal sorted_arr at i=2 is [2,2,1]. The key is1. So processing this:\n\nj starts at1, sorted_arr[j] is2>1: so we change sorted_arr[j+1] (2 becomes2, so the third element becomes2. Then j=0: sorted_arr[j] is2>1: so sorted_arr[1]=2. j becomes-1. So we place 1 at 0.\n\nSo the sorted array becomes [1,2,2], which is correct.\n\nSo the insertion_sort function with the code I wrote handles duplicates correctly.\n\nSo the code seems solid.\n\nAnother test case: [5,1,3,2,4,6].\n\nLet me see how the code would sort this.\n\nThe process would be:\n\nCopy to sorted_arr: [5,1,3,2,4,6].\n\ni=1: key=1. j=0, 5>1. So j becomes-1. Insert 1 at 0: [1,5,3,2,4,6].\n\ni=2: key=3. j=1, 5>3: shift. sorted_arr becomes [1,5,5,2,4,6], j=0. sorted_arr[j] =1 <3: insert 3 at 1. So sorted_arr becomes [1,3,5,2,4,6].\n\ni=3: key=2.\n\nj=2: 5>2. Shift to 5 to position3: sorted_arr[3]=5, j=1. sorted_arr[j] is3>2: shift to position2 becomes3. j=0: sorted_arr[0]=1<2. So insert at1: sorted_arr becomes [1,2,3,5,4,6].\n\ni=4: key=4.\n\nj=3: 5>4: shift 5 to position4 becomes5. j=2: 3<4: insert 4 at3. So sorted_arr becomes [1,2,3,4,5,6].\n\ni=5: key=6. All elements before are smaller, so j=4, compare 5<6: no shifting. Insert 6 at5. So done.\n\nSo the function returns [1,2,3,4,5,6].\n\nLooks correct.\n\nSo I think the code is correct.\n</think>\n\nTo implement the insertion sort algorithm, we will follow a step-by-step approach where each element is inserted into its correct position within a sorted subarray. This process continues until the entire array is sorted.\n\n### Approach\n1. **Initialization**: We start by copying the input list to avoid modifying the original list.\n2. **Outer Loop**: This loop iterates over each element of the list starting from the second element (index 1). Each element is considered as the 'key' that needs to be inserted into its correct position.\n3. **Inner Loop**: For each key, we compare it with the elements in the sorted portion of the list (from the previous element to the start of the list). If an element in the sorted portion is greater than the key, it is shifted one position to the right.\n4. **Insertion**: The key is inserted into the position where the elements in the sorted portion are no longer greater than the key, completing the insertion for that key.\n\n### Solution Code\n```python\nfrom typing import List\n\ndef insertion_sort(arr: List[int]) -> List[int]:\n    # Create a copy of the input array to avoid modifying the original list\n    sorted_arr = arr.copy()\n    for i in range(1, len(sorted_arr)):\n        key = sorted_arr[i]\n        j = i - 1\n        while j >= 0 and sorted_arr[j] > key:\n            sorted_arr[j + 1] = sorted_arr[j]\n            j -= 1\n        sorted_arr[j + 1] = key\n    return sorted_arr\n```\n\n### Explanation\n- **Initialization**: The function starts by making a copy of the input list to ensure the original list remains unchanged.\n- **Outer Loop**: The outer loop runs from the second element (index 1) to the end of the list. This loop picks each element to be placed in its correct sorted position.\n- **Inner Loop**: For each key (current element in the outer loop), the inner loop shifts elements in the sorted subarray to the right until it finds the correct position for the key.\n- **Insertion**: Once the correct position is found, the key is inserted there. This process ensures that the sorted subarray grows with each iteration until the entire list is sorted.\n\nThis approach efficiently sorts the list in-place with a time complexity of O(n^2), which is suitable for smaller lists or lists that are partially sorted.",
  "r1_solution": "from typing import List\n\ndef insertion_sort(arr: List[int]) -> List[int]:\n    # Create a copy of the input array to avoid modifying the original list\n    sorted_arr = arr.copy()\n    for i in range(1, len(sorted_arr)):\n        key = sorted_arr[i]\n        j = i - 1\n        while j >= 0 and sorted_arr[j] > key:\n            sorted_arr[j + 1] = sorted_arr[j]\n            j -= 1\n        sorted_arr[j + 1] = key\n    return sorted_arr",
  "metadata": {
    "prompt_id": "00000106",
    "row_id": 106,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to perform insertion sort on a list of integers. Please make sure to provide detailed comments explaining each part of your code."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}