{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000061_C",
  "question": "def find_first_unique(arr: List[int]) -> int:\n    \"\"\" Returns the first index of the element that is not repeated in the array.\n    If no such element exists, returns -1.\n    >>> find_first_unique([2, 3, 4, 3, 2])\n    0\n    >>> find_first_unique([1, 2, 3, 4])\n    0\n    >>> find_first_unique([1, 1, 2, 2])\n    -1\n    >>> find_first_unique([])\n    -1\n    >>> find_first_unique([5])\n    0\n    >>> find_first_unique([7, 8, 8, 9, 7])\n    3\n    \"\"\"",
  "solution": "def find_first_unique(arr):\n    \"\"\"\n    Returns the first index of the element that is not repeated in the array.\n    If no such element exists, returns -1.\n    \"\"\"\n    element_count = {}\n    \n    # Count the occurrences of each element\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    \n    # Find the first element with a count of 1\n    for i, element in enumerate(arr):\n        if element_count[element] == 1:\n            return i\n    \n    return -1",
  "test_code": "from solution import find_first_unique\n\ndef test_find_first_unique_with_repeated_elements():\n    assert find_first_unique([2, 3, 4, 3, 2]) == 2\n\ndef test_find_first_unique_with_unique_first_element():\n    assert find_first_unique([1, 2, 3, 4]) == 0\n\ndef test_find_first_unique_with_duplicates_only():\n    assert find_first_unique([1, 1, 2, 2]) == -1\n\ndef test_find_first_unique_with_empty_list():\n    assert find_first_unique([]) == -1\n\ndef test_find_first_unique_with_single_element():\n    assert find_first_unique([5]) == 0\n\ndef test_find_first_unique_with_mixed_occurrences():\n    assert find_first_unique([7, 8, 8, 9, 7]) == 3",
  "test_info": [
    {
      "function_name": "find_first_unique",
      "parameter_list": "(arr)",
      "function_declaration": "def find_first_unique(arr):",
      "docstring": "Returns the first index of the element that is not repeated in the array.\nIf no such element exists, returns -1."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to find the first unique element in an array of integers. Hmm, how do I approach this? Let's see, so the function is called find_first_unique and it takes a list of integers. It should return the index of the first element that doesn't repeat anywhere else in the array. If no such element exists, return -1.\n\nFirst, I should think about how to track the frequency of each element. Oh right, a hash map or a dictionary can be useful here. Because I can count how many times each number appears.\n\nSo maybe I can loop through the array and count the occurrences. Then, loop through the array again and check each element's count in the hash map. The first element with a count of 1 is the unique one, so I return its index.\n\nWait, but what about the order? Oh right, because I need the first occurrence. So when I loop the second time, I have to check each element in the original order and find the first one with count 1.\n\nThat makes sense. So the steps are:\n\n1. Check if the array is empty. If yes, return -1.\n2. Create a frequency dictionary to count occurrences.\n3. Loop through each element in the array, updating the counts.\n4. Loop through each element again, this time checking their counts.\n5. The first element with count 1 is our answer, return its index.\n6. If no element is found after checking all, return -1.\n\nTesting with some examples.\n\nLike, for [2,3,4,3,2], the frequency is 2:2, 3:2, 4:1. So in the second loop, the first element with count 1 is 4 at index 2. Wait wait, no. No, the second loop is in the order of the array. Wait wait, the array is [2,3,4,3,2]. So the first element is 2, in the hash it's 2 which has count 2. Then 3, count is 2. Then 4, count is 1. So we return index 2, which is correct as per the test case.\n\nAnother example: [1, 1, 2, 2]. Frequencies are 1:2, 2:2. So in the second loop, both 1's are count 2, so return -1.\n\nAnother test case is [5], it should return 0.\n\nHmm, but what about when multiple unique elements are present? Like [0,1,0,2,3]. The first unique is 0, no, wait no. Wait, [0,1,0,2,3]. So frequency counts are 0:2, 1:1, 2:1, 3:1. So when we loop, the first element with count 1 is 1 at index 1. Wait no: Let me explain. The array is [0,1,0,2,3]. So in the second loop, check each element:\n\nindex 0: 0's count is 2 \u2192 not unique.\n\nindex 1: 1's count is 1 \u2192 return index 1.\n\nSo that seems correct.\n\nAnother test case: [7,8,8,9,7], the unique is 9 at index 3.\n\nSo the approach seems solid.\n\nWait, are there any edge cases I should worry about? Like if the unique element is the only one in the array, as in [5], which returns 0. Or when all elements are unique, like [1,2,3], which returns 0.\n\nWhat about when all elements are the same? Like [4,4,4], returns -1.\n\nNow, implementing this in Python.\n\nWe can use a dictionary where keys are the elements, values are their counts.\n\nLet's write some code.\n\nFunction definition:\n\ndef find_first_unique(arr: List[int]) -> int:\n\nFirst, handle the empty case.\n\nif not arr:\n    return -1\n\nCreate the frequency dict.\n\nfreq = {}\nfor num in arr:\n    if num in freq:\n        freq[num] += 1\n    else:\n        freq[num] = 1\n\nThen, loop through each index and number in arr:\n\nfor index, num in enumerate(arr):\n    if freq[num] == 1:\n        return index\n\nIf after all this, none found, return -1.\n\nSo after the loop, return -1.\n\nPutting it all together:\n\ndef find_first_unique(arr: List[int]) -> int:\n    if not arr:\n        return -1\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    for index, num in enumerate(arr):\n        if freq[num] == 1:\n            return index\n    return -1\n\nWait wait, but in the first example given, [2,3,4,3,2], the frequencies are 2:2, 3:2,4:1. So the second loop will check 2 (count 2) \u2192 not. Next, 3 (count 2) \u2192 not. Next, 4 (count 1) \u2192 returns 2, which matches the sample correctly.\n\nAnother test case, [7,8,8,9,7]. Frequencies:7:2, 8:2,9:1. When looping, first element is 7 (count 2) \u2192 no. Then 8 (count 2) \u2192 no. Then 8 (count 2)... Then 9 (count1) at index 3 \u2192 return 3. Correct.\n\nYes, that seems to cover it.\n\nWhat about a case where the first occurrence of a unique element is not the first element? Like [1,2,3,2,1]. The first unique would be 3 at index 2.\n\nSo, in the frequency dict, 1 and 2 have 2 each, 3 has 1. So in the second loop, the 3 is at index 2, which is the first occurrence, so returns 2.\n\nThis logic should handle that.\n\nI think this solution should cover all cases correctly.\n</think>\n\nTo solve this problem, we need to identify the first unique element in an array of integers. A unique element is one that does not appear more than once in the array. If no such element exists, we should return -1.\n\n### Approach\nThe approach to solve this problem involves the following steps:\n\n1. **Check for Empty Array**: If the input array is empty, immediately return -1 since there can be no unique elements.\n2. **Frequency Counting**: Use a dictionary to count the occurrences of each element in the array. This helps in efficiently determining which elements are unique.\n3. **Identify First Unique Element**: Loop through the array again and use the frequency dictionary to check each element's count. The first element with a count of 1 is the unique element, and we return its index.\n4. **Return -1 if No Unique Element**: If no unique element is found after checking all elements, return -1.\n\nThis approach ensures that we efficiently count the occurrences and then determine the first unique element in a single pass over the array after the initial counting.\n\n### Solution Code\n\n```python\nfrom typing import List\n\ndef find_first_unique(arr: List[int]) -> int:\n    if not arr:\n        return -1\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    for index, num in enumerate(arr):\n        if freq[num] == 1:\n            return index\n    return -1\n```\n\n### Explanation\n1. **Frequency Dictionary**: The dictionary `freq` is used to store the count of each element in the array. This allows for O(1) average time complexity to check the count of each element.\n2. **First Unique Check**: By looping through the array again after building the frequency dictionary, we ensure that the first element encountered with a count of 1 is the correct result, maintaining the original order of the array.\n\nThis solution efficiently handles the problem with a time complexity of O(n), where n is the number of elements in the array, making it suitable for large arrays as well.",
  "r1_solution": "from typing import List\n\ndef find_first_unique(arr: List[int]) -> int:\n    if not arr:\n        return -1\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    for index, num in enumerate(arr):\n        if freq[num] == 1:\n            return index\n    return -1",
  "metadata": {
    "prompt_id": "00000061",
    "row_id": 61,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to find the first occurrence of an element in an array that is not repeated (i.e., appears exactly once). If there is no such element, return -1."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}