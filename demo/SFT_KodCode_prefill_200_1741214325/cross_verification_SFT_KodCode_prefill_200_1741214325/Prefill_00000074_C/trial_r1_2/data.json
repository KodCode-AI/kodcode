{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000074_C",
  "question": "def is_perfect_square(num: int) -> bool:\n    \"\"\" Checks if the given number is a perfect square.\n    \n    >>> is_perfect_square(1)\n    True\n    >>> is_perfect_square(4)\n    True\n    >>> is_perfect_square(9)\n    True\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(25)\n    True\n    >>> is_perfect_square(-4)\n    False\n    >>> is_perfect_square(2)\n    False\n    >>> is_perfect_square(3)\n    False\n    >>> is_perfect_square(5)\n    False\n    >>> is_perfect_square(6)\n    False\n    >>> is_perfect_square(7)\n    False\n    >>> is_perfect_square(0)\n    True\n    >>> is_perfect_square(15625)\n    True\n    >>> is_perfect_square(15626)\n    False\n    \"\"\"",
  "solution": "def is_perfect_square(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect square.\n    \n    Args:\n    num (int): The number to check\n    \n    Returns:\n    bool: True if num is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    root = int(num ** 0.5)\n    return root * root == num",
  "test_code": "import pytest\nfrom solution import is_perfect_square\n\ndef test_is_perfect_square_positive_perfect_square():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(9) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n\ndef test_is_perfect_square_negative_number():\n    assert is_perfect_square(-4) == False\n\ndef test_is_perfect_square_non_perfect_square():\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(5) == False\n    assert is_perfect_square(6) == False\n    assert is_perfect_square(7) == False\n\ndef test_is_perfect_square_zero():\n    assert is_perfect_square(0) == True\n\ndef test_is_perfect_square_large_number():\n    assert is_perfect_square(15625) == True\n    assert is_perfect_square(15626) == False",
  "test_info": [
    {
      "function_name": "is_perfect_square",
      "parameter_list": "(num)",
      "function_declaration": "def is_perfect_square(num):",
      "docstring": "Checks if the given number is a perfect square.\n\nArgs:\nnum (int): The number to check\n\nReturns:\nbool: True if num is a perfect square, False otherwise."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, I need to write a function called is_perfect_square that checks if a given number is a perfect square. Let me think about how to approach this.\n\nHmm, perfect squares are numbers that can be expressed as the square of an integer. So for example, 4 is 2 squared, 9 is 3 squared, etc. Also, zero is a perfect square because 0 squared is zero. And negative numbers can't be perfect squares because squaring any real number gives a non-negative result.\n\nSo first, I should handle the case when the input number is negative. If it's negative, I can immediately return False.\n\nWait, wait, what about 0? Yeah, 0 is a perfect square, so in that case I return True.\n\nFor positive numbers and zero, the next step is to find out if there's an integer whose square is exactly the input number.\n\nWhat's an efficient way to do this? Well, one approach is to take the square root of the number, round it to the nearest integer, and then square that to see if it equals the original number.\n\nBut wait, there could be floating point inaccuracies when taking the square root. Maybe I should handle this with integer operations to avoid such issues.\n\nAnother idea: for the given number, compute the integer square root and then square it to check. For example, the integer square root of 16 is 4, 4 squared is 16, so it's a perfect square. For 2, the integer square root is 1, 1 squared is 1, which is not 2, so not a perfect square.\n\nSo in Python, I can use the math.isqrt function which returns the integer square root. Or wait, in Python 3.8 and above, isqrt is available. Using that might be more accurate than dealing with floating points.\n\nSo the steps are:\n1. If the number is negative, return False.\n2. If the number is 0, return True.\n3. Else, compute the square root using math.isqrt.\n4. Square that result and see if it equals the original number.\n\nWait, because math.isqrt returns the largest integer less than or equal to the exact square root. So if I square that and get the number, then the number is a perfect square. Yes.\n\nLet me think about this. For example, say the number is 25. isqrt(25) is 5, 5 squared is 25. So return True. For 26, isqrt is 5 (since 5^2 is 25 and 6^2 is 36 which is larger than 26), so 5 squared is 25, which is not 26. So return False.\n\nSo the plan is:\n\n- import math module.\n- Check if num is less than 0: return False.\n- Else, take s = math.isqrt(num)\n- Check if s * s == num.\n- Return True if yes, else False.\n\nAlso, what about when num is zero? math.isqrt(0) returns 0, 0*0 is 0, which is equal to num, so it returns True. That's good.\n\nTesting the examples given:\n\nExamples where it should return True:\n1,4,9,16,25,0,15625.\n\nTesting 1: isqrt(1) is 1. 1*1=1: True.\n4: same way.\n0: returns True as in the code.\n15625: sqrt is 125, 125^2 is 15625: True.\n\nExamples where it should return False:\n-4: return False right away.\n2: isqrt(2) is 1, 1 squared is 1 !=2: False.\nSame for 3, 5,6,7, in all cases squaring the isqrt gives a lower number.\n\nAnother test case: 15626. isqrt(15626) is 125, since 125^2 is 15625, 126^2 is 15876 which is >15626. So 125^2 is 15625 != 15626. So return False.\n\nSo the code should handle all these cases.\n\nPotential edge cases:\n\n- numbers like 1, which is a perfect square.\n- zero: as discussed.\n- very large numbers: as 15625, but in Python, isqrt can handle that.\n\nWait, but what about numbers that are very large but not perfect squares? Probably still works as the function is efficient.\n\nSo the code outline:\n\nImport math.\n\nDefine the function:\ndef is_perfect_square(num: int) -> bool:\n    if num <0:\n        return False\n    if num ==0:\n        return True\n    s = math.isqrt(num)\n    return s * s == num\n\nWait, or can we make it even more concise? What about combining the first two conditions.\n\nWait, let's think. For num <0: return False. For num ==0, let it proceed: because isqrt(0) is 0, 0^2 is 0: the condition holds.\n\nSo perhaps the code can be:\n\nif num <0:\n    return False\n\ns = math.isqrt(num)\nreturn s * s == num\n\nBecause for num ==0, it would compute s=0, 0^2=0: returns True.\n\nYes, that simplifies it.\n\nSo the function becomes:\n\nimport math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    s = math.isqrt(num)\n    return s * s == num\n\nDoes this handle all cases?\n\nTesting num=0: in the else case, s=0, returns True.\n\nSeems solid.\n\nLet me test with the examples:\n\n- is_perfect_square(-4) \u2192 False: handled by first condition.\n\nSample test is_perfect_square(2): isqrt(2) is 1. 1^2=1 !=2: returns False.\n\nYes.\n\nSo the function should work as required.\n</think>\n\nTo solve this problem, we need to determine if a given integer is a perfect square. A perfect square is a number that can be expressed as the square of an integer. The approach to solve this problem efficiently involves using integer operations to avoid floating point inaccuracies.\n\n### Approach\n1. **Check for Negative Numbers:** Since negative numbers cannot be perfect squares, we immediately return False for any negative input.\n2. **Compute Integer Square Root:** For non-negative numbers, we compute the integer square root using `math.isqrt`, which returns the largest integer less than or equal to the exact square root of the given number.\n3. **Check Square:** Square the result of the integer square root and check if it equals the original number. If it does, the number is a perfect square; otherwise, it is not.\n\nThis approach ensures that we handle all edge cases, including zero and very large numbers, efficiently and accurately.\n\n### Solution Code\n```python\nimport math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    s = math.isqrt(num)\n    return s * s == num\n```\n\n### Explanation\n1. **Negative Check:** The function first checks if the input number is negative. If it is, the function returns False immediately.\n2. **Integer Square Root:** The function then computes the integer square root of the given number using `math.isqrt`. This avoids any floating point inaccuracies that might arise from using other square root functions.\n3. **Square and Compare:** The function squares the integer result of the square root computation and checks if it equals the original number. If it does, the number is confirmed to be a perfect square, and the function returns True. Otherwise, it returns False.\n\nThis method efficiently handles all possible cases, including the edge case of zero and very large numbers, ensuring accurate and reliable results.",
  "r1_solution": "import math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    s = math.isqrt(num)\n    return s * s == num",
  "metadata": {
    "prompt_id": "00000074",
    "row_id": 74,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to check if a given number is perfect square or not. The function should take an integer as input and return True if the number is a perfect square, False otherwise."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results2.jsonl"
}