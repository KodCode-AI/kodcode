{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000074_C",
  "question": "def is_perfect_square(num: int) -> bool:\n    \"\"\" Checks if the given number is a perfect square.\n    \n    >>> is_perfect_square(1)\n    True\n    >>> is_perfect_square(4)\n    True\n    >>> is_perfect_square(9)\n    True\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(25)\n    True\n    >>> is_perfect_square(-4)\n    False\n    >>> is_perfect_square(2)\n    False\n    >>> is_perfect_square(3)\n    False\n    >>> is_perfect_square(5)\n    False\n    >>> is_perfect_square(6)\n    False\n    >>> is_perfect_square(7)\n    False\n    >>> is_perfect_square(0)\n    True\n    >>> is_perfect_square(15625)\n    True\n    >>> is_perfect_square(15626)\n    False\n    \"\"\"",
  "solution": "def is_perfect_square(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect square.\n    \n    Args:\n    num (int): The number to check\n    \n    Returns:\n    bool: True if num is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    root = int(num ** 0.5)\n    return root * root == num",
  "test_code": "import pytest\nfrom solution import is_perfect_square\n\ndef test_is_perfect_square_positive_perfect_square():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(9) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n\ndef test_is_perfect_square_negative_number():\n    assert is_perfect_square(-4) == False\n\ndef test_is_perfect_square_non_perfect_square():\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(5) == False\n    assert is_perfect_square(6) == False\n    assert is_perfect_square(7) == False\n\ndef test_is_perfect_square_zero():\n    assert is_perfect_square(0) == True\n\ndef test_is_perfect_square_large_number():\n    assert is_perfect_square(15625) == True\n    assert is_perfect_square(15626) == False",
  "test_info": [
    {
      "function_name": "is_perfect_square",
      "parameter_list": "(num)",
      "function_declaration": "def is_perfect_square(num):",
      "docstring": "Checks if the given number is a perfect square.\n\nArgs:\nnum (int): The number to check\n\nReturns:\nbool: True if num is a perfect square, False otherwise."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, so I need to write a Python function called is_perfect_square that checks if a given number is a perfect square. Hmm, let's think about what a perfect square is. It's a number that is the square of an integer. For example, 1 is 1 squared, 4 is 2 squared, 9 is 3 squared, and so on.\n\nWait, but what about negative numbers? Oh right, the square of any real number can't be negative, so if the input is negative, we should return False right away. Like, is_perfect_square(-4) should be False. So that's the first condition: if num is less than 0, return False.\n\nWhat about zero? Well, zero is a perfect square because 0 squared is 0. So when num is 0, we return True.\n\nNow, for positive numbers. I think the standard approach is to take the square root of the number, round it down, and then square it to see if you get back the original number. Like, for 16, square root is 4, so 4 squared is 16: yes.\n\nSo here's the plan: if the number is negative, return False. Else, compute the integer square root, square it, and check if it equals the original number.\n\nWait, but computing square roots with math.sqrt might give me a float, and I need to be careful with precision. So for larger numbers, is there a more efficient way? Maybe using binary search or something, but for this problem, since it's about implementing it correctly rather than efficiently, perhaps the straightforward method is sufficient.\n\nWait, but there's a function in Python called math.isqrt which returns the integer square root. For example, math.isqrt(16) is 4. So if I calculate s = math.isqrt(num), and then if s*s == num, then it's a perfect square. That makes sense.\n\nLet's outline the steps:\n\n1. If num is negative, return False.\n\n2. Else, if num is zero, return True.\n\n3. Else, compute s = integer square root of num.\n\n4. Check if s*s == num.\n\nWait, wait. Wait a second: what about when num is not an integer? Oh, but the function is defined to take an integer as input, so the function's parameter is num: int.\n\nSo the function is passed an integer, no issues there.\n\nSo the steps in code would be:\n\n- Import math.\n\n- Handle the case where num is negative: return False.\n\n- Compute s = math.isqrt(num)\n\n- If s * s == num, return True.\n\n- Else, return False.\n\nBut wait, what about when num is a perfect square, but the square is larger than some integer but fits in Python's int? E.g., numbers beyond 2^64, but Python handles big integers well, so no issues.\n\nLet's test this with some examples.\n\nTest case 1: num = 1\n\ns = isqrt(1) =1, 1*1=1: True.\n\nTest case 2: num = -4: return False.\n\nTest case 3: num = 2. So s=1, 1*1=1 !=2 \u2192 False.\n\nTest case: num=0: s=0, 0*0=0 \u2192 True.\n\nWhat about large numbers, like 15625. Its square root is 125, 125^2 is 15625: True.\n\nIf num is 15626: isqrt(15626) is 125 (since 125^2 = 15625, which is less than 15626). So 125^2 is 15625 <15626 \u2192 return False.\n\nWait, but what about s being the exact square root. Because, s = isqrt(16) is 4, and 4\u00b2 is 16, so returns True.\n\nThis logic seems solid.\n\nSo the code outline is:\n\ndef is_perfect_square(num: int) -> bool:\n\n    if num < 0:\n\n        return False\n\n    s = math.isqrt(num)\n\n    return s * s == num\n\nBut wait! Let me think about some edge cases.\n\nWhat if num is 2? isqrt(2)=1 \u2192 1*1=1\u22602: returns False. Correct.\n\nWhat about num=3: isqrt(3)=1 \u2192 1 \u22603: returns False.\n\nWhat about num=4? isqrt is 2 \u2192 4 \u2192 True.\n\nThat's all correct.\n\nAnother edge case: num=15 \u2192 isqrt is 3, 3^2 is 9\u226015 \u2192 False.\n\nSo, that's consistent with what's expected.\n\nAnother point: in Python, for numbers like 25, isqrt returns 5, 5\u00b2 is 25 \u2192 True.\n\nWhat about zero: isqrt(0) is 0, 0\u00b2 is 0 \u2192 returns True. Which is correct.\n\nWait, but what about when the square is a very large number, say the square of the maximum 64-bit integer. But in Python, integers can be arbitrarily large, so math.isqrt can handle them as well as possible, so no issue.\n\nSo the function should cover all these cases.\n\nWait, but is math.isqrt available? Oh right, it's available in Python 3.8 and above. So we need to make sure that in the environment where this function is run, math.isqrt exists. Otherwise, an AttributeError would be raised. But perhaps the problem expects using the standard library in a recent version.\n\nAlternatively, for older Python versions, we could compute the square root by taking the integer and checking, but the problem assumes the function receives an integer, so the current approach is acceptable.\n\nThus, putting it all together:\n\nWe'll need to import math.\n\nThen handle num <0 \u2192 return False.\n\nElse compute s = math.isqrt(num), check if s\u00b2 is num.\n\nSo coding it:\n\nimport math\n\ndef is_perfect_square(num: int) -> bool:\n\n    if num < 0:\n\n        return False\n\n    s = math.isqrt(num)\n\n    return s * s == num\n\nTesting the provided examples:\n\nFor all given test cases, this function should return the correct output. For example, is_perfect_square(25) \u2192 5*5=25 \u2192 True.\n\nAnother example, is_perfect_square(2) \u2192 returns False.\n\nYes, that should be correct.\n\nI think this covers all cases.\n</think>\n\nTo solve this problem, we need to determine if a given integer is a perfect square. A perfect square is a number that can be expressed as the square of an integer. The solution should efficiently check this condition and handle various edge cases, including negative numbers and zero.\n\n### Approach\n1. **Negative Numbers Check**: Since a perfect square cannot be negative, any negative input should immediately return `False`.\n2. **Zero Check**: Zero is a perfect square because it is the square of zero. Hence, zero should return `True`.\n3. **Integer Square Root Calculation**: For positive numbers, compute the integer square root. This gives the largest integer `s` such that `s^2` is less than or equal to the input number.\n4. **Square Check**: Multiply the integer square root by itself and compare it with the original number. If they are equal, the number is a perfect square.\n\nThis approach leverages the efficiency of integer operations and avoids floating-point precision issues by using the `math.isqrt` function, which computes the integer square root accurately.\n\n### Solution Code\n```python\nimport math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    s = math.isqrt(num)\n    return s * s == num\n```\n\n### Explanation\nThe function `is_perfect_square` works as follows:\n1. **Negative Check**: If the input number is negative, the function returns `False` immediately as negative numbers cannot be perfect squares.\n2. **Zero Handling**: If the input number is zero, the function implicitly moves past the negative check and continues to compute the integer square root, which is zero. Squaring this root gives zero, so the function correctly returns `True`.\n3. **Integer Square Root Calculation**: For non-negative numbers, the function computes the integer square root using `math.isqrt`, which efficiently finds the largest integer `s` such that `s^2` is less than or equal to the input number.\n4. **Square and Compare**: The function then squares the computed integer square root and checks if it equals the original number. If it does, the number is a perfect square, and the function returns `True`; otherwise, it returns `False`.\n\nThis method is efficient and handles all edge cases properly, ensuring correctness for both small and large integers.",
  "r1_solution": "import math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    s = math.isqrt(num)\n    return s * s == num",
  "metadata": {
    "prompt_id": "00000074",
    "row_id": 74,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to check if a given number is perfect square or not. The function should take an integer as input and return True if the number is a perfect square, False otherwise."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}