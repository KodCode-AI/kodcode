{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000074_C",
  "question": "def is_perfect_square(num: int) -> bool:\n    \"\"\" Checks if the given number is a perfect square.\n    \n    >>> is_perfect_square(1)\n    True\n    >>> is_perfect_square(4)\n    True\n    >>> is_perfect_square(9)\n    True\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(25)\n    True\n    >>> is_perfect_square(-4)\n    False\n    >>> is_perfect_square(2)\n    False\n    >>> is_perfect_square(3)\n    False\n    >>> is_perfect_square(5)\n    False\n    >>> is_perfect_square(6)\n    False\n    >>> is_perfect_square(7)\n    False\n    >>> is_perfect_square(0)\n    True\n    >>> is_perfect_square(15625)\n    True\n    >>> is_perfect_square(15626)\n    False\n    \"\"\"",
  "solution": "def is_perfect_square(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect square.\n    \n    Args:\n    num (int): The number to check\n    \n    Returns:\n    bool: True if num is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    root = int(num ** 0.5)\n    return root * root == num",
  "test_code": "import pytest\nfrom solution import is_perfect_square\n\ndef test_is_perfect_square_positive_perfect_square():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(9) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n\ndef test_is_perfect_square_negative_number():\n    assert is_perfect_square(-4) == False\n\ndef test_is_perfect_square_non_perfect_square():\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(5) == False\n    assert is_perfect_square(6) == False\n    assert is_perfect_square(7) == False\n\ndef test_is_perfect_square_zero():\n    assert is_perfect_square(0) == True\n\ndef test_is_perfect_square_large_number():\n    assert is_perfect_square(15625) == True\n    assert is_perfect_square(15626) == False",
  "test_info": [
    {
      "function_name": "is_perfect_square",
      "parameter_list": "(num)",
      "function_declaration": "def is_perfect_square(num):",
      "docstring": "Checks if the given number is a perfect square.\n\nArgs:\nnum (int): The number to check\n\nReturns:\nbool: True if num is a perfect square, False otherwise."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, I need to write a Python function called is_perfect_square that takes an integer num as input and returns a boolean indicating whether it's a perfect square. Hmm, let's think about how to approach this.\n\nFirst, what's a perfect square? A number is a perfect square if it's the square of an integer. So I need to check if there exists an integer n such that n squared equals num.\n\nWait, but what about negative numbers? Oh right, the square of any real number can't be negative, so if num is negative, the function should return False. That covers cases like num = -4, which returns False.\n\nWhat about zero? Zero is a perfect square because 0 squared is 0. So if num is 0, return True.\n\nNow, for positive numbers. How do I determine if a positive integer is a perfect square?\n\nOne approach is to take the square root of num, round it to the nearest integer, and then check if squaring that integer gives back num. But how do I accurately compute the square root and handle possible floating-point inaccuracies?\n\nAlternatively, I could iterate from 0 upwards, square each number, and see if it matches num. But that might be inefficient for very large numbers.\n\nWait, maybe using math.isqrt for integers in Python. Because math.isqrt returns the integer square root. Oh right, in Python 3.8 and above, math.isqrt gives the largest integer less than or equal to the square root. So I can compute s = math.isqrt(num) and then check if s*s == num. Oh, but wait, what about (s+1) squared? No, because isqrt returns the floor of the exact square root. So if num is a perfect square, isqrt(num) squared should equal num.\n\nLet me test this logic with examples. Let's see, num=25, isqrt(25) is 5. 5*5=25, so returns True. What about num=26? isqrt(26) is 5. 5*5=25 !=26, returns False. Similarly, num=16: 4*4=16, returns True. For num=17, isqrt is 4, 4\u00b2=16\u226017, so False. That seems to work.\n\nBut wait what about num=2: isqrt(2) is 1, 1\u00b2=1\u22602, so returns False. Correct.\n\nWait, what if num is a very large number, like 15625. isqrt would calculate 125, and 125\u00b2 is 15625, so returns True. For num=15626, isqrt is 125, 125\u00b2 is 15625\u226015626. So correct as well.\n\nSo the steps are:\n\n1. If num is negative, return False.\n2. Else, compute the integer square root of num using math.isqrt.\n3. Square that integer and check if it equals num.\n4. Return the result accordingly.\n\nBut wait, I should also handle num=0, which is already covered, because isqrt(0)=0, 0\u00b2=0, so returns True.\n\nLet's outline the code:\n\nImport math.\n\nDefine is_perfect_square(num: int) -> bool:\n\nFirst, if num is less than 0, return False.\n\nElse, compute s = math.isqrt(num)\n\nCheck if s*s == num. Return True if yes, else False.\n\nWait, wait, wait. What about numbers where s is larger than the actual square root? No, because math.isqrt returns the largest integer less than or equal to the square root. So if num is a perfect square, s squared will be exactly num. Otherwise, it won't.\n\nSo this logic should work.\n\nTesting the sample inputs:\n\nTest case 1: num=1 \u2192 True.\n\nTest case 2: num=4 \u2192 True.\n\nnum=9 \u2192 True.\n\nnum=16 \u2192 True.\n\nnum=25 \u2192 True.\n\nnum = -4 \u2192 False.\n\nnum=2 \u2192 False.\n\nnum=3 \u2192 False.\n\nnum=5 \u2192 False.\n\nnum=6 \u2192 s=2 \u2192 4\u22606 \u2192 False.\n\nnum=0 \u2192 returns 0 squared is 0 \u2192 True.\n\nnum=15625 \u2192 125\u00b2=15625 \u2192 True.\n\nnum=15626 \u2192125\u00b2=15625\u226015626 \u2192 False.\n\nThese all match the sample outputs.\n\nWhat about a large number like (10^16)^2 = 1e32? Let's see, isqrt of 1e32 would be 1e16, squared is 1e32 \u2192 returns True.\n\nWhat about very large numbers, will this approach be efficient? Since math.isqrt is O(1) and doesn't loop, this should be efficient.\n\nWhat about for num=1? It should be True because 1 is 1\u00b2.\n\nCould I think about another approach, like handling this with logarithms or something? But that might introduce floating point errors, which are harder to manage. The method using integer square root is precise and efficient.\n\nSo, this approach seems solid.\n\nSo, the code would be:\n\nImport math.\n\nThen:\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    s = math.isqrt(num)\n    return s * s == num\n\nWait, let me test this.\n\nWhat about num=2: isqrt(2)=1, 1*1=1 !=2 \u2192 returns False.\n\nSimilarly, num=3: same as above.\n\nWhat about num=49: s=7, 7\u00b2=49 \u2192 True.\n\nWhat about num=15: s=3, 3\u00b2=9\u226015 \u2192 False.\n\nYes.\n\nWait, I remember that isqrt for 65 would be 8, and 8\u00b2 is 64. So 65 is not a perfect square, function returns False.\n\nSo yes.\n\nI think this should handle all the cases correctly. Hence, that should be the implementation.\n</think>\n\nTo solve this problem, we need to determine if a given integer is a perfect square. A perfect square is a number that can be expressed as the square of an integer. Our approach will efficiently check this condition using mathematical properties.\n\n### Approach\n1. **Check for Negative Numbers**: Since a perfect square cannot be negative, any negative input should immediately return `False`.\n2. **Compute Integer Square Root**: Use the `math.isqrt` function to compute the integer square root of the given number. This function returns the largest integer less than or equal to the exact square root.\n3. **Square the Integer Square Root**: Check if squaring the integer square root results in the original number. If it does, the number is a perfect square.\n\nThis approach is efficient and avoids potential floating-point inaccuracies by working entirely with integers.\n\n### Solution Code\n```python\nimport math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    s = math.isqrt(num)\n    return s * s == num\n```\n\n### Explanation\n1. **Negative Check**: The function first checks if the input number is negative. If it is, the function returns `False` since negative numbers cannot be perfect squares.\n2. **Integer Square Root Calculation**: Using `math.isqrt`, the function calculates the largest integer less than or equal to the square root of the input number.\n3. **Square Check**: The function then squares this integer and checks if the result equals the original input number. If they are equal, the number is a perfect square, and the function returns `True`. Otherwise, it returns `False`.\n\nThis method efficiently handles all edge cases, including zero and very large numbers, ensuring accurate and quick results.",
  "r1_solution": "import math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    s = math.isqrt(num)\n    return s * s == num",
  "metadata": {
    "prompt_id": "00000074",
    "row_id": 74,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to check if a given number is perfect square or not. The function should take an integer as input and return True if the number is a perfect square, False otherwise."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}