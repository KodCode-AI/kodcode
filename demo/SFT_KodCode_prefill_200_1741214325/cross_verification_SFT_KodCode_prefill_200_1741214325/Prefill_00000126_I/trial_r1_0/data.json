{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000126_I",
  "question": "Write a python function to check if a list of numbers is sorted in ascending order.",
  "solution": "def is_sorted_ascending(numbers):\n    \"\"\"\n    Returns True if the list of numbers is sorted in ascending order, else False.\n    \"\"\"\n    return all(numbers[i] <= numbers[i + 1] for i in range(len(numbers) - 1))",
  "test_code": "from solution import is_sorted_ascending\n\ndef test_is_sorted_ascending_positive():\n    assert is_sorted_ascending([1, 2, 3, 4, 5]) == True\n\ndef test_is_sorted_ascending_with_equal_elements():\n    assert is_sorted_ascending([1, 1, 2, 3, 4]) == True\n\ndef test_is_sorted_ascending_negative():\n    assert is_sorted_ascending([5, 3, 2, 1]) == False\n\ndef test_is_sorted_ascending_single_element():\n    assert is_sorted_ascending([5]) == True\n\ndef test_is_sorted_ascending_empty_list():\n    assert is_sorted_ascending([]) == True\n\ndef test_is_sorted_ascending_mixed():\n    assert is_sorted_ascending([1, 2, 3, 2, 5]) == False",
  "test_info": [
    {
      "function_name": "is_sorted_ascending",
      "parameter_list": "(numbers)",
      "function_declaration": "def is_sorted_ascending(numbers):",
      "docstring": "Returns True if the list of numbers is sorted in ascending order, else False."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1,
    1
  ],
  "gpt_pass_trial_num": 3,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, I need to write a Python function to check if a list of numbers is sorted in ascending order. Hmm, where do I start?\n\nLet me think about what ascending order means. Each element should be less than or equal to the next one. So for a list like [1,2,3,4], each number is followed by a bigger or same number. If any element is followed by a smaller number, the list isn't sorted.\n\nSo the function needs to go through the list, compare each pair of adjacent elements. If all pairs satisfy the condition, return True; else, return False.\n\nHow do I do that in Python? I can loop through the list using a for loop, from the first to the second last element. For each index i, compare list[i] and list[i+1]. If any of these comparisons show list[i] > list[i+1], then the list isn't sorted, so return False. If the loop finishes without finding any such case, return True.\n\nWait, what about an empty list or a single-element list? Oh right, those are trivially sorted. So if the list has 0 or 1 elements, the function should return True immediately.\n\nNow, writing the code structure. The function can be named is_sorted. It takes one argument, numbers, which is a list.\n\nInside the function, handle the edge cases first: if len(numbers) is less than or equal to 1, return True.\n\nElse, loop from i=0 to len(numbers)-2 (inclusive). For each i, check if numbers[i] > numbers[i+1]. If yes, return False. After checking all pairs, return True.\n\nAlternatively, I can use a more Pythonic approach with a generator expression and the all() function. For each consecutive pair, create a list of booleans where each is True if the pair is in order. Then, check if all are True.\n\nSo, for each i in range(len(numbers)-1), check numbers[i] <= numbers[i+1], and collect these as a list. Then, return all of them evaluated.\n\nYes, that could be a more concise way. So the function can be written in a single return statement, except for handling the edge case.\n\nWait, but for an empty list, len(numbers)-1 would be -1, which causes range to not loop, so that case is handled correctly.\n\nLet me test with some examples.\n\nTest case 1: [1,2,3,4] \u2192 should return True. Each pair 1<=2, 2<=3, 3<=4 \u2192 True.\n\nTest case 2: [4,3,2,1] \u2192 should return False. Because 4>3 right away.\n\nTest case 3: [2,2,2] \u2192 True, since each is equal.\n\nTest case 4: [1,3,2] \u2192 False, because 3>2.\n\nEdge cases: empty list \u2192 True, single element \u2192 True.\n\nNow, writing the code.\n\nFunction is_sorted(numbers):\n\nFirst, if len(numbers) <= 1: return True.\n\nElse, for each i from 0 to len(numbers)-2, compare numbers[i] <= numbers[i+1]. If all are True, return True else False.\n\nAlternatively, using list comprehensions or generator expressions.\n\nSo in code:\n\ndef is_sorted(numbers):\n    if len(numbers) <= 1:\n        return True\n    for i in range(len(numbers)-1):\n        if numbers[i] > numbers[i+1]:\n            return False\n    return True\n\nAlternatively, using all():\n\ndef is_sorted(numbers):\n    return all(numbers[i] <= numbers[i+1] for i in range(len(numbers)-1))\n\nBut wait, what if len(numbers) is 0 or 1? Then the range is empty, so all() returns True, which is correct. So the function can simply be written as that single return statement without the prior check.\n\nYes, that's even better. Because for len=0, range(-1) is empty, all() is True. Same for len=1, range(0) is empty, all() returns True.\n\nSo the function can be written concisely as:\n\ndef is_sorted(numbers):\n    return all(numbers[i] <= numbers[i+1] for i in range(len(numbers)-1))\n\nLet me test this with some examples.\n\nTesting numbers = [1,2,3]: len is 3. range(2). i=0: 1<=2, i=1:2<=3 \u2192 all True \u2192 return True.\n\nnumbers = [3,2,1]: i=0,3>2 \u2192 False, so all returns False.\n\nnumbers = [2,2,2]: each step is 2<=2 \u2192 True.\n\nnumbers = [1,3,2]: i=0: 1<=3 \u2192 True, i=1: 3<=2 \u2192 False, so all returns False.\n\nThis should work.\n\nI think that's a solid solution. So the final code is the one-liner using all() and a generator expression.\n</think>\n\nTo determine if a list of numbers is sorted in ascending order, we can compare each element with the next one. If all consecutive elements are in non-decreasing order, the list is sorted.\n\n**Step-by-Step Explanation:**\n\n1. **Problem Analysis:**\n   - A list is sorted in ascending order if for every consecutive pair of elements, the earlier element is less than or equal to the next one.\n   - We need a function that checks this condition for the entire list.\n\n2. **Edge Cases Handling:**\n   - An empty list and a single-element list are considered sorted.\n   - This can be handled by checking if the list has zero or one elements, but it's more efficient to use a method that inherently handles these cases without explicit checks.\n\n3. **Approach Using `all()` Function:**\n   - Loop through each index `i` from 0 to the second last index.\n   - For each index `i`, check if `numbers[i] <= numbers[i+1]`.\n   - The `all()` function returns `True` if all elements of the iterable are true. Using a generator expression, this approach concisely checks all consecutive pairs.\n\n**Solution Code:**\n\n```python\ndef is_sorted(numbers):\n    return all(numbers[i] <= numbers[i + 1] for i in range(len(numbers) - 1))\n```\n\n**Example Usage:**\n\n```python\n# Test case 1: Sorted list\nprint(is_sorted([1, 2, 3, 4]))  # Output: True\n\n# Test case 2: Unsorted list\nprint(is_sorted([4, 3, 2, 1]))  # Output: False\n\n# Test case 3: List with equal elements\nprint(is_sorted([2, 2, 2]))     # Output: True\n\n# Test case 4: Unsorted with some correct order\nprint(is_sorted([1, 3, 2]))     # Output: False\n\n# Test case 5: Single element\nprint(is_sorted([5]))           # Output: True\n\n# Test case 6: Empty list\nprint(is_sorted([]))            # Output: True\n```\n\nThis function efficiently checks if the list is sorted in ascending order by leveraging the `all()` function with a generator expression, ensuring clarity and conciseness.",
  "r1_solution": "def is_sorted_ascending(numbers):\n    return all(numbers[i] <= numbers[i + 1] for i in range(len(numbers) - 1))",
  "metadata": {
    "prompt_id": "00000126",
    "row_id": 126,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}