{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000189_I",
  "question": "Write a python function to check if a given number is a Fibonacci number or not.",
  "solution": "def is_perfect_square(x):\n    s = int(x ** 0.5)\n    return s * s == x\n\ndef is_fibonacci_number(n):\n    \"\"\"\n    Returns True if n is a Fibonacci number, False otherwise.\n    \"\"\"\n    # A number is Fibonacci if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square\n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)",
  "test_code": "from solution import is_fibonacci_number, is_perfect_square\n\ndef test_is_perfect_square():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(9) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(17) == False\n\ndef test_is_fibonacci_number():\n    assert is_fibonacci_number(0) == True\n    assert is_fibonacci_number(1) == True\n    assert is_fibonacci_number(5) == True\n    assert is_fibonacci_number(8) == True\n    assert is_fibonacci_number(13) == True\n    assert is_fibonacci_number(21) == True\n    assert is_fibonacci_number(34) == True\n    assert is_fibonacci_number(55) == True\n    assert is_fibonacci_number(6) == False\n    assert is_fibonacci_number(-4) == False\n    assert is_fibonacci_number(20) == False",
  "test_info": [
    {
      "function_name": "is_perfect_square",
      "parameter_list": "(x)",
      "function_declaration": "def is_perfect_square(x):",
      "docstring": null
    },
    {
      "function_name": "is_fibonacci_number",
      "parameter_list": "(n)",
      "function_declaration": "def is_fibonacci_number(n):",
      "docstring": "Returns True if n is a Fibonacci number, False otherwise."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, so I need to figure out how to write a Python function that checks if a given number is a Fibonacci number. Hmm, let's think about what Fibonacci numbers are. They start with 0 and 1, and each subsequent number is the sum of the two preceding ones. So the sequence goes 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on.\n\nFirst, maybe I should understand the properties of Fibonacci numbers that can help me determine if a given number is part of this sequence. I remember that there's a mathematical test to check if a number is Fibonacci. It has something to do with the square of the number and its relationship with adjacent Fibonacci numbers.\n\nWait, yes, I think it's called the Fibonacci number test. The idea is that a number 'n' is a Fibonacci number if and only if one or both of (5n\u00b2 + 4) or (5n\u00b2 - 4) are perfect squares. That makes sense because each Fibonacci number has this property. So, if I can compute 5n\u00b2 plus 4 and minus 4 and check if either is a perfect square, I can determine if n is a Fibonacci number.\n\nBut wait, how do I efficiently check if a number is a perfect square in Python? Well, one way is to take the square root of the number, round it to the nearest integer, and then square it again to see if it gives back the original number. For example, if I have a number x, I can compute s = sqrt(x), then round s to get m. If m\u00b2 equals x, then x is a perfect square.\n\nSo, putting this together, the steps for the function should be:\n\n1. Take an input number 'n'.\n2. Calculate 5n\u00b2 + 4 and 5n\u00b2 - 4.\n3. For each of these two results, check if they are perfect squares.\n4. If either of them is a perfect square, return True. Otherwise, return False.\n\nLet's think about possible issues. What about n being negative? Well, Fibonacci numbers are non-negative, so if n is negative, we can immediately return False. Also, what about n being 0 or 1? Let's test these edge cases.\n\nFor n=0: 5*(0)\u00b2 +4 =4, which is 2\u00b2, so it should return True.\nFor n=1: 5*(1)\u00b2 +4=9, which is 3\u00b2, so True. Also, 5*(1)\u00b2 -4=1, which is 1\u00b2, so that's also True.\nFor n=2: 5*4 +4=24, which isn't a square. 5*4 -4=16, which is 4\u00b2. So True.\n\nWait, 5n\u00b2 -4 for n=2 is 16, which is 4 squared, so yes.\n\nOkay, so the logic seems solid.\n\nLet me outline the function:\n\ndef is_fibonacci(n):\n    if n < 0:\n        return False\n    return is_perfect_square(5*n*n +4) or is_perfect_square(5*n*n -4)\n\nBut wait, I need to define the is_perfect_square function.\n\nHow to implement is_perfect_square. Let's do a helper function inside.\n\nWait, but perhaps we can handle it without a helper function, just compute it inline.\n\nImplement is_perfect_square:\n\ndef is_perfect_square(x):\n    if x < 0:\n        return False\n    s = int(math.sqrt(x))\n    return s*s == x\n\nSo, for x negative, return False. Otherwise, compute the square.\n\nPutting it all together.\n\nSo, overall, the steps are:\n\n1. Check if n is negative: return False.\n2. Compute a = 5n\u00b2 +4 and b=5n\u00b2 -4.\n3. Check if a is a perfect square or b is a perfect square.\n4. Return True if either is, else False.\n\nBut wait, what about the data types? For very large numbers, 5n\u00b2 can get very big. But Python handles big integers well, so that should be okay.\n\nSo, to write the code:\n\nImport math.\n\nThen, define is_fibonacci function.\n\nWait, but in the initial step, what if n is 0? Well, as tested before, 5*(0)^2 +4 is 4, which is square.\n\nNow, testing n=1: both a and b are perfect squares.\n\nTesting n=2: a=24, not a square; b=16, yes.\n\nTesting n=3: a=5*9+4=49, which is 7\u00b2. So returns True.\n\nn=4: a=5*16+4=84, not a square. b=5*16-4=76, not a square. So 4 is not a Fibonacci number? Wait, hold on. Wait, the Fibonacci sequence: 0,1,1,2,3,5,8,13. So 4 is not in the list. So function correctly returns False.\n\nWait, what about n=5: a=5*25+4=129, not a square; b=5*25-4=121, which is 11\u00b2. So returns True.\n\nGreat.\n\nAnother test case: n=6. a=5*36+4=184, not square. b=5*36-4=176, not square. So returns False, which is correct because 6 isn't Fibonacci.\n\nn=7: a=5*49+4=249, not square. b=5*49-4=241, not square. So returns False. 7 isn't a Fibonacci number.\n\nWait, what about n=8: 5*(64) +4= 324, which is 18\u00b2. So returns True.\n\nYes.\n\nSo the function should correctly handle these cases.\n\nNow, what about n=1? It is a Fibonacci number, and it's handled correctly.\n\nn=0? Also correct.\n\nWhat about n=1/2? Well, the function expects an integer, but if someone passes a non-integer, n is not integer, but let's see. Suppose n=1.5, not integer, then 5*(1.5)^2= 11.25, which is not an integer, so a and b would be 11.25+4=15.25 and 11.25-4=7.25. Then sqrt(15.25) is approx 3.905..., which when squared is 15.25. So s is 3, then 3\u00b2=9 !=15.25, so returns False.\n\nBut wait, since n must be integer, perhaps in the function, we should check that n is an integer.\n\nSo, perhaps add a check at the beginning: if n is not integer, return False.\n\nYes, because Fibonacci numbers are integers. So perhaps modify the first condition:\n\nif not isinstance(n, int) or n <0:\n    return False\n\nBut wait, n could be a float that is integral, like 5.0. So to check if it is an integer, perhaps better to see if n is equal to its integer cast.\n\nSo:\n\nif not (isinstance(n, int) or (isinstance(n, float) and n.is_integer())):\n    return False\n\nWait, but n could be passed as a float, but if it's an integer value, like 5.0, we can still proceed. So perhaps the initial check should ensure that n is integer or can be converted to integer without a remainder.\n\nAlternatively, we can cast n to integer if it's a float and has no decimal part.\n\nWait, but perhaps it's better to handle this within the function.\n\nWait, perhaps a better approach is to check if n is an integer, either int or float with integral value. So:\n\nif isinstance(n, int):\n    pass\nelif isinstance(n, float):\n    if not n.is_integer():\n        return False\n    else:\n        n = int(n)\nelse:\n    return False\n\nSo, for n=5.0, it becomes 5, and then the function proceeds.\n\nAlternatively, perhaps we can let n be any number, but if it's not an integer, the condition will fail. Because a and b need to be integers, so their square roots may not be integers.\n\nBut to make it more robust, maybe in the function, we should check whether n is an integer or can be converted to one.\n\nHmm, perhaps it's not necessary because, even if n is a float, 5n\u00b2 could be an integer if n is a multiple of 0.5. But better safe than sorry.\n\nAlternatively, perhaps just proceed. Because, if someone passes a non-integer, it's likely that when they compute a and b, which would involve decimals, unless n is an integer. So the checks for perfect squares would fail, and the function correctly returns False.\n\nSo perhaps no need for an explicit check. However, maybe it's better to make the function more robust by ensuring that n is an integer.\n\nSo, perhaps write:\n\ndef is_fibonacci(n):\n    import math\n    if not isinstance(n, int):\n        # Check if it's a float with integer value\n        if isinstance(n, float) and n.is_integer():\n            n = int(n)\n        else:\n            return False\n    if n < 0:\n        return False\n    a = 5 * n * n +4\n    b = 5 * n * n -4\n    def is_square(x):\n        if x <0:\n            return False\n        s = int(math.sqrt(x))\n        return s*s == x\n    return is_square(a) or is_square(b)\n\nWait, maybe also considering that 0 is a valid case: for n=0, a=4, which is a square, so function returns True. That's correct because 0 is a Fibonacci number.\n\nAlternatively, some people might consider the Fibonacci sequence starting from 1 instead of 0, but the original definition includes 0 as well.\n\nBut as per the user's question, I think the standard definition includes 0, so it's fine.\n\nTherefore, putting all this together, the function is_fibonacci would first check if n is an integer (either int or float with integer value), then computes a and b, checks if either is a perfect square, and returns accordingly.\n\nAlternatively, another method is to generate Fibonacci numbers up to the given number and check if it exists in the generated list.\n\nBut that method is less efficient, especially for large n, because it would require generating all previous Fibonacci numbers up to n, which for very large n could take a lot of time. So the mathematical approach is much better.\n\nBut, just to think, what if the given number is very large, like 10^18? The mathematical method is still efficient, because it's just a couple of operations with big integers.\n\nSo I think the mathematical approach is the way to go.\n\nThus, the code should be written as per above, handling possible input as integer or float, but only allowing integral values, converting them to integers if necessary.\n\nWait, but in the code above, I included 'import math' inside the function. Wait, that's not efficient if the function is called multiple times because importing is done every time. So perhaps better to import math at the top.\n\nBut if it's a standalone function, then it's fine.\n\nSo the complete function:\n\nImport math first.\n\nBut since the function may be called multiple times, perhaps it's better to have the import at the top.\n\nBut in the function, the helper function is defined inside. But since it's a small function, it's okay.\n\nWait, another point: for n=0, 5n\u00b2 is 0, so a=4, which is square, correct.\n\nn=1: a=9, b=1, both squares.\n\nn=2: a=24, not square; b=16, which is. So returns True.\n\nSo the code should handle these.\n\nI think that's the solution.\n\n**Final Answer**\n\nTo determine if a given number is a Fibonacci number, we can use a mathematical property where a number \\( n \\) is Fibonacci if either \\( 5n^2 + 4 \\) or \\( 5n^2 - 4 \\) is a perfect square. Here is the Python function implementing this logic:\n\n```python\nimport math\n\ndef is_fibonacci(n):\n    if not isinstance(n, int):\n        if isinstance(n, float) and n.is_integer():\n            n = int(n)\n        else:\n            return False\n    if n < 0:\n        return False\n    def is_perfect_square(x):\n        if x < 0:\n            return False\n        s = int(math.sqrt(x))\n        return s * s == x\n    a = 5 * n * n + 4\n    b = 5 * n * n - 4\n    return is_perfect_square(a) or is_perfect_square(b)\n```\n\n**Step-by-Step Explanation:**\n\n1. **Type Check:** The function first ensures the input \\( n \\) is an integer. If \\( n \\) is a float, it checks if it's an integer value and converts it to an integer if so. Non-integer types result in returning False.\n\n2. **Negative Check:** If \\( n \\) is negative, it immediately returns False since Fibonacci numbers are non-negative.\n\n3. **Perfect Square Check Helper:** A nested function `is_perfect_square` checks if a number is a perfect square by taking the integer square root, squaring it, and comparing it to the original number.\n\n4. **Mathematical Property Application:** The function computes \\( 5n^2 + 4 \\) and \\( 5n^2 - 4 \\) and checks if either is a perfect square using the helper function.\n\n5. **Return Result:** If either value is a perfect square, the function returns True, indicating \\( n \\) is a Fibonacci number. Otherwise, it returns False.\n\nThis approach efficiently checks for Fibonacci numbers using a mathematical property, ensuring optimal performance even for large values of \\( n \\).\n\n**Answer:** The function is defined above, and the final answer is to use this function. To present it succinctly, the code is:\n\n```python\nimport math\n\ndef is_fibonacci(n):\n    if not isinstance(n, int):\n        if isinstance(n, float) and n.is_integer():\n            n = int(n)\n        else:\n            return False\n    if n < 0:\n        return False\n    def is_perfect_square(x):\n        if x < 0:\n            return False\n        s = int(math.sqrt(x))\n        return s * s == x\n    a = 5 * n * n + 4\n    b = 5 * n * n - 4\n    return is_perfect_square(a) or is_perfect_square(b)\n```\n\n\\boxed{is\\_fibonacci}\n</think>\n\nTo determine if a given number is a Fibonacci number, we can use a mathematical property where a number \\( n \\) is Fibonacci if either \\( 5n^2 + 4 \\) or \\( 5n^2 - 4 \\) is a perfect square. Here is the Python function implementing this logic:\n\n```python\nimport math\n\ndef is_fibonacci(n):\n    if not isinstance(n, int):\n        if isinstance(n, float) and n.is_integer():\n            n = int(n)\n        else:\n            return False\n    if n < 0:\n        return False\n    def is_perfect_square(x):\n        if x < 0:\n            return False\n        s = int(math.sqrt(x))\n        return s * s == x\n    a = 5 * n * n + 4\n    b = 5 * n * n - 4\n    return is_perfect_square(a) or is_perfect_square(b)\n```\n\nThis function first checks if the input \\( n \\) is an integer. If \\( n \\) is a float, it checks if it's an integer value and converts it to an integer if so. Non-integer types result in returning False. For negative numbers, it returns False. The function then computes \\( 5n^2 + 4 \\) and \\( 5n^2 - 4 \\) and checks if either is a perfect square using a helper function. If either value is a perfect square, the function returns True, indicating \\( n \\) is a Fibonacci number. Otherwise, it returns False.\n\n\\boxed{is\\_fibonacci}",
  "r1_solution": "import math\n\ndef is_fibonacci(n):\n    if not isinstance(n, int):\n        if isinstance(n, float) and n.is_integer():\n            n = int(n)\n        else:\n            return False\n    if n < 0:\n        return False\n    def is_perfect_square(x):\n        if x < 0:\n            return False\n        s = int(math.sqrt(x))\n        return s * s == x\n    a = 5 * n * n + 4\n    b = 5 * n * n - 4\n    return is_perfect_square(a) or is_perfect_square(b)",
  "metadata": {
    "prompt_id": "00000189",
    "row_id": 189,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}