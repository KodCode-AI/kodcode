{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000055_C",
  "question": "def is_isomorphic(s1: str, s2: str) -> bool:\n    \"\"\"\n    Checks if two strings are isomorphic. Two strings are isomorphic if the characters in s1 can be replaced to get s2.\n    \n    >>> is_isomorphic(\"egg\", \"add\")\n    True\n    >>> is_isomorphic(\"foo\", \"bar\")\n    False\n    >>> is_isomorphic(\"paper\", \"title\")\n    True\n    >>> is_isomorphic(\"abc\", \"abc\")\n    True\n    >>> is_isomorphic(\"\", \"\")\n    True\n    >>> is_isomorphic(\"a\", \"a\")\n    True\n    >>> is_isomorphic(\"aabb\", \"ccdd\")\n    True\n    >>> is_isomorphic(\"ab\", \"aa\")\n    False\n    \"\"\"",
  "solution": "def is_isomorphic(s1, s2):\n    \"\"\"\n    Checks if two strings are isomorphic. Two strings are isomorphic if the characters in s1 can be replaced to get s2.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    s1_to_s2_map = {}\n    s2_to_s1_map = {}\n    \n    for char_from_s1, char_from_s2 in zip(s1, s2):\n        if char_from_s1 in s1_to_s2_map:\n            if s1_to_s2_map[char_from_s1] != char_from_s2:\n                return False\n        else:\n            s1_to_s2_map[char_from_s1] = char_from_s2\n        \n        if char_from_s2 in s2_to_s1_map:\n            if s2_to_s1_map[char_from_s2] != char_from_s1:\n                return False\n        else:\n            s2_to_s1_map[char_from_s2] = char_from_s1\n    \n    return True",
  "test_code": "from solution import is_isomorphic\n\ndef test_isomorphic_example1():\n    assert is_isomorphic(\"egg\", \"add\") == True\n\ndef test_isomorphic_example2():\n    assert is_isomorphic(\"foo\", \"bar\") == False\n\ndef test_isomorphic_example3():\n    assert is_isomorphic(\"paper\", \"title\") == True\n\ndef test_isomorphic_identical_strings():\n    assert is_isomorphic(\"abc\", \"abc\") == True\n\ndef test_isomorphic_empty_strings():\n    assert is_isomorphic(\"\", \"\") == True\n\ndef test_isomorphic_no_characters():\n    assert is_isomorphic(\"a\", \"a\") == True\n\ndef test_isomorphic_mismatched_characters():\n    assert is_isomorphic(\"aabb\", \"ccdd\") == True\n\ndef test_isomorphic_non_unique_replacement():\n    assert is_isomorphic(\"ab\", \"aa\") == False",
  "test_info": [
    {
      "function_name": "is_isomorphic",
      "parameter_list": "(s1, s2)",
      "function_declaration": "def is_isomorphic(s1, s2):",
      "docstring": "Checks if two strings are isomorphic. Two strings are isomorphic if the characters in s1 can be replaced to get s2."
    }
  ],
  "gpt_pass_sequence": [
    0,
    1,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to solve this problem where I have to check if two given strings are isomorphic. Hmm, what does isomorphic mean here? From the problem statement, I think two strings s1 and s2 are isomorphic if there's a one-to-one mapping between the characters of s1 to s2. So each character in s1 must correspond to exactly one character in s2 and vice versa. Oh right, and it's bidirectional, so the mapping shouldn't allow two different characters in s1 mapping to the same character in s2, and same for s2 mapping back to s1.\n\nSo let me think about how to approach this. Maybe I can create two dictionaries: one mapping characters from s1 to s2, and another to map s2 back to s1. As I iterate through each character pair from s1 and s2, I'll check if the current mapping holds. If I find any inconsistency, I return False. Otherwise, if I go through all pairs without issues, return True.\n\nWait, what's the initial condition? Well, both strings need to be of the same length. If their lengths are different, they can't be isomorphic. So, first, I should check if len(s1) == len(s2). If not, return False immediately.\n\nOkay, now for the main logic. For each index i, look at s1[i] and s2[i]. Let's say s1_char is s1[i], s2_char is s2[i].\n\nI'll need two dictionaries: s1_map which maps s1_char to s2_char, and s2_map which maps s2_char back to s1_char.\n\nSo when processing each pair:\n- Check if s1_char is already in s1_map:\n   - If it is, the corresponding value must be equal to s2_char. If not, return False.\n   - If not, then I also need to check if s2_char is in s2_map. Because if it is, that means some other s1_char is already mapped to it. Which violates the bidirectional mapping. So in that case, return False.\n   - If neither map has conflicting entries, add s1_char -> s2_char to s1_map and s2_char -> s1_char to s2_map.\n- Continue this for all characters.\n\nLet me think about some test cases.\n\nFirst sample: \"egg\" and \"add\"\ns1: e \u2192 a, g\u2192d.\nIn \"egg\":\n- e is mapped to a. Second character is g, which isn't mapped yet. Map g to d. Then third character is g again. It should have mapping d. So that's consistent.\nSo function should return True.\n\nAnother sample: \"foo\" and \"bar\".\nf is mapped to b, o to a. Then next o is a again, which is consistent. But s2 is 'ba' followed by 'r'? Wait, s2 is \"bar\". Oh right, the third character should be the same as in the third position. So in s1, 'o' is third character if I'm thinking of the string correctly? Wait, s1 is \"foo\", which is 'f','o','o'.\ns2 is \"bar\": 'b','a','r'.\nWait, for the second character in s1 (o), we expect the second character in s2 is a. Then the third o should correspond to a again, so the third s2 would have to be a. But in the sample, the third character is 'r'. Which is inconsistent, so it's False.\n\nSo the function correctly returns False.\n\nAnother case: \"paper\" and \"title\".\ns1: p, a, p, e, r\ns2: t, i, t, l, e\n\nFirst, p is not mapped, t is mapped to p. So add p\u2192t and t\u2192p.\n\nThen a is mapped to i, add a\u2192i and i\u2192a.\n\nNext, p again, and it should map to t. Which is same as s2's third character.\n\nThen e: in s1 is e, and in s2 it's l. So add e\u2192l and l\u2192e.\n\nThen r in s1 maps to e, and add r\u2192e and e\u2192r. Wait wait, no. Because s2's last character is e. So for s1's 'r', it's being mapped to 'e'? But then in the second map, e was already mapped by some other s1 character.\n\nWait this is a tricky point. Let me think again.\n\nWait, in this case: e in s1 is at position 4, s2 is 'l' and 'e' at positions 4 and 5?\n\nWait no: the string \"paper\" has 5 letters. So indexes 0,1,2,3,4.\n\np a p e r \u2192 s2: t i t l e.\n\nWait, let's list all pairs:\n\ns1: p (0) \u2192 t (0)\ns1: a (1) \u2192 i (1)\ns1: p (2) \u2192 t (2) \u2192 correct.\ns1: e (3) \u2192 l (3)\ns1: r (4) \u2192 e (4)\n\nSo when processing r (4), it's mapped to e. Now, check the s2_map. Does e already have a mapping?\n\nIn s2, at position 3, we have 'l', which was mapped to e (s1_map e \u2192 l). So for s2_map, l was mapped to e in s1.\n\nBut now, the previous mappings are okay: for s2, each character is mapped correctly in the reverse direction.\n\nSo in this case, the function correctly returns True.\n\nAnother test case: is_isomorphic(\"a\", \"a\") \u2192 True.\n\nEdge case: both empty \u2192 True.\n\nWhat about \"ab\" and \"aa\"? Here, s1's a is mapped to a, but s1's b is mapped to a. That would mean two different s1 characters are mapped to the same s2 character. So s1_map a\u2192a, then b is about to be mapped to a. But in s2_map, a is already the key, pointing back to a. So when processing the second pair, for s1_char 'b' and s2_char 'a', I check s1_map for 'b' \u2192 no, so I need to check if 'a' is already in s2_map. Indeed, s2_map has 'a' which points to 'a', which is different from 'b'. Thus, this would be invalid, so function returns False, as per the sample.\n\nSo how to implement this.\n\nLet's outline the steps:\n\n1. Check if the lengths of s1 and s2 are equal. If not, return False.\n\n2. Create two dictionaries, map1 and map2. map1 will map s1 chars to s2 chars. map2 will map s2 chars back to s1.\n\n3. Iterate over each pair of characters (c1, c2) from s1 and s2.\n\n4. For each pair, do the following:\n\n   a. If c1 is in map1, then check if map1[c1] is c2. If not, return False.\n\n   b. Else, if c2 is already in map2, then return False. Because that would mean c2 was previously mapped to a different c1.\n\n   c. Otherwise, add map1[c1] = c2, and map2[c2] = c1.\n\nBut wait, point b: no. Wait, c1 is not in map1 (that's why we're in the else part) but what about c2? Maybe c2 is already mapped by another c pair. So adding c1\u2192c2 would cause a conflict in map2, because c2 is already a key. So for example in the \"ab\" to \"aa\" case:\n\n- Pair 0: a and a. So map1[a] = a, map2[a] = a.\n\n- Pair 1: b and a. Check map1: b is not present.\n\nCheck if a is in map2. Yes, it is, and map2[a] is a, not b. So adding b\u2192a would conflict because map2[a] exists but points to a, which is not equal to b. So in this case, in step 4b, since s2's a is in map2, which maps to a, which is different from s1's b. Hence, it's a conflict, function returns False.\n\nWait, so the condition is: if c1 is not in map1, then check if c2 is in map2. If yes, then it's a conflict because this c2 would have to be mapped back to another c1. Hence, the function cannot proceed.\n\nYes, that's correct.\n\nSo implementing this, now code.\n\nIn Python, the function would be:\n\ndef is_isomorphic(s1: str, s2: str) -> bool:\n    if len(s1) != len(s2):\n        return False\n    map_s1 = {}\n    map_s2 = {}\n    for c1, c2 in zip(s1, s2):\n        if c1 in map_s1:\n            if map_s1[c1] != c2:\n                return False\n        else:\n            if c2 in map_s2:\n                # c2 is already mapped to another c1\n                return False\n            map_s1[c1] = c2\n            map_s2[c2] = c1\n    return True\n\nWait, but perhaps using zip isn't sufficient if one is longer than the other? But earlier, we already check that lengths are equal, so zip will cover all because it takes the minimum of the two. But since we have len(s1) == len(s2), it will process all characters.\n\nTesting some scenarios.\n\nFor the case when s1 is empty string and s2 is empty, function returns True.\n\nAnother test case: when s1 and s2 are the same, like \"abc\" \u2192 \"abc\". Both maps will be identity, and it returns True.\n\nAnother case: s1 is \"aabb\", s2 is \"ccdd\". So mappings are a\u2192c, and the first b\u2192d. Then the second a must be c, and the second b must be d. Then it's all good. Function returns True.\n\nSo all test cases pass.\n\nThus, this approach should solve the problem.\n</think>\n\nTo solve this problem, we need to determine if two given strings are isomorphic. Two strings are isomorphic if there's a one-to-one mapping between the characters of the first string to the second string, such that each character in the first string can be replaced to get the second string, and vice versa.\n\n### Approach\n1. **Check Lengths**: First, check if the lengths of the two strings are equal. If they are not, they cannot be isomorphic, so return False.\n2. **Create Mappings**: Use two dictionaries to maintain the mappings: one from the first string to the second string and another for the reverse mapping.\n3. **Iterate Through Characters**: For each character pair from the two strings, check the following:\n   - If the character from the first string is already mapped, ensure it maps to the corresponding character in the second string.\n   - If the character from the second string is already mapped to a different character in the first string, return False.\n   - Otherwise, update the mappings in both dictionaries.\n4. **Return Result**: If all character pairs are processed without conflicts, return True.\n\n### Solution Code\n```python\ndef is_isomorphic(s1: str, s2: str) -> bool:\n    if len(s1) != len(s2):\n        return False\n    map_s1 = {}\n    map_s2 = {}\n    for c1, c2 in zip(s1, s2):\n        if c1 in map_s1:\n            if map_s1[c1] != c2:\n                return False\n        else:\n            if c2 in map_s2:\n                return False\n            map_s1[c1] = c2\n            map_s2[c2] = c1\n    return True\n```\n\n### Explanation\n- **Length Check**: The function starts by checking if the lengths of the two strings are the same. If not, it returns False immediately.\n- **Mappings**: Two dictionaries, `map_s1` and `map_s2`, are used to track the mappings from `s1` to `s2` and from `s2` to `s1`, respectively.\n- **Character Processing**: For each pair of characters, the function checks if the characters are already mapped. If a conflict is detected (i.e., a character from `s1` maps to different characters in `s2` or vice versa), it returns False. Otherwise, it updates the mappings.\n- **Result**: If all characters are processed without conflicts, the function returns True, indicating that the strings are isomorphic.",
  "r1_solution": "def is_isomorphic(s1: str, s2: str) -> bool:\n    if len(s1) != len(s2):\n        return False\n    map_s1 = {}\n    map_s2 = {}\n    for c1, c2 in zip(s1, s2):\n        if c1 in map_s1:\n            if map_s1[c1] != c2:\n                return False\n        else:\n            if c2 in map_s2:\n                return False\n            map_s1[c1] = c2\n            map_s2[c2] = c1\n    return True",
  "metadata": {
    "prompt_id": "00000055",
    "row_id": 55,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to identify if two string s1 and s2 are isomorphic. Two strings are isomorphic if the characters in s1 can be replaced to get s2. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}