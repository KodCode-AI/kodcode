{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000190_C",
  "question": "def is_perfect_square(num: int) -> bool:\n    \"\"\"Checks if the given number is a perfect square.\n    \n    >>> is_perfect_square(1)\n    True\n    >>> is_perfect_square(4)\n    True\n    >>> is_perfect_square(9)\n    True\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(25)\n    True\n    >>> is_perfect_square(2)\n    False\n    >>> is_perfect_square(3)\n    False\n    >>> is_perfect_square(5)\n    False\n    >>> is_perfect_square(7)\n    False\n    >>> is_perfect_square(8)\n    False\n    >>> is_perfect_square(0)\n    True\n    >>> is_perfect_square(-4)\n    False\n    \"\"\"",
  "solution": "def is_perfect_square(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect square.\n    \n    Args:\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    root = int(num ** 0.5)\n    return root * root == num",
  "test_code": "from solution import is_perfect_square\n\ndef test_perfect_squares():\n    assert is_perfect_square(1) is True  # 1 = 1^2\n    assert is_perfect_square(4) is True  # 4 = 2^2\n    assert is_perfect_square(9) is True  # 9 = 3^2\n    assert is_perfect_square(16) is True # 16 = 4^2\n    assert is_perfect_square(25) is True # 25 = 5^2\n\ndef test_non_perfect_squares():\n    assert is_perfect_square(2) is False  # No integer square root\n    assert is_perfect_square(3) is False  # No integer square root\n    assert is_perfect_square(5) is False  # No integer square root\n    assert is_perfect_square(7) is False  # No integer square root\n    assert is_perfect_square(8) is False  # No integer square root\n\ndef test_zero_and_negative_numbers():\n    assert is_perfect_square(0) is True  # 0 = 0^2\n    assert is_perfect_square(-4) is False # Negative numbers cannot be perfect squares",
  "test_info": [
    {
      "function_name": "is_perfect_square",
      "parameter_list": "(num)",
      "function_declaration": "def is_perfect_square(num):",
      "docstring": "Checks if the given number is a perfect square.\n\nArgs:\nnum (int): The number to check.\n\nReturns:\nbool: True if num is a perfect square, False otherwise."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nAlright, I need to write a Python function called is_perfect_square that checks if a given integer is a perfect square. Hmm, let's think about what a perfect square is. A perfect square is a number that can be expressed as the square of an integer. So, for example, 4 is a perfect square because it's 2 squared, and 9 is 3 squared. But numbers like 2 or 3 are not because their square roots are not integers.\n\nFirst, I should consider the cases where the input number is zero or negative. Wait, the square of any real number can't be negative, so any negative number should return False. But zero is a perfect square because 0 squared is zero. So, if the number is negative, immediately return False.\n\nNext, for non-negative numbers. How do I check if a number is a perfect square? An approach I remember is taking the square root of the number, converting it to an integer, squaring it, and seeing if it equals the original number. Because sometimes due to floating point inaccuracies, checking the square root's type might not be reliable.\n\nSo here's the plan: for num >=0, compute sqrt = integer square root (using math.isqrt or int(math.sqrt(num))), then check if sqrt squared equals num. If yes, return True; else, False.\n\nWait, what about when num is 0? Then sqrt would be 0, and 0 squared is 0. So yes, 0 is handled correctly.\n\nLet me outline the steps:\n\n1. If num is less than 0, return False.\n2. If num is 0, return True.\n3. Else, compute the integer square root of num. How? Using math.sqrt might give a float, converting to int could lose information if the float isn't exact. Wait, math.sqrt(4) gives 2.0, converting to int gives 2. But for numbers like 5, math.sqrt gives ~2.236, so converting to int is 2, then 2^2 is 4, which is less than 5, so correctly returns False.\n\nWait but I remember that for very large numbers, math.sqrt might not be precise because of floating point precision limits. Maybe a better way is to compute the integer square root using a more precise method. Alternatively, since Python has math.isqrt which returns the integer square root. So using math.isqrt might be better.\n\nWait, let's see. For example, math.isqrt(25) returns 5. So 5^2 is 25, correct. For 26, math.isqrt returns 5, 5^2=25 <26, so returns False.\n\nWait, so the steps with math.isqrt would be:\n\nFor num >=0:\n\nsqrt_num = math.isqrt(num)\nif sqrt_num * sqrt_num == num: return True\nelse: return False\n\nYes! Because math.isqrt returns the largest integer less than or equal to the square root of num. So if that integer's square equals num, then it's a perfect square.\n\nSo putting it all together:\n\n- Handle num <0: return False\n- For num >=0: compute sqrt_num via math.isqrt, then check if its square is num.\n\nBut wait, what if num is 1? math.isqrt(1) is 1, 1*1=1, True.\n\nWhat about num=2? math.isqrt(2) is 1, 1^2=1 !=2, so False.\n\nThat should handle all cases.\n\nSo the function would be:\n\nImport math.\n\nWait, wait wait. Let's think about the case num=0. Because 0 is a valid perfect square, but in the negative case, return False before checking 0. Then for num=0, it's covered in the else.\n\nWait, no: when num=0, in step 2, it's handled and returns True. So that's fine.\n\nNow, testing the examples:\n\nTest case 1: is_perfect_square(1) \u2192 True: 1=1\u00b2 \u2192 correct.\n\nTest case 2: is_perfect_square(4)\u2192 2\u00b2=4 \u2192 True.\n\nSame with 9 (3\u00b2) and 16 (4\u00b2), etc.\n\nFor 2,3,5,7, etc., correctly returns False.\n\nWait, what about num=6: 2^2 is 4 <6, but 3^2 is 9>6, so correctly returns False.\n\nWhat about a big number, like 25: 5^2=25\u2192 True.\n\nZero is handled, negative numbers return False.\n\nWait, what about 2 squared plus 1? Like 5: 2^2 is 4 <5\u2192 returns False.\n\nAnother thing: What about the number 1, 0? Both return True.\n\nWhat about numbers that are squares but because of negative square roots, but the function only checks positive square roots, which is correct.\n\nSo the code would look like:\n\nImport math\n\ndef is_perfect_square(num: int) -> bool:\n    if num <0:\n        return False\n    sqrt_num = math.isqrt(num)\n    return sqrt_num * sqrt_num == num\n\nWait, but what about for num=2, let's see:\n\nmath.isqrt(2) is 1, then 1 squared is 1, which is not equal to 2. So returns False.\n\nAnother way: the same approach.\n\nBut wait, what about if the square root is a float, like for num=25, it returns 5.0 but when squared is 25. But in this approach, since math.isqrt returns an integer, so no problem.\n\nYes, this should correctly handle all cases.\n\nSo the function is_perfect_square will first handle negative numbers. For non-negative, it computes the integer square root, squares it, and checks against the original number. If it's equal, returns True, else False.\n\nLet me test some edge cases.\n\nWhat about num=-4? Returns False.\n\nnum=0: is it included? Because in the function, num >=0 includes 0, and 0 is correctly computed as True.\n\nAnother edge case: num=1.\n\nIt works.\n\nWhat about a very large number like 1000000:\n\nmath.isqrt(1000000) is 1000, 1000^2 is 1e6, so returns True.\n\nWhat about 1000001: math.isqrt returns 1000, 1000^2 is 1e6, which is less than 1e6+1 \u2192 returns False.\n\nYes, the code should handle this.\n\nWait, but is there any case where math.isqrt returns a float? No, because isqrt returns the integer part as an integer.\n\nSo the code should be correct.\n\nThus, the function is implemented as follows.\n</think>\n\nTo solve this problem, we need to determine if a given integer is a perfect square. A perfect square is a number that can be expressed as the square of an integer. For example, 4 is a perfect square because it is 2 squared, and 9 is 3 squared. Negative numbers cannot be perfect squares because the square of any real number is non-negative.\n\n### Approach\n1. **Handle Negative Numbers**: If the input number is negative, it immediately returns False because negative numbers cannot be perfect squares.\n2. **Check for Zero**: Zero is considered a perfect square since it is the square of zero.\n3. **Compute Integer Square Root**: For non-negative numbers, compute the integer square root using `math.isqrt`, which returns the largest integer less than or equal to the square root of the given number.\n4. **Check Perfection**: Square the integer square root and check if it equals the original number. If it does, the number is a perfect square; otherwise, it is not.\n\n### Solution Code\n\n```python\nimport math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    sqrt_num = math.isqrt(num)\n    return sqrt_num * sqrt_num == num\n```\n\n### Explanation\n- **Negative Check**: The function first checks if the input number is less than zero. If it is, the function returns False because negative numbers cannot be perfect squares.\n- **Zero Case**: If the number is zero, it is a perfect square, so the function returns True.\n- **Integer Square Root Calculation**: For non-negative numbers, the function uses `math.isqrt` to compute the integer square root. This function efficiently returns the floor value of the square root without floating-point inaccuracies.\n- **Perfection Check**: The function then squares the integer square root and checks if it equals the original number. If it does, the number is a perfect square, and the function returns True. Otherwise, it returns False.\n\nThis approach efficiently handles all edge cases, including very large numbers, ensuring accurate results without floating-point errors.",
  "r1_solution": "import math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    sqrt_num = math.isqrt(num)\n    return sqrt_num * sqrt_num == num",
  "metadata": {
    "prompt_id": "00000190",
    "row_id": 190,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to determine if a number is a \"perfect square\" number. A \"perfect square\" number is an integer that is the square of an integer. For example, 16 is a perfect square because it is 4 squared."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}