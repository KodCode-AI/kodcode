{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000190_C",
  "question": "def is_perfect_square(num: int) -> bool:\n    \"\"\"Checks if the given number is a perfect square.\n    \n    >>> is_perfect_square(1)\n    True\n    >>> is_perfect_square(4)\n    True\n    >>> is_perfect_square(9)\n    True\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(25)\n    True\n    >>> is_perfect_square(2)\n    False\n    >>> is_perfect_square(3)\n    False\n    >>> is_perfect_square(5)\n    False\n    >>> is_perfect_square(7)\n    False\n    >>> is_perfect_square(8)\n    False\n    >>> is_perfect_square(0)\n    True\n    >>> is_perfect_square(-4)\n    False\n    \"\"\"",
  "solution": "def is_perfect_square(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect square.\n    \n    Args:\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    root = int(num ** 0.5)\n    return root * root == num",
  "test_code": "from solution import is_perfect_square\n\ndef test_perfect_squares():\n    assert is_perfect_square(1) is True  # 1 = 1^2\n    assert is_perfect_square(4) is True  # 4 = 2^2\n    assert is_perfect_square(9) is True  # 9 = 3^2\n    assert is_perfect_square(16) is True # 16 = 4^2\n    assert is_perfect_square(25) is True # 25 = 5^2\n\ndef test_non_perfect_squares():\n    assert is_perfect_square(2) is False  # No integer square root\n    assert is_perfect_square(3) is False  # No integer square root\n    assert is_perfect_square(5) is False  # No integer square root\n    assert is_perfect_square(7) is False  # No integer square root\n    assert is_perfect_square(8) is False  # No integer square root\n\ndef test_zero_and_negative_numbers():\n    assert is_perfect_square(0) is True  # 0 = 0^2\n    assert is_perfect_square(-4) is False # Negative numbers cannot be perfect squares",
  "test_info": [
    {
      "function_name": "is_perfect_square",
      "parameter_list": "(num)",
      "function_declaration": "def is_perfect_square(num):",
      "docstring": "Checks if the given number is a perfect square.\n\nArgs:\nnum (int): The number to check.\n\nReturns:\nbool: True if num is a perfect square, False otherwise."
    }
  ],
  "gpt_pass_sequence": [
    1,
    0,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 0.667,
  "r1_response": "<think>\nOkay, so I need to write a function called is_perfect_square that takes an integer and returns a boolean indicating whether it's a perfect square. Hmm. Let's think about what a perfect square is. It's a number that's the square of an integer, right? So like 4 is 2 squared, 9 is 3 squared, etc. But also, zero is 0 squared, so that's why it returns True. Oh, and negative numbers shouldn't be perfect squares because squaring any integer gives a non-negative result.\n\nFirst, I should consider the cases. If num is negative, then return False immediately. Wait, but what if num is zero? Then return True. So I need to handle num >= 0.\n\nWait, but can num be non-integer? Oh, wait no, the function is given a num: int. So it's an integer, so I don't have to handle floating points. Wait, but in Python, what about if someone passes something else? But the function signature says it's an int, so I guess we can assume that num is an integer.\n\nSo, for num < 0, return False.\n\nNext, for num >=0, I need to check if there's an integer that when squared equals num. How can I do that?\n\nHmm, the straightforward way is to take the square root and then check if it's an integer. So in Python, I can compute the square root using math.sqrt(). But wait, math.sqrt returns a float, and comparing for equality with integers might not be precise. So perhaps taking the integer closest to the square root, then squaring and checking.\n\nFor example, take num = 25. math.sqrt(25) is 5.0, so int(5.0) is 5. Squaring gives 25, which is equal to num. So it's a perfect square.\n\nAnother example: num=8. math.sqrt(8) is about 2.828, so int is 2. 2 squared is 4, which is not 8. So it's not a perfect square.\n\nBut wait, what about taking the square root and checking if it's an integer. But more accurately, maybe using the ** operator and then rounding.\n\nWait, another approach is to loop through all possible integers from 0 up to the square root of num and see if any square equals num. But that could be inefficient for large numbers, but for the purposes of this problem, maybe it's acceptable.\n\nAlternatively, finding the integer square root and then squaring it.\n\nHmm, in Python, there's math.isqrt which returns the integer square root, which is the largest integer less than or equal to the square root of num. So if I compute s = isqrt(num), then s*s == num.\n\nWait, that's a good approach. So, for num >=0, s = math.isqrt(num). If s*s == num, then return True. Otherwise, False.\n\nSo that should handle all the cases.\n\nWait, what about when num is 0? Let's see: math.isqrt(0) is 0, 0*0 is 0. So returns True.\n\nWhat about 1? math.isqrt(1) is 1, 1*1 =1, True.\n\nWhat about num=2: math.isqrt(2) is 1. 1*1=1!=2, so False.\n\nAnother example: num = 100. s=10. s^2 =100, True.\n\nSo this approach should work.\n\nWait, but in Python versions? I think math.isqrt is available from Python 3.8 onwards. So yes, as per standard libraries now.\n\nSo the function can be written as:\n\nimport math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    s = math.isqrt(num)\n    return s * s == num\n\nBut wait, wait. What about for very large numbers that are perfect squares, but the product s*s could overflow? Hmm, but in Python, integers can be arbitrarily large, so overflow isn't an issue.\n\nSo that should cover all cases.\n\nLet's test the sample inputs:\n\nSample 1: num=1 \u2192 returns True. Correct.\n\nSample 2: num=4 \u2192 True.\n\nSimilarly, 9, 16, 25 all True.\n\nFor num=0 \u2192 True.\n\nNegative numbers, like -4 \u2192 False.\n\nNumbers like 2,3,5,7,8: returns False.\n\nSo all the provided test cases should pass.\n\nAnother test: what about num=64? math.isqrt(64) is 8. 8^2 is 64 \u2192 True.\n\nWhat about numbers larger than 2^32? Like 18446744082299486225 which is (2^63 + 1)^2. It should return True. From a computational standpoint, it's a big number, but in Python, it's handled.\n\nAnother possible edge case: num=1. Since 1 is 1^2, returns True.\n\nSo, the function should work.\n</think>\n\nTo solve this problem, we need to determine if a given integer is a perfect square. A perfect square is a number that can be expressed as the square of an integer. For example, 25 is a perfect square because it is 5 squared.\n\n### Approach\nThe approach to solving this problem involves the following steps:\n1. **Check for Negative Numbers**: Since negative numbers cannot be perfect squares, we immediately return False if the input number is negative.\n2. **Compute Integer Square Root**: For non-negative numbers, we compute the integer square root using Python's `math.isqrt` function. This function returns the largest integer less than or equal to the square root of the given number.\n3. **Check Perfection**: We then square this integer square root and check if the result equals the original number. If it does, the number is a perfect square; otherwise, it is not.\n\nThis approach efficiently handles both small and very large numbers, taking advantage of Python's ability to manage arbitrarily large integers without overflow issues.\n\n### Solution Code\n```python\nimport math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    s = math.isqrt(num)\n    return s * s == num\n```\n\n### Explanation\n1. **Negative Check**: The function first checks if the input number is negative. If it is, the function returns False immediately since negative numbers cannot be perfect squares.\n2. **Integer Square Root Calculation**: For non-negative numbers, the function calculates the integer square root using `math.isqrt`. This function efficiently finds the floor value of the square root without floating-point inaccuracies.\n3. **Perfection Check**: The function then squares the integer square root and compares it to the original number. If they are equal, the number is a perfect square, and the function returns True. Otherwise, it returns False.\n\nThis method is both efficient and concise, ensuring correct results for all integer inputs.",
  "r1_solution": "import math\n\ndef is_perfect_square(num: int) -> bool:\n    if num < 0:\n        return False\n    s = math.isqrt(num)\n    return s * s == num",
  "metadata": {
    "prompt_id": "00000190",
    "row_id": 190,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to determine if a number is a \"perfect square\" number. A \"perfect square\" number is an integer that is the square of an integer. For example, 16 is a perfect square because it is 4 squared."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}