{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000002_C",
  "question": "def max_depth_bst(root: TreeNode) -> int:\n    \"\"\"Returns the maximum depth of a binary search tree.\n    >>> max_depth_bst(TreeNode(2, TreeNode(1), TreeNode(3)))\n    2\n    >>> max_depth_bst(TreeNode(2, TreeNode(1, TreeNode(0)), None))\n    3\n    \"\"\"",
  "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"\n    Returns the maximum depth of a binary search tree.\n    \"\"\"\n    if root is None:\n        return 0\n    return 1 + max(max_depth_bst(root.left), max_depth_bst(root.right))",
  "test_code": "from solution import max_depth_bst, TreeNode\n\ndef test_max_depth_bst_empty_tree():\n    assert max_depth_bst(None) == 0\n\ndef test_max_depth_bst_single_node():\n    root = TreeNode(1)\n    assert max_depth_bst(root) == 1\n\ndef test_max_depth_bst_balanced_tree():\n    root = TreeNode(2, TreeNode(1), TreeNode(3))\n    assert max_depth_bst(root) == 2\n\ndef test_max_depth_bst_unbalanced_tree_left():\n    root = TreeNode(2, TreeNode(1, TreeNode(0), None), TreeNode(3))\n    assert max_depth_bst(root) == 3\n\ndef test_max_depth_bst_unbalanced_tree_right():\n    root = TreeNode(2, TreeNode(1), TreeNode(3, None, TreeNode(4)))\n    assert max_depth_bst(root) == 3",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to find the maximum depth of a binary search tree. Hmm, wait, the function is called max_depth_bst and it takes a root node. I remember that the maximum depth is the longest path from the root to a leaf node. So I think it's similar to calculating the height of a binary tree.\n\nBut wait, am I supposed to do anything different because it's a BST? Probably not, because the structure of a BST might affect the balance, but the maximum depth would still be the same as the height of the tree. Oh right, the problem just wants the maximum depth, so I don't have to validate whether it's a BST or not.\n\nSo how do I compute this? I think recursively. For each node, the depth is 1 plus the maximum depth of its left or right child, whichever is larger. But wait, for the root node, the maximum depth would be the max between left and right subtrees plus one.\n\nWait, let me think. For a node that's a leaf (both children are None), the depth would be 1. No, wait, sometimes people define the depth of a leaf as 0. Oh wait, in the sample input, the first case is:\n\nmax_depth_bst(TreeNode(2, TreeNode(1), TreeNode(3))) returns 2. So the depth of root is 1, and each of its children is depth 2? Or perhaps each level counts as depth. Let me check: the root is level 1, children level 2.\n\nSo, for that case, the tree is root with two children, so height is 2.\n\nAnother sample: root is 2, left child is 1 which has a left child 0, right is None. So tree looks like:\n\n2\n|\\\n1 None\n| \n0\n\nThis is a chain, so the depth is 3. So the function returns 3, which matches the sample.\n\nSo, the recursion should work.\n\nSo the approach is to recursively compute the depth of the left and right subtrees and take the maximum, then add 1.\n\nBase case: if the node is None, the depth is 0.\n\nWait, but when node is null, should it return 0 or maybe -1 or not affect the max? Let me think. Suppose a node has no left child, then the depth of the left subtree is 0, and the depth from the left is 0, so the max would be whatever the right subtree is plus one.\n\nWait, right, for example, if the root has only a right child. Then the left depth is 0, right is (depth of right child's subtrees) plus one. So the root's depth is that value. So base case when node is null returns 0.\n\nSo the steps:\n\n1. If root is null, return 0.\n\n2. Else, compute left depth as max_depth_bst(root.left).\n\n3. Compute right depth as max_depth_bst(root.right).\n\n4. Return 1 + max(left_depth, right_depth).\n\nWait, let me see.\n\nIn the first sample: root is 2, left is 1, right is 3.\n\nLeft depth: compute for 1. It has no children, left and right are None.\n\nSo left depth returns 0.\n\nWait, wait no. Wait, the left node (1) has left child as null and right child as null. So the recursion would: for root=1, compute left depth which is 0, right depth which is 0, return 1.\n\nWait, so for the root node 2's left child, the depth is 1, not 0. So for the sample where root has two children, each has depth 1, so the max is 1, then add 1, so root's depth is 2, which matches.\n\nWait, maybe I'm mixing up definitions. So the function returns the maximum depth of the BST, which is the depth of the deepest node. The depth is the number of edges on the path from the root to the node, but sometimes people count the levels. Like the root is depth 1, children depth 2, etc.\n\nWait in the problem statement, the first sample returns 2. The tree is root with two children, so the maximum depth is 2.\n\nSo the root is at depth 1, each child is at depth 2.\n\nSo the function calculates the number of levels, not edges.\n\nSo when a node is null, the depth is 0. So for a leaf node (its children are null), the function would return 1: because left and right return 0, and 1 + max(0,0) =1.\n\nThus, the function correctly returns the depth as the number of levels.\n\nSo now, coding this.\n\nThe function is defined as:\n\ndef max_depth_bst(root: TreeNode) -> int:\n\nAs per the examples, when the root is None, the depth should be 0? Or does it even happen? Because a root is passed, so if root is null, maybe the tree is empty, and depth is 0.\n\nWait, according to the problem's second sample, the tree has a structure leading to depth 3. So in code:\n\nImplement the recursive approach.\n\nPotential code:\n\nif root is None:\n    return 0\nelse:\n    left_depth = max_depth_bst(root.left)\n    right_depth = max_depth_bst(root.right)\n    return 1 + max(left_depth, right_depth)\n\nThat's should be straightforward.\n\nBut wait, should I handle cases where the tree is not a BST? But the function isn't supposed to validate it. The problem says it's a BST, so the structure is correct, but that doesn't affect the depth.\n\nSo the code should be as above.\n\nTesting sample one:\n\nroot is the node 2.\n\nLeft is 1, right is 3.\n\nLeft of 1 is None: so left_depth of 2 is the function called on 1.\n\nFor 1: its left is None, returns 0; right is None, returns 0. So 1's max is 0, returns 1.\n\nSimilarly, for 3: same as 1. Returns 1.\n\nSo root's left_depth is 1, right_depth is 1. Max is 1, plus 1 is 2. Correct.\n\nSample two:\n\nRoot is 2.\n\nLeft is 1.\n\nLeft's left is 0, which has no children.\n\nSo, call for 0: returns 1 (because no children, so 1).\n\n1's left is 0, which returns 1: left_depth is 1. 1's right is None, right_depth 0. So for node 1, returns 1+1=2.\n\nThen, root 2's left_depth is 2, right is None returns 0. So root returns 1 + 2=3. Correct.\n\nSo I think the code is correct.\n\nWait, another test case: a single node should return 1.\n\nmax_depth_bst(TreeNode(5))?\n\nYes, returns 1.\n\nIf root is null, the function returns 0. Which makes sense.\n\nThus, the code should handle all cases.\n</think>\n\nTo solve this problem, we need to determine the maximum depth of a binary search tree (BST). The maximum depth is defined as the number of levels in the tree, where the root node is at level 1, its children are at level 2, and so on.\n\n### Approach\nThe approach to solve this problem involves using a recursive method to traverse the tree and calculate the depth at each level. Here\u2019s a step-by-step breakdown of the approach:\n\n1. **Base Case**: If the current node is `None`, the depth at this level is 0.\n2. **Recursive Case**: For each node, compute the depth of its left subtree and right subtree recursively.\n3. **Compute Maximum Depth**: The depth of the current node is 1 (for the node itself) plus the maximum depth of its left and right subtrees.\n\nThis approach ensures that we traverse each node exactly once, making the time complexity O(n), where n is the number of nodes in the tree. The space complexity, on the other hand, is O(h), where h is the height of the tree, due to the recursion stack.\n\n### Solution Code\n```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    if root is None:\n        return 0\n    left_depth = max_depth_bst(root.left)\n    right_depth = max_depth_bst(root.right)\n    return 1 + max(left_depth, right_depth)\n```\n\n### Explanation\nThe provided solution recursively calculates the maximum depth of the BST. Here's how it works:\n\n1. **Base Case Handling**: If the current node is `None`, the function returns 0, indicating no depth at this level.\n2. **Recursive Depth Calculation**: For each non-null node, the function calculates the depth of the left subtree (`left_depth`) and the right subtree (`right_depth`).\n3. **Return Maximum Depth**: The function returns 1 (accounting for the current node) plus the maximum of `left_depth` and `right_depth`. This effectively calculates the depth of the tree from the root node down to the deepest leaf node.\n\nThis approach efficiently computes the maximum depth by leveraging the properties of recursive tree traversal, ensuring that each node is processed exactly once.",
  "r1_solution": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    if root is None:\n        return 0\n    left_depth = max_depth_bst(root.left)\n    right_depth = max_depth_bst(root.right)\n    return 1 + max(left_depth, right_depth)",
  "metadata": {
    "prompt_id": "00000002",
    "row_id": 2,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to find the maximum depth of a binary search tree (BST)."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}