{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000002_C",
  "question": "def max_depth_bst(root: TreeNode) -> int:\n    \"\"\"Returns the maximum depth of a binary search tree.\n    >>> max_depth_bst(TreeNode(2, TreeNode(1), TreeNode(3)))\n    2\n    >>> max_depth_bst(TreeNode(2, TreeNode(1, TreeNode(0)), None))\n    3\n    \"\"\"",
  "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"\n    Returns the maximum depth of a binary search tree.\n    \"\"\"\n    if root is None:\n        return 0\n    return 1 + max(max_depth_bst(root.left), max_depth_bst(root.right))",
  "test_code": "from solution import max_depth_bst, TreeNode\n\ndef test_max_depth_bst_empty_tree():\n    assert max_depth_bst(None) == 0\n\ndef test_max_depth_bst_single_node():\n    root = TreeNode(1)\n    assert max_depth_bst(root) == 1\n\ndef test_max_depth_bst_balanced_tree():\n    root = TreeNode(2, TreeNode(1), TreeNode(3))\n    assert max_depth_bst(root) == 2\n\ndef test_max_depth_bst_unbalanced_tree_left():\n    root = TreeNode(2, TreeNode(1, TreeNode(0), None), TreeNode(3))\n    assert max_depth_bst(root) == 3\n\ndef test_max_depth_bst_unbalanced_tree_right():\n    root = TreeNode(2, TreeNode(1), TreeNode(3, None, TreeNode(4)))\n    assert max_depth_bst(root) == 3",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function called max_depth_bst that takes a TreeNode as the root of a binary search tree and returns the maximum depth of this tree. Hmm, wait, actually, I should remember that the function needs to work correctly for a BST, so maybe the way I check left and right subtrees is important.\n\nFirst, I remember that the depth of a root node is 1. So for each node, its depth is 1 plus the maximum depth of its children. Wait, no, wait. Or maybe it's the maximum of the left and right subtree depths plus one. Oh right, that's the standard approach for tree depth calculation.\n\nBut wait, is there any difference because it's a BST? Oh right, a BST has properties about the left and right children. For any node, all nodes in the left subtree have values less than the node's value, and the right subtree's nodes have values greater than the node's. Wait, that's necessary for a BST. So does that affect how I calculate the depth? Hmm, perhaps not directly, because the depth is a measure of the structure, not the actual data in the nodes. But maybe the user wants to ensure that it's a BST, but the problem statement says the function is for a BST, so I don't need to validate the BST structure. So I can proceed as normal.\n\nSo the approach is to recursively compute for each node, the maximum depth of the left subtree and the right subtree, add 1 for the current node, and return the maximum of the two plus one.\n\nWait, wait: base cases. If the root is None, the depth is 0. Because an empty tree has depth 0. Else, it's 1 plus the maximum of the left and right depths.\n\nSo the function can be written recursively. Let's think about the code structure.\n\nDefine a helper function maybe that takes a node and returns its maximum depth. Because if the current node (root) is None, return 0. Else, return 1 + max(left_depth, right_depth).\n\nSo in the helper, for left_depth, call it on node.left, similarly for right.\n\nWait, wait the function parameter is given as 'root: TreeNode', so it's the root of the entire tree. So the root can be None. If the function is called as max_depth_bst(None), it should return 0.\n\nLet's test with the first example given.\n\nFirst example: root is 2, which has a left child 1 and right child 3. So the tree structure is:\n\n      2\n    /   \\\n   1     3\nSo the depth is 2.\n\nIn recursive terms, the root is not None, left has depth 1, right has depth 1. So max is 1, so 1+1=2.\n\nSecond example: root is 2, left child is 1, which has a left child 0, right is None. So structure is:\n\n      2\n    /\n   1\n  /\n 0\nSo depth is 3. Root (2) adds 1, its left subtree (1) adds 1, left subtree of 1 is 0, which adds another, so 1+2.\n\nSo yes, the approach would work.\n\nSo coding:\n\nWe can define a helper function _max_depth inside the main function, but maybe not necessary. Alternatively, just write the function recursively.\n\nWait, the function signature is max_depth_bst(root: TreeNode) -> int: ... So the code inside would first handle the case where root is None by returning 0.\n\nElse, compute left_depth as max_depth_bst(root.left), right_depth as max_depth_bst(root.right), return 1 + max(left_depth, right_depth).\n\nWait, but wait\u2014that would only be the case if it's a BST, but no, as I thought earlier, it's a general tree depth calculation. But since the root is a BST, perhaps no issue.\n\nWait, but perhaps the initial usage requires the BST property for validity. No, because it's the same structure; regardless of the BST's node values, the depth is determined by the structure. So the function will correctly calculate the depth.\n\nTesting the examples:\n\nFirst example:\n\nmax_depth_bst(TreeNode(2, TreeNode(1), TreeNode(3))) should return 2.\n\nLet's see:\n\nroot is 2. Not None.\n\nleft child is 1: max_depth_bst(1) is ... Not None.\n\n1's left is None, so left_depth is 0.\n\n1's right child is None, right_depth 0.\n\nSo left subtree of 2 has depth 1.\n\nSimilarly, right of 2 is 3, which has no children, so right depth is 1.\n\nSo overall depth is 1 + max(1,1 )= 2.\n\nWhich is correct.\n\nSecond example: root is 2, left is 1, whose left is 0, else None.\n\nSo root.left is 1. That's not None.\n\n1's left is 0, not None. Its left and right are None.\n\nSo for node 0, it's 1 (left_depth 0, right 0, so max is 0 -> overall 1).\n\nSo then for node 1, left depth is 1, right depth 0 -> 1 + 1 = 2.\n\nThen back to root 2: left depth is 2, right_depth is 0 (since right is None, returns 0). So 1 + max(2,0) = 3.\n\nSo code seems correct.\n\nAnother test case: root is None, function returns 0.\n\nAnother test: root has only right child. For example, 1 \u2192 2 \u2192 3. Then depth is 3.\n\nSo for code, when called for 3, its children are None, returns 1. Then 2 returns max(0,1) +1=2. Then 1 returns 3.\n\nSo code is correct.\n\nI think the initial approach is correct. So now the code:\n\ndef max_depth_bst(root: TreeNode) -> int:\n    if root is None:\n        return 0\n    left_depth = max_depth_bst(root.left)\n    right_depth = max_depth_bst(root.right)\n    return 1 + max(left_depth, right_depth)\n\nWait, but what about if the BST is valid but the values are not? Like, 1's right child is 3, 3's left is 2. So structurally, the depth is 3, but it's not a correct BST. But the problem says it's a BST, so function can assume it's a BST. Or does the function have to check. The question is about BST, but as the function is a BST, so the depth is calculated normally.\n\nWait, the function name is max_depth_bst, which is for a binary search tree, but the function doesn't check whether the tree is a BST. So perhaps the user is supposed to make sure the tree is a BST, and the function just calculates the depth.\n\nTherefore, the code is correct as above.\n\nThus, the code given is:\n\ndef max_depth_bst(root: TreeNode) -> int:\n    if root is None:\n        return 0\n    return 1 + max(max_depth_bst(root.left), max_depth_bst(root.right))\n\nWait, but in the if condition, the code might return 0. However, for root being None, the depth is 0. Otherwise, it's 1 plus the max of left and right.\n\nYes.\n\nSo the code seems correct.\n</think>\n\nTo solve this problem, we need to determine the maximum depth of a binary search tree (BST). The depth of a tree is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n### Approach\nThe approach to solve this problem involves recursively calculating the depth of the left and right subtrees of each node. The maximum depth of the tree rooted at a node is 1 (for the node itself) plus the maximum depth among its left and right subtrees. \n\nHere's a step-by-step breakdown of the approach:\n\n1. **Base Case**: If the current node is `None`, the depth is 0. This serves as the base case for our recursion.\n2. **Recursive Case**: For each node, calculate the depth of its left subtree and its right subtree. The maximum depth of the subtree rooted at the current node is 1 plus the maximum of the depths of its left and right subtrees.\n\nBy recursively applying this approach, we can determine the maximum depth of the entire tree.\n\n### Solution Code\n```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    if root is None:\n        return 0\n    return 1 + max(max_depth_bst(root.left), max_depth_bst(root.right))\n```\n\n### Explanation\n1. **Base Case Handling**: The function first checks if the root is `None`, in which case it returns a depth of 0.\n2. **Recursive Depth Calculation**: For a non-null node, the function recursively calculates the depth of the left subtree and the right subtree. It then returns 1 plus the maximum of these two depths, effectively counting the current node and considering the deeper of the two subtrees.\n\nThis approach efficiently computes the maximum depth using the properties of recursion and ensures that each subtree is evaluated correctly. The time complexity of this solution is O(n), where n is the number of nodes in the tree, as each node is visited exactly once. The space complexity is O(h), where h is the height of the tree, due to the recursive call stack.",
  "r1_solution": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    if root is None:\n        return 0\n    return 1 + max(max_depth_bst(root.left), max_depth_bst(root.right))",
  "metadata": {
    "prompt_id": "00000002",
    "row_id": 2,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to find the maximum depth of a binary search tree (BST)."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results2.jsonl"
}