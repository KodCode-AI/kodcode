{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000002_C",
  "question": "def max_depth_bst(root: TreeNode) -> int:\n    \"\"\"Returns the maximum depth of a binary search tree.\n    >>> max_depth_bst(TreeNode(2, TreeNode(1), TreeNode(3)))\n    2\n    >>> max_depth_bst(TreeNode(2, TreeNode(1, TreeNode(0)), None))\n    3\n    \"\"\"",
  "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"\n    Returns the maximum depth of a binary search tree.\n    \"\"\"\n    if root is None:\n        return 0\n    return 1 + max(max_depth_bst(root.left), max_depth_bst(root.right))",
  "test_code": "from solution import max_depth_bst, TreeNode\n\ndef test_max_depth_bst_empty_tree():\n    assert max_depth_bst(None) == 0\n\ndef test_max_depth_bst_single_node():\n    root = TreeNode(1)\n    assert max_depth_bst(root) == 1\n\ndef test_max_depth_bst_balanced_tree():\n    root = TreeNode(2, TreeNode(1), TreeNode(3))\n    assert max_depth_bst(root) == 2\n\ndef test_max_depth_bst_unbalanced_tree_left():\n    root = TreeNode(2, TreeNode(1, TreeNode(0), None), TreeNode(3))\n    assert max_depth_bst(root) == 3\n\ndef test_max_depth_bst_unbalanced_tree_right():\n    root = TreeNode(2, TreeNode(1), TreeNode(3, None, TreeNode(4)))\n    assert max_depth_bst(root) == 3",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function called max_depth_bst that takes a root TreeNode and returns the maximum depth of the binary search tree. Hmm, wait, is it a binary search tree or just a binary tree? Oh right, the function is for a binary search tree (BST), so each node has a left child less than it and a right child greater than it, but I don't think that affects the maximum depth calculation directly. \n\nSo maximum depth of a tree is the number of nodes along the longest path from the root to the farthest leaf. For each node, the maximum depth is 1 (for the node itself) plus the maximum depth of its left and right subtrees. Wait, no, the way depth is calculated: actually, for a leaf node, the depth is 1. So for the function, the standard approach is to recursively calculate the depth.\n\nWait, but sometimes people implement it with height where the height of a leaf is 0. But in the examples given, like when the tree is just a single node, the depth is 1, I think. Let's check the examples.\n\nIn the first sample input: root is 2, with left child 1 and right child 3. So it's depth is 2. Wait, no, the root has two children but both are leaf nodes. So the depth is 2? Wait the function should return 2 in the first example. So where root's depth is 1, the children add to it. So the function considers the root as depth 1, each child adds 1 if they're present.\n\nSo the standard approach is to write a recursive function that for each node, returns 1 plus the max of the left child's depth and right child's depth. That makes sense.\n\nI remember that the base case is when the node is None, right? Because if a node doesn't have a left child, you treat that subtree's depth as 0. But wait, when a node has no children, its depth is 1.\n\nWait no. Wait the function max_depth_bst is supposed to find the depth of the tree, which is the longest path from the root. So for a single node, the depth is 1. If it has two children, then each child adds its own depth.\n\nSo I'll model the function recursively:\n\nFor the current node:\n\n- if it's None, return 0 (since it doesn't contribute to the depth)\n- else, for left child, compute max_depth, same for right child\n- the current depth is 1 + max(left_depth, right_depth)\n\nWait wait, let me test this against the first example:\n\nTree structure:\n    2\n   / \\\n  1   3\n\nThe root is 2. For left child 1, which is a leaf: depth is 1 + max(0,0) = 1. Then the right child 3, also a leaf, same. So the max of left and right is 1. So the root's depth is 1 + 1 = 2. Which matches the sample.\n\nSecond example:\n    2\n   /\n  1\n /\n0\n\nSo root is 2, depth 1 plus the maximum of left and right. The right is None, so 0. The left is 1, which has a left child 0 and no right. So for 1: 1 + max(0 (since its left is 0? Wait no, wait:\n\nFor 1, the left child is 0. Let's compute the depth:\n\n0 is a leaf (no children), so its depth is 1. So the depth for 1 is 1 + max(1, 0) = 2. So back to root's left subtree, which is 1+2 = 2? Wait no, wait 1's depth is 2, so the root's left is 2. Since right is None, so the root returns 1 + 2 = 3. Which matches the second sample.\n\nSo the logic seems correct.\n\nSo the algorithm is:\n\nif node is None: return 0\nelse:\n    left_depth = max_depth_bst(node.left)\n    right_depth = max_depth_bst(node.right)\n    return 1 + max(left_depth, right_depth)\n\nSo now, how to implement this in Python. Assuming that TreeNode is a class with left and right attributes.\n\nWait, but in the sample code, the TreeNode is constructed with left and right children. So in Python, I can access root.left and root.right.\n\nSo the function will look like:\n\ndef max_depth_bst(root: TreeNode) -> int:\n    if not root:\n        return 0\n    left_depth = max_depth_bst(root.left)\n    right_depth = max_depth_bst(root.right)\n    return 1 + max(left_depth, right_depth)\n\nYes, that should suffice.\n\nBut wait, I should test case when root is None. For example, if the root is None, return 0. But the function is supposed to return the max depth, and if root is None, the tree doesn't exist, so the max depth is 0, which is correct.\n\nSo I think the function is correct.\n</think>\n\nTo solve this problem, we need to determine the maximum depth of a binary search tree (BST). The depth of a tree is defined as the number of nodes along the longest path from the root to the farthest leaf node. \n\n### Approach\nThe approach to solve this problem involves using recursion to traverse the tree and calculate the depth of each subtree. Here's a detailed breakdown of the approach:\n\n1. **Base Case:** If the current node is `None`, the depth of that subtree is 0. This serves as the base case for our recursion.\n2. **Recursive Case:** For each node, we recursively calculate the depth of its left and right subtrees.\n3. **Calculate Depth:** The depth of the current node is 1 (for the node itself) plus the maximum depth of its left and right subtrees. This is because the depth of a node is determined by the longest path from that node to any leaf node in its subtree.\n\nBy following this approach, we ensure that we explore all paths from the root to the leaves, and the longest path (in terms of the number of nodes) determines the maximum depth of the tree.\n\n### Solution Code\n```python\nclass TreeNode:\n    def __init__(self, x, left=None, right=None):\n        self.val = x\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"Returns the maximum depth of a binary search tree.\"\"\"\n    if not root:\n        return 0\n    left_depth = max_depth_bst(root.left)\n    right_depth = max_depth_bst(root.right)\n    return 1 + max(left_depth, right_depth)\n```\n\n### Explanation\n- **TreeNode Class:** This class is used to define the structure of a node in the BST. Each node has a value, a left child, and a right child.\n- **max_depth_bst Function:** This function calculates the maximum depth of the BST rooted at the given node.\n  - If the root is `None`, the function returns 0 as there are no nodes to consider.\n  - For each node, the function recursively calculates the maximum depth of the left and right subtrees.\n  - The depth of the current node is 1 plus the maximum depth of its left and right subtrees.\n  \nThis approach efficiently calculates the maximum depth using recursion, ensuring all nodes are visited and the longest path is determined.",
  "r1_solution": "class TreeNode:\n    def __init__(self, x, left=None, right=None):\n        self.val = x\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"Returns the maximum depth of a binary search tree.\"\"\"\n    if not root:\n        return 0\n    left_depth = max_depth_bst(root.left)\n    right_depth = max_depth_bst(root.right)\n    return 1 + max(left_depth, right_depth)",
  "metadata": {
    "prompt_id": "00000002",
    "row_id": 2,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to find the maximum depth of a binary search tree (BST)."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}