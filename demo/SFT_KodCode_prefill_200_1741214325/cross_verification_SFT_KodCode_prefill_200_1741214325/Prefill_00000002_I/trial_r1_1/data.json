{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000002_I",
  "question": "Write a python function to find the maximum depth of a binary search tree (BST).",
  "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"\n    Returns the maximum depth of a binary search tree.\n    \"\"\"\n    if root is None:\n        return 0\n    return 1 + max(max_depth_bst(root.left), max_depth_bst(root.right))",
  "test_code": "from solution import max_depth_bst, TreeNode\n\ndef test_max_depth_bst_empty_tree():\n    assert max_depth_bst(None) == 0\n\ndef test_max_depth_bst_single_node():\n    root = TreeNode(1)\n    assert max_depth_bst(root) == 1\n\ndef test_max_depth_bst_balanced_tree():\n    root = TreeNode(2, TreeNode(1), TreeNode(3))\n    assert max_depth_bst(root) == 2\n\ndef test_max_depth_bst_unbalanced_tree_left():\n    root = TreeNode(2, TreeNode(1, TreeNode(0), None), TreeNode(3))\n    assert max_depth_bst(root) == 3\n\ndef test_max_depth_bst_unbalanced_tree_right():\n    root = TreeNode(2, TreeNode(1), TreeNode(3, None, TreeNode(4)))\n    assert max_depth_bst(root) == 3",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nAlright, I need to write a Python function to find the maximum depth of a binary search tree (BST). First, I should recall what the maximum depth means. It's the length of the longest path from the root to a leaf node. So, for each node, I need to consider the depth of its left and right subtrees and take the larger one, then add one for the current node.\n\nWait, but since it's a BST, the structure follows the properties that all left descendants are less than the node and all right descendants are greater. But for calculating depth, the BST property might not directly affect the algorithm beyond the tree structure.\n\nI'll need to represent the BST. Typically, I can define a Node class with left and right children and a value. Then, the function will take the root of the BST as input.\n\nIf the root is null, the depth is 0. That's the base case for my recursion. Otherwise, I'll recursively calculate the depth of the left subtree and the right subtree, then return the maximum of those two plus one.\n\nWait, no. Actually, if a node doesn't exist, its depth contribution should be zero. So for a leaf node, both left and right children are None, so their depth would be 0, and adding 1 gives the correct depth.\n\nSo the function could be something like:\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = max_depth(root.left)\n        right_depth = max_depth(root.right)\n        return max(left_depth, right_depth) + 1\n\nYes, that makes sense. Let's test it with some examples.\n\nFor an empty tree (root is None), the depth is 0.\n\nFor a single node, both children are None, so left_depth and right_depth are 0, returning 1, which is correct.\n\nIf the tree is unbalanced to the left: root has a left child, which has its own left child, etc. The function should traverse each left path correctly.\n\nAnother example: a balanced tree with three levels. Root has left and right children, each of those has two children. The maximum depth should be 3. Let's see:\n\nmax_depth(root) calls left_depth (max_depth of left child), which is 2, same for right_depth. So returns 2 + 1 = 3.\n\nThat seems correct.\n\nWhat about a tree where one side is deeper? Like root -> left -> left -> left. Left subtree depth is 3 (since each level adds 1), right subtree is 0. So the function would return 3 + 1? Wait, no.\n\nWait, let me count:\n\n- Root has left child, no right.\n\n- The left child has a left child, no right.\n\n- That left child has another left child, which is a leaf.\n\nSo the structure is four nodes in a straight line on the left.\n\nWait, the root is level 1. Its left child is level 2, next left is level 3, next left is level 4. So the depth is 4.\n\nSo for the root, the left depth would be max_depth called on its left child (node B). Node B's left_depth is node C, which has left_depth of node D, which returns 1 when node D is a leaf. So:\n\nnode D: left and right are None \u2192 returns 0 + 1 = 1.\n\nnode C: left is node D, so left depth 1, right depth 0 \u2192 returns 1 +1 = 2.\n\nnode B: left depth 2, right 0 \u2192 2 + 1 =3.\n\nRoot: left depth 3, right 0 \u2192 3 +1 =4.\n\nYes, so the function returns 4, correct.\n\nTherefore, the function should work.\n</think>\n\nTo find the maximum depth of a binary search tree (BST), we need to determine the length of the longest path from the root to any leaf node. This can be efficiently done using a recursive approach where we calculate the depth of the left and right subtrees for each node and return the maximum of these depths plus one (for the current node).\n\n### Approach\nThe approach involves using recursion to explore each node of the tree:\n1. **Base Case**: If the current node is `None`, the depth at this point is 0.\n2. **Recursive Case**: For each node, recursively find the maximum depth of its left subtree and its right subtree. The depth of the current node is then 1 plus the maximum depth of its subtrees.\n\n### Solution Code\n```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = max_depth(root.left)\n        right_depth = max_depth(root.right)\n        return max(left_depth, right_depth) + 1\n```\n\n### Explanation\n- **Node Class**: This defines the structure of a node in the BST, containing a value and pointers to left and right children.\n- **max_depth Function**: \n  - If the root (current node) is `None`, it returns 0 since there are no nodes to traverse.\n  - For each node, it calculates the depth of the left and right subtrees recursively.\n  - It returns the maximum of the left and right depths plus one, accounting for the current node.\n\nThis approach ensures that we correctly compute the maximum depth by exploring all possible paths in the tree, leveraging recursion to break down the problem into smaller subproblems.",
  "r1_solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = max_depth(root.left)\n        right_depth = max_depth(root.right)\n        return max(left_depth, right_depth) + 1",
  "metadata": {
    "prompt_id": "00000002",
    "row_id": 2,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}