{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000002_I",
  "question": "Write a python function to find the maximum depth of a binary search tree (BST).",
  "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"\n    Returns the maximum depth of a binary search tree.\n    \"\"\"\n    if root is None:\n        return 0\n    return 1 + max(max_depth_bst(root.left), max_depth_bst(root.right))",
  "test_code": "from solution import max_depth_bst, TreeNode\n\ndef test_max_depth_bst_empty_tree():\n    assert max_depth_bst(None) == 0\n\ndef test_max_depth_bst_single_node():\n    root = TreeNode(1)\n    assert max_depth_bst(root) == 1\n\ndef test_max_depth_bst_balanced_tree():\n    root = TreeNode(2, TreeNode(1), TreeNode(3))\n    assert max_depth_bst(root) == 2\n\ndef test_max_depth_bst_unbalanced_tree_left():\n    root = TreeNode(2, TreeNode(1, TreeNode(0), None), TreeNode(3))\n    assert max_depth_bst(root) == 3\n\ndef test_max_depth_bst_unbalanced_tree_right():\n    root = TreeNode(2, TreeNode(1), TreeNode(3, None, TreeNode(4)))\n    assert max_depth_bst(root) == 3",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function to find the maximum depth of a binary search tree, or BST. Hmm, let me think about what the maximum depth actually means. Oh right, it's the longest path from the root to a leaf node. So, for each node, I should consider the maximum depth of its left and right subtrees and add one for the current node.\n\nWait, but the BST part\u2014does that affect the way I calculate the depth? Oh, right, the structure of BST affects the shape of the tree, but for calculating depth, it's the same as any binary tree. So the maximum depth isn't about whether the BST properties are satisfied, just the structure.\n\nSo the function needs to traverse the tree. I can either do this iteratively with a stack or recursively, which seems simpler. Maybe I'll go with recursion because it's easier to implement.\n\nAlright, let's outline the steps. The function will take the root of the BST as input. If the root is None, the depth is 0. Otherwise, for each node, I calculate the depth of the left child and the depth of the right child. Then the maximum depth of the current node is 1 plus the maximum of the left and right depths.\n\nWait, does that cover all cases? What about a single node\u2014should return 1 maybe? Let's see. For a single node, the left and right are None, which return 0, so 1+0=1. That makes sense.\n\nSo in code, I'll define a helper function or just calculate it directly. Maybe create a function called max_depth that takes a node as an argument.\n\nLet's structure it:\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = max_depth(root.left)\n        right_depth = max_depth(root.right)\n        return max(left_depth, right_depth) +1\n\nYes, that seems right. I need to make sure this works with a BST structure, like the Node class having left and right attributes.\n\nWait, what if the tree is unbalanced? Let's say all nodes are to the left. The function would correctly compute the depth because it's going all the way down each time.\n\nTesting with some examples. For example, a root with only a left child, which has a left child, etc. The function should return the number of nodes along that path.\n\nAnother test case: a balanced tree. For instance, a root with left and right children, each with their own two children. The depth should be 3.\n\nLet me think of edge cases. If the tree is empty\u2014root is None. The function returns 0, which might be correct. But sometimes depth is considered 0 for an empty tree, yes.\n\nAlternatively, some people consider the number of edges as the depth, so a single node has depth 0. Hmm, the question says \"maximum depth\"\u2014which is a bit ambiguous. But I think in most definitions, the maximum depth is the number of edges on the longest downt path, which would mean a single node has a depth of 0. But my function returns 1 for a single node, which might not align with that.\n\nWait, let me double-check. Oh, maybe I confused depth and height. Actually, sometimes height is the number of edges, so depth might be the number of nodes. Or vice versa.\n\nWait, let's clarify. In the context of this problem, what's required?\n\nWait, the problem says \"maximum depth of BST\". I think in this case, the function should return the number of nodes along the longest path from the root to a leaf. So a single-node tree has a depth of 1, and the function is correct as is.\n\nBut maybe the function should return 0 if the tree is empty. So, perhaps when root is None, return 0. Otherwise, proceed as before.\n\nSo the function as is should be correct.\n\nNow, for the BST, do I need to validate whether it's a BST or not? No, because the function is only calculating the depth, regardless of the BST properties. The function just treats the tree as a binary tree.\n\nSo, I'll proceed with writing the function as described.\n</think>\n\nTo find the maximum depth of a binary search tree (BST), we can use a recursive approach that calculates the depth by considering each node and its subtrees. The maximum depth is determined by the longest path from the root to a leaf node.\n\n### Approach\n\n1. **Define the Problem**: The maximum depth of a binary search tree is the number of nodes along the longest path from the root to a leaf node.\n2. **Recursive Solution**: For each node, we recursively find the depth of its left and right subtrees. The depth of the current node is 1 (for itself) plus the maximum depth of its subtrees.\n3. **Base Case**: If a node is `None`, the depth is 0. This handles the base case where the tree is empty or we've reached a leaf node's child.\n\n### Solution Code\n\n```python\nclass Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = max_depth(root.left)\n        right_depth = max_depth(root.right)\n        return max(left_depth, right_depth) + 1\n```\n\n### Explanation\n\n- **Node Class**: Represents each node in the BST, with a value and pointers to left and right children.\n- **max_depth Function**: \n  - Checks if the current node is `None`, returning 0 if it is (base case).\n  - Recursively calculates the depth of the left and right subtrees.\n  - Returns the maximum of these two depths plus one (for the current node), ensuring the longest path is always considered.\n\nThis approach efficiently computes the maximum depth using recursion, ensuring all nodes are visited and the structure of the BST is respected.",
  "r1_solution": "class Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = max_depth(root.left)\n        right_depth = max_depth(root.right)\n        return max(left_depth, right_depth) + 1",
  "metadata": {
    "prompt_id": "00000002",
    "row_id": 2,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}