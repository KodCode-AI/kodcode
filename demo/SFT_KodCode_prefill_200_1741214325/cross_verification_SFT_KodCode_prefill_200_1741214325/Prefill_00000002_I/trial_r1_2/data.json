{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000002_I",
  "question": "Write a python function to find the maximum depth of a binary search tree (BST).",
  "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"\n    Returns the maximum depth of a binary search tree.\n    \"\"\"\n    if root is None:\n        return 0\n    return 1 + max(max_depth_bst(root.left), max_depth_bst(root.right))",
  "test_code": "from solution import max_depth_bst, TreeNode\n\ndef test_max_depth_bst_empty_tree():\n    assert max_depth_bst(None) == 0\n\ndef test_max_depth_bst_single_node():\n    root = TreeNode(1)\n    assert max_depth_bst(root) == 1\n\ndef test_max_depth_bst_balanced_tree():\n    root = TreeNode(2, TreeNode(1), TreeNode(3))\n    assert max_depth_bst(root) == 2\n\ndef test_max_depth_bst_unbalanced_tree_left():\n    root = TreeNode(2, TreeNode(1, TreeNode(0), None), TreeNode(3))\n    assert max_depth_bst(root) == 3\n\ndef test_max_depth_bst_unbalanced_tree_right():\n    root = TreeNode(2, TreeNode(1), TreeNode(3, None, TreeNode(4)))\n    assert max_depth_bst(root) == 3",
  "test_info": null,
  "gpt_pass_sequence": [
    1,
    0,
    0
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a Python function to find the maximum depth of a binary search tree (BST). Let me think about how to approach this.\n\nFirst, I remember that the maximum depth of a tree is the number of nodes along the longest path from the root to a leaf node. So, for a BST, which is a type of binary tree, each node has at most two children: left and right.\n\nWait, but how is the BST structure different from a regular binary tree? Oh right, in a BST, for every node, all the nodes in its left subtree have values less than the node's value, and all the nodes in the right subtree have values greater than the node's value. But for the purpose of calculating depth, the BST properties don't really affect the structure other than how the tree is constructed. So the calculation of depth is similar to a regular binary tree.\n\nSo, the function will take the root of the BST and return the maximum depth.\n\nLet me recall: the depth of the tree is the maximum depth of the root's left subtree and right subtree plus one for the root node itself. Because if I think recursively, the depth is 1 more than the maximum of the left and right subtree depths.\n\nBut wait, if the root is None, then the depth should be 0, right? Because there are no nodes, so the depth is 0.\n\nSo, I can structure this recursively. The base case is when the node is None, return 0. Else, return 1 + the maximum of the left child's depth and the right child's depth.\n\nHmm, but I'm trying to remember: in some definitions, the depth of a leaf node is 1, and the root's children are at depth 2. So, this approach would handle that correctly.\n\nLet's test this logic with a simple example. Suppose the tree is just a single node (root). Then, the left and right are None, so their depths are 0. The root's depth is 1 + max(0,0) = 1. That's correct.\n\nAnother example: root has a left child and a right child. The left child has its own left and right children. Then the depth should be 3.\n\nWait, let's see:\n\nRoot (depth: to be calculated)\nLeft child: depth 2 (because it has its own left and right)\nRight child: depth 1\n\nSo the maximum of left (2) and right (1) is 2, plus 1 is 3. So the function should return 3, which is correct.\n\nSo the recursive approach seems to work.\n\nNow, how to implement this in Python.\n\nFirst, I'll define a Node class. Wait, do I need that? Well, the user might pass nodes to the function. So, assuming that the tree is built with nodes that have 'left' and 'right' attributes. So I'll need to define a helper function or include it in the main function.\n\nWait, in Python, if the tree is already built, perhaps the root node is passed in. So in the function, I'll have a parameter root.\n\nThe function will be something like max_depth(root). And for each node, recursively compute the depth.\n\nSo the function could look like this:\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    else:\n        return 1 + max(max_depth(root.left), max_depth(root.right))\n\nWait, yes, but what if the root is not None but is a leaf node? Then both children are None, so max(0,0) is 0, returns 1.\n\nYes, that should be correct.\n\nWait another test case: an unbalanced tree.\n\nFor example, a right-skewed tree: root \u2192 right \u2192 right \u2192 right. The depth is 4.\n\nThe function would, for each node, return 1 + max(left_depth, right_depth). So, for the root, it's 1 + max(0, depth of right child (which is 3)). So 1 +3=4. Correct.\n\nSo this recursive approach should handle all cases.\n\nNow, writing the code.\n\nBut I also need to make sure that the initial call handles an empty tree correctly. So, if root is None, return 0.\n\nIn Python, the function can be written as above.\n\nWait, what about if a node has only one child, say left. Its depth would be 2.\n\nFor example, root has left child, which is a leaf. The max of left_depth (1) and right_depth (0) is 1, plus 1 gives 2.\n\nYes, correct.\n\nAnother case: root has only a right child, which is a leaf. Then depth is 2.\n\nSo seems correct.\n\nThus, the function should be:\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    return 1 + max(max_depth(root.left), max_depth(root.right))\n\nBut wait, is there a non-recursive approach? Like using a stack or queue for BFS? Well, yes, but for trees, recursion is often more straightforward for depth calculations, as it naturally traverses each branch to its end.\n\nAlternatively, an iterative approach could involve using a stack to keep track of nodes and their current depths. Each time you pop a node, you check if its depth is greater than the current maximum, then push its children with depth incremented by 1. That's another way, but perhaps more code.\n\nBut since recursion is simpler for this problem, probably better to use it unless stack depth is a problem for very deep trees.\n\nBut in practice, for a coding problem like this, the recursive approach is acceptable.\n\nThus, I think this function should work.\n</think>\n\nTo determine the maximum depth of a binary search tree (BST), we repeatedly calculate the depth of each subtree, starting from the root node and moving down to the leaves. The maximum depth is the largest value obtained from either the left or right subtree at each level.\n\n**Approach:**\n1. **Base Case:** If the current node is `None`, the depth is 0.\n2. **Recursive Case:** For each node, compute the depth of its left subtree and right subtree. The depth of the current node is 1 (for the node itself) plus the maximum depth of its two subtrees.\n\nThis approach efficiently traverses each path in the tree, ensuring that the longest path from root to leaf is found.\n\n**Solution Code:**\n\n```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    return 1 + max(max_depth(root.left), max_depth(root.right))\n```\n\n**Explanation:**\n- **Node Class:** Defines the structure of a tree node with a value and pointers to left and right children.\n- **max_depth Function:** Recursively calculates the depth of the BST. If the node is `None`, it returns 0. Otherwise, it computes the depth by adding 1 to the maximum depth of its left and right subtrees.\n\nThis solution efficiently computes the maximum depth using a straightforward recursive approach, ensuring clarity and correctness for any BST structure.",
  "r1_solution": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    return 1 + max(max_depth(root.left), max_depth(root.right))",
  "metadata": {
    "prompt_id": "00000002",
    "row_id": 2,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results2.jsonl"
}