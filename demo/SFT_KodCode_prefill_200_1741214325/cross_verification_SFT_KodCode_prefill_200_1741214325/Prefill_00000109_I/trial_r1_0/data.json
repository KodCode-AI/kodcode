{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000109_I",
  "question": "Write a python function to find the common elements between two lists, and return a new list containing these common elements.",
  "solution": "def find_common_elements(list1, list2):\n    \"\"\"\n    Returns a new list containing elements common to both input lists.\n    \"\"\"\n    set1 = set(list1)\n    set2 = set(list2)\n    common_elements = set1.intersection(set2)\n    return list(common_elements)",
  "test_code": "from solution import find_common_elements\n\ndef test_find_common_elements():\n    assert find_common_elements([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n\ndef test_find_common_elements_with_no_common():\n    assert find_common_elements([1, 2, 3], [4, 5, 6]) == []\n\ndef test_find_common_elements_with_duplicates():\n    assert find_common_elements([1, 2, 2, 3], [2, 2, 3, 4]) == [2, 3]\n\ndef test_find_common_elements_with_empty_lists():\n    assert find_common_elements([], [1, 2, 3]) == []\n    assert find_common_elements([1, 2, 3], []) == []",
  "test_info": [
    {
      "function_name": "find_common_elements",
      "parameter_list": "(list1, list2)",
      "function_declaration": "def find_common_elements(list1, list2):",
      "docstring": "Returns a new list containing elements common to both input lists."
    }
  ],
  "gpt_pass_sequence": [
    1,
    1
  ],
  "gpt_pass_trial_num": 2,
  "gpt_difficulty": "easy",
  "gpt_pass_percentage": 1.0,
  "r1_response": "<think>\nOkay, I need to write a Python function that finds the common elements between two lists. Hmm, the function should return a new list with these common elements. Let me think about how to approach this.\n\nFirst, I remember that in Python, there's a way to find common elements using sets. Sets have an intersection method which returns elements present in both sets. So if I convert both lists into sets, I can use the intersection method to get the common elements. But wait, sets don't maintain order, and if there are duplicates, the intersection might not handle them as I want. Maybe the user expects each common element to appear as many times as it appears in both lists, but I'm not sure. The problem doesn't specify, so maybe the simplest approach is to find elements that are present in both, regardless of count.\n\nAlternatively, if I want to preserve the order or handle duplicates, perhaps using a list comprehension would be better. Like, for each element in the first list, check if it's in the second list. But that might not be efficient for large lists because the 'in' operator has to scan the entire list each time. Oh, but for small lists, it's manageable.\n\nLet me outline the steps. The function will take two lists as arguments, say list1 and list2. I can create a new list that includes elements that are present in both. So, for each element in list1, if it is also in list2, add it to the result. But I should make sure that each element is added only once, right? Or should it include duplicates as long as they are present in both?\n\nWait, the problem says \"common elements.\" I think that typically, common elements are considered as unique elements present in both. So using a set approach would probably work, but that would eliminate duplicates. So for example, if list1 is [1, 2, 2, 3] and list2 is [2, 2, 4], then the common elements would be [2], or [2,2]?\n\nThe problem description doesn't specify whether to include duplicates. The example given in the answer shows a function that returns a list, but in the example, the output is [5, 7, 9], which are unique. So perhaps the intention is to include each common element once.\n\nBut wait, if the user passes lists with duplicates, maybe the result should include each occurrence. For example, the first list has two 2s and the second list has three 2s; the result would have two 2s. Or would it include the minimum number of occurrences? That's a good question. Since the problem isn't clear, perhaps the simplest solution is to return a list of unique common elements.\n\nAlternatively, another approach could be to iterate through both lists, count the occurrences, and find the minimum for each element, then include that many times. But that might be more complex.\n\nBut since the problem is to find common elements, perhaps the solution is to return elements that are present in both lists, but without duplicates, just each element once.\n\nSo, the function would convert both lists to sets and then find the intersection, then turn it back into a list.\n\nWait, but sets automatically remove duplicates. So if the original lists have duplicates, the intersection set will only contain each element once. So the order could be lost as well because sets are unordered. So for example, if list1 is [3,1,2] and list2 is [2,1,4], the function returns [1,2].\n\nBut in the example provided in the answer, the order is preserved. Wait, in the sample input, the output is [5,7,9], which is the same as the order in list1. Hmm, but in that case, using sets might not preserve the order. So if order matters, maybe another approach is needed.\n\nAlternatively, the function could iterate through one of the lists, check for existence in the other, and collect unique elements.\n\nWait, perhaps using a list comprehension with if element in the second list, but ensuring that each element is added only once. So, to avoid duplicates in the result, even if they appear multiple times in both lists.\n\nWait, but that's a bit tricky. Maybe using a set to track which elements have already been added.\n\nSo, the approach would be:\n\nInitialize an empty list for the result.\n\nInitialize an empty set to keep track of elements already added.\n\nIterate through each element in the first list:\n\n   if the element is not in the set, and it's present in the second list:\n\n       add it to the result.\n\n       add it to the set.\n\nThis way, the result will have unique elements that are common, and the order is preserved as per the first list.\n\nSo, putting it into code:\n\ndef common_elements(list1, list2):\n\n    seen = set()\n\n    result = []\n\n    for element in list1:\n\n        if element in list2 and element not in seen:\n\n            result.append(element)\n\n            seen.add(element)\n\n    return result\n\nWait, but checking if element is in list2 could be time-consuming if list2 is large because the 'in' operator has to scan the entire list. So for efficiency, perhaps converting list2 to a set first.\n\nYes, that's better.\n\nSo modified code:\n\ndef common_elements(list1, list2):\n\n    set2 = set(list2)\n\n    seen = set()\n\n    result = []\n\n    for element in list1:\n\n        if element in set2 and element not in seen:\n\n            result.append(element)\n\n            seen.add(element)\n\n    return result\n\nThis way, the 'element in set2' check is O(1), making the function more efficient.\n\nLet me test this function with the sample inputs.\n\nSample Input 1:\n\nlist1 = [1, 2, 5, 7, 9, 2, 3, 4]\n\nlist2 = [2, 4, 5, 6, 7, 8, 9]\n\nThe common elements are 2,5,7,9. However, since 2 is in list1 twice, but in set2 once, the function will add 2 only once. The function returns [2,5,7,9].\n\nBut wait, in the sample input in the answer given earlier, the output was [5,7,9,2], since the order is preserved based on list1. Wait, in the example, the function returns the elements in the order they appear in list1.\n\nBut in our code, the function returns [2,5,7,9] because 2 comes first in list1. Wait, no: in the sample input given in the initial example, list1 is [1,2,5,7,9,2,3,4], so when the function processes element 2 first, adds it, and then 5,7,9 come later in their order.\n\nSo yes, the function returns [2,5,7,9], which is the correct order.\n\nWait, but the sample output the user had was [5,7,9]. No, in their initial example, the output was [5,7,9,2], but perhaps they didn't process duplicates correctly.\n\nWait, maybe the user's example is incorrect or I'm misunderstanding. Let me see the initial problem.\n\nWait, no, looking back, the user provided an example function, but perhaps it's a mistake. Wait, no, the user just requested to write a function, not to provide an example. I might have to clarify, but perhaps it's better to proceed with the function that returns unique common elements in the order they appear in the first list.\n\nBut the problem says to return a new list containing these common elements. It doesn't specify whether they should be unique or include duplicates. However, in typical cases, when finding common elements, duplicates are not included multiple times.\n\nAnother approach could be to count the minimum number of occurrences in both lists. For example, if list1 has [2,2,3] and list2 has [2,3,3], the common elements would be 2 and 3, each appearing twice. But that's more complex and perhaps beyond what the problem expects.\n\nGiven that, I think the most straightforward solution is to return the unique common elements, in the order they appear in the first list. So using the function I wrote should be sufficient.\n\nAnother test case:\n\nlist1 = [2, 2, 3]\n\nlist2 = [2, 3, 3]\n\nThe function would return [2,3].\n\nIs that acceptable? Since the problem doesn't specify, yes.\n\nAlternatively, if the user wants all occurrences, but that's more complicated.\n\nBut the problem doesn't specify handling duplicates, so I'll proceed with the function that returns unique elements.\n\nAnother point to consider: if the function should return elements in the order they appear in both lists, but that's unclear. So I'll proceed as per the initial approach.\n\nSo, final code:\n\ndef common_elements(list1, list2):\n\n    set2 = set(list2)\n\n    seen = set()\n\n    result = []\n\n    for element in list1:\n\n        if element in set2 and element not in seen:\n\n            result.append(element)\n\n            seen.add(element)\n\n    return result\n\nAlternatively, if we want to preserve all common elements, including duplicates, the approach would be different.\n\nBut in that case, the function would have to track the minimum number of occurrences.\n\nBut without knowing the problem's exact requirements on duplicates, I think the initial approach is safer.\n\nTherefore, the code above should solve the problem.\n</think>\n\nTo find the common elements between two lists, we can convert the second list into a set for efficient lookup and then iterate through the first list, collecting elements that are present in both. This approach ensures that each element is included only once and maintains the order of appearance from the first list.\n\nHere is the Python function:\n\n```python\ndef common_elements(list1, list2):\n    seen = set()\n    set2 = set(list2)\n    result = []\n    for element in list1:\n        if element in set2 and element not in seen:\n            result.append(element)\n            seen.add(element)\n    return result\n```\n\n**Example Usage:**\n\n```python\nlist1 = [1, 2, 5, 7, 9, 2, 3, 4]\nlist2 = [2, 4, 5, 6, 7, 8, 9]\nprint(common_elements(list1, list2))  # Output: [2, 5, 7, 9]\n```\n\n**Explanation:**\n\n1. **Convert `list2` to a Set:** This allows for O(1) average-time complexity checks for membership.\n2. **Track Seen Elements:** A set `seen` is used to ensure each element is added to the result only once.\n3. **Iterate Through `list1`:** For each element, check if it exists in `set2` and hasn't been added to the result yet.\n4. **Build Result List:** Collect elements in the order they appear in `list1`, ensuring uniqueness.\n\nThis method efficiently finds and returns the unique common elements in the order they first appear in `list1`.",
  "r1_solution": "def find_common_elements(list1, list2):\n    seen = set()\n    set2 = set(list2)\n    result = []\n    for element in list1:\n        if element in set2 and element not in seen:\n            result.append(element)\n            seen.add(element)\n    return result",
  "metadata": {
    "prompt_id": "00000109",
    "row_id": 109,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": ""
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}