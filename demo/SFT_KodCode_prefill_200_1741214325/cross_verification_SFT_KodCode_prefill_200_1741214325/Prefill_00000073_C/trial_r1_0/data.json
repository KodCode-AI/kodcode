{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000073_C",
  "question": "def binary_search(arr: List[int], target: int) -> int:\n    \"\"\" Perform a binary search on a sorted list of integers.\n    Returns the index of the target value if found, otherwise -1.\n    >>> binary_search([1, 2, 3, 4, 5], 3)\n    2\n    >>> binary_search([10, 20, 30, 40, 50], 40)\n    3\n    >>> binary_search([1, 2, 3, 4, 5], 6)\n    -1\n    >>> binary_search([10, 20, 30, 40, 50], 7)\n    -1\n    >>> binary_search([5], 5)\n    0\n    >>> binary_search([5], 4)\n    -1\n    >>> binary_search([], 1)\n    -1\n    >>> binary_search([], 2)\n    -1\n    >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1)\n    0\n    >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10)\n    9\n    \"\"\"",
  "solution": "def binary_search(arr, target):\n    \"\"\"\n    Perform a binary search on a sorted list of integers.\n    Returns the index of the target value if found, otherwise -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
  "test_code": "from solution import binary_search\n\ndef test_binary_search_positive():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([10, 20, 30, 40, 50], 40) == 3\n\ndef test_binary_search_not_found():\n    assert binary_search([1, 2, 3, 4, 5], 6) == -1\n    assert binary_search([10, 20, 30, 40, 50], 7) == -1\n\ndef test_binary_search_single_element():\n    assert binary_search([5], 5) == 0\n    assert binary_search([5], 4) == -1\n\ndef test_binary_search_empty_list():\n    assert binary_search([], 1) == -1\n    assert binary_search([], 2) == -1\n\ndef test_binary_search_edge_cases():\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 9",
  "test_info": [
    {
      "function_name": "binary_search",
      "parameter_list": "(arr, target)",
      "function_declaration": "def binary_search(arr, target):",
      "docstring": "Perform a binary search on a sorted list of integers.\nReturns the index of the target value if found, otherwise -1."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to implement a binary search function for a sorted list of integers. Hmm, binary search works by repeatedly dividing the search interval in half. Right, so the key steps are: find the middle element, compare it with the target, then decide to search in the left or right half.\n\nWait, but how do I handle possible Cases? Let me think. Well, the target could be smaller than the middle, so I go left. If it\u2019s larger, I go right. If it's equal, I return the middle index. But what if the target isn\u2019t present? Then I have to return -1.\n\nSo first, I'll need two pointers: low and high. I'll initialize low to 0 and high to len(arr) - 1. While low is less than or equal to high, I continue looping. Because once low exceeds high, there's nothing left to search.\n\nEach iteration, calculate mid as the average of low and high. Oh wait, but to avoid integer overflow in some languages, sometimes mid is calculated as (low + high) // 2. But in Python, integers can be big, so maybe not a problem here.\n\nCompare the element at mid index with the target. If arr[mid] equals target, return mid. If target is less than arr[mid], move high to mid - 1. Else, move low to mid + 1.\n\nWait, let me test this logic with an example. Take [1,2,3,4,5], target 3.\n\nInitial low is 0, high is 4. Mid is 2, arr[2] is 3. So found, return 2. Yeah, that works.\n\nAnother example: [10,20,30,40,50], target 40. Low 0, high 4. Mid 2, which is 30. Target is larger, so low becomes 3. Now low is 3, high 4, mid is 3.5 \u2192 3. Wait, wait in Python integer division is //, so (3+4)//2 is 3. So check 40, which equals target, return 3.\n\nAnother test case: target 6 in [1,2,3,4,5]. low is 0, high is 4. mid is 2, arr[mid] is 3. 6>3: low becomes 3. Now low=3, high=4. Mid is 3, arr[mid] is 4. 6>4, so low becomes 4. Now mid is 4. arr[mid] is 5, 6>5: low becomes 5. Now low is 5 which is greater than high 4, loop exits. Return -1.\n\nThat's correct.\n\nWhat about when the array is empty? Let's see, if arr is empty, high is -1, since len(arr)-1 is -1. So low (0) is not less than or equal to high (-1), so the loop doesn't run. We return -1, which is correct.\n\nWhat about an array with a single element? Like arr is [5], target is 5. low is 0, high is 0. mid is 0. Check arr[0], which is 5: found, return 0. If target is 4: first mid is 0, check 5 is higher than 4, set high to -1. Loop ends, return -1.\n\nSo the logic seems solid.\n\nSo now, putting this into code.\n\nThe function signature is given: def binary_search(arr: List[int], target: int) -> int:\n\nFirst, initialize low and high.\n\nlow = 0\n\nhigh = len(arr) - 1\n\nWhile low <= high:\n\nCalculate mid:\n\nmid = (low + high) // 2\n\nCheck arr[mid] against target.\n\nIf equal, return mid.\n\nIf target smaller: high = mid -1\n\nElse: low = mid +1\n\nAfter the loop, return -1.\n\nWait, but wait. Let me look at some test cases where the target is at the ends. For example, the array [1,2,3,4,5,6,7,8,9,10], target 1: low=0, high=9. mid=4, 5. 1 is less than 5, so high=3. Now loop continues with low=0, high=3. Mid=1, arr[1]=2>1. So high=0. Next iteration: low=0, high=0. Mid=0. arr[0]=1: found, return 0.\n\nYes, that's right.\n\nSimilarly for target 10 in the same array:\n\nLoop starts, mid=4:5<10, so low becomes 5.\n\nNext: low=5, high=9; mid=7. arr[7]=8<10: low becomes8.\n\nNow mid is 8+9//2=8.5\u21928. arr[8]=9 <10: low=9. Next mid is 9 (since (9+9)//2 is9). arr[9]=10: found and return.\n\nYes, that works.\n\nAnother edge case: what if the array has even length, like 2 elements. Let's say [1,3], target 3:\n\nlow is 0, high is 1. mid 0.5 rounded to 0. arr[0] is 1 <3, so low becomes 1.\n\nLoop continues with low=1, high=1. mid is 1, check: found.\n\nAnother example: [1,3], target 2. low=0, high=1. mid=0, arr[0]=1 <2, so low=1. Next iteration, low<=high: yes. mid=1, arr[1]=3>2: high=0. Now loop ends. Return -1.\n\nSo code should correctly handle all these cases.\n\nSo I think the code would be something like:\n\ndef binary_search(arr: List[int], target: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif target < arr[mid]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n\nYes, that should work.\n\nTesting all the test cases provided:\n\nbinary_search([1, 2, 3, 4, 5], 3) \u2192 2, which works.\n\nbinary_search([10, 20, 30, 40, 50], 40) \u2192 3 \u2192 correct.\n\nbinary_search([1, 2, 3, 4, 5], 6) \u2192 -1.\n\nbinary_search([10, 20, 30, 40, 50], 7) \u2192 -1.\n\nbinary_search([5],5) \u21920.\n\nbinary_search([5],4)\u2192-1.\n\nbinary_search([],1) \u2192 -1.\n\nbinary_search([],2)\u2192-1.\n\nbinary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) \u21920.\n\nbinary_search([1,...,10],10) \u21929.\n\nAll test cases should pass.\n\nWait, but how does Python handle integer division with very large numbers? Since the problem constraints are not specified, but binary search is O(log n) time which is efficient.\n\nI think this code should cover all cases.\n</think>\n\nTo solve this problem, we need to implement a binary search algorithm to find the index of a target value in a sorted list of integers. Binary search is an efficient algorithm that works by repeatedly dividing the search interval in half, making it much faster than a linear search, especially for large datasets.\n\n### Approach\n1. **Binary Search Logic**: Binary search works on the principle of dividing the search interval in half. If the target value is found, the algorithm returns its index. If the target value is smaller than the middle element, the search continues in the left half of the array. If the target value is larger, the search continues in the right half.\n\n2. **Initialization**: We initialize two pointers, `low` and `high`, to the start and end of the array respectively.\n\n3. **Loop Until Search Interval is Valid**: We continue the search as long as `low` is less than or equal to `high`. This ensures that we cover the entire array without missing any elements.\n\n4. **Midpoint Calculation**: In each iteration, we calculate the midpoint `mid` using integer division of the sum of `low` and `high`.\n\n5. **Comparison and Adjustment**:\n   - If the middle element is equal to the target, return the midpoint index.\n   - If the target is smaller than the middle element, adjust the upper bound `high` to `mid - 1`.\n   - If the target is larger than the middle element, adjust the lower bound `low` to `mid + 1`.\n\n6. **Edge Cases**: Handle cases where the array is empty or has only one element, or when the target is not found in the array.\n\n### Solution Code\n```python\nfrom typing import List\n\ndef binary_search(arr: List[int], target: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif target < arr[mid]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n```\n\n### Explanation\nThe provided code efficiently performs a binary search on a sorted list of integers. Here\u2019s a step-by-step breakdown:\n\n1. **Initialization**: `low` is set to 0 (start of the array), and `high` is set to the last index of the array.\n\n2. **Loop Execution**: The loop runs as long as `low` is less than or equal to `high`. This ensures that the search space is not exhausted.\n\n3. **Mid Calculation**: The midpoint `mid` is calculated using integer division to avoid indexing issues.\n\n4. **Target Comparison**:\n   - If the middle element is the target, return `mid`.\n   - If the target is smaller than the middle element, adjust `high` to narrow the search to the left half.\n   - If the target is larger, adjust `low` to search the right half.\n\n5. **Termination**: If the loop exits without finding the target, return -1 to indicate that the target is not present in the array.\n\nThis approach ensures that the binary search runs in O(log n) time complexity, making it highly efficient for large sorted arrays.",
  "r1_solution": "from typing import List\n\ndef binary_search(arr: List[int], target: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif target < arr[mid]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1",
  "metadata": {
    "prompt_id": "00000073",
    "row_id": 73,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to perform a binary search on a sorted list of integers. The function should return the index of the target value if it is found, or -1 if it is not found. The list may not be empty."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results0.jsonl"
}