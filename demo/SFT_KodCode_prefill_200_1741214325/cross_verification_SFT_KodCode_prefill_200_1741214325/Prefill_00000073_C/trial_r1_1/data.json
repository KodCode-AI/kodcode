{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000073_C",
  "question": "def binary_search(arr: List[int], target: int) -> int:\n    \"\"\" Perform a binary search on a sorted list of integers.\n    Returns the index of the target value if found, otherwise -1.\n    >>> binary_search([1, 2, 3, 4, 5], 3)\n    2\n    >>> binary_search([10, 20, 30, 40, 50], 40)\n    3\n    >>> binary_search([1, 2, 3, 4, 5], 6)\n    -1\n    >>> binary_search([10, 20, 30, 40, 50], 7)\n    -1\n    >>> binary_search([5], 5)\n    0\n    >>> binary_search([5], 4)\n    -1\n    >>> binary_search([], 1)\n    -1\n    >>> binary_search([], 2)\n    -1\n    >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1)\n    0\n    >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10)\n    9\n    \"\"\"",
  "solution": "def binary_search(arr, target):\n    \"\"\"\n    Perform a binary search on a sorted list of integers.\n    Returns the index of the target value if found, otherwise -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
  "test_code": "from solution import binary_search\n\ndef test_binary_search_positive():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([10, 20, 30, 40, 50], 40) == 3\n\ndef test_binary_search_not_found():\n    assert binary_search([1, 2, 3, 4, 5], 6) == -1\n    assert binary_search([10, 20, 30, 40, 50], 7) == -1\n\ndef test_binary_search_single_element():\n    assert binary_search([5], 5) == 0\n    assert binary_search([5], 4) == -1\n\ndef test_binary_search_empty_list():\n    assert binary_search([], 1) == -1\n    assert binary_search([], 2) == -1\n\ndef test_binary_search_edge_cases():\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 9",
  "test_info": [
    {
      "function_name": "binary_search",
      "parameter_list": "(arr, target)",
      "function_declaration": "def binary_search(arr, target):",
      "docstring": "Perform a binary search on a sorted list of integers.\nReturns the index of the target value if found, otherwise -1."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a binary search function in Python. Let's see, binary search works on a sorted array by repeatedly dividing the search interval in half. So the array needs to be sorted, but I don't think I have to check that in this function. The function should take a list arr and a target integer, and return the index where the target is found. If it's not present, return -1.\n\nHmm, the steps I remember for binary search are: start with the middle element, compare it to the target. If the target is smaller, move to the left half, else move to the right half. Repeat this until the target is found or the search space is exhausted.\n\nWait, how do I handle the boundaries? Let me think about the variables. Initialize low to 0 and high to len(arr) - 1. Loop while low is less than or equal to high.\n\nSo, in each iteration:\nCalculate mid = (low + high) // 2.\nIf arr[mid] equals target, return mid.\nIf arr[mid] is less than target, set low to mid + 1.\nElse, set high to mid - 1.\n\nIf the loop ends without finding the target, return -1.\n\nWhat are the edge cases I need to consider? Let's see:\n\n1. Empty list: return -1 immediately.\n2. Single element list: target equal to that element returns index 0, else -1.\n3. Target is the first or last element.\n4. Duplicate elements? Wait, the problem says the array is a list of integers, but nothing about whether they're unique. So the function should return the first occurrence or any occurrence? Well, in standard binary search each element is unique, but if duplicates exist, the function will find the first occurrence in the case of equal elements, but if the elements are same, the function might return any? Wait, but how? Let me think about that.\n\nWait, no, in the examples given, the array is sorted in increasing order and each element is unique. So maybe the test cases don't expect handling of duplicates, but perhaps the function will work regardless as it's supposed to find the index of the target, whichever the first, but if multiple exists, it can return any, but the problem examples don't have duplicates. So for this problem, I think the basic approach will suffice.\n\nSo let's outline the code:\n\ndef binary_search(arr: List[int], target: int) -> int:\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        mid_val = arr[mid]\n\n        if mid_val == target:\n            return mid\n        elif mid_val < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\nWait, but wait! Let's test this logic with one of the sample cases.\n\nSample 1: [1,2,3,4,5], target 3.\n\nlow = 0, high=4. mid=2, arr[mid]=3, which is the target. Returns 2. Correct.\n\nSample 2: [10,20,30,40,50], target40.\n\nlow=0, high=4.\n\nmid=2, arr[2]=30 <40, so set low=3. Now mid is (3+4)//2=3, arr[3]=40, return 3. Correct.\n\nSample 3: [1,2,3,4,5], target6.\n\nlow=0, high=4. mid=2: 3<6. low=3. mid (3+4)//2=3:4<6. Set low=4. mid=4:5<6. Set low=5. Now low>high (5>4), loop exists. Return -1.\n\nSample4: [], returns -1.\n\nSample5: [5], target5 returns 0.\n\nWhat about when the target is in the first position? Let's say [1,2,3,4,5], target1.\n\nlow=0, high=4. mid=2:3>1, set high=1. Then mid is (0+1)//2=0: arr[0]=1, return 0. Correct.\n\nSimilarly, target5: start with mid=2, high=4. Target is larger, so low increases. Eventually high becomes 4, mid is 4, which is 5.\n\nAnother test case: target is larger than all elements.\n\nHmm, that's handled correctly.\n\nSo this code should work as per the examples.\n\nI think this should handle all possible cases. Now let's implement it.\n</think>\n\nTo solve this problem, we need to perform a binary search on a sorted list of integers to find the index of a target value. Binary search is an efficient algorithm that works by dividing the search interval in half repeatedly until the target is found or the interval is exhausted.\n\n### Approach\n1. **Initialize Boundaries**: Start with the entire array by setting two pointers, `low` at the beginning (index 0) and `high` at the end (index `len(arr) - 1`).\n2. **Loop Until Boundaries Overlap**: Continue the search while `low` is less than or equal to `high`.\n3. **Calculate Midpoint**: Compute the middle index `mid` as the average of `low` and `high`, using integer division to ensure an integer result.\n4. **Compare Middle Element with Target**: \n   - If the element at `mid` is the target, return `mid`.\n   - If the element at `mid` is less than the target, move the `low` pointer to `mid + 1` to search the right half.\n   - If the element at `mid` is greater than the target, move the `high` pointer to `mid - 1` to search the left half.\n5. **Return -1 if Target Not Found**: If the loop ends without finding the target, return -1 indicating the target is not present in the array.\n\nThis approach ensures that the time complexity is O(log n), making it efficient for large sorted arrays.\n\n### Solution Code\n```python\nfrom typing import List\n\ndef binary_search(arr: List[int], target: int) -> int:\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        mid_val = arr[mid]\n\n        if mid_val == target:\n            return mid\n        elif mid_val < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n```\n\n### Explanation\n- **Initialization**: `low` is set to 0 and `high` to the last index of the array.\n- **Midpoint Calculation**: In each iteration, the midpoint `mid` is calculated to divide the current search interval.\n- **Comparison and Adjustment**: Depending on whether the middle element is less than or greater than the target, the search interval is adjusted by moving `low` or `high`.\n- **Termination**: The loop terminates when the search interval is empty, and if the target was not found, -1 is returned.\n\nThis method efficiently narrows down the search space, ensuring that each comparison effectively halves the remaining elements to check, leading to a logarithmic time complexity.",
  "r1_solution": "from typing import List\n\ndef binary_search(arr: List[int], target: int) -> int:\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        mid_val = arr[mid]\n\n        if mid_val == target:\n            return mid\n        elif mid_val < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1",
  "metadata": {
    "prompt_id": "00000073",
    "row_id": 73,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to perform a binary search on a sorted list of integers. The function should return the index of the target value if it is found, or -1 if it is not found. The list may not be empty."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results1.jsonl"
}