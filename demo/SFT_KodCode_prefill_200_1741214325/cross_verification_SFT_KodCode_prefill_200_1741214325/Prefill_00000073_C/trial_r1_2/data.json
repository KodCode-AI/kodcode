{
  "style": "instruct",
  "subset": "Prefill",
  "question_id": "Prefill_00000073_C",
  "question": "def binary_search(arr: List[int], target: int) -> int:\n    \"\"\" Perform a binary search on a sorted list of integers.\n    Returns the index of the target value if found, otherwise -1.\n    >>> binary_search([1, 2, 3, 4, 5], 3)\n    2\n    >>> binary_search([10, 20, 30, 40, 50], 40)\n    3\n    >>> binary_search([1, 2, 3, 4, 5], 6)\n    -1\n    >>> binary_search([10, 20, 30, 40, 50], 7)\n    -1\n    >>> binary_search([5], 5)\n    0\n    >>> binary_search([5], 4)\n    -1\n    >>> binary_search([], 1)\n    -1\n    >>> binary_search([], 2)\n    -1\n    >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1)\n    0\n    >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10)\n    9\n    \"\"\"",
  "solution": "def binary_search(arr, target):\n    \"\"\"\n    Perform a binary search on a sorted list of integers.\n    Returns the index of the target value if found, otherwise -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
  "test_code": "from solution import binary_search\n\ndef test_binary_search_positive():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([10, 20, 30, 40, 50], 40) == 3\n\ndef test_binary_search_not_found():\n    assert binary_search([1, 2, 3, 4, 5], 6) == -1\n    assert binary_search([10, 20, 30, 40, 50], 7) == -1\n\ndef test_binary_search_single_element():\n    assert binary_search([5], 5) == 0\n    assert binary_search([5], 4) == -1\n\ndef test_binary_search_empty_list():\n    assert binary_search([], 1) == -1\n    assert binary_search([], 2) == -1\n\ndef test_binary_search_edge_cases():\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 9",
  "test_info": [
    {
      "function_name": "binary_search",
      "parameter_list": "(arr, target)",
      "function_declaration": "def binary_search(arr, target):",
      "docstring": "Perform a binary search on a sorted list of integers.\nReturns the index of the target value if found, otherwise -1."
    }
  ],
  "gpt_pass_sequence": [
    0,
    0,
    1
  ],
  "gpt_pass_trial_num": 1,
  "gpt_difficulty": "medium",
  "gpt_pass_percentage": 0.333,
  "r1_response": "<think>\nOkay, I need to write a binary search function. Let me think about how binary search works. So, binary search is for sorted arrays, right? And it finds the target by repeatedly dividing the search interval in half. So the basic idea is to compare the target with the middle element. If it matches, we return that index. If the target is smaller, we look in the left half, else in the right half.\n\nSo, the function will take a sorted list arr and a target as input, and return the index of the target if found, else -1.\n\nHmm where to start. Maybe I should initialize two pointers, low and high. Low starts at 0, high at the last index of the array. While low is less than or equal to high, we continue.\n\nWait, wait, should high be len(arr) -1? Because if the array is empty, we should return -1 right away. Oh right, so first, I need to check if the array is empty, but wait, what if the array has zero elements? So in the code, the first thing I should do is check if the array is empty. Oh but looking at the test cases, for example, when arr is empty and target is 1, it returns -1. So yes, handling the empty list is crucial.\n\nAlternatively, even with zero elements, if I have a while loop that runs only when low <= high, but if the array is empty, low is 0 and high is -1, so the loop doesn't run and returns -1. That might handle the empty case. But perhaps it's better to have a separate check for an empty array.\n\nWait, looking at my initial setup. Let's think about the steps.\n\nSet low to 0, high to len(arr)-1. So if the array is empty, len(arr) is zero, high is -1. So the loop condition will be 0 <= -1, which is false. So the loop doesn't execute, and we proceed to return -1, which is correct.\n\nSo I don't need a separate check; the loop and the pointers handle that.\n\nSo in code:\n\nlow = 0\nhigh = len(arr) -1\n\nThen, while low <= high:\n\nIn each iteration, calculate mid = (low + high) // 2.\n\nThen compare arr[mid] with target.\n\nIf arr[mid] == target: return mid.\n\nElse if target < arr[mid], set high = mid -1.\n\nElse: set low = mid +1.\n\nIf the loop exits without returning, then return -1.\n\nWait, but let me test that with some examples.\n\nTest case 1: [1,2,3,4,5], target is 3.\n\nlow=0, high=4.\n\nmid is (0+4)//2=2. arr[mid] is 3, so return 2. Correct.\n\nTest case 2: [10,20,30,40,50], target 40.\n\nlow=0, high=4.\n\nmid = 2. arr[mid] is 30, which is less than 40. So set low=3.\n\nNow low is 3, high is 4.\n\nmid is (3+4)//2=3. arr[3]=40. match, return 3. Correct.\n\nAnother test case: [1,2,3,4,5], target 6.\n\nLoop:\n\nlow=0, high=4.\n\nmid=2: 3 <6 \u2192 low becomes 3.\n\nNow low=3, high=4. mid=(3+4)//2=3. arr[3]=4 <6 \u2192 low becomes4.\n\nNow low=4, high=4 \u2192 mid is4. arr[4]=5 <6 \u2192 low becomes5. Now low is5 which is >high=4. Loop ends.\n\nReturn -1. Correct.\n\nAnother test case: [5], target is5. low=0, high=0. mid is0. arr[mid]=5. Return0.\n\nAnother test case: [5], target4. low=0, high=0. arr[0] is5>4. So high becomes -1. Exit loop, return-1. Correct.\n\nSo the logic seems to handle these cases. Now what about where the target is the last element or the first element?\n\nLet's see: [1,2,3,...10], target1. Should return0.\n\nAnd in the function, mid would eventually reach when low=0, high=0, etc.\n\nNow what about even and odd lengths?\n\nLike arr is [1], it's handled. For arr of length 2, high is1.\n\nSo the code seems solid.\n\nWait wait, one thing. What if the array has duplicate elements? Oh the problem statement doesn't specify, but binary search for the target should return the correct index regardless of duplicates, as long as it's sorted. Oh in the function, since it finds the first occurrence in case of duplicates, or any occurrence because the problem states that as long as the target is present, any index is possible.\n\nWait no, the function returns the index of the target if found. So if the array has duplicates, as long as the element is there, the function will find some index. It may not find the first occurrence, depending on how the search proceeds.\n\nBut the problem statement's test cases don't involve duplicates, so perhaps it's sufficient.\n\nSo in code:\n\ndef binary_search(arr: List[int], target: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif target < arr[mid]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n\nYes, that's the code.\n\nLet me test with test cases.\n\nbinary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) \u2192 should return 9.\n\nLet's see:\n\nlow=0, high=9. mid=4, arr[4]=5 <10 \u2192 high=4-1=5? Wait wait wait, wait, no.\n\nWait, low=0, high=9. mid is (0+9)/2=4 (since 4.5 becomes 4 in integer division). arr[4] is5 <10 \u2192 so low becomes5.\n\nNow low=5, high=9: mid=(5+9)//2 =7.\n\narr[7]=8 <10 \u2192 low=8.\n\nlow=8, high=9. mid=8. arr[8] =9 <10 \u2192 low=9.\n\nNow mid=9, arr[9]=10 \u2192 return9. Correct.\n\nAnother test case: binary_search([1,2,3,4,5],3). Low is0, high4.\n\nmid=2: correct.\n\nSo yes, the function works as expected.\n\nI think this should handle all test cases and edge cases correctly.\n</think>\n\nTo solve this problem, we need to implement a binary search algorithm on a sorted list of integers. Binary search is an efficient algorithm that repeatedly divides the search interval in half. The goal is to find the index of a target value if it exists in the list, or return -1 if it does not.\n\n### Approach\n1. **Initialize Pointers**: Start by setting two pointers, `low` at the beginning of the list (index 0) and `high` at the end of the list (index `len(arr) - 1`).\n2. **Loop Until Pointers Meet**: Continue the search while `low` is less than or equal to `high`.\n3. **Calculate Midpoint**: In each iteration, calculate the midpoint `mid` of the current interval.\n4. **Compare Target with Midpoint**: \n   - If the target is found at the midpoint, return the midpoint index.\n   - If the target is less than the midpoint value, adjust the `high` pointer to narrow the search to the left half.\n   - If the target is greater than the midpoint value, adjust the `low` pointer to narrow the search to the right half.\n5. **Return -1 if Not Found**: If the loop exits without finding the target, return -1.\n\nThis approach ensures that each iteration effectively halves the search space, leading to a time complexity of O(log n).\n\n### Solution Code\n```python\nfrom typing import List\n\ndef binary_search(arr: List[int], target: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif target < arr[mid]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n```\n\n### Explanation\n- **Initialization**: The pointers `low` and `high` are set to the start and end of the list, respectively.\n- **Loop Condition**: The loop continues as long as `low` is less than or equal to `high`, ensuring that all possible indices are checked.\n- **Midpoint Calculation**: The midpoint is calculated to split the current search interval in half.\n- **Comparison and Adjustment**: Depending on whether the target is found, less than, or greater than the midpoint value, the search interval is adjusted to narrow down the possible locations of the target.\n- **Termination**: If the target is not found by the end of the loop, -1 is returned.\n\nThis method efficiently finds the target or determines its absence, making it a robust solution for searching in sorted lists.",
  "r1_solution": "from typing import List\n\ndef binary_search(arr: List[int], target: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif target < arr[mid]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1",
  "metadata": {
    "prompt_id": "00000073",
    "row_id": 73,
    "seed_ids": [
      0
    ],
    "mode": "prefill",
    "original_instruction": "Write a python function to perform a binary search on a sorted list of integers. The function should return the index of the target value if it is found, or -1 if it is not found. The list may not be empty."
  },
  "file_source": "KodCode_prefill_200_1741214325_prepared_results2.jsonl"
}