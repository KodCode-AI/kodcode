[
  {
    "instruction": "Write a python function to sort an array using the selection sort algorithm.",
    "response": "def selection_sort(arr):\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum element in remaining unsorted array\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Swap the found minimum element with the first element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
    "test_code": "from solution import selection_sort\n\ndef test_selection_sort_with_positive_numbers():\n    assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]\n\ndef test_selection_sort_with_negative_numbers():\n    assert selection_sort([-64, -25, -12, -22, -11]) == [-64, -25, -22, -12, -11]\n\ndef test_selection_sort_with_mixed_numbers():\n    assert selection_sort([-1, 5, -7, 8, 0, 12, 10]) == [-7, -1, 0, 5, 8, 10, 12]\n\ndef test_selection_sort_with_single_element():\n    assert selection_sort([5]) == [5]\n\ndef test_selection_sort_with_empty_list():\n    assert selection_sort([]) == []",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def selection_sort(arr):\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum element in remaining unsorted array\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        # Swap the found minimum element with the first element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
        "test_code": "from solution import selection_sort\n\ndef test_selection_sort_sorted_array():\n    assert selection_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_selection_sort_reversed_array():\n    assert selection_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n\ndef test_selection_sort_duplicate_elements():\n    assert selection_sort([4, 2, 2, 1, 3]) == [1, 2, 2, 3, 4]\n\ndef test_selection_sort_with_negative_numbers():\n    assert selection_sort([3, -1, -2, 6, 4]) == [-2, -1, 3, 4, 6]\n\ndef test_selection_sort_empty_list():\n    assert selection_sort([]) == []\n\ndef test_selection_sort_single_element_list():\n    assert selection_sort([5]) == [5]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def selection_sort(arr):\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    for i in range(len(arr)):\n        # Find the minimum element in remaining unsorted array\n        min_index = i\n        for j in range(i+1, len(arr)):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        # Swap the found minimum element with the first element\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr",
        "test_code": "from solution import selection_sort\n\ndef test_selection_sort_positive_numbers():\n    assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]\n\ndef test_selection_sort_negative_numbers():\n    assert selection_sort([-64, -25, -12, -22, -11]) == [-64, -25, -22, -12, -11]\n\ndef test_selection_sort_mixed_numbers():\n    assert selection_sort([64, -25, 0, 22, -11, 12]) == [-25, -11, 0, 12, 22, 64]\n\ndef test_selection_sort_empty_list():\n    assert selection_sort([]) == []\n\ndef test_selection_sort_single_element():\n    assert selection_sort([5]) == [5]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def selection_sort(arr):\n    \"\"\"\n    Sorts an array using the selection sort algorithm.\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Find the minimum element in remaining unsorted array\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Swap the found minimum element with the first element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
        "test_code": "from solution import selection_sort\n\ndef test_selection_sort_with_positive_numbers():\n    assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64]\n\ndef test_selection_sort_with_negative_numbers():\n    assert selection_sort([-64, -25, -12, -22, -11]) == [-64, -25, -22, -12, -11]\n\ndef test_selection_sort_with_mixed_numbers():\n    assert selection_sort([-1, 5, -7, 8, 0, 12, 10]) == [-7, -1, 0, 5, 8, 10, 12]\n\ndef test_selection_sort_with_single_element():\n    assert selection_sort([5]) == [5]\n\ndef test_selection_sort_with_empty_list():\n    assert selection_sort([]) == []",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000001",
      "row_id": 1,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the maximum depth of a binary search tree (BST).",
    "response": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"\n    Returns the maximum depth of a binary search tree.\n    \"\"\"\n    if root is None:\n        return 0\n    return 1 + max(max_depth_bst(root.left), max_depth_bst(root.right))",
    "test_code": "from solution import max_depth_bst, TreeNode\n\ndef test_max_depth_bst_empty_tree():\n    assert max_depth_bst(None) == 0\n\ndef test_max_depth_bst_single_node():\n    root = TreeNode(1)\n    assert max_depth_bst(root) == 1\n\ndef test_max_depth_bst_balanced_tree():\n    root = TreeNode(2, TreeNode(1), TreeNode(3))\n    assert max_depth_bst(root) == 2\n\ndef test_max_depth_bst_unbalanced_tree_left():\n    root = TreeNode(2, TreeNode(1, TreeNode(0), None), TreeNode(3))\n    assert max_depth_bst(root) == 3\n\ndef test_max_depth_bst_unbalanced_tree_right():\n    root = TreeNode(2, TreeNode(1), TreeNode(3, None, TreeNode(4)))\n    assert max_depth_bst(root) == 3",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"\n    Returns the maximum depth of a binary search tree.\n    \"\"\"\n    if root is None:\n        return 0\n    return 1 + max(max_depth_bst(root.left), max_depth_bst(root.right))",
        "test_code": "from solution import max_depth_bst, TreeNode\n\ndef test_max_depth_bst_empty_tree():\n    assert max_depth_bst(None) == 0\n\ndef test_max_depth_bst_single_node():\n    root = TreeNode(1)\n    assert max_depth_bst(root) == 1\n\ndef test_max_depth_bst_balanced_tree():\n    root = TreeNode(2, TreeNode(1), TreeNode(3))\n    assert max_depth_bst(root) == 2\n\ndef test_max_depth_bst_unbalanced_tree_left():\n    root = TreeNode(2, TreeNode(1, TreeNode(0), None), TreeNode(3))\n    assert max_depth_bst(root) == 3\n\ndef test_max_depth_bst_unbalanced_tree_right():\n    root = TreeNode(2, TreeNode(1), TreeNode(3, None, TreeNode(4)))\n    assert max_depth_bst(root) == 3",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"\n    Returns the maximum depth of a binary search tree.\n    \"\"\"\n    if not root:\n        return 0\n    left_depth = max_depth_bst(root.left)\n    right_depth = max_depth_bst(root.right)\n    return max(left_depth, right_depth) + 1",
        "test_code": "from solution import max_depth_bst, TreeNode\n\ndef setup_tree():\n    # Creating a simple BST\n    #       3\n    #      / \\\n    #     2   5\n    #    /   / \\\n    #   1   4   6\n    root = TreeNode(3)\n    root.left = TreeNode(2, left=TreeNode(1))\n    root.right = TreeNode(5, left=TreeNode(4), right=TreeNode(6))\n    return root\n\ndef test_max_depth_bst_empty_tree():\n    assert max_depth_bst(None) == 0\n\ndef test_max_depth_bst_simple_tree():\n    root = setup_tree()\n    assert max_depth_bst(root) == 3\n\ndef test_max_depth_bst_with_deeper_right():\n    #       3\n    #      /\n    #     2\n    #    / \\\n    #   1   5\n    #      / \\\n    #     4   6\n    root = TreeNode(3)\n    root.left = TreeNode(2, left=TreeNode(1))\n    root.right = TreeNode(5, left=TreeNode(4), right=TreeNode(6))\n    assert max_depth_bst(root) == 4",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth_bst(root: TreeNode) -> int:\n    \"\"\"\n    Returns the maximum depth of a binary search tree.\n    \"\"\"\n    if root is None:\n        return 0\n    else:\n        left_depth = max_depth_bst(root.left)\n        right_depth = max_depth_bst(root.right)\n        return max(left_depth, right_depth) + 1",
        "test_code": "``\nfrom solution import TreeNode, max_depth_bst\n\ndef test_max_depth_bst_empty_tree():\n    assert max_depth_bst(None) == 0\n\ndef test_max_depth_bst_single_node():\n    root = TreeNode(5)\n    assert max_depth_bst(root) == 1\n\ndef test_max_depth_bst_balanced_tree():\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(7)\n    root.right.right = TreeNode(9)\n    assert max_depth_bst(root) == 3\n\ndef test_max_depth_bst_skewed_right():\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.right = TreeNode(3)\n    assert max_depth_bst(root) == 3\n\ndef test_max_depth_bst_skewed_left():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.left.left = TreeNode(3)\n    assert max_depth_bst(root) == 3",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000002",
      "row_id": 2,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to merge two sorted lists into one sorted list using the merge function from the heapq module. Since heapq's merge function can be used to merge multiple iterables directly, your function should accept two lists, sort each individually if they are not already sorted, and then merge them using heapq.merge(). Ensure the output is a list, not a heapq.merge object.",
    "response": "import heapq\n\ndef merge_sorted_lists(lst1, lst2):\n    \"\"\"\n    Given two sorted lists, it merges them into a single sorted list\n    using the heapq.merge function.\n    \"\"\"\n    # Ensure both lists are sorted\n    sorted_lst1 = sorted(lst1)\n    sorted_lst2 = sorted(lst2)\n    \n    # Use heapq.merge to merge the two sorted lists\n    result = list(heapq.merge(sorted_lst1, sorted_lst2))\n    \n    return result",
    "test_code": "import pytest\nfrom heapq import merge as test_merge\nfrom solution import merge_sorted_lists\n\ndef test_merge_sorted_lists_positive():\n    assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\n\ndef test_merge_empty_lists():\n    assert merge_sorted_lists([], []) == []\n\ndef test_merge_with_duplicates():\n    assert merge_sorted_lists([1, 3, 3], [2, 3, 4]) == [1, 2, 3, 3, 3, 4]\n\ndef test_merge_mixed_signs():\n    assert merge_sorted_lists([-2, 0, 2], [-3, 1, 3]) == [-3, -2, 0, 1, 2, 3]\n\ndef test_merge_with_same_elements():\n    assert merge_sorted_lists([1, 2, 3], [1, 2, 3]) == [1, 1, 2, 2, 3, 3]\n\ndef test_merge_with_different_lengths():\n    assert merge_sorted_lists([1, 3, 5, 7], [2, 4, 6]) == [1, 2, 3, 4, 5, 6, 7]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "import heapq\n\ndef merge_sorted_lists(lst1, lst2):\n    \"\"\"\n    Merges two sorted lists into one sorted list using the heapq.merge function.\n    \n    Parameters:\n    lst1 (list): First sorted list.\n    lst2 (list): Second sorted list.\n    \n    Returns:\n    list: Merged and sorted list.\n    \"\"\"\n    # Ensure both lists are sorted\n    sorted_lst1 = sorted(lst1) if lst1 else []\n    sorted_lst2 = sorted(lst2) if lst2 else []\n    # Merge the sorted lists using heapq.merge and convert the result to a list\n    merged_list = list(heapq.merge(sorted_lst1, sorted_lst2))\n    return merged_list",
        "test_code": "import pytest\nfrom solution import merge_sorted_lists\nfrom heapq import merge as built_in_merge\n\ndef test_merge_sorted_lists_positive():\n    assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == list(built_in_merge([1, 3, 5], [2, 4, 6]))\n\ndef test_merge_empty_lists():\n    assert merge_sorted_lists([], []) == []\n    assert merge_sorted_lists([], [2, 4, 6]) == [2, 4, 6]\n    assert merge_sorted_lists([1, 3, 5], []) == [1, 3, 5]\n\ndef test_merge_with_common_elements():\n    assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == list(built_in_merge([1, 3, 5], [2, 4, 6]))\n    assert merge_sorted_lists([1, 3, 5], [5, 6]) == list(built_in_merge([1, 3, 5], [5, 6]))\n\ndef test_merge_mixed_sign_numbers():\n    assert merge_sorted_lists([-1, 0, 2], [-2, -2, 3]) == list(built_in_merge([-1, 0, 2], [-2, -2, 3]))",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "import heapq\n\ndef merge_sorted_lists(list1, list2):\n    \"\"\"\n    Merge two sorted lists into one sorted list.\n    \"\"\"\n    # Ensure the lists are sorted\n    sorted_list1 = sorted(list1)\n    sorted_list2 = sorted(list2)\n    # Merge the sorted lists using heapq.merge and convert the result to a list\n    merged_list = list(heapq.merge(sorted_list1, sorted_list2))\n    return merged_list",
        "test_code": "import heapq\nfrom solution import merge_sorted_lists\n\ndef test_merge_sorted_lists_with_two_sorted_lists():\n    assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\n\ndef test_merge_sorted_lists_with_duplicates():\n    assert merge_sorted_lists([1, 3, 5, 5], [2, 4, 6, 6]) == [1, 2, 3, 4, 5, 5, 6, 6]\n\ndef test_merge_sorted_lists_with_unsorted_lists():\n    assert merge_sorted_lists([3, 1, 5], [6, 4, 2]) == [1, 2, 3, 4, 5, 6]\n\ndef test_merge_sorted_lists_with_empty_lists():\n    assert merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3]\n    assert merge_sorted_lists([1, 2, 3], []) == [1, 2, 3]\n    assert merge_sorted_lists([], []) == []",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "import heapq\n\ndef merge_sorted_lists(lst1, lst2):\n    \"\"\"\n    Given two sorted lists, it merges them into a single sorted list\n    using the heapq.merge function.\n    \"\"\"\n    # Ensure both lists are sorted\n    sorted_lst1 = sorted(lst1)\n    sorted_lst2 = sorted(lst2)\n    \n    # Use heapq.merge to merge the two sorted lists\n    result = list(heapq.merge(sorted_lst1, sorted_lst2))\n    \n    return result",
        "test_code": "import pytest\nfrom heapq import merge as test_merge\nfrom solution import merge_sorted_lists\n\ndef test_merge_sorted_lists_positive():\n    assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\n\ndef test_merge_empty_lists():\n    assert merge_sorted_lists([], []) == []\n\ndef test_merge_with_duplicates():\n    assert merge_sorted_lists([1, 3, 3], [2, 3, 4]) == [1, 2, 3, 3, 3, 4]\n\ndef test_merge_mixed_signs():\n    assert merge_sorted_lists([-2, 0, 2], [-3, 1, 3]) == [-3, -2, 0, 1, 2, 3]\n\ndef test_merge_with_same_elements():\n    assert merge_sorted_lists([1, 2, 3], [1, 2, 3]) == [1, 1, 2, 2, 3, 3]\n\ndef test_merge_with_different_lengths():\n    assert merge_sorted_lists([1, 3, 5, 7], [2, 4, 6]) == [1, 2, 3, 4, 5, 6, 7]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000003",
      "row_id": 3,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to calculate the sum of all numbers in a list using recursion.",
    "response": "def sum_recursive(numbers):\n    \"\"\"\n    Calculate the sum of all numbers in a list using recursion.\n    \n    Args:\n        numbers (list): A list of integers or floats.\n    \n    Returns:\n        int or float: The sum of all numbers in the list.\n    \"\"\"\n    if not numbers:\n        return 0\n    else:\n        return numbers[0] + sum_recursive(numbers[1:])",
    "test_code": "def test_sum_recursive_empty_list():\n    assert sum_recursive([]) == 0\n\ndef test_sum_recursive_positive_numbers():\n    assert sum_recursive([1, 2, 3, 4, 5]) == 15\n\ndef test_sum_recursive_with_zeros():\n    assert sum_recursive([0, 0, 0, 0]) == 0\n\ndef test_sum_recursive_negative_numbers():\n    assert sum_recursive([-1, -2, -3, -4, -5]) == -15\n\ndef test_sum_recursive_mixed_numbers():\n    assert sum_recursive([-1, 1, -2, 2, -3, 3]) == 0\n\ndef test_sum_recursive_single_element():\n    assert sum_recursive([42]) == 42",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def sum_recursive(lst):\n    \"\"\"\n    Returns the sum of all numbers in a list using recursion.\n    \"\"\"\n    if not lst:\n        return 0\n    else:\n        return lst[0] + sum_recursive(lst[1:])",
        "test_code": "from solution import sum_recursive\n\ndef test_sum_recursive_empty_list():\n    assert sum_recursive([]) == 0\n\ndef test_sum_recursive_single_element():\n    assert sum_recursive([5]) == 5\n\ndef test_sum_recursive_positive_numbers():\n    assert sum_recursive([1, 2, 3, 4, 5]) == 15\n\ndef test_sum_recursive_mixed_numbers():\n    assert sum_recursive([-1, 1, -2, 2, -3, 3]) == 0\n\ndef test_sum_recursive_large_list():\n    assert sum_recursive(range(1, 101)) == 5050",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def sum_recursive(numbers):\n    \"\"\"\n    Calculate the sum of all numbers in a list using recursion.\n    \n    Args:\n        numbers (list): A list of integers or floats.\n    \n    Returns:\n        int or float: The sum of all numbers in the list.\n    \"\"\"\n    if not numbers:\n        return 0\n    else:\n        return numbers[0] + sum_recursive(numbers[1:])",
        "test_code": "def test_sum_recursive_empty_list():\n    assert sum_recursive([]) == 0\n\ndef test_sum_recursive_positive_numbers():\n    assert sum_recursive([1, 2, 3, 4, 5]) == 15\n\ndef test_sum_recursive_with_zeros():\n    assert sum_recursive([0, 0, 0, 0]) == 0\n\ndef test_sum_recursive_negative_numbers():\n    assert sum_recursive([-1, -2, -3, -4, -5]) == -15\n\ndef test_sum_recursive_mixed_numbers():\n    assert sum_recursive([-1, 1, -2, 2, -3, 3]) == 0\n\ndef test_sum_recursive_single_element():\n    assert sum_recursive([42]) == 42",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000004",
      "row_id": 4,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to convert a string to an integer. Consider edge cases where the string may contain leading or trailing whitespaces, and it might also contain invalid characters.",
    "response": "def str_to_int(s: str) -> int:\n    \"\"\"\n    Converts a string to an integer, handling leading/trailing whitespaces and invalid characters.\n    \"\"\"\n    s = s.strip()  # Remove leading and trailing whitespaces\n    if not s:  # Empty string after stripping\n        return 0\n    \n    sign = 1\n    i = 0\n    if s[0] == '-':  # Negative number\n        sign = -1\n        i = 1\n    elif s[0] == '+':\n        i = 1\n    \n    num = 0\n    for c in s[i:]:\n        if not '0' <= c <= '9':\n            break\n        num = num * 10 + (ord(c) - ord('0'))\n    \n    return max(-2**31, min(num * sign, 2**31 - 1))",
    "test_code": "import pytest\n\ndef test_str_to_int_valid():\n    assert str_to_int(\"42\") == 42\n    assert str_to_int(\"   -42\") == -42\n    assert str_to_int(\"4193 with words\") == 4193\n\ndef test_str_to_int_leading_whitespace():\n    assert str_to_int(\"     42\") == 42\n    assert str_to_int(\"     -42\") == -42\n\ndef test_str_to_int_trailing_whitespace():\n    assert str_to_int(\"42   \") == 42\n    assert str_to_int(\"-42   \") == -42\n\ndef test_str_to_int_invalid_characters():\n    assert str_to_int(\"4193.23+193\") == 4193\n    assert str_to_int(\"words and 987\") == 0\n    assert str_to_int(\"-91283472332\") == -2147483648  # Lower bound of int32\n\ndef test_str_to_int_empty_string():\n    assert str_to_int(\"\") == 0\n\ndef test_str_to_int_negative_with_space():\n    assert str_to_int(\"  -42abc\") == -42\n\ndef test_str_to_int_positive_with_space():\n    assert str_to_int(\"  +42abc\") == 42\n\ndef test_str_to_int_overflow():\n    assert str_to_int(\"2147483648\") == 2147483647  # Upper bound of int32\n    assert str_to_int(\"-2147483649\") == -2147483648  # Lower bound of int32",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def string_to_int(s: str) -> int:\n    \"\"\"\n    Converts a string to an integer, handling leading/trailing whitespaces and invalid characters.\n    Returns 0 for empty strings or strings with no valid digits.\n    \"\"\"\n    s = s.strip()\n    if not s:\n        return 0\n    \n    sign = 1\n    start = 0\n    if s[0] in ('-', '+'):\n        if s[0] == '-':\n            sign = -1\n        start = 1\n    \n    integer_value = 0\n    for i in range(start, len(s)):\n        if not s[i].isdigit():\n            break\n        integer_value = integer_value * 10 + int(s[i])\n    \n    if sign == -1:\n        integer_value *= -1\n    \n    return max(min(integer_value, 2**31 - 1), -2**31)",
        "test_code": "def test_string_to_int():\n    assert string_to_int(\"42\") == 42\n    assert string_to_int(\"   -42\") == -42\n    assert string_to_int(\"4193 with words\") == 4193\n    assert string_to_int(\"words and 987\") == 0\n    assert string_to_int(\"-91283472332\") == -2147483648 #\u8d85\u51faint\u8303\u56f4\u7684\u8d1f\u6570\u8f6c\u6362\u4e3a\u6700\u5c0fint\u503c\n    assert string_to_int(\"+1\") == 1\n    assert string_to_int(\"\") == 0\n    assert string_to_int(\"    \") == 0\n    assert string_to_int(\"+-2\") == 0 # \u6df7\u5408\u7b26\u53f7\uff0c\u5e94\u8be5\u89c6\u4e3a0\n    assert string_to_int(\"2147483647\") == 2147483647\n    assert string_to_int(\"-2147483648\") == -2147483648 # \u6309\u716732\u4f4d\u6574\u6570\u8303\u56f4\u8c03\u6574\n    assert string_to_int(\"2147483648\") == 2147483647 # \u8d85\u51fa\u8303\u56f4\u7684\u6b63\u6570\u8f6c\u6362\u4e3a\u6700\u5927int\u503c",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "import string\n\ndef str_to_int(s: str) -> int:\n    \"\"\"\n    Converts a string to an integer, considering edge cases with leading/trailing whitespaces and invalid characters.\n    \"\"\"\n    # Remove leading and trailing whitespaces\n    s = s.strip()\n    \n    if not s:\n        return 0\n    \n    sign = 1\n    i = 0\n    if s[0] == '-':\n        sign = -1\n        i = 1\n    elif s[0] == '+':\n        i = 1\n\n    int_val = 0\n    for char in s[i:]:\n        if char.isdigit():\n            int_val = int_val * 10 + int(char)\n        else:\n            break\n    \n    # Handle 32-bit signed integer range\n    INT_MAX = 2**31 - 1\n    INT_MIN = -2**31\n\n    if sign * int_val > INT_MAX:\n        return INT_MAX\n    elif sign * int_val < INT_MIN:\n        return INT_MIN\n    else:\n        return sign * int_val",
        "test_code": "import pytest\n\ndef test_str_to_int_positive():\n    assert str_to_int(\"42\") == 42\n    assert str_to_int('0000042') == 42\n\ndef test_str_to_int_negative():\n    assert str_to_int(\"-42\") == -42\n    assert str_to_int(\"-12345678901234567890\") == -2147483648  # INT_MIN\n\ndef test_invalid_characters():\n    assert str_to_int(\"   123abc\") == 123\n    assert str_to_int(\"abc123\") == 0  # No valid digit at the start\n\ndef test_empty_string():\n    assert str_to_int(\"\") == 0\n\ndef test_trailing_whitespace():\n    assert str_to_int(\"  -42\") == -42\n\ndef test_leading_whitespace():\n    assert str_to_int(\"42   \") == 42",
        "test_result": "Pass",
        "test_coverage": 92.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def str_to_int(s: str) -> int:\n    \"\"\"\n    Converts a string to an integer, handling leading/trailing whitespaces and invalid characters.\n    \"\"\"\n    s = s.strip()  # Remove leading and trailing whitespaces\n    if not s:  # Empty string after stripping\n        return 0\n    \n    sign = 1\n    i = 0\n    if s[0] == '-':  # Negative number\n        sign = -1\n        i = 1\n    elif s[0] == '+':\n        i = 1\n    \n    num = 0\n    for c in s[i:]:\n        if not '0' <= c <= '9':\n            break\n        num = num * 10 + (ord(c) - ord('0'))\n    \n    return max(-2**31, min(num * sign, 2**31 - 1))",
        "test_code": "import pytest\n\ndef test_str_to_int_valid():\n    assert str_to_int(\"42\") == 42\n    assert str_to_int(\"   -42\") == -42\n    assert str_to_int(\"4193 with words\") == 4193\n\ndef test_str_to_int_leading_whitespace():\n    assert str_to_int(\"     42\") == 42\n    assert str_to_int(\"     -42\") == -42\n\ndef test_str_to_int_trailing_whitespace():\n    assert str_to_int(\"42   \") == 42\n    assert str_to_int(\"-42   \") == -42\n\ndef test_str_to_int_invalid_characters():\n    assert str_to_int(\"4193.23+193\") == 4193\n    assert str_to_int(\"words and 987\") == 0\n    assert str_to_int(\"-91283472332\") == -2147483648  # Lower bound of int32\n\ndef test_str_to_int_empty_string():\n    assert str_to_int(\"\") == 0\n\ndef test_str_to_int_negative_with_space():\n    assert str_to_int(\"  -42abc\") == -42\n\ndef test_str_to_int_positive_with_space():\n    assert str_to_int(\"  +42abc\") == 42\n\ndef test_str_to_int_overflow():\n    assert str_to_int(\"2147483648\") == 2147483647  # Upper bound of int32\n    assert str_to_int(\"-2147483649\") == -2147483648  # Lower bound of int32",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000005",
      "row_id": 5,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to check if a given set of cevablar can win a greedy game played with blueblocks, greenblocks, and redblocks).",
    "response": "def can_win_game(cevablar):\n    \"\"\"\n    Checks if a given set of cevablar can win the game.\n    \n    Parameters:\n    cevablar (list): A list containing the number of blueblocks, greenblocks, and redblocks.\n    \n    Returns:\n    bool: True if the given set can win the game, False otherwise.\n    \"\"\"\n    blueblocks, greenblocks, redblocks = cevablar\n    # A player can win if they can form a sequence of blocks such that each block is of a different color\n    # This means there should be at least one block of each color\n    return blueblocks > 0 and greenblocks > 0 and redblocks > 0",
    "test_code": "from solution import can_win_game\n\ndef test_can_win_game_with_all_nonzero_blocks():\n    assert can_win_game([1, 1, 1]) == True\n\ndef test_can_win_game_with_one_zero_block():\n    assert can_win_game([0, 1, 1]) == False\n    assert can_win_game([1, 0, 1]) == False\n    assert can_win_game([1, 1, 0]) == False\n\ndef test_can_win_game_with_two_zero_blocks():\n    assert can_win_game([0, 0, 1]) == False\n    assert can_win_game([1, 0, 0]) == False\n\ndef test_can_win_game_with_zero_blocks():\n    assert can_win_game([0, 0, 0]) == False",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def can_win_game(cevablar):\n    \"\"\"\n    Returns True if the given set of cevablar (list of integers representing the number of blueblocks, greenblocks, and redblocks) \n    can win a greedy game, otherwise returns False.\n    A player wins if they can make more moves than their opponent.\n    A move consists of picking either a blueblock (decrementing the blueblock count by 1), a greenblock (decrementing the greenblock count by 2), or a redblock (decrementing the redblock count by 3).\n    \"\"\"\n    blueblocks, greenblocks, redblocks = cevablar\n    total_blocks = blueblocks + greenblocks + redblocks\n    green_blocks twice = greenblocks * 2\n    red_blocks\u4e09\u6b21 = redblocks * 3\n    \n    # The opponent's initial number of moves would be the sum of all blocks\n    opponent_moves = total_blocks\n    \n    # If the sum of all blocks is less than or equal to the opponent's initial moves, the player can't win\n    if total_blocks <= opponent_moves:\n        return False\n    \n    # The player's additional moves would be the sum of all blocks minus 2\n    player_moves = total_blocks - 2\n    \n    # Calculate the total possible moves for the player considering the initial moves of the opponent\n    player_possible_moves = (player_moves + 2) // 3 * 3 + (player_moves % 3 + 2) // 2 * 2 + player_moves % 3\n    \n    # If the player's total possible moves are greater than or equal to the opponent's moves, the player can win\n    return player_possible_moves >= opponent_moves",
        "test_code": "import pytest\n\ndef test_can_win_game():\n    assert can_win_game([1, 1, 1]) == False\n    assert can_win_game([0, 2, 2]) == True\n    assert can_win_game([1, 2, 3]) == True\n    assert can_win_game([2, 1, 1]) == False\n    assert can_win_game([3, 3, 3]) == True\n\ndef test_can_win_game_with_zeroes():\n    assert can_win_game([0, 0, 0]) == False\n    assert can_win_game([0, 1, 1]) == True\n    assert can_win_game([1, 0, 1]) == True\n    assert can_win_game([1, 1, 0]) == True\n\ndef test_can_win_game_with_large_numbers():\n    assert can_win_game([5, 7, 9]) == True\n    assert can_win_game([10, 10, 10]) == True\n    assert can_win_game([20, 15, 10]) == True\n    assert can_win_game([50, 50, 50]) == True",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def can_win_game(cevablar):\n    \"\"\"\n    Checks if a given set of cevablar can win the game.\n    \n    Parameters:\n    cevablar (list): A list containing the number of blueblocks, greenblocks, and redblocks.\n    \n    Returns:\n    bool: True if the given set can win the game, False otherwise.\n    \"\"\"\n    blueblocks, greenblocks, redblocks = cevablar\n    # A player can win if they can form a sequence of blocks such that each block is of a different color\n    # This means there should be at least one block of each color\n    return blueblocks > 0 and greenblocks > 0 and redblocks > 0",
        "test_code": "from solution import can_win_game\n\ndef test_can_win_game_with_all_nonzero_blocks():\n    assert can_win_game([1, 1, 1]) == True\n\ndef test_can_win_game_with_one_zero_block():\n    assert can_win_game([0, 1, 1]) == False\n    assert can_win_game([1, 0, 1]) == False\n    assert can_win_game([1, 1, 0]) == False\n\ndef test_can_win_game_with_two_zero_blocks():\n    assert can_win_game([0, 0, 1]) == False\n    assert can_win_game([1, 0, 0]) == False\n\ndef test_can_win_game_with_zero_blocks():\n    assert can_win_game([0, 0, 0]) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def can_win_greedy_game(blueblocks, greenblocks, redblocks):\n    \"\"\"\n    Returns True if the given set of blocks can win the greedy game, \n    otherwise returns False. A player can win the game if they can \n    make a strictly increasing sequence of blocks, where each block's \n    value is greater than the previous block's value.\n    \"\"\"\n    total_blocks = blueblocks + greenblocks + redblocks\n    if total_blocks < 3:\n        return False\n    if blueblocks > 0 and greenblocks > 0 and redblocks > 0:\n        return True\n    if blueblocks > 0 and redblocks > 0:\n        return True\n    if greenblocks > 0 and redblocks > 0:\n        return True\n    return False",
        "test_code": "from solution import can_win_greedy_game\n\ndef test_can_win_greedy_game_all_blocks():\n    assert can_win_greedy_game(1, 1, 1) == True\n\ndef test_can_win_greedy_game_two_blocks():\n    assert can_win_greedy_game(1, 0, 1) == True\n    assert can_win_greedy_game(0, 1, 1) == True\n    assert can_win_greedy_game(1, 1, 0) == True\n\ndef test_cannot_win_greedy_game_less_than_three_blocks():\n    assert can_win_greedy_game(0, 0, 0) == False\n    assert can_win_greedy_game(1, 0, 0) == False\n    assert can_win_greedy_game(0, 1, 0) == False\n    assert can_win_greedy_game(0, 0, 1) == False\n\ndef test_cannot_win_greedy_game_no_common_blocks():\n    assert can_win_greedy_game(0, 0, 0) == False\n    assert can_win_greedy_game(0, 0, 1) == False\n    assert can_win_greedy_game(0, 1, 0) == False\n    assert can_win_greedy_game(1, 0, 0) == False\n\ndef test_can_win_greedy_game_single_block():\n    assert can_win_greedy_game(1, 0, 0) == True\n    assert can_win_greedy_game(0, 1, 0) == True\n    assert can_win_greedy_game(0, 0, 1) == True",
        "test_result": "Fail",
        "test_coverage": 55.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000007",
      "row_id": 7,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the maximum product of a subarray within a given array of integers. The function should work for both positive and negative numbers.",
    "response": "def max_product_subarray(nums):\n    \"\"\"\n    Returns the maximum product of a subarray within the given array of integers.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_product = min_product = result = nums[0]\n    \n    for num in nums[1:]:\n        temp_max = max(num, max_product * num, min_product * num)\n        min_product = min(num, max_product * num, min_product * num)\n        max_product = temp_max\n        \n        result = max(result, max_product)\n        \n    return result",
    "test_code": "from solution import max_product_subarray\n\ndef test_max_product_subarray_positive_numbers():\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n\ndef test_max_product_subarray_mixed_sign_numbers():\n    assert max_product_subarray([-2, 0, -1]) == 0\n\ndef test_max_product_subarray_large_numbers():\n    assert max_product_subarray([0, 2]) == 2\n    assert max_product_subarray([-1, -2, -3, 0]) == 6\n\ndef test_max_product_subarray_single_element():\n    assert max_product_subarray([1]) == 1\n\ndef test_max_product_subarray_all_negative():\n    assert max_product_subarray([-1, -2, -3, -4]) == 24\n\ndef test_max_product_subarray_all_positive():\n    assert max_product_subarray([1, 2, 3, 4]) == 24\n\ndef test_max_product_subarray_with_zero():\n    assert max_product_subarray([0, 2, 3, -5]) == 6",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def max_product_subarray(nums):\n    \"\"\"\n    Finds the maximum product of a subarray within the given array of integers.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_product = min_product = result = nums[0]\n    \n    for num in nums[1:]:\n        temp_max = max(num, max_product * num, min_product * num)\n        min_product = min(num, max_product * num, min_product * num)\n        max_product = temp_max\n        \n        result = max(result, max_product)\n    \n    return result",
        "test_code": "from solution import max_product_subarray\n\ndef test_max_product_subarray_positive_numbers():\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n    assert max_product_subarray([0, 2]) == 2\n\ndef test_max_product_subarray_negative_numbers():\n    assert max_product_subarray([-2, 0, -1]) == 0\n    assert max_product_subarray([-2, 3, -4]) == 24\n\ndef test_max_product_subarray_mixed_numbers():\n    assert max_product_subarray([0, -1, 2, -3, 5]) == 75\n    assert max_product_subarray([-1, -2, -3, 0]) == 6\n\ndef test_max_product_subarray_single_element():\n    assert max_product_subarray([2]) == 2\n\ndef test_max_product_subarray_empty_array():\n    assert max_product_subarray([]) == 0",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def max_product_subarray(nums):\n    \"\"\"\n    Returns the maximum product of a subarray within the given array of integers.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_product = min_product = result = nums[0]\n    \n    for num in nums[1:]:\n        temp_max = max(num, max_product * num, min_product * num)\n        min_product = min(num, max_product * num, min_product * num)\n        max_product = temp_max\n        \n        result = max(result, max_product)\n        \n    return result",
        "test_code": "from solution import max_product_subarray\n\ndef test_max_product_subarray_positive_numbers():\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n\ndef test_max_product_subarray_mixed_sign_numbers():\n    assert max_product_subarray([-2, 0, -1]) == 0\n\ndef test_max_product_subarray_large_numbers():\n    assert max_product_subarray([0, 2]) == 2\n    assert max_product_subarray([-1, -2, -3, 0]) == 6\n\ndef test_max_product_subarray_single_element():\n    assert max_product_subarray([1]) == 1\n\ndef test_max_product_subarray_all_negative():\n    assert max_product_subarray([-1, -2, -3, -4]) == 24\n\ndef test_max_product_subarray_all_positive():\n    assert max_product_subarray([1, 2, 3, 4]) == 24\n\ndef test_max_product_subarray_with_zero():\n    assert max_product_subarray([0, 2, 3, -5]) == 6",
        "test_result": "Pass",
        "test_coverage": 90.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def max_product_subarray(nums):\n    \"\"\"\n    Returns the maximum product of a contiguous subarray within the input array.\n    \"\"\"\n    if not nums:\n        return 0\n\n    max_product = min_product = result = nums[0]\n\n    for num in nums[1:]:\n        candidates = (max_product * num, min_product * num, num)\n        max_product = max(candidates)\n        min_product = min(candidates)\n        result = max(result, max_product)\n\n    return result",
        "test_code": "from solution import max_product_subarray\n\ndef test_max_product_subarray_positive_numbers():\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n\ndef test_max_product_subarray_with_zero():\n    assert max_product_subarray([2, 0, -2, 4]) == 8\n\ndef test_max_product_subarray_negative_numbers():\n    assert max_product_subarray([-2, 0, -1]) == 0\n\ndef test_max_product_subarray_mixed_sign_numbers():\n    assert max_product_subarray([-2, -3, 7]) == 42\n\ndef test_max_product_subarray_single_element():\n    assert max_product_subarray([2]) == 2\n\ndef test_max_product_subarray_all_negative():\n    assert max_product_subarray([-1, -2, -3, -4]) == 24\n\ndef test_max_product_subarray_empty_array():\n    assert max_product_subarray([]) == 0",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000011",
      "row_id": 11,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to convert a Celsius temperature to Fahrenheit.",
    "response": "def celsius_to_fahrenheit(celsius):\n    \"\"\"\n    Converts a temperature from Celsius to Fahrenheit.\n    \n    Parameters:\n    celsius (float): Temperature in Celsius.\n    \n    Returns:\n    float: Temperature in Fahrenheit.\n    \"\"\"\n    return (celsius * 9/5) + 32",
    "test_code": "from solution import celsius_to_fahrenheit\n\ndef test_celsius_to_fahrenheit_freezing_point():\n    assert celsius_to_fahrenheit(0) == 32.0\n\ndef test_celsius_to_fahrenheit_boiling_point():\n    assert celsius_to_fahrenheit(100) == 212.0\n\ndef test_celsius_to_fahrenheit_room_temperature():\n    assert celsius_to_fahrenheit(25) == 77.0\n\ndef test_celsius_to_fahrenheit_negative_temperature():\n    assert celsius_to_fahrenheit(-40) == -40.0\n\ndef test_celsius_to_fahrenheit_freezing_point_reverse():\n    assert round(celsius_to_fahrenheit(0) - 32, 1) == 0  # Using round to allow for floating point precision issues",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def celsius_to_fahrenheit(celsius):\n    \"\"\"\n    Converts a temperature from Celsius to Fahrenheit.\n    Formula used: F = (C * 9/5) + 32\n    \"\"\"\n    return (celsius * 9/5) + 32",
        "test_code": "from solution import celsius_to_fahrenheit\n\ndef test_celsius_to_fahrenheit_freezing_point():\n    assert celsius_to_fahrenheit(0) == 32\n\ndef test_celsius_to_fahrenheit_boiling_point():\n    assert celsius_to_fahrenheit(100) == 212\n\ndef test_celsius_to_fahrenheit_room_temperature():\n    assert celsius_to_fahrenheit(25) == 77\n\ndef test_celsius_to_fahrenheit_negative_temperature():\n    assert celsius_to_fahrenheit(-40) == -40\n\ndef test_celsius_to_fahrenheit_float_temperature():\n    assert celsius_to_fahrenheit(23.5) == 74.3",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def celsius_to_fahrenheit(celsius):\n    \"\"\"\n    Converts a temperature from Celsius to Fahrenheit.\n    \n    Parameters:\n    celsius (float): Temperature in Celsius.\n    \n    Returns:\n    float: Temperature in Fahrenheit.\n    \"\"\"\n    return (celsius * 9/5) + 32",
        "test_code": "from solution import celsius_to_fahrenheit\n\ndef test_celsius_to_fahrenheit():\n    assert round(celsius_to_fahrenheit(0), 2) == 32.00\n\ndef test_celsius_to_fahrenheit_positive():\n    assert round(celsius_to_fahrenheit(100), 2) == 212.00\n\ndef test_celsius_to_fahrenheit_negative():\n    assert round(celsius_to_fahrenheit(-40), 2) == -40.00\n\ndef test_celsius_to_fahrenheit_half():\n    assert round(celsius_to_fahrenheit(-273.15), 2) == -459.67",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def celsius_to_fahrenheit(celsius):\n    \"\"\"\n    Converts a temperature from Celsius to Fahrenheit.\n    \n    Parameters:\n    celsius (float): Temperature in Celsius.\n    \n    Returns:\n    float: Temperature in Fahrenheit.\n    \"\"\"\n    return (celsius * 9/5) + 32",
        "test_code": "from solution import celsius_to_fahrenheit\n\ndef test_celsius_to_fahrenheit_freezing_point():\n    assert celsius_to_fahrenheit(0) == 32.0\n\ndef test_celsius_to_fahrenheit_boiling_point():\n    assert celsius_to_fahrenheit(100) == 212.0\n\ndef test_celsius_to_fahrenheit_room_temperature():\n    assert celsius_to_fahrenheit(25) == 77.0\n\ndef test_celsius_to_fahrenheit_negative_temperature():\n    assert celsius_to_fahrenheit(-40) == -40.0\n\ndef test_celsius_to_fahrenheit_freezing_point_reverse():\n    assert round(celsius_to_fahrenheit(0) - 32, 1) == 0  # Using round to allow for floating point precision issues",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000017",
      "row_id": 17,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to calculate and return the area of a triangle given its base and height.",
    "response": "def triangle_area(base, height):\n    \"\"\"\n    Returns the area of a triangle given its base and height.\n    \"\"\"\n    return 0.5 * base * height",
    "test_code": "from solution import triangle_area\n\ndef test_triangle_area_positive_numbers():\n    assert triangle_area(2, 3) == 3.0\n\ndef test_triangle_area_with_zero():\n    assert triangle_area(0, 5) == 0.0\n    assert triangle_area(5, 0) == 0.0\n\ndef test_triangle_area_negative_numbers():\n    assert triangle_area(-1, -1) == 0.5\n\ndef test_triangle_area_mixed_sign_numbers():\n    assert triangle_area(-1, 3) == -1.5",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def triangle_area(base, height):\n    \"\"\"\n    Returns the area of a triangle given its base and height.\n    \"\"\"\n    return 0.5 * base * height",
        "test_code": "from solution import triangle_area\n\ndef test_triangle_area_positive_numbers():\n    assert triangle_area(2, 3) == 3.0\n\ndef test_triangle_area_with_zero():\n    assert triangle_area(0, 5) == 0.0\n    assert triangle_area(5, 0) == 0.0\n\ndef test_triangle_area_negative_numbers():\n    assert triangle_area(-1, -1) == 0.5\n\ndef test_triangle_area_mixed_sign_numbers():\n    assert triangle_area(-1, 3) == -1.5",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      }
    },
    "pass_sequence": [
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000020",
      "row_id": 20,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the sum of all even numbers in a list.",
    "response": "def sum_of_even_numbers(numbers_list):\n    \"\"\"\n    Returns the sum of all even numbers in the given list.\n    \"\"\"\n    return sum(num for num in numbers_list if num % 2 == 0)",
    "test_code": "from solution import sum_of_even_numbers\n\ndef test_sum_of_even_numbers_empty_list():\n    assert sum_of_even_numbers([]) == 0\n\ndef test_sum_of_even_numbers_no_even_numbers():\n    assert sum_of_even_numbers([1, 3, 5, 7]) == 0\n\ndef test_sum_of_even_numbers_single_even_number():\n    assert sum_of_even_numbers([2]) == 2\n\ndef test_sum_of_even_numbers_multiple_even_numbers():\n    assert sum_of_even_numbers([2, 4, 6, 8]) == 20\n\ndef test_sum_of_even_numbers_mixed_numbers():\n    assert sum_of_even_numbers([1, 2, 3, 4, 5, 6]) == 12",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def sum_of_even_numbers(numbers_list):\n    \"\"\"\n    Returns the sum of all even numbers in the given list.\n    \"\"\"\n    return sum(num for num in numbers_list if num % 2 == 0)",
        "test_code": "from solution import sum_of_even_numbers\n\ndef test_sum_of_even_numbers_empty_list():\n    assert sum_of_even_numbers([]) == 0\n\ndef test_sum_of_even_numbers_no_even_numbers():\n    assert sum_of_even_numbers([1, 3, 5, 7]) == 0\n\ndef test_sum_of_even_numbers_single_even_number():\n    assert sum_of_even_numbers([2]) == 2\n\ndef test_sum_of_even_numbers_multiple_even_numbers():\n    assert sum_of_even_numbers([2, 4, 6, 8]) == 20\n\ndef test_sum_of_even_numbers_mixed_numbers():\n    assert sum_of_even_numbers([1, 2, 3, 4, 5, 6]) == 12",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def sum_of_evens(numbers):\n    \"\"\"\n    Returns the sum of all even numbers in the given list.\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)",
        "test_code": "from solution import sum_of_evens\n\ndef test_sum_of_evens_empty_list():\n    assert sum_of_evens([]) == 0\n\ndef test_sum_of_evens_all_evens():\n    assert sum_of_evens([2, 4, 6, 8]) == 20\n\ndef test_sum_of_evens_mixed Numbers():\n    assert sum_of_evens([1, 2, 3, 4, 5, 6]) == 12\n\ndef test_sum_of_evens_with_odds():\n    assert sum_of_evens([1, 3, 5, 7]) == 0\n\ndef test_sum_of_evens_negative_and_positive():\n    assert sum_of_evens([-2, 2, -4, 4]) == 0",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000021",
      "row_id": 21,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the number of paths from the top-left corner to the bottom-right corner of an M x N grid, where you can only move either down or right at any point in time. The function should handle cases where the grid size can be as large as 10x10 for efficiency. Use memoization to optimize the algorithm.",
    "response": "def count_paths(m, n, memo={}):\n    \"\"\"\n    Returns the number of unique paths from the top-left corner to the bottom-right corner\n    of an M x N grid. Movement is restricted to only down or right.\n    \"\"\"\n    key = (m, n)\n    if key in memo:\n        return memo[key]\n    if m == 1 or n == 1:\n        return 1  # Base case: if either dimension is 1, there's only one way to reach the end\n    memo[key] = count_paths(m - 1, n, memo) + count_paths(m, n - 1, memo)\n    return memo[key]",
    "test_code": "from solution import count_paths\n\ndef test_count_paths_small_grid():\n    assert count_paths(2, 2) == 2\n\ndef test_count_paths_medium_grid():\n    assert count_paths(3, 3) == 6\n\ndef test_count_paths_large_grid():\n    assert count_paths(5, 5) == 70\n\ndef test_count_paths_one_row_or_column():\n    assert count_paths(1, 10) == 1\n    assert count_paths(10, 1) == 1\n\ndef test_count_paths_memoization():\n    # This tests the dynamic programming memoization effect by calling the function\n    # multiple times with the same inputs to check if it returns the cached result directly\n    count_paths(3, 3)\n    assert count_paths(3, 3) == 6  # Verifies the result comes from memoization",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def num_paths_memo(m, n, memo={}):\n    \"\"\"\n    Returns the number of unique paths from the top-left corner to the bottom-right corner of an M x N grid.\n    Can only move down or right.\n    Uses memoization for optimization.\n    \"\"\"\n    if (m, n) in memo:\n        return memo[(m, n)]\n    if m == 1 or n == 1:\n        return 1\n    memo[(m, n)] = num_paths_memo(m - 1, n, memo) + num_paths_memo(m, n - 1, memo)\n    return memo[(m, n)]",
        "test_code": "from solution import num_paths_memo\n\ndef test_num_paths_memo():\n    assert num_paths_memo(2, 3) == 3\n    assert num_paths_memo(3, 2) == 3\n    assert num_paths_memo(3, 3) == 6\n    assert num_paths_memo(1, 1) == 1\n    assert num_paths_memo(3, 7) == 28\n    assert num_paths_memo(5, 5) == 70",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "import functools\n\ndef count_paths(m, n):\n    \"\"\"\n    Returns the number of paths from the top-left corner to the bottom-right corner of an M x N grid.\n    Movement is restricted to down and right.\n    \"\"\"\n    @functools.lru_cache(maxsize=None)\n    def dp(r, c):\n        if r == 0 or c == 0:\n            return 1\n        return dp(r - 1, c) + dp(r, c - 1)\n    \n    return dp(m - 1, n - 1)",
        "test_code": "from solution import count_paths\n\ndef test_count_paths_small_grid():\n    assert count_paths(2, 2) == 2\n\ndef test_count_paths_medium_grid():\n    assert count_paths(3, 3) == 6\n    assert count_paths(4, 3) == 10\n    assert count_paths(3, 4) == 10\n\ndef test_count_paths_large_grid():\n    assert count_paths(10, 10) == 184756\n\ndef test_count_paths_with_m_equal_n():\n    for i in range(1, 11):\n        assert count_paths(i, i) == (2 * i - 2) // 2 + 1",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def count_paths(m, n, memo={}):\n    \"\"\"\n    Returns the number of unique paths from the top-left corner to the bottom-right corner\n    of an M x N grid. Movement is restricted to only down or right.\n    \"\"\"\n    key = (m, n)\n    if key in memo:\n        return memo[key]\n    if m == 1 or n == 1:\n        return 1  # Base case: if either dimension is 1, there's only one way to reach the end\n    memo[key] = count_paths(m - 1, n, memo) + count_paths(m, n - 1, memo)\n    return memo[key]",
        "test_code": "from solution import count_paths\n\ndef test_count_paths_small_grid():\n    assert count_paths(2, 2) == 2\n\ndef test_count_paths_medium_grid():\n    assert count_paths(3, 3) == 6\n\ndef test_count_paths_large_grid():\n    assert count_paths(5, 5) == 70\n\ndef test_count_paths_one_row_or_column():\n    assert count_paths(1, 10) == 1\n    assert count_paths(10, 1) == 1\n\ndef test_count_paths_memoization():\n    # This tests the dynamic programming memoization effect by calling the function\n    # multiple times with the same inputs to check if it returns the cached result directly\n    count_paths(3, 3)\n    assert count_paths(3, 3) == 6  # Verifies the result comes from memoization",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000024",
      "row_id": 24,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to calculate the factorial of a number using recursion. The function should take an integer as an argument and return the factorial of that number.",
    "response": "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a number using recursion.\n    \n    Args:\n    n (int): The input number whose factorial is to be calculated.\n    \n    Returns:\n    int: The factorial of the input number.\n    \n    Raises:\n    ValueError: If the input is a negative integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)",
    "test_code": "from solution import factorial\n\ndef test_factorial_positive_numbers():\n    assert factorial(5) == 120\n    assert factorial(3) == 6\n    assert factorial(1) == 1\n\ndef test_factorial_zero():\n    assert factorial(0) == 1\n\ndef test_factorial_negative_numbers():\n    try:\n        factorial(-1)\n        assert False, \"Expected ValueError for negative input\"\n    except ValueError as e:\n        assert str(e) == \"Factorial is not defined for negative numbers\"\n\ndef test_factorial_large_numbers():\n    assert factorial(10) == 3628800",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def factorial(n):\n    \"\"\"\n    Calculates the factorial of a number using recursion.\n    :param n: Integer, the number to calculate the factorial for.\n    :return: Integer, the factorial of n.\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)",
        "test_code": "from solution import factorial\n\ndef test_factorial_zero():\n    assert factorial(0) == 1\n\ndef test_factorial_positive_numbers():\n    assert factorial(5) == 120\n    assert factorial(3) == 6\n\ndef test_factorial_one():\n    assert factorial(1) == 1\n\ndef test_factorial_large_number():\n    assert factorial(10) == 3628800\n\ndef test_factorial_negative_number():\n    try:\n        factorial(-1)\n    except ValueError:\n        pass\n    else:\n        assert False, \"Expected ValueError for negative input\"",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a number using recursion.\n    \n    Args:\n    n (int): The input number whose factorial is to be calculated.\n    \n    Returns:\n    int: The factorial of the input number.\n    \n    Raises:\n    ValueError: If the input is a negative integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)",
        "test_code": "from solution import factorial\n\ndef test_factorial_positive_numbers():\n    assert factorial(5) == 120\n    assert factorial(3) == 6\n    assert factorial(1) == 1\n\ndef test_factorial_zero():\n    assert factorial(0) == 1\n\ndef test_factorial_negative_numbers():\n    try:\n        factorial(-1)\n        assert False, \"Expected ValueError for negative input\"\n    except ValueError as e:\n        assert str(e) == \"Factorial is not defined for negative numbers\"\n\ndef test_factorial_large_numbers():\n    assert factorial(10) == 3628800",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def factorial(n):\n    \"\"\"\n    Returns the factorial of n using recursion.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)",
        "test_code": "from solution import factorial\n\ndef test_factorial_zero():\n    assert factorial(0) == 1\n\ndef test_factorial_one():\n    assert factorial(1) == 1\n\ndef test_factorial_positive_numbers():\n    assert factorial(5) == 120\n    assert factorial(4) == 24\n    assert factorial(3) == 6\n\ndef test_factorial_negative_numbers():\n    assert factorial(-1) == 1  # This should not happen. Factorial is not defined for negative numbers. But included for completeness.",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000026",
      "row_id": 26,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the union of elements in two lists.",
    "response": "def union_of_lists(list1, list2):\n    \"\"\"\n    Returns the union of elements in two lists.\n    \n    Args:\n    list1: First input list.\n    list2: Second input list.\n    \n    Returns:\n    A list containing the union of the two input lists, without duplicates.\n    \"\"\"\n    return list(set(list1 + list2))",
    "test_code": "def test_union_of_lists():\n    assert union_of_lists([1, 2, 3], [3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert union_of_lists([1, 2, 2, 3], [3, 3, 4, 4, 5]) == [1, 2, 3, 4, 5]\n    assert union_of_lists([], [1, 2, 3]) == [1, 2, 3]\n    assert union_of_lists([1, 2, 3], []) == [1, 2, 3]\n    assert union_of_lists([], []) == []",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def union_of_lists(list1, list2):\n    \"\"\"\n    Returns the union of elements in two lists.\n    \n    Args:\n    list1: First input list.\n    list2: Second input list.\n    \n    Returns:\n    A list containing the union of the two input lists, without duplicates.\n    \"\"\"\n    return list(set(list1 + list2))",
        "test_code": "def test_union_of_lists():\n    assert union_of_lists([1, 2, 3], [3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert union_of_lists([1, 2, 2, 3], [3, 3, 4, 4, 5]) == [1, 2, 3, 4, 5]\n    assert union_of_lists([], [1, 2, 3]) == [1, 2, 3]\n    assert union_of_lists([1, 2, 3], []) == [1, 2, 3]\n    assert union_of_lists([], []) == []",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def find_union(list1, list2):\n    \"\"\"\n    Returns a list containing unique elements that are present in both list1 and list2.\n    \"\"\"\n    return list(set(list1 + list2))",
        "test_code": "from solution import find_union\n\ndef test_find_union_with_unique_elements():\n    assert find_union([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n\ndef test_find_union_with_common_elements():\n    assert find_union([1, 2, 2, 3], [2, 3, 3, 4]) == [1, 2, 3, 4]\n\ndef test_find_union_with_mixed_data_types():\n    assert find_union([1, 'a', 3], [2, 'a', 4]) == [1, 2, 3, 'a', 4]\n\ndef test_find_union_with_no_intersection():\n    assert find_union([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n\ndef test_find_union_with_empty_lists():\n    assert find_union([], []) == []\n    assert find_union([], [1, 2, 3]) == [1, 2, 3]\n    assert find_union([1, 2, 3], []) == [1, 2, 3]",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000027",
      "row_id": 27,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to check if a given string is a valid double (a number with a decimal point).",
    "response": "import re\n\ndef is_valid_double(s):\n    \"\"\"\n    Returns True if the given string is a valid double, False otherwise.\n    \"\"\"\n    pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\n    return bool(re.match(pattern, s))",
    "test_code": "import re\nfrom solution import is_valid_double\n\ndef test_is_valid_double_positive_numbers():\n    assert is_valid_double(\"123.456\") == True\n\ndef test_is_valid_double_negative_numbers():\n    assert is_valid_double(\"-123.456\") == True\n\ndef test_is_valid_double_numbers_with_exponent():\n    assert is_valid_double(\"123.456e-2\") == True\n    assert is_valid_double(\"-123.456E+2\") == True\n\ndef test_is_valid_double_invalid_exponent():\n    assert is_valid_double(\"123.e.2\") == False\n\ndef test_is_valid_double_additional_characters():\n    assert is_valid_double(\".123\") == True\n    assert is_valid_double(\"123.\") == True\n    assert is_valid_double(\"123.0\") == True\n    assert is_valid_double(\"123e\") == False\n    assert is_valid_double(\"abc123.456\") == False\n    assert is_valid_double(\"123.456abc\") == False\n\ndef test_is_valid_double_edge_cases():\n    assert is_valid_double(\"\") == False\n    assert is_valid_double(\"e123\") == False\n    assert is_valid_double(\".e123\") == False\n    assert is_valid_double(\"123.e\") == False\n    assert is_valid_double(\"123e.\") == False\n    assert is_valid_double(\"+123.456\") == True\n    assert is_valid_double(\"-.456\") == True\n    assert is_valid_double(\".\") == False",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "import re\n\ndef is_valid_double(s):\n    \"\"\"\n    Returns True if the input string is a valid double, otherwise False.\n    \"\"\"\n    # Regular expression for matching valid doubles\n    double_pattern = r'^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$'\n    return bool(re.match(double_pattern, s))",
        "test_code": "import pytest\n\ndef test_is_valid_double():\n    assert is_valid_double(\"123.456\") == True\n    assert is_valid_double(\"-123.456\") == True\n    assert is_valid_double(\"+123.456\") == True\n    assert is_valid_double(\"123\") == True\n    assert is_valid_double(\".456\") == True\n    assert is_valid_double(\"123.\") == True\n    assert is_valid_double(\"123.456e-7\") == True\n    assert is_valid_double(\"123.456E7\") == True\n    assert is_valid_double(\"123.456e+7\") == True\n    assert is_valid_double(\"123.456E+7\") == True\n    assert is_valid_double(\"123.\") == True\n    assert is_valid_double(\".123\") == True\n    assert is_valid_double(\"123.123.123\") == False\n    assert is_valid_double(\"abc\") == False\n    assert is_valid_double(\"\") == False\n    assert is_valid_double(\"123e\") == False\n    assert is_valid_double(\"e123\") == False\n    assert is_valid_double(\"123e5.45\") == False\n    assert is_valid_double(\"--123.456\") == False\n    assert is_valid_double(\"-+123.456\") == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "import re\n\ndef is_valid_double(s):\n    \"\"\"\n    Returns True if the given string is a valid double, False otherwise.\n    \"\"\"\n    pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\n    return bool(re.match(pattern, s))",
        "test_code": "import re\nfrom solution import is_valid_double\n\ndef test_is_valid_double_positive_numbers():\n    assert is_valid_double(\"123.456\") == True\n\ndef test_is_valid_double_negative_numbers():\n    assert is_valid_double(\"-123.456\") == True\n\ndef test_is_valid_double_numbers_with_exponent():\n    assert is_valid_double(\"123.456e-2\") == True\n    assert is_valid_double(\"-123.456E+2\") == True\n\ndef test_is_valid_double_invalid_exponent():\n    assert is_valid_double(\"123.e.2\") == False\n\ndef test_is_valid_double_additional_characters():\n    assert is_valid_double(\".123\") == True\n    assert is_valid_double(\"123.\") == True\n    assert is_valid_double(\"123.0\") == True\n    assert is_valid_double(\"123e\") == False\n    assert is_valid_double(\"abc123.456\") == False\n    assert is_valid_double(\"123.456abc\") == False\n\ndef test_is_valid_double_edge_cases():\n    assert is_valid_double(\"\") == False\n    assert is_valid_double(\"e123\") == False\n    assert is_valid_double(\".e123\") == False\n    assert is_valid_double(\"123.e\") == False\n    assert is_valid_double(\"123e.\") == False\n    assert is_valid_double(\"+123.456\") == True\n    assert is_valid_double(\"-.456\") == True\n    assert is_valid_double(\".\") == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "import re\n\ndef is_valid_double(s):\n    \"\"\"\n    Returns True if the string is a valid double, False otherwise.\n    A valid double is defined as a number with a decimal point.\n    \"\"\"\n    # Regular expression to match a valid double\n    double_pattern = re.compile(r'^-?\\d+(?:\\.\\d+)?$')\n    return bool(double_pattern.match(s))",
        "test_code": "import pytest\n\ndef test_is_valid_double_positive():\n    assert is_valid_double(\"123.456\") == True\n    assert is_valid_double(\"-123.456\") == True\n\ndef test_is_valid_double_decimal_only():\n    assert is_valid_double(\".456\") == True\n\ndef test_is_valid_double_integer():\n    assert is_valid_double(\"123\") == False\n    assert is_valid_double(\"-123\") == False\n\ndef test_is_valid_double_negative():\n    assert is_valid_double(\"-.456\") == True\n\ndef test_is_valid_double_empty():\n    assert is_valid_double(\"\") == False\n\ndef test_is_valid_double_special_chars():\n    assert is_valid_double(\"123.456.789\") == False\n    assert is_valid_double(\"123..456\") == False\n    assert is_valid_double(\"abc\") == False\n    assert is_valid_double(\"123..\") == False\n    assert is_valid_double(\".123\") == True\n    assert is_valid_double(\"123.\") == True",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      0
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000028",
      "row_id": 28,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to implement a simple bubble sort algorithm.",
    "response": "def bubble_sort(arr):\n    \"\"\"\n    Sorts an array using the bubble sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Flag to detect any swap\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                # Swap arr[j] and arr[j+1]\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        # If no two elements were swapped by inner loop, then break\n        if not swapped:\n            break\n    return arr",
    "test_code": "import pytest\nfrom solution import bubble_sort\n\ndef test_bubble_sort_positive_numbers():\n    assert bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]\n\ndef test_bubble_sort_negative_numbers():\n    assert bubble_sort([-2, -34, -60, -1, -50]) == [-60, -50, -34, -2, -1]\n\ndef test_bubble_sort_mixed_sign_numbers():\n    assert bubble_sort([-2, 34, -60, 12, -50, 72]) == [-60, -50, -2, 12, 34, 72]\n\ndef test_bubble_sort_single_element():\n    assert bubble_sort([5]) == [5]\n\ndef test_bubble_sort_empty_list():\n    assert bubble_sort([]) == []\n\ndef test_bubble_sort_already_sorted():\n    assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_duplicate_elements():\n    assert bubble_sort([4, 2, 1, 2, 3, 4]) == [1, 2, 2, 3, 4, 4]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def bubble_sort(arr):\n    \"\"\"\n    Sorts an array using the bubble sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Create a flag that will allow the function to terminate early if there's nothing left to sort\n        already_sorted = True\n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                # Swap if the element found is greater than the next element\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                already_sorted = False\n        # If there were no swaps during the last iteration, the array is already sorted, and we can terminate\n        if already_sorted:\n            break\n    return arr",
        "test_code": "from solution import bubble_sort\n\ndef test_bubble_sort_empty():\n    assert bubble_sort([]) == []\n\ndef test_bubble_sort_single_element():\n    assert bubble_sort([5]) == [5]\n\ndef test_bubble_sort_already_sorted():\n    assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_descending_order():\n    assert bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_random_numbers():\n    assert bubble_sort([34, 12, 24, 9, 5]) == [5, 9, 12, 24, 34]\n\ndef test_bubble_sort_with_duplicates():\n    assert bubble_sort([2, 4, 1, 2, 3]) == [1, 2, 2, 3, 4]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def bubble_sort(arr):\n    \"\"\"\n    Sorts an array using the bubble sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Flag to detect any swap\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                # Swap arr[j] and arr[j+1]\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        # If no two elements were swapped by inner loop, then break\n        if not swapped:\n            break\n    return arr",
        "test_code": "import pytest\nfrom solution import bubble_sort\n\ndef test_bubble_sort_positive_numbers():\n    assert bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]\n\ndef test_bubble_sort_negative_numbers():\n    assert bubble_sort([-2, -34, -60, -1, -50]) == [-60, -50, -34, -2, -1]\n\ndef test_bubble_sort_mixed_sign_numbers():\n    assert bubble_sort([-2, 34, -60, 12, -50, 72]) == [-60, -50, -2, 12, 34, 72]\n\ndef test_bubble_sort_single_element():\n    assert bubble_sort([5]) == [5]\n\ndef test_bubble_sort_empty_list():\n    assert bubble_sort([]) == []\n\ndef test_bubble_sort_already_sorted():\n    assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_duplicate_elements():\n    assert bubble_sort([4, 2, 1, 2, 3, 4]) == [1, 2, 2, 3, 4, 4]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def bubble_sort(arr):\n    \"\"\"\n    Sorts a list of numbers using the bubble sort algorithm.\n    \n    Parameters:\n    arr (list): The list of numbers to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Create a flag that will allow the function to terminate early if there's nothing left to sort\n        swapped = False\n        for j in range(0, n-i-1):\n            # Swap if the element found is greater than the next element\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        # If no elements were swapped by inner loop, then break\n        if not swapped:\n            break\n    return arr",
        "test_code": "import pytest\n\ndef test_bubble_sort_empty_list():\n    assert bubble_sort([]) == []\n\ndef test_bubble_sort_positive_numbers():\n    assert bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]\n\ndef test_bubble_sort_negative_numbers():\n    assert bubble_sort([-64, -34, -25, -12, -22, -11, -90]) == [-90, -64, -34, -25, -22, -12, -11]\n\ndef test_bubble_sort_mixed_numbers():\n    assert bubble_sort([-64, 34, -25, 12, -22, 11, 90]) == [-64, -25, -22, -11, 11, 12, 34, 90]\n\ndef test_bubble_sort_already_sorted():\n    assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_single_element():\n    assert bubble_sort([42]) == [42]",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      0
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000029",
      "row_id": 29,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to determine if all elements in an array are unique. Pseudocode is not necessary. Please include comments in your code to explain its functionality.",
    "response": "def are_elements_unique(arr):\n    \"\"\"\n    Returns True if all elements in the array are unique, otherwise returns False.\n    \n    Parameters:\n    arr (list): The input list of elements\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(arr) == len(set(arr))",
    "test_code": "import pytest\n\ndef test_are_elements_unique_with_unique_elements():\n    assert are_elements_unique([1, 2, 3, 4, 5]) == True\n\ndef test_are_elements_unique_with_duplicates():\n    assert are_elements_unique([1, 2, 3, 3, 5]) == False\n\ndef test_are_elements_unique_with_negative_numbers():\n    assert are_elements_unique([-1, -2, -3, -4, -5]) == True\n\ndef test_are_elements_unique_with_mixed_sign_numbers():\n    assert are_elements_unique([0, 1, -1, 2, -2]) == True\n\ndef test_are_elements_unique_with_all_same_elements():\n    assert are_elements_unique([1, 1, 1, 1, 1]) == False\n\ndef test_are_elements_unique_with_empty_list():\n    assert are_elements_unique([]) == True\n\ndef test_are_elements_unique_with_single_element():\n    assert are_elements_unique([42]) == True",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def are_elements_unique(arr):\n    \"\"\"\n    Check if all elements in the given array are unique.\n    \n    This function uses a set to track seen elements. If an element is encountered that\n    is already in the set, it means the element is not unique, and the function returns False.\n    Otherwise, if the loop completes without finding any duplicates, the function returns True.\n    \"\"\"\n    seen = set()\n    for element in arr:\n        if element in seen:\n            return False\n        seen.add(element)\n    return True",
        "test_code": "from solution import are_elements_unique\n\ndef test_are_elements_unique_all_unique():\n    assert are_elements_unique([1, 2, 3, 4, 5]) == True\n\ndef test_are_elements_unique_with_repeats():\n    assert are_elements_unique([1, 2, 3, 3, 4]) == False\n\ndef test_are_elements_unique_empty_array():\n    assert are_elements_unique([]) == True\n\ndef test_are_elements_unique_single_element():\n    assert are_elements_unique([1]) == True\n\ndef test_are_elements_unique_complex_data_types():\n    # Test with non-hashable elements\n    assert are_elements_unique([(1, 2), (1, 2), (3, 4)]) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def are_elements_unique(arr):\n    \"\"\"\n    Determines if all elements in the array are unique.\n\n    Arguments:\n    arr -- list of elements\n\n    Returns:\n    bool -- True if all elements are unique, False otherwise.\n    \"\"\"\n    # Convert the list to a set and compare its length to the original list's length\n    return len(arr) == len(set(arr))",
        "test_code": "from solution import are_elements_unique\n\ndef test_unique_elements():\n    assert are_elements_unique([1, 2, 3, 4, 5]) == True\n\ndef test_duplicate_elements():\n    assert are_elements_unique([1, 2, 3, 3, 5]) == False\n\ndef test_empty_array():\n    assert are_elements_unique([]) == True\n\ndef test_single_element_array():\n    assert are_elements_unique([42]) == True\n\ndef test_multiple_duplicates():\n    assert are_elements_unique([1, 2, 3, 3, 2, 1]) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def are_elements_unique(arr):\n    \"\"\"\n    Returns True if all elements in the array are unique, otherwise returns False.\n    \n    Parameters:\n    arr (list): The input list of elements\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(arr) == len(set(arr))",
        "test_code": "import pytest\n\ndef test_are_elements_unique_with_unique_elements():\n    assert are_elements_unique([1, 2, 3, 4, 5]) == True\n\ndef test_are_elements_unique_with_duplicates():\n    assert are_elements_unique([1, 2, 3, 3, 5]) == False\n\ndef test_are_elements_unique_with_negative_numbers():\n    assert are_elements_unique([-1, -2, -3, -4, -5]) == True\n\ndef test_are_elements_unique_with_mixed_sign_numbers():\n    assert are_elements_unique([0, 1, -1, 2, -2]) == True\n\ndef test_are_elements_unique_with_all_same_elements():\n    assert are_elements_unique([1, 1, 1, 1, 1]) == False\n\ndef test_are_elements_unique_with_empty_list():\n    assert are_elements_unique([]) == True\n\ndef test_are_elements_unique_with_single_element():\n    assert are_elements_unique([42]) == True",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000030",
      "row_id": 30,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to count the frequency of each character in a given string.",
    "response": "def char_frequency(input_string):\n    \"\"\"\n    Returns a dictionary containing the frequency of each character in the input_string.\n    \"\"\"\n    frequency_dict = {}\n    for char in input_string:\n        if char in frequency_dict:\n            frequency_dict[char] += 1\n        else:\n            frequency_dict[char] = 1\n    return frequency_dict",
    "test_code": "from solution import char_frequency\n\ndef test_char_frequency_empty_string():\n    assert char_frequency(\"\") == {}\n\ndef test_char_frequency_single_character():\n    assert char_frequency(\"a\") == {\"a\": 1}\n\ndef test_char_frequency_multiple_characters():\n    assert char_frequency(\"hello\") == {\"h\": 1, \"e\": 1, \"l\": 2, \"o\": 1}\n\ndef test_char_frequency_with_spaces():\n    assert char_frequency(\"hello world\") == {\"h\": 1, \"e\": 1, \"l\": 3, \"o\": 2, \" \": 1, \"w\": 1, \"r\": 1, \"d\": 1}\n\ndef test_char_frequency_with_special_characters():\n    assert char_frequency(\"#$@hello world!\") == {\"#\": 1, \"$\": 1, \"@\": 1, \"h\": 1, \"e\": 1, \"l\": 3, \"o\": 2, \" \": 1, \"w\": 1, \"r\": 1, \"d\": 1, \"!\": 1}",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def char_frequency(input_string):\n    \"\"\"\n    Returns a dictionary containing characters and their frequencies in the given string.\n    \"\"\"\n    frequency = {}\n    for char in input_string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency",
        "test_code": "from solution import char_frequency\n\ndef test_char_frequency_empty_string():\n    assert char_frequency(\"\") == {}\n\ndef test_char_frequency_single_character():\n    assert char_frequency(\"a\") == {'a': 1}\n\ndef test_char_frequency_multiple_characters():\n    assert char_frequency(\"aabbc\") == {'a': 2, 'b': 2, 'c': 1}\n\ndef test_char_frequency_with_spaces():\n    assert char_frequency(\"hello world\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1}\n\ndef test_char_frequency_with_special_characters():\n    assert char_frequency(\"!!@#$%^&*()_+\") == {'!': 2, '@': 1, '#': 1, '$': 1, '%': 1, '^': 1, '&': 1, '*': 1, '(': 1, ')': 1, '_': 1, '+': 1}",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def char_frequency(input_string):\n    \"\"\"\n    Returns a dictionary containing the frequency of each character in the input_string.\n    \"\"\"\n    frequency_dict = {}\n    for char in input_string:\n        if char in frequency_dict:\n            frequency_dict[char] += 1\n        else:\n            frequency_dict[char] = 1\n    return frequency_dict",
        "test_code": "from solution import char_frequency\n\ndef test_char_frequency_empty_string():\n    assert char_frequency(\"\") == {}\n\ndef test_char_frequency_single_character():\n    assert char_frequency(\"a\") == {\"a\": 1}\n\ndef test_char_frequency_multiple_characters():\n    assert char_frequency(\"hello\") == {\"h\": 1, \"e\": 1, \"l\": 2, \"o\": 1}\n\ndef test_char_frequency_with_spaces():\n    assert char_frequency(\"hello world\") == {\"h\": 1, \"e\": 1, \"l\": 3, \"o\": 2, \" \": 1, \"w\": 1, \"r\": 1, \"d\": 1}\n\ndef test_char_frequency_with_special_characters():\n    assert char_frequency(\"#$@hello world!\") == {\"#\": 1, \"$\": 1, \"@\": 1, \"h\": 1, \"e\": 1, \"l\": 3, \"o\": 2, \" \": 1, \"w\": 1, \"r\": 1, \"d\": 1, \"!\": 1}",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000038",
      "row_id": 38,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the length of the longest increasing subsequence (LIS) in an array of integers. The function should take a list of integers as input and return the length of the LIS.",
    "response": "def longest_increasing_subsequence(nums):\n    \"\"\"\n    Returns the length of the longest increasing subsequence in the given list of integers.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)",
    "test_code": "from solution import longest_increasing_subsequence\n\ndef test_lis_empty():\n    assert longest_increasing_subsequence([]) == 0\n\ndef test_lis_single_element():\n    assert longest_increasing_subsequence([1]) == 1\n\ndef test_lis_constant_elements():\n    assert longest_increasing_subsequence([1, 1, 1, 1]) == 1\n\ndef test_lis_increasing_sequence():\n    assert longest_increasing_subsequence([1, 2, 3]) == 3\n\ndef test_lis_decreasing_sequence():\n    assert longest_increasing_subsequence([3, 2, 1]) == 1\n\ndef test_lis_random_sequence():\n    assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n\ndef test_lis_with_repeated_elements():\n    assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def longest_increasing_subsequence(nums):\n    \"\"\"\n    Returns the length of the longest increasing subsequence in the given list of integers.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)",
        "test_code": "from solution import longest_increasing_subsequence\n\ndef test_lis_empty():\n    assert longest_increasing_subsequence([]) == 0\n\ndef test_lis_single_element():\n    assert longest_increasing_subsequence([1]) == 1\n\ndef test_lis_constant_elements():\n    assert longest_increasing_subsequence([1, 1, 1, 1]) == 1\n\ndef test_lis_increasing_sequence():\n    assert longest_increasing_subsequence([1, 2, 3]) == 3\n\ndef test_lis_decreasing_sequence():\n    assert longest_increasing_subsequence([3, 2, 1]) == 1\n\ndef test_lis_random_sequence():\n    assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n\ndef test_lis_with_repeated_elements():\n    assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def length_of_lis(nums):\n    \"\"\"\n    Returns the length of the longest increasing subsequence in the given list of integers.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)",
        "test_code": "from solution import length_of_lis\n\ndef test_length_of_lis_with_empty_list():\n    assert length_of_lis([]) == 0\n\ndef test_length_of_lis_with_single_element():\n    assert length_of_lis([1]) == 1\n\ndef test_length_of_lis_with_constant_values():\n    assert length_of_lis([1, 1, 1, 1]) == 1\n\ndef test_length_of_lis_with_multiple_elements():\n    assert length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n\ndef test_length_of_lis_with_reversed_increasing_sequence():\n    assert length_of_lis([5, 4, 3, 2, 1]) == 1\n\ndef test_length_of_lis_with_random_sequence():\n    assert length_of_lis([4, 2, 4, 3, 3, 1, 2, 1]) == 4",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000043",
      "row_id": 43,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to calculate the binomial coefficient for given number 'n' and 'k'. The binomial coefficient, often denoted as C(n, k), represents the number of ways to choose k items from a set of n distinct items. This function will be defined by the return statement: `return binomial_coefficient(n, k)`. The binomial coefficient can be calculated using the formula: C(n, k) = C(n-1, k-1) + C(n-1, k), with the base cases being C(n, 0) = C(n, n) = 1.",
    "response": "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k).\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)",
    "test_code": "import pytest\n\ndef test_binomial_coefficient():\n    assert binomial_coefficient(5, 2) == 10\n    assert binomial_coefficient(10, 0) == 1\n    assert binomial_coefficient(10, 10) == 1\n    assert binomial_coefficient(6, 3) == 20\n    assert binomial_coefficient(7, 1) == 7",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k).\n    \n    Args:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n    \n    Returns:\n    int: The binomial coefficient.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)",
        "test_code": "``\nfrom solution import binomial_coefficient\n\ndef test_binomial_coefficient():\n    assert binomial_coefficient(5, 2) == 10\n    assert binomial_coefficient(10, 3) == 120\n    assert binomial_coefficient(0, 0) == 1\n    assert binomial_coefficient(6, 0) == 1\n    assert binomial_coefficient(6, 6) == 1\n    assert binomial_coefficient(6, 1) == 6\n    assert binomial_coefficient(6, 5) == 6\n    assert binomial_coefficient(3, 3) == 1\n    assert binomial_coefficient(3, 1) == 3\n    assert binomial_coefficient(3, 2) == 3\n    assert binomial_coefficient(7, 4) == 35\n    assert binomial_coefficient(9, 4) == 126\n    assert binomial_coefficient(12, 5) == 792",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k) using a recursive approach.\n    \"\"\"\n    # Base cases\n    if k == 0 or k == n:\n        return 1\n    # Recursive case\n    return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)",
        "test_code": "from solution import binomial_coefficient\n\ndef test_binomial_coefficient_small_values():\n    assert binomial_coefficient(5, 2) == 10\n    assert binomial_coefficient(6, 3) == 20\n\ndef test_binomial_coefficient_large_values():\n    assert binomial_coefficient(20, 10) == 184756\n    assert binomial_coefficient(25, 15) == 3268760\n\ndef test_binomial_coefficient_edge_cases():\n    assert binomial_coefficient(0, 0) == 1\n    assert binomial_coefficient(1, 0) == 1\n    assert binomial_coefficient(1, 1) == 1\n\ndef test_binomial_coefficient_mixed_sign_numbers():\n    # n and k should be non-negative integers\n    assert binomial_coefficient(5, -1) is None\n    assert binomial_coefficient(-5, 2) is None\n    assert binomial_coefficient(5, 6) == 0  # n < k, which is not allowed",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k).\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)",
        "test_code": "import pytest\n\ndef test_binomial_coefficient():\n    assert binomial_coefficient(5, 2) == 10\n    assert binomial_coefficient(10, 0) == 1\n    assert binomial_coefficient(10, 10) == 1\n    assert binomial_coefficient(6, 3) == 20\n    assert binomial_coefficient(7, 1) == 7",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      0,
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000044",
      "row_id": 44,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to duplicate a linked list, including both the values of the nodes and the node's next pointers. Here, a duplicated linked list means creating a copy of the original linked list with new memory allocated for each node.",
    "response": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef duplicate_linked_list(node):\n    \"\"\"\n    Duplicates the given linked list.\n    :param node: ListNode\n    :return: ListNode\n    \"\"\"\n    if not node:\n        return None\n    \n    # Create a node with the same value\n    new_head = ListNode(node.val)\n    current_node = node\n    new_current_node = new_head\n\n    # Traverse the original linked list and create nodes for each value\n    while current_node.next:\n        new_next_node = ListNode(current_node.next.val)\n        new_current_node.next = new_next_node\n        current_node = current_node.next\n        new_current_node = new_current_node.next\n\n    return new_head",
    "test_code": "def create_linked_list(values):\n    \"\"\"Helper function to create a linked list from a list of values.\"\"\"\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for value in values[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\ndef linked_list_to_list(node):\n    \"\"\"Helper function to convert a linked list back to a list of values.\"\"\"\n    result = []\n    while node:\n        result.append(node.val)\n        node = node.next\n    return result\n\ndef test_duplicate_linked_list():\n    # Test with empty list\n    assert linked_list_to_list(duplicate_linked_list(None)) == []\n    \n    # Test with a simple linked list: 1 -> 2 -> 3\n    original_list = create_linked_list([1, 2, 3])\n    duplicated_list = duplicate_linked_list(original_list)\n    assert linked_list_to_list(duplicated_list) == [1, 2, 3]\n    \n    # Test with a more complex linked list\n    original_list = create_linked_list([1, 2, 3, 4, 5])\n    duplicated_list = duplicate_linked_list(original_list)\n    assert linked_list_to_list(duplicated_list) == [1, 2, 3, 4, 5]\n\n# Run the tests\ntest_duplicate_linked_list()",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "class ListNode:\n    \"\"\"Simple linked list node class.\"\"\"\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef duplicate_linked_list(head):\n    \"\"\"\n    Duplicates the linked list including both the node values and the next pointers.\n    \"\"\"\n    if head is None:\n        return None\n    \n    # Create a dummy node to help with the initial insertion\n    current_original = head\n    dummy = ListNode(0)\n    current_duplicated = dummy\n    \n    # Dictionary to store the mapping of original nodes to new nodes\n    mapping = {None: None}\n    \n    while current_original is not None:\n        new_node = ListNode(current_original.value)\n        current_duplicated.next = new_node\n        mapping[current_original] = new_node\n        \n        current_original = current_original.next\n        current_duplicated = current_duplicated.next\n    \n    # Set up the next pointers of the duplicated list\n    current_detailed = dummy.next\n    current_original = head\n    while current_detailed is not None:\n        current_detailed.next = mapping[current_original.next]\n        current_original = current_original.next\n        current_detailed = current_detailed.next\n    \n    return dummy.next",
        "test_code": "import pytest\n\n# Helper function to create linked list from a list of values\ndef create_linked_list(values):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for value in values[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\n# Helper function to convert a linked list to a list of values\ndef linked_list_to_list(node):\n    values = []\n    while node:\n        values.append(node.value)\n        node = node.next\n    return values\n\ndef test_duplicate_linked_list_empty_list():\n    assert linked_list_to_list(duplicate_linked_list(None)) == []\n\ndef test_duplicate_linked_list_simple_list():\n    head = create_linked_list([1, 2, 3])\n    duplicated_head = duplicate_linked_list(head)\n    assert linked_list_to_list(duplicated_head) == [1, 2, 3]\n\ndef test_duplicate_linked_list_complex_list():\n    head = create_linked_list([1, 2, 3, 4, 5])\n    duplicated_head = duplicate_linked_list(head)\n    assert linked_list_to_list(duplicated_head) == [1, 2, 3, 4, 5]\n\ndef test_duplicate_linked_list_same_elements():\n    head = create_linked_list([1, 1, 1, 1])\n    duplicated_head = duplicate_linked_list(head)\n    assert linked_list_to_list(duplicated_head) == [1, 1, 1, 1]\n\ndef test_duplicate_linked_list_with_none():\n    head = create_linked_list([None, 1, None, 2])\n    duplicated_head = duplicate_linked_list(head)\n    assert linked_list_to_list(duplicated_head) == [None, 1, None, 2]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef duplicate_linked_list(head):\n    \"\"\"\n    Duplicates a linked list including values and next pointers.\n    \"\"\"\n    if not head:\n        return None\n    \n    current = head\n    while current:\n        new_node = ListNode(current.val)\n        new_node.next = current.next\n        current.next = new_node\n        current = new_node.next\n    \n    current = head\n    copy_head = None\n    copy_current = None\n    \n    while current:\n        if not copy_head:\n            copy_head = copy_current = current.next\n        else:\n            copy_current.next = current.next.next\n            copy_current = copy_current.next\n        current.next = current.next.next\n        current = current.next\n    \n    return copy_head",
        "test_code": "def create_linked_list(values):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for value in values[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\ndef linked_list_to_list(head):\n    result = []\n    current = head\n    while current:\n        result.append(current.val)\n        current = current.next\n    return result\n\ndef test_duplicate_linked_list():\n    # Test with a simple linked list: 1 -> 2 -> 3\n    head = create_linked_list([1, 2, 3])\n    copied_head = duplicate_linked_list(head)\n    assert linked_list_to_list(copied_head) == [1, 2, 3]\n    \n    # Test with an empty linked list\n    head = create_linked_list([])\n    copied_head = duplicate_linked_list(head)\n    assert linked_list_to_list(copied_head) == []\n    \n    # Test with a linked list with one element: 4\n    head = create_linked_list([4])\n    copied_head = duplicate_linked_list(head)\n    assert linked_list_to_list(copied_head) == [4]\n    \n    # Test with a more complex linked list: 10 -> 20 -> 30 -> 40 -> 50\n    head = create_linked_list([10, 20, 30, 40, 50])\n    copied_head = duplicate_linked_list(head)\n    assert linked_list_to_list(copied_head) == [10, 20, 30, 40, 50]\n\ntest_duplicate_linked_list()",
        "test_result": "Fail",
        "test_coverage": 92.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef duplicate_linked_list(node):\n    \"\"\"\n    Duplicates the given linked list.\n    :param node: ListNode\n    :return: ListNode\n    \"\"\"\n    if not node:\n        return None\n    \n    # Create a node with the same value\n    new_head = ListNode(node.val)\n    current_node = node\n    new_current_node = new_head\n\n    # Traverse the original linked list and create nodes for each value\n    while current_node.next:\n        new_next_node = ListNode(current_node.next.val)\n        new_current_node.next = new_next_node\n        current_node = current_node.next\n        new_current_node = new_current_node.next\n\n    return new_head",
        "test_code": "def create_linked_list(values):\n    \"\"\"Helper function to create a linked list from a list of values.\"\"\"\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for value in values[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\ndef linked_list_to_list(node):\n    \"\"\"Helper function to convert a linked list back to a list of values.\"\"\"\n    result = []\n    while node:\n        result.append(node.val)\n        node = node.next\n    return result\n\ndef test_duplicate_linked_list():\n    # Test with empty list\n    assert linked_list_to_list(duplicate_linked_list(None)) == []\n    \n    # Test with a simple linked list: 1 -> 2 -> 3\n    original_list = create_linked_list([1, 2, 3])\n    duplicated_list = duplicate_linked_list(original_list)\n    assert linked_list_to_list(duplicated_list) == [1, 2, 3]\n    \n    # Test with a more complex linked list\n    original_list = create_linked_list([1, 2, 3, 4, 5])\n    duplicated_list = duplicate_linked_list(original_list)\n    assert linked_list_to_list(duplicated_list) == [1, 2, 3, 4, 5]\n\n# Run the tests\ntest_duplicate_linked_list()",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000045",
      "row_id": 45,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to check if a number is a palindrome number. A palindrome number is a number that remains the same when its digits are reversed, such as 121 or 1331.",
    "response": "def is_palindrome_number(number: int) -> bool:\n    \"\"\"\n    Checks if the given number is a palindrome number.\n    \n    Args:\n    number (int): The number to check\n    \n    Returns:\n    bool: True if the number is a palindrome, False otherwise.\n    \"\"\"\n    if number < 0:\n        return False\n    original_number = number\n    reversed_number = 0\n    while number > 0:\n        digit = number % 10\n        reversed_number = reversed_number * 10 + digit\n        number = number // 10\n    return original_number == reversed_number",
    "test_code": "from solution import is_palindrome_number\n\ndef test_is_palindrome_number_positive():\n    assert is_palindrome_number(121) == True\n    assert is_palindrome_number(1331) == True\n    assert is_palindrome_number(12321) == True\n\ndef test_is_palindrome_number_zero():\n    assert is_palindrome_number(0) == True\n\ndef test_is_palindrome_number_single_digit():\n    assert is_palindrome_number(1) == True\n    assert is_palindrome_number(9) == True\n\ndef test_is_palindrome_number_negative():\n    assert is_palindrome_number(-121) == False\n\ndef test_is_palindrome_number_not_palindrome():\n    assert is_palindrome_number(123) == False\n    assert is_palindrome_number(56789) == False",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def is_palindrome_number(number: int) -> bool:\n    \"\"\"\n    Checks if a given number is a palindrome number.\n    \"\"\"\n    if number < 0:\n        return False\n    original_number = number\n    reversed_number = 0\n    while number > 0:\n        digit = number % 10\n        reversed_number = reversed_number * 10 + digit\n        number = number // 10\n    return original_number == reversed_number",
        "test_code": "from solution import is_palindrome_number\n\ndef test_palindrome_number_positive():\n    assert is_palindrome_number(121) == True\n\ndef test_palindrome_number_large():\n    assert is_palindrome_number(12321) == True\n\ndef test_palindrome_number_edge_case():\n    assert is_palindrome_number(1) == True\n\ndef test_palindrome_number_negative():\n    assert is_palindrome_number(-121) == False\n\ndef test_palindrome_number_non_palindrome():\n    assert is_palindrome_number(123) == False\n\ndef test_palindrome_number_zero():\n    assert is_palindrome_number(0) == True",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def is_palindrome_number(number: int) -> bool:\n    \"\"\"\n    Checks if the given number is a palindrome.\n    \n    A number is a palindrome if it reads the same backward as forward.\n    \"\"\"\n    if number < 0:\n        return False\n    original_number = number\n    reversed_number = 0\n    while number > 0:\n        digit = number % 10\n        reversed_number = reversed_number * 10 + digit\n        number = number // 10\n    return original_number == reversed_number",
        "test_code": "from solution import is_palindrome_number\n\ndef test_is_palindrome_number_positive():\n    assert is_palindrome_number(121) == True\n    assert is_palindrome_number(1331) == True\n    assert is_palindrome_number(12321) == True\n\ndef test_is_palindrome_number_negative():\n    assert is_palindrome_number(-121) == False\n\ndef test_is_palindrome_number_zero():\n    assert is_palindrome_number(0) == True\n\ndef test_is_palindrome_number_zero_padded():\n    assert is_palindrome_number(1001) == True\n\ndef test_is_palindrome_number_single_digit():\n    assert is_palindrome_number(7) == True\n\ndef test_is_palindrome_number_non_palindrome():\n    assert is_palindrome_number(123) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_palindrome_number(number: int) -> bool:\n    \"\"\"\n    Checks if the given number is a palindrome number.\n    \n    Args:\n    number (int): The number to check\n    \n    Returns:\n    bool: True if the number is a palindrome, False otherwise.\n    \"\"\"\n    if number < 0:\n        return False\n    original_number = number\n    reversed_number = 0\n    while number > 0:\n        digit = number % 10\n        reversed_number = reversed_number * 10 + digit\n        number = number // 10\n    return original_number == reversed_number",
        "test_code": "from solution import is_palindrome_number\n\ndef test_is_palindrome_number_positive():\n    assert is_palindrome_number(121) == True\n    assert is_palindrome_number(1331) == True\n    assert is_palindrome_number(12321) == True\n\ndef test_is_palindrome_number_zero():\n    assert is_palindrome_number(0) == True\n\ndef test_is_palindrome_number_single_digit():\n    assert is_palindrome_number(1) == True\n    assert is_palindrome_number(9) == True\n\ndef test_is_palindrome_number_negative():\n    assert is_palindrome_number(-121) == False\n\ndef test_is_palindrome_number_not_palindrome():\n    assert is_palindrome_number(123) == False\n    assert is_palindrome_number(56789) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000046",
      "row_id": 46,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to calculate the sum of two numbers.",
    "response": "def sum_two_numbers(a, b):\n    \"\"\"\n    Returns the sum of a and b.\n    \"\"\"\n    return a + b",
    "test_code": "from solution import sum_two_numbers\n\ndef test_sum_two_positive_numbers():\n    assert sum_two_numbers(2, 3) == 5\n\ndef test_sum_with_zero():\n    assert sum_two_numbers(0, 5) == 5\n    assert sum_two_numbers(5, 0) == 5\n\ndef test_sum_negative_numbers():\n    assert sum_two_numbers(-1, -1) == -2\n\ndef test_sum_mixed_sign_numbers():\n    assert sum_two_numbers(-1, 3) == 2\n    assert sum_two_numbers(4, -4) == 0",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def sum_two_numbers(a, b):\n    \"\"\"\n    Returns the sum of a and b.\n    \"\"\"\n    return a + b",
        "test_code": "from solution import sum_two_numbers\n\ndef test_sum_two_positive_numbers():\n    assert sum_two_numbers(2, 3) == 5\n\ndef test_sum_with_zero():\n    assert sum_two_numbers(0, 5) == 5\n    assert sum_two_numbers(5, 0) == 5\n\ndef test_sum_negative_numbers():\n    assert sum_two_numbers(-1, -1) == -2\n\ndef test_sum_mixed_sign_numbers():\n    assert sum_two_numbers(-1, 3) == 2\n    assert sum_two_numbers(4, -4) == 0",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      }
    },
    "pass_sequence": [
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000049",
      "row_id": 49,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to check if a given string is a valid palindrome. A valid palindrome is a string that reads the same forward and backward, ignoring cases and non-alphanumeric characters.",
    "response": "def is_valid_palindrome(s: str) -> bool:\n    \"\"\"\n    Checks if the given string is a valid palindrome, ignoring cases and non-alphanumeric characters.\n    \"\"\"\n    # Normalize the string by removing non-alphanumeric characters and converting to lower case\n    normalized_str = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Check if the normalized string is equal to its reverse\n    return normalized_str == normalized_str[::-1]",
    "test_code": "from solution import is_valid_palindrome\n\ndef test_is_valid_palindrome():\n    assert is_valid_palindrome(\"A man, a plan, a canal: Panama\") == True\n    assert is_valid_palindrome(\"race a car\") == False\n    assert is_valid_palindrome(\"No lemon, no melon\") == True\n    assert is_valid_palindrome(\"\") == True\n    assert is_valid_palindrome(\" \") == True\n    assert is_valid_palindrome(\"a.\") == True\n    assert is_valid_palindrome(\"0P\") == False\n    assert is_valid_palindrome(\"Was it a car or a cat I saw?\") == True",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "import re\n\ndef is_valid_palindrome(s: str) -> bool:\n    \"\"\"\n    Returns True if the string is a valid palindrome, False otherwise.\n    A valid palindrome reads the same forward and backward, ignoring cases and non-alphanumeric characters.\n    \"\"\"\n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    # Check if the cleaned string is equal to its reverse\n    return cleaned == cleaned[::-1]",
        "test_code": "import pytest\nfrom solution import is_valid_palindrome\n\ndef test_is_valid_palindrome():\n    assert is_valid_palindrome(\"A man, a plan, a canal: Panama\") == True\n    assert is_valid_palindrome(\"race a car\") == False\n    assert is_valid_palindrome(\" \") == True\n    assert is_valid_palindrome(\"No 'x' in Noxide\") == True\n    assert is_valid_palindrome(\"\") == True\n    assert is_valid_palindrome(\"12321\") == True\n    assert is_valid_palindrome(\"123a321\") == True",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "import re\n\ndef is_valid_palindrome(s: str) -> bool:\n    \"\"\"\n    Returns True if the string is a valid palindrome, False otherwise.\n    A valid palindrome reads the same forward and backward, ignoring cases and non-alphanumeric characters.\n    \"\"\"\n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    # Check if the cleaned string is equal to its reverse\n    return cleaned_s == cleaned_s[::-1]",
        "test_code": "from solution import is_valid_palindrome\n\ndef test_is_valid_palindrome():\n    assert is_valid_palindrome(\"A man, a plan, a canal: Panama\") == True\n    assert is_valid_palindrome(\"race a car\") == False\n    assert is_valid_palindrome(\" \") == True\n    assert is_valid_palindrome(\"0P\") == False\n    assert is_valid_palindrome(\"No 'x' in Nixon\") == True\n    assert is_valid_palindrome(\"No lemon, no melon\") == True",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_valid_palindrome(s: str) -> bool:\n    \"\"\"\n    Checks if the given string is a valid palindrome, ignoring cases and non-alphanumeric characters.\n    \"\"\"\n    # Normalize the string by removing non-alphanumeric characters and converting to lower case\n    normalized_str = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Check if the normalized string is equal to its reverse\n    return normalized_str == normalized_str[::-1]",
        "test_code": "from solution import is_valid_palindrome\n\ndef test_is_valid_palindrome():\n    assert is_valid_palindrome(\"A man, a plan, a canal: Panama\") == True\n    assert is_valid_palindrome(\"race a car\") == False\n    assert is_valid_palindrome(\"No lemon, no melon\") == True\n    assert is_valid_palindrome(\"\") == True\n    assert is_valid_palindrome(\" \") == True\n    assert is_valid_palindrome(\"a.\") == True\n    assert is_valid_palindrome(\"0P\") == False\n    assert is_valid_palindrome(\"Was it a car or a cat I saw?\") == True",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000053",
      "row_id": 53,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the maximum product of a contiguous subarray within a one-dimensional array of numbers.",
    "response": "def max_product_subarray(nums):\n    \"\"\"\n    Returns the maximum product of a contiguous subarray within the one-dimensional array of numbers.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    # Initialize local minimum, local maximum, and the answer with the first element.\n    local_min, local_max, ans = nums[0], nums[0], nums[0]\n    \n    for num in nums[1:]:\n        # If the current number is negative, swap the local min and max.\n        if num < 0:\n            local_min, local_max = local_max, local_min\n        \n        # Update the local max and min.\n        local_max = max(num, local_max * num)\n        local_min = min(num, local_min * num)\n        \n        # Update the answer.\n        ans = max(ans, local_max)\n    \n    return ans",
    "test_code": "from solution import max_product_subarray\n\ndef test_max_product_subarray_positive():\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n    assert max_product_subarray([0, 2]) == 2\n\ndef test_max_product_subarray_negative():\n    assert max_product_subarray([-2, 0, -1]) == 0\n    assert max_product_subarray([-2, -3, -1]) == 6\n\ndef test_max_product_subarray_single_element():\n    assert max_product_subarray([2]) == 2\n\ndef test_max_product_subarray_all_negative():\n    assert max_product_subarray([-1, -2, -3]) == 6\n    assert max_product_subarray([-1]) == -1\n\ndef test_max_product_subarray_empty():\n    assert max_product_subarray([]) == 0",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def max_product_subarray(nums):\n    \"\"\"\n    Finds the maximum product of a contiguous subarray within a one-dimensional array of numbers.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_product = min_product = result = nums[0]\n    \n    for num in nums[1:]:\n        candidates = (num, max_product * num, min_product * num)\n        max_product = max(candidates)\n        min_product = min(candidates)\n        result = max(result, max_product)\n        \n    return result",
        "test_code": "from solution import max_product_subarray\n\ndef test_max_product_subarray_positive():\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n\ndef test_max_product_subarray_negative():\n    assert max_product_subarray([-2, 0, -1]) == 0\n\ndef test_max_product_subarray_large():\n    assert max_product_subarray([0, 2, -3, -1, 5]) == 15\n\ndef test_max_product_subarray_all_negative():\n    assert max_product_subarray([-1, -2, -3, -4]) == 24\n\ndef test_max_product_subarray_with_zero():\n    assert max_product_subarray([0, -1, 0, -2, 3, 0, -4]) == 12\n\ndef test_max_product_subarray_single_element():\n    assert max_product_subarray([-1]) == -1\n\ndef test_max_product_subarray_empty():\n    assert max_product_subarray([]) == 0",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def max_product_subarray(nums):\n    \"\"\"\n    Returns the maximum product of a contiguous subarray within nums.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_product = min_product = result = nums[0]\n    \n    for num in nums[1:]:\n        # The maximum product can be updated using the current number, max_product, or min_product\n        candidates = (num, max_product * num, min_product * num)\n        max_product = max(candidates)\n        min_product = min(candidates)\n        \n        # Update the result with the maximum product found so far\n        result = max(result, max_product)\n    \n    return result",
        "test_code": "import pytest\n\ndef test_max_product_subarray_positive():\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n\ndef test_max_product_subarray_negative():\n    assert max_product_subarray([-2, 0, -1]) == 0\n\ndef test_max_product_subarray_with_one_negative():\n    assert max_product_subarray([0, -1]) == 0\n\ndef test_max_product_subarray_all_negative():\n    assert max_product_subarray([-2, -3, -1]) == 6\n\ndef test_max_product_subarray_single_element():\n    assert max_product_subarray([2]) == 2\n\ndef test_max_product_subarray_empty():\n    assert max_product_subarray([]) == 0\n\ndef test_max_product_subarray_mixed():\n    assert max_product_subarray([2, -5, -2, -4, 3]) == 24",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def max_product_subarray(nums):\n    \"\"\"\n    Returns the maximum product of a contiguous subarray within the one-dimensional array of numbers.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    # Initialize local minimum, local maximum, and the answer with the first element.\n    local_min, local_max, ans = nums[0], nums[0], nums[0]\n    \n    for num in nums[1:]:\n        # If the current number is negative, swap the local min and max.\n        if num < 0:\n            local_min, local_max = local_max, local_min\n        \n        # Update the local max and min.\n        local_max = max(num, local_max * num)\n        local_min = min(num, local_min * num)\n        \n        # Update the answer.\n        ans = max(ans, local_max)\n    \n    return ans",
        "test_code": "from solution import max_product_subarray\n\ndef test_max_product_subarray_positive():\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n    assert max_product_subarray([0, 2]) == 2\n\ndef test_max_product_subarray_negative():\n    assert max_product_subarray([-2, 0, -1]) == 0\n    assert max_product_subarray([-2, -3, -1]) == 6\n\ndef test_max_product_subarray_single_element():\n    assert max_product_subarray([2]) == 2\n\ndef test_max_product_subarray_all_negative():\n    assert max_product_subarray([-1, -2, -3]) == 6\n    assert max_product_subarray([-1]) == -1\n\ndef test_max_product_subarray_empty():\n    assert max_product_subarray([]) == 0",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000054",
      "row_id": 54,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to identify if two string s1 and s2 are isomorphic. Two strings are isomorphic if the characters in s1 can be replaced to get s2. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.",
    "response": "def is_isomorphic(s1, s2):\n    \"\"\"\n    Checks if two strings are isomorphic. Two strings are isomorphic if the characters in s1 can be replaced to get s2.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    s1_to_s2_map = {}\n    s2_to_s1_map = {}\n    \n    for char_from_s1, char_from_s2 in zip(s1, s2):\n        if char_from_s1 in s1_to_s2_map:\n            if s1_to_s2_map[char_from_s1] != char_from_s2:\n                return False\n        else:\n            s1_to_s2_map[char_from_s1] = char_from_s2\n        \n        if char_from_s2 in s2_to_s1_map:\n            if s2_to_s1_map[char_from_s2] != char_from_s1:\n                return False\n        else:\n            s2_to_s1_map[char_from_s2] = char_from_s1\n    \n    return True",
    "test_code": "from solution import is_isomorphic\n\ndef test_isomorphic_example1():\n    assert is_isomorphic(\"egg\", \"add\") == True\n\ndef test_isomorphic_example2():\n    assert is_isomorphic(\"foo\", \"bar\") == False\n\ndef test_isomorphic_example3():\n    assert is_isomorphic(\"paper\", \"title\") == True\n\ndef test_isomorphic_identical_strings():\n    assert is_isomorphic(\"abc\", \"abc\") == True\n\ndef test_isomorphic_empty_strings():\n    assert is_isomorphic(\"\", \"\") == True\n\ndef test_isomorphic_no_characters():\n    assert is_isomorphic(\"a\", \"a\") == True\n\ndef test_isomorphic_mismatched_characters():\n    assert is_isomorphic(\"aabb\", \"ccdd\") == True\n\ndef test_isomorphic_non_unique_replacement():\n    assert is_isomorphic(\"ab\", \"aa\") == False",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def is_isomorphic(s1, s2):\n    \"\"\"\n    Returns True if s1 and s2 are isomorphic, otherwise False.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    mapping_s1_to_s2 = {}\n    mapping_s2_to_s1 = {}\n    \n    for char_s1, char_s2 in zip(s1, s2):\n        if char_s1 in mapping_s1_to_s2:\n            if mapping_s1_to_s2[char_s1] != char_s2:\n                return False\n        else:\n            mapping_s1_to_s2[char_s1] = char_s2\n        \n        if char_s2 in mapping_s2_to_s1:\n            if mapping_s2_to_s1[char_s2] != char_s1:\n                return False\n        else:\n            mapping_s2_to_s1[char_s2] = char_s1\n    \n    return True",
        "test_code": "from solution import is_isomorphic\n\ndef test_isomorphic_strings():\n    assert is_isomorphic(\"egg\", \"add\") == True\n    assert is_isomorphic(\"foo\", \"bar\") == False\n    assert is_isomorphic(\"paper\", \"title\") == True\n    assert is_isomorphic(\"badc\", \"baba\") == False\n    assert is_isomorphic(\"abab\", \"baba\") == False\n    assert is_isomorphic(\"ab\", \"aa\") == False\n    assert is_isomorphic(\"a\", \"b\") == True\n    assert is_isomorphic(\"aa\", \"bb\") == True\n    assert is_isomorphic(\"paper\", \"exas\") == False",
        "test_result": "Fail",
        "test_coverage": 93.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def is_isomorphic(s1, s2):\n    \"\"\"\n    Checks if two strings are isomorphic. Two strings are isomorphic if the characters in s1 can be replaced to get s2.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    s1_to_s2_map = {}\n    s2_to_s1_map = {}\n    \n    for char_from_s1, char_from_s2 in zip(s1, s2):\n        if char_from_s1 in s1_to_s2_map:\n            if s1_to_s2_map[char_from_s1] != char_from_s2:\n                return False\n        else:\n            s1_to_s2_map[char_from_s1] = char_from_s2\n        \n        if char_from_s2 in s2_to_s1_map:\n            if s2_to_s1_map[char_from_s2] != char_from_s1:\n                return False\n        else:\n            s2_to_s1_map[char_from_s2] = char_from_s1\n    \n    return True",
        "test_code": "from solution import is_isomorphic\n\ndef test_isomorphic_example1():\n    assert is_isomorphic(\"egg\", \"add\") == True\n\ndef test_isomorphic_example2():\n    assert is_isomorphic(\"foo\", \"bar\") == False\n\ndef test_isomorphic_example3():\n    assert is_isomorphic(\"paper\", \"title\") == True\n\ndef test_isomorphic_identical_strings():\n    assert is_isomorphic(\"abc\", \"abc\") == True\n\ndef test_isomorphic_empty_strings():\n    assert is_isomorphic(\"\", \"\") == True\n\ndef test_isomorphic_no_characters():\n    assert is_isomorphic(\"a\", \"a\") == True\n\ndef test_isomorphic_mismatched_characters():\n    assert is_isomorphic(\"aabb\", \"ccdd\") == True\n\ndef test_isomorphic_non_unique_replacement():\n    assert is_isomorphic(\"ab\", \"aa\") == False",
        "test_result": "Pass",
        "test_coverage": 93.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_isomorphic(s1: str, s2: str) -> bool:\n    \"\"\"\n    Checks if two strings are isomorphic.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    s1_to_s2 = {}\n    s2_to_s1 = {}\n    \n    for char1, char2 in zip(s1, s2):\n        if (char1 in s1_to_s2 and s1_to_s2[char1] != char2) or \\\n           (char2 in s2_to_s1 and s2_to_s1[char2] != char1):\n            return False\n        s1_to_s2[char1] = char2\n        s2_to_s1[char2] = char1\n    \n    return True",
        "test_code": "def test_is_isomorphic():\n    assert is_isomorphic(\"egg\", \"add\") == True\n    assert is_isomorphic(\"foo\", \"bar\") == False\n    assert is_isomorphic(\"paper\", \"title\") == True\n    assert is_isomorphic(\"badc\", \"baba\") == False\n    assert is_isomorphic(\"ab\", \"aa\") == False\n    assert is_isomorphic(\"\", \"\") == True\n    assert is_isomorphic(\"a\", \"a\") == True\n    assert is_isomorphic(\"aac\", \"yxy\") == True\n    assert is_isomorphic(\"aabb\", \"xyyx\") == True\n    assert is_isomorphic(\"aabb\", \"xyxy\") == False",
        "test_result": "Fail",
        "test_coverage": 91.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000055",
      "row_id": 55,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to count the number of uppercase letters in a given string. The function should also handle edge cases such as an empty string or a string with no uppercase letters.",
    "response": "def count_uppercase(s: str) -> int:\n    \"\"\"\n    Returns the number of uppercase letters in the string s.\n    \"\"\"\n    return sum(1 for c in s if c.isupper())",
    "test_code": "from solution import count_uppercase\n\ndef test_count_uppercase_empty_string():\n    assert count_uppercase(\"\") == 0\n\ndef test_count_uppercase_no_uppercase():\n    assert count_uppercase(\"hello world\") == 0\n\ndef test_count_uppercase_all_uppercase():\n    assert count_uppercase(\"HELLO WORLD\") == 10\n\ndef test_count_uppercase_mixed_case():\n    assert count_uppercase(\"HeLlO WoRlD\") == 6",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def count_uppercase_letters(s):\n    \"\"\"\n    Counts and returns the number of uppercase letters in the given string.\n    \"\"\"\n    return sum(1 for c in s if c.isupper())",
        "test_code": "def test_count_uppercase_letters_empty_string():\n    assert count_uppercase_letters(\"\") == 0\n\ndef test_count_uppercase_letters_no_uppercase():\n    assert count_uppercase_letters(\"hello world\") == 0\n\ndef test_count_uppercase_letters_all_uppercase():\n    assert count_uppercase_letters(\"HELLO WORLD\") == 10\n\ndef test_count_uppercase_letters_mixed_case():\n    assert count_uppercase_letters(\"HeLlO WoRlD\") == 6",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def count_uppercase(s):\n    \"\"\"\n    Returns the number of uppercase letters in the string `s`.\n    \"\"\"\n    return sum(1 for c in s if c.isupper())",
        "test_code": "from solution import count_uppercase\n\ndef test_count_uppercase_empty_string():\n    assert count_uppercase(\"\") == 0\n\ndef test_count_uppercase_no_uppercase_chars():\n    assert count_uppercase(\"hello world\") == 0\n\ndef test_count_uppercase_mixed_case():\n    assert count_uppercase(\"Hello World\") == 2\n\ndef test_count_uppercase_all_uppercase():\n    assert count_uppercase(\"HELLO WORLD\") == 10\n\ndef test_count_uppercase_punctuation():\n    assert count_uppercase(\"Hello, World!\") == 2\n\ndef test_count_uppercase_num_and_special():\n    assert count_uppercase(\"123!@#ABCDEFG\") == 7",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def count_uppercase(s: str) -> int:\n    \"\"\"\n    Returns the number of uppercase letters in the string s.\n    \"\"\"\n    return sum(1 for c in s if c.isupper())",
        "test_code": "from solution import count_uppercase\n\ndef test_count_uppercase_empty_string():\n    assert count_uppercase(\"\") == 0\n\ndef test_count_uppercase_no_uppercase():\n    assert count_uppercase(\"hello world\") == 0\n\ndef test_count_uppercase_all_uppercase():\n    assert count_uppercase(\"HELLO WORLD\") == 10\n\ndef test_count_uppercase_mixed_case():\n    assert count_uppercase(\"HeLlO WoRlD\") == 6",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000057",
      "row_id": 57,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to reverse a given string. Here's a rough outline on how you might approach the problem:",
    "response": "def reverse_string(s):\n    \"\"\"\n    Returns the reverse of the given string.\n    \"\"\"\n    return s[::-1]",
    "test_code": "from solution import reverse_string\n\ndef test_reverse_string_empty():\n    assert reverse_string(\"\") == \"\"\n\ndef test_reverse_string_single_character():\n    assert reverse_string(\"a\") == \"a\"\n\ndef test_reverse_string_normal():\n    assert reverse_string(\"hello\") == \"olleh\"\n\ndef test_reverse_string_with_spaces():\n    assert reverse_string(\"hello world\") == \"dlrow olleh\"\n\ndef test_reverse_string_with_punctuation():\n    assert reverse_string(\"hello, world!\") == \"!dlrow ,olleh\"",
    "trials": {
      "trial_qwen2.5_1": {
        "solution_code": "def reverse_string(s):\n    \"\"\"\n    Returns the reverse of the given string.\n    \"\"\"\n    return s[::-1]",
        "test_code": "from solution import reverse_string\n\ndef test_reverse_string_empty():\n    assert reverse_string(\"\") == \"\"\n\ndef test_reverse_string_single_character():\n    assert reverse_string(\"a\") == \"a\"\n\ndef test_reverse_string_normal():\n    assert reverse_string(\"hello\") == \"olleh\"\n\ndef test_reverse_string_with_spaces():\n    assert reverse_string(\"hello world\") == \"dlrow olleh\"\n\ndef test_reverse_string_with_punctuation():\n    assert reverse_string(\"hello, world!\") == \"!dlrow ,olleh\"",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000058",
      "row_id": 58,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the first occurrence of an element in an array that is not repeated (i.e., appears exactly once). If there is no such element, return -1.",
    "response": "def find_first_unique(arr):\n    \"\"\"\n    Returns the first index of the element that is not repeated in the array.\n    If no such element exists, returns -1.\n    \"\"\"\n    element_count = {}\n    \n    # Count the occurrences of each element\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    \n    # Find the first element with a count of 1\n    for i, element in enumerate(arr):\n        if element_count[element] == 1:\n            return i\n    \n    return -1",
    "test_code": "from solution import find_first_unique\n\ndef test_find_first_unique_with_repeated_elements():\n    assert find_first_unique([2, 3, 4, 3, 2]) == 2\n\ndef test_find_first_unique_with_unique_first_element():\n    assert find_first_unique([1, 2, 3, 4]) == 0\n\ndef test_find_first_unique_with_duplicates_only():\n    assert find_first_unique([1, 1, 2, 2]) == -1\n\ndef test_find_first_unique_with_empty_list():\n    assert find_first_unique([]) == -1\n\ndef test_find_first_unique_with_single_element():\n    assert find_first_unique([5]) == 0\n\ndef test_find_first_unique_with_mixed_occurrences():\n    assert find_first_unique([7, 8, 8, 9, 7]) == 3",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def find_first_unique(arr):\n    \"\"\"\n    Returns the first index of the element that is not repeated in the array.\n    If no such element exists, returns -1.\n    \"\"\"\n    element_count = {}\n    \n    # Count the occurrences of each element\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    \n    # Find the first element with a count of 1\n    for i, element in enumerate(arr):\n        if element_count[element] == 1:\n            return i\n    \n    return -1",
        "test_code": "from solution import find_first_unique\n\ndef test_find_first_unique_with_repeated_elements():\n    assert find_first_unique([2, 3, 4, 3, 2]) == 2\n\ndef test_find_first_unique_with_unique_first_element():\n    assert find_first_unique([1, 2, 3, 4]) == 0\n\ndef test_find_first_unique_with_duplicates_only():\n    assert find_first_unique([1, 1, 2, 2]) == -1\n\ndef test_find_first_unique_with_empty_list():\n    assert find_first_unique([]) == -1\n\ndef test_find_first_unique_with_single_element():\n    assert find_first_unique([5]) == 0\n\ndef test_find_first_unique_with_mixed_occurrences():\n    assert find_first_unique([7, 8, 8, 9, 7]) == 3",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def find_unique_element(arr):\n    \"\"\"\n    Returns the index of the first unique element in the given array.\n    If no unique element is found, returns -1.\n    \"\"\"\n    element_counts = {}\n    \n    # Count occurrences of each element\n    for i, num in enumerate(arr):\n        if num in element_counts:\n            element_counts[num] += 1\n        else:\n            element_counts[num] = 1\n    \n    # Find the first unique element's index\n    for i, num in enumerate(arr):\n        if element_counts[num] == 1:\n            return i\n    \n    return -1",
        "test_code": "from solution import find_unique_element\n\ndef test_find_unique_element():\n    assert find_unique_element([2, 3, 4, 5, 4]) == 1\n    assert find_unique_element([1, 2, 3, 4, 4, 3, 2]) == 0\n    assert find_unique_element([1, 1, 2, 2, 3, 3]) == -1\n    assert find_unique_element([10, 20, 20, 30]) == 0\n    assert find_unique_element([7, 7, 7, 7]) == -1",
        "test_result": "Fail",
        "test_coverage": 90.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def find_non_repeated(arr):\n    \"\"\"\n    Returns the index of the first non-repeated element in the array.\n    If no such element exists, returns -1.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(arr)\n    for idx, value in enumerate(arr):\n        if counts[value] == 1:\n            return idx\n    return -1",
        "test_code": "def test_find_non_repeated():\n    assert find_non_repeated([2, 3, 4, 3, 5]) == 0\n    assert find_non_repeated([1, 2, 2, 3, 4, 4, 5]) == 0\n    assert find_non_repeated([6, 7, 8, 8, 9, 9]) == 0\n    assert find_non_repeated([1, 1, 2, 2, 3, 3, 4, 5, 5]) == 7\n    assert find_non_repeated([1, 1, 2, 2]) == -1\n    assert find_non_repeated([7]) == 0\n    assert find_non_repeated([]) == -1\n\n# Edge cases\ndef test_find_non_repeated_edge_cases():\n    assert find_non_repeated([1, 1, 1, 2]) == 3\n    assert find_non_repeated([1, 2, 1, 3, 3, 4, 4]) == 1\n    assert find_non_repeated([1, 2, 2, 3]) == 0",
        "test_result": "Fail",
        "test_coverage": 86.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000061",
      "row_id": 61,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the second maximum number in a list of integers. If the list does not contain at least two different numbers, return None.",
    "response": "def second_maximum(numbers):\n    \"\"\"\n    Returns the second maximum number in a list of integers.\n    If the list does not contain at least two different numbers, returns None.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n    \n    max_num = second_max_num = float('-inf')\n    \n    for num in numbers:\n        if num > max_num:\n            second_max_num = max_num\n            max_num = num\n        elif max_num > num > second_max_num:\n            second_max_num = num\n            \n    if second_max_num == float('-inf'):\n        return None\n    return second_max_num",
    "test_code": "from solution import second_maximum\n\ndef test_second_maximum_with_two_unique_numbers():\n    assert second_maximum([1, 2]) == 1\n\ndef test_second_maximum_with_sorted_repeating_numbers():\n    assert second_maximum([5, 5, 4, 4, 3, 3]) == 4\n\ndef test_second_maximum_with_descending_repeating_numbers():\n    assert second_maximum([10, 9, 10, 9]) == 9\n\ndef test_second_maximum_with_no_enough_unique_numbers():\n    assert second_maximum([2, 2]) == None\n\ndef test_second_maximum_with_random_numbers():\n    assert second_maximum([7, 8, 9, 10, 11, 9]) == 10\n\ndef test_second_maximum_with_only_one_number():\n    assert second_maximum([100]) == None\n\ndef test_second_maximum_with_empty_list():\n    assert second_maximum([]) == None",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def second_maximum(numbers):\n    \"\"\"\n    Returns the second maximum number in the list. If there are not at least two different numbers, returns None.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n    \n    first_max = second_max = float('-inf')\n    \n    for num in numbers:\n        if num > first_max:\n            second_max = first_max\n            first_max = num\n        elif first_max > num > second_max:\n            second_max = num\n            \n    return second_max if second_max != float('-inf') else None",
        "test_code": "from solution import second_maximum\n\ndef test_second_maximum_with_multiple_different_numbers():\n    assert second_maximum([1, 3, 5, 7, 9]) == 7\n    assert second_maximum([10, 5, 10, 7, 10]) == 7\n\ndef test_second_maximum_with_one_unique_number():\n    assert second_maximum([5, 5, 5, 5]) == None\n\ndef test_second_maximum_with_no_numbers():\n    assert second_maximum([]) == None\n\ndef test_second_maximum_with_one_number():\n    assert second_maximum([5]) == None\n\ndef test_second_maximum_with_duplicates():\n    assert second_maximum([2, 2, 3, 5, 5]) == 3\n    assert second_maximum([1, 1, 4, 4, 10, 10]) == 4\n\ndef test_second_maximum_SINGLE_NUMBER():\n    assert second_maximum([9]) == None",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def find_second_maximum(nums):\n    \"\"\"\n    Returns the second maximum number in a list of integers. Returns None if there is no such number.\n    \"\"\"\n    if len(nums) < 2:\n        return None\n    max_num = second_max_num = float('-inf')\n    for num in nums:\n        if num > max_num:\n            second_max_num, max_num = max_num, num\n        elif max_num > num > second_max_num:\n            second_max_num = num\n    return second_max_num if second_max_num != max_num else None",
        "test_code": "from solution import find_second_maximum\n\ndef test_find_second_maximum_with_long_list():\n    assert find_second_maximum([10, 5, 2, 8, 5, 11, 13]) == 11\n\ndef test_find_second_maximum_with_repeated_max():\n    assert find_second_maximum([10, 10, 10, 10]) == None\n\ndef test_find_second_maximum_single_element():\n    assert find_second_maximum([5]) == None\n\ndef test_find_second_maximum_empty_list():\n    assert find_second_maximum([]) == None\n\ndef test_find_second_maximum_with_negative_numbers():\n    assert find_second_maximum([-10, -5, -6, -1, -3]) == -5\n\ndef test_find_second_maximum_with_mixed_numbers():\n    assert find_second_maximum([1, 2, 3, 4, 5, -1, -2, -3, -4, -5]) == 2\n\ndef test_find_second_maximum_with_two_elements():\n    assert find_second_maximum([5, 5]) == None\n\ndef test_find_second_maximum_with_descending_order():\n    assert find_second_maximum([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 9\n\ndef test_find_second_maximum_with_all_equal_elements():\n    assert find_second_maximum([2, 2, 2, 2, 2]) == None",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def second_maximum(numbers):\n    \"\"\"\n    Returns the second maximum number in a list of integers.\n    If the list does not contain at least two different numbers, returns None.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n    \n    max_num = second_max_num = float('-inf')\n    \n    for num in numbers:\n        if num > max_num:\n            second_max_num = max_num\n            max_num = num\n        elif max_num > num > second_max_num:\n            second_max_num = num\n            \n    if second_max_num == float('-inf'):\n        return None\n    return second_max_num",
        "test_code": "from solution import second_maximum\n\ndef test_second_maximum_with_two_unique_numbers():\n    assert second_maximum([1, 2]) == 1\n\ndef test_second_maximum_with_sorted_repeating_numbers():\n    assert second_maximum([5, 5, 4, 4, 3, 3]) == 4\n\ndef test_second_maximum_with_descending_repeating_numbers():\n    assert second_maximum([10, 9, 10, 9]) == 9\n\ndef test_second_maximum_with_no_enough_unique_numbers():\n    assert second_maximum([2, 2]) == None\n\ndef test_second_maximum_with_random_numbers():\n    assert second_maximum([7, 8, 9, 10, 11, 9]) == 10\n\ndef test_second_maximum_with_only_one_number():\n    assert second_maximum([100]) == None\n\ndef test_second_maximum_with_empty_list():\n    assert second_maximum([]) == None",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000062",
      "row_id": 62,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to convert a string into a list of words.",
    "response": "def string_to_list_of_words(input_string):\n    \"\"\"\n    Converts a given string into a list of words (separated by spaces).\n    \n    :param input_string: The string to convert.\n    :return: A list of words from the input string.\n    \"\"\"\n    return input_string.split()",
    "test_code": "from solution import string_to_list_of_words\n\ndef test_string_to_list_of_words_single_word():\n    assert string_to_list_of_words(\"hello\") == [\"hello\"]\n\ndef test_string_to_list_of_words_multiple_words():\n    assert string_to_list_of_words(\"hello world\") == [\"hello\", \"world\"]\n\ndef test_string_to_list_of_words_with_punctuation():\n    assert string_to_list_of_words(\"hello, world!\") == [\"hello,\", \"world!\"]\n\ndef test_string_to_list_of_words_empty_string():\n    assert string_to_list_of_words(\"\") == []\n\ndef test_string_to_list_of_words_with_spaces():\n    assert string_to_list_of_words(\"  hello  world  \") == [\"hello\", \"world\"]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def string_to_list_of_words(s):\n    \"\"\"\n    Converts a given string into a list of words separated by spaces.\n    Args:\n    s (str): The input string.\n    \n    Returns:\n    list: A list of words from the input string.\n    \"\"\"\n    return s.split()",
        "test_code": "from solution import string_to_list_of_words\n\ndef test_string_to_list_of_words_basic():\n    assert string_to_list_of_words(\"hello world\") == [\"hello\", \"world\"]\n\ndef test_string_to_list_of_words_empty():\n    assert string_to_list_of_words(\"\") == []\n\ndef test_string_to_list_of_words_with_newline():\n    assert string_to_list_of_words(\"split\\nnextline\") == [\"split\", \"nextline\"]\n\ndef test_string_to_list_of_words_with_tabs():\n    assert string_to_list_of_words(\"one\\ttwo\\tthree\") == [\"one\", \"two\", \"three\"]\n\ndef test_string_to_list_of_words_with_punctuation():\n    assert string_to_list_of_words(\"end.of.sentences,are.detected.automatically\") == [\"end.of.sentences\", \"are.detected.automatically\"]",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def string_to_list_of_words(input_string):\n    \"\"\"\n    Converts a given string into a list of words (separated by spaces).\n    \n    :param input_string: The string to convert.\n    :return: A list of words from the input string.\n    \"\"\"\n    return input_string.split()",
        "test_code": "from solution import string_to_list_of_words\n\ndef test_string_to_list_of_words_single_word():\n    assert string_to_list_of_words(\"hello\") == [\"hello\"]\n\ndef test_string_to_list_of_words_multiple_words():\n    assert string_to_list_of_words(\"hello world\") == [\"hello\", \"world\"]\n\ndef test_string_to_list_of_words_with_punctuation():\n    assert string_to_list_of_words(\"hello, world!\") == [\"hello,\", \"world!\"]\n\ndef test_string_to_list_of_words_empty_string():\n    assert string_to_list_of_words(\"\") == []\n\ndef test_string_to_list_of_words_with_spaces():\n    assert string_to_list_of_words(\"  hello  world  \") == [\"hello\", \"world\"]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def string_to_list_of_words(input_string):\n    \"\"\"\n    Converts a string into a list of words based on whitespace.\n    \n    Parameters:\n    input_string (str): The string to be converted.\n    \n    Returns:\n    list: A list of words from the input string.\n    \"\"\"\n    return input_string.split()",
        "test_code": "from solution import string_to_list_of_words\n\ndef test_string_to_list_of_words_simple():\n    assert string_to_list_of_words(\"hello world\") == ['hello', 'world']\n\ndef test_string_to_list_of_words_with_punctuation():\n    assert string_to_list_of_words(\"hello, world!\") == ['hello', 'world!']\n\ndef test_string_to_list_of_words_empty_string():\n    assert string_to_list_of_words(\"\") == []\n\ndef test_string_to_list_of_words_multiple_spaces():\n    assert string_to_list_of_words(\"hello  world\") == ['hello', 'world']\n\ndef test_string_to_list_of_words_newline():\n    assert string_to_list_of_words(\"hello\\nworld\") == ['hello', 'world']",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000063",
      "row_id": 63,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to detect and remove duplicate elements from a list. Write a test case to validate your function.",
    "response": "def remove_duplicates(input_list):\n    \"\"\"\n    Returns a new list with duplicates removed while preserving the original order.\n    \"\"\"\n    seen = set()\n    unique_list = []\n    for item in input_list:\n        if item not in seen:\n            unique_list.append(item)\n            seen.add(item)\n    return unique_list",
    "test_code": "from solution import remove_duplicates\n\ndef test_remove_duplicates_empty_list():\n    assert remove_duplicates([]) == []\n\ndef test_remove_duplicates_single_element():\n    assert remove_duplicates([1]) == [1]\n\ndef test_remove_duplicates_with_duplicates():\n    assert remove_duplicates([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_remove_duplicates_with_duplicates_and_empty():\n    assert remove_duplicates([1, 2, 2, 3, 4, 4, 5, 'a', 'a']) == [1, 2, 3, 4, 5, 'a']\n\ndef test_remove_duplicates_with_duplicates_and_strings():\n    assert remove_duplicates([\"apple\", \"banana\", \"apple\", \"orange\"]) == [\"apple\", \"banana\", \"orange\"]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def remove_duplicates(lst):\n    \"\"\"\n    Returns a new list with duplicates removed while preserving the original order.\n    \n    Args:\n    lst (list): The input list which may contain duplicate elements.\n    \n    Returns:\n    list: A list with unique elements.\n    \"\"\"\n    unique_elements = []\n    seen = set()\n    for item in lst:\n        if item not in seen:\n            unique_elements.append(item)\n            seen.add(item)\n    return unique_elements",
        "test_code": "def test_remove_duplicates():\n    # Test with a list that has duplicates\n    assert remove_duplicates([1, 2, 2, 3, 4, 4, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # Test with a list that has no duplicates\n    assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    \n    # Test with an empty list\n    assert remove_duplicates([]) == []\n    \n    # Test with a list that has all the same elements\n    assert remove_duplicates([1, 1, 1, 1, 1]) == [1]\n    \n    # Test with a list that has strings with duplicates\n    assert remove_duplicates([\"apple\", \"banana\", \"apple\", \"orange\"]) == [\"apple\", \"banana\", \"orange\"]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def remove_duplicates(input_list):\n    \"\"\"\n    Returns a new list with duplicates removed while preserving the original order.\n    \"\"\"\n    seen = set()\n    unique_list = []\n    for item in input_list:\n        if item not in seen:\n            unique_list.append(item)\n            seen.add(item)\n    return unique_list",
        "test_code": "from solution import remove_duplicates\n\ndef test_remove_duplicates_empty_list():\n    assert remove_duplicates([]) == []\n\ndef test_remove_duplicates_single_element():\n    assert remove_duplicates([1]) == [1]\n\ndef test_remove_duplicates_with_duplicates():\n    assert remove_duplicates([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_remove_duplicates_with_duplicates_and_empty():\n    assert remove_duplicates([1, 2, 2, 3, 4, 4, 5, 'a', 'a']) == [1, 2, 3, 4, 5, 'a']\n\ndef test_remove_duplicates_with_duplicates_and_strings():\n    assert remove_duplicates([\"apple\", \"banana\", \"apple\", \"orange\"]) == [\"apple\", \"banana\", \"orange\"]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000064",
      "row_id": 64,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the nth Fibonacci number.",
    "response": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number.\n    \n    The Fibonacci sequence is a series of numbers where each number is the sum\n    of the two preceding ones, usually starting with 0 and 1. That is,\n    F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1.\n    \n    Parameters:\n    n (int): The position in the Fibonacci sequence.\n    \n    Returns:\n    int: The nth Fibonacci number.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b",
    "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_one():\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == 1\n\ndef test_fibonacci_five():\n    assert fibonacci(5) == 5\n\ndef test_fibonacci_twenty():\n    assert fibonacci(20) == 6765",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number.\n    \n    The Fibonacci sequence is defined by the following:\n    F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_one():\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == 1\n\ndef test_fibonacci_five():\n    assert fibonacci(5) == 5\n\ndef test_fibonacci_ten():\n    assert fibonacci(10) == 55\n\ndef test_fibonacci_negative():\n    assert fibonacci(-1) == 0  # Assuming 0 as the base case for negative inputs",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number.\n    \n    The Fibonacci sequence is a series of numbers where a number is the addition of the last two numbers, starting with 0, and 1.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_0():\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_1():\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_10():\n    assert fibonacci(10) == 55\n\ndef test_fibonacci_negative():\n    assert fibonacci(-1) == 0\n\ndef test_fibonacci_large_value():\n    assert fibonacci(50) == 12586269025",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number.\n    \n    The Fibonacci sequence is a series of numbers where each number is the sum\n    of the two preceding ones, usually starting with 0 and 1. That is,\n    F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1.\n    \n    Parameters:\n    n (int): The position in the Fibonacci sequence.\n    \n    Returns:\n    int: The nth Fibonacci number.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_one():\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == 1\n\ndef test_fibonacci_five():\n    assert fibonacci(5) == 5\n\ndef test_fibonacci_twenty():\n    assert fibonacci(20) == 6765",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000065",
      "row_id": 65,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the maximum sum of a subarray within an array of integers. This is the famous Kadane's algorithm problem.",
    "response": "def max_subarray_sum(arr):\n    \"\"\"\n    Returns the maximum sum of a contiguous subarray within the one-dimensional array of numbers.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    # Initialize max_sum and current_sum with the first element\n    max_sum = current_sum = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for num in arr[1:]:\n        # If current_sum is negative, discard it and start a new subarray\n        current_sum = max(num, current_sum + num)\n        # Update max_sum if current_sum is greater\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum",
    "test_code": "from solution import max_subarray_sum\n\ndef test_max_subarray_sum_positive():\n    assert max_subarray_sum([1, 2, 3, 4, -10, 10]) == 10\n\ndef test_max_subarray_sum_single_element():\n    assert max_subarray_sum([5]) == 5\n\ndef test_max_subarray_sum_all_negative():\n    assert max_subarray_sum([-2, -3, -1]) == -1\n\ndef test_max_subarray_sum_mixed_elements():\n    assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\n\ndef test_max_subarray_sum_empty_array():\n    assert max_subarray_sum([]) == 0",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def max_subarray_sum(arr):\n    \"\"\"\n    Finds the maximum sum of a contiguous subarray within a one-dimensional array of numbers.\n    \n    Args:\n    arr (list of int): The input array.\n    \n    Returns:\n    int: The maximum subarray sum.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    max_current = max_global = arr[0]\n    for num in arr[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n            \n    return max_global",
        "test_code": "``\nfrom solution import max_subarray_sum\n\ndef test_max_subarray_sum_positive():\n    assert max_subarray_sum([1, 2, 3, -2, 5]) == 9\n\ndef test_max_subarray_sum_single_element():\n    assert max_subarray_sum([5]) == 5\n\ndef test_max_subarray_sum_all_negative():\n    assert max_subarray_sum([-1, -2, -3, -4]) == -1\n\ndef test_max_subarray_sum\u6df7\u5408\u6b63\u8d1f\u6570():\n    assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\n\ndef test_max_subarray_sum_empty_array():\n    assert max_subarray_sum([]) == 0",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def max_subarray_sum(arr):\n    \"\"\"\n    Returns the maximum sum of a contiguous subarray within the one-dimensional array of numbers.\n    \"\"\"\n    if not arr:\n        return 0\n\n    current_sum = max_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
        "test_code": "def test_max_subarray_sum():\n    assert max_subarray_sum([1, 2, 3, -2, 5]) == 9  # [1, 2, 3, -2, 5] -> 9\n    assert max_subarray_sum([-1, -2, -3, -4]) == -1  # Single element\n    assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6  # [4, -1, 2, 1] -> 6\n    assert max_subarray_sum([0, -1, 2, -3, 5]) == 5  # Single positive number\n    assert max_subarray_sum([-3, -6, -2, -5, -4]) == -2  # All negative numbers\n    assert max_subarray_sum([]) == 0  # Empty array",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def max_subarray_sum(arr):\n    \"\"\"\n    Returns the maximum sum of a contiguous subarray within the one-dimensional array of numbers.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    # Initialize max_sum and current_sum with the first element\n    max_sum = current_sum = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for num in arr[1:]:\n        # If current_sum is negative, discard it and start a new subarray\n        current_sum = max(num, current_sum + num)\n        # Update max_sum if current_sum is greater\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum",
        "test_code": "from solution import max_subarray_sum\n\ndef test_max_subarray_sum_positive():\n    assert max_subarray_sum([1, 2, 3, 4, -10, 10]) == 10\n\ndef test_max_subarray_sum_single_element():\n    assert max_subarray_sum([5]) == 5\n\ndef test_max_subarray_sum_all_negative():\n    assert max_subarray_sum([-2, -3, -1]) == -1\n\ndef test_max_subarray_sum_mixed_elements():\n    assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\n\ndef test_max_subarray_sum_empty_array():\n    assert max_subarray_sum([]) == 0",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000066",
      "row_id": 66,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to calculate the sum of all even numbers in a list. You should use list comprehension along with the `sum()` function to achieve this.",
    "response": "def sum_of_evens(numbers):\n    \"\"\"\n    Returns the sum of all even numbers in the given list.\n    \n    Example:\n    - Given [1, 2, 3, 4, 5, 6], it should return 12 (2 + 4 + 6 = 12).\n    \"\"\"\n    return sum([num for num in numbers if num % 2 == 0])",
    "test_code": "from solution import sum_of_evens\n\ndef test_sum_of_evens_empty_list():\n    assert sum_of_evens([]) == 0\n\ndef test_sum_of_evens_all_odd():\n    assert sum_of_evens([1, 3, 5, 7]) == 0\n\ndef test_sum_of_evens_all_even():\n    assert sum_of_evens([2, 4, 6, 8]) == 20\n\ndef test_sum_of_evens_mixed_numbers():\n    assert sum_of_evens([1, 2, 3, 4, 5, 6]) == 12\n\ndef test_sum_of_evens_with_zero():\n    assert sum_of_evens([0, 1, 2, 3, 4]) == 6",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def sum_of_evens(numbers):\n    \"\"\"\n    Returns the sum of all even numbers in the given list.\n    \n    Example:\n    - Given [1, 2, 3, 4, 5, 6], it should return 12 (2 + 4 + 6 = 12).\n    \"\"\"\n    return sum([num for num in numbers if num % 2 == 0])",
        "test_code": "from solution import sum_of_evens\n\ndef test_sum_of_evens_empty_list():\n    assert sum_of_evens([]) == 0\n\ndef test_sum_of_evens_all_odd():\n    assert sum_of_evens([1, 3, 5, 7]) == 0\n\ndef test_sum_of_evens_all_even():\n    assert sum_of_evens([2, 4, 6, 8]) == 20\n\ndef test_sum_of_evens_mixed_numbers():\n    assert sum_of_evens([1, 2, 3, 4, 5, 6]) == 12\n\ndef test_sum_of_evens_with_zero():\n    assert sum_of_evens([0, 1, 2, 3, 4]) == 6",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def sum_of_evens(lst):\n    \"\"\"\n    Returns the sum of all even numbers in the given list using list comprehension.\n    \"\"\"\n    return sum([x for x in lst if x % 2 == 0])",
        "test_code": "from solution import sum_of_evens\n\ndef test_sum_of_evens_with_even_numbers():\n    assert sum_of_evens([1, 2, 3, 4, 5, 6]) == 12\n\ndef test_sum_of_evens_with_odd_numbers():\n    assert sum_of_evens([1, 3, 5, 7]) == 0\n\ndef test_sum_of_evens_with_mixed_numbers():\n    assert sum_of_evens([10, 23, 45, 68, 90]) == 256\n\ndef test_sum_of_evens_with_negative_numbers():\n    assert sum_of_evens([-2, -4, -6, -8]) == -20\n\ndef test_sum_of_evens_with_empty_list():\n    assert sum_of_evens([]) == 0",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def sum_of_evens(lst):\n    \"\"\"\n    Returns the sum of all even numbers in the given list.\n    \"\"\"\n    return sum([x for x in lst if x % 2 == 0])",
        "test_code": "from solution import sum_of_evens\n\ndef test_sum_of_evens_empty_list():\n    assert sum_of_evens([]) == 0\n\ndef test_sum_of_evens_single_odd_element():\n    assert sum_of_evens([3]) == 0\n\ndef test_sum_of_evens_single_even_element():\n    assert sum_of_evens([2]) == 2\n\ndef test_sum_of_evens_multiple_elements():\n    assert sum_of_evens([1, 2, 3, 4, 5, 6]) == 12\n\ndef test_sum_of_evens_with_odds():\n    assert sum_of_evens([1, 3, 5, 7]) == 0\n\ndef test_sum_of_evens_with_negatives_and_zerors():\n    assert sum_of_evens([-4, -3, -2, -1, 0]) == -4",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000067",
      "row_id": 67,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to implement the quick sort algorithm, and explain the code line by line.",
    "response": "def quick_sort(arr):\n    \"\"\"\n    Sorts an array using the Quick Sort algorithm.\n    \n    Quick Sort is a divide-and-conquer algorithm. It works by selecting a 'pivot'\n    element from the array and partitioning the other elements into two sub-arrays,\n    according to whether they are less than or greater than the pivot. The sub-arrays\n    are then sorted recursively.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    \n    # Base case: if the array is empty or contains a single element, it is already sorted\n    if len(arr) <= 1:\n        return arr\n    \n    # Choose a pivot (here we choose the last element)\n    pivot = arr[-1]\n    \n    # Partition the array into three lists: less than, equal to, and greater than the pivot\n    less = [x for x in arr[:-1] if x < pivot]\n    greater = [x for x in arr[:-1] if x > pivot]\n    equal = [x for x in arr if x == pivot]\n    \n    # Recursively apply quick_sort to the less and greater lists and combine the results\n    return quick_sort(less) + equal + quick_sort(greater)",
    "test_code": "from solution import quick_sort\n\ndef test_quick_sort_empty():\n    assert quick_sort([]) == []\n\ndef test_quick_sort_single_element():\n    assert quick_sort([5]) == [5]\n\ndef test_quick_sort_positive_numbers():\n    assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\n\ndef test_quick_sort_negative_numbers():\n    assert quick_sort([-3, -6, -8, -10, -1, -2, -1]) == [-10, -8, -6, -3, -2, -1, -1]\n\ndef test_quick_sort_mixed_numbers():\n    assert quick_sort([-3, 6, -8, 10, -1, 2, 1, 0]) == [-8, -3, -1, 0, 1, 2, 6, 10]\n\ndef test_quick_sort_with_duplicates():\n    assert quick_sort([8, 8, 8, 8, 5, 3, 2]) == [2, 3, 5, 8, 8, 8, 8]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def quick_sort(arr):\n    \"\"\"\n    Sorts an array using the quick sort algorithm.\n\n    Parameters:\n    arr (list): The list to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    # Base case: if the array has 1 or 0 elements, it is already sorted\n    if len(arr) <= 1:\n        return arr\n\n    # Recursive case\n    else:\n        # Select the pivot element (here, the last element is chosen)\n        pivot = arr[-1]\n        # Partition the array into two halves based on the pivot\n        smaller_elements = [x for x in arr[:-1] if x <= pivot]\n        larger_elements = [x for x in arr[:-1] if x > pivot]\n\n        # Recursively sort the smaller and larger arrays, then combine with the pivot\n        return quick_sort(smaller_elements) + [pivot] + quick_sort(larger_elements)\n\n\nLet's break down the code line by line:\n1. **Function Definition**: Defines a function named `quick_sort` that takes a list `arr` as its parameter.\n2. **Base Case**: Checks if the input array has 1 or 0 elements. If so, it returns the array as it is already sorted.\n3. **Recursive Case**: If the array has more than one element, continues to the next steps.\n   - **Pivot**: Chooses the last element of the array as the pivot.\n   - **Partitioning**: Uses list comprehensions to create two new lists: `smaller_elements` for elements less than or equal to the pivot, and `larger_elements` for elements greater than the pivot.\n   - **Recursive Sorting**: Recursively calls `quick_sort` on the `smaller_elements` and `larger_elements`, and combines the results with the pivot in between.\n4. **Return**: Returns the sorted list.\n\nThe pivot selection and partitioning are crucial steps in implementing the quick sort algorithm, and the recursion progresses until the base case is reached.",
        "test_code": "from solution import quick_sort\n\ndef test_quick_sort Albania():\n    assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\n\ndef test_quick_sort_Burma():\n    assert quick_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n\ndef test_quick_sort_Canada():\n    assert quick_sort([10, 5, 2, 3, 7, 8, 1]) == [1, 2, 3, 5, 7, 8, 10]\n\ndef test_quick_sort_Denmark():\n    assert quick_sort([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1]\n\ndef test_quick_sort_Empty_list():\n    assert quick_sort([]) == []\n\ndef test_quick_sort_One_element():\n    assert quick_sort([7]) == [7]\n\ndef test_quick_sort_Mix_of_positive_and_negative():\n    assert quick_sort([-5, -1, 5, 1]) == [-5, -1, 1, 5]",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def quick_sort(arr):\n    \"\"\"\n    Sorts an array using the Quick Sort algorithm.\n    \n    Quick Sort is a divide-and-conquer algorithm. It works by selecting a 'pivot'\n    element from the array and partitioning the other elements into two sub-arrays,\n    according to whether they are less than or greater than the pivot. The sub-arrays\n    are then sorted recursively.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    \n    # Base case: if the array is empty or contains a single element, it is already sorted\n    if len(arr) <= 1:\n        return arr\n    \n    # Choose a pivot (here we choose the last element)\n    pivot = arr[-1]\n    \n    # Partition the array into three lists: less than, equal to, and greater than the pivot\n    less = [x for x in arr[:-1] if x < pivot]\n    greater = [x for x in arr[:-1] if x > pivot]\n    equal = [x for x in arr if x == pivot]\n    \n    # Recursively apply quick_sort to the less and greater lists and combine the results\n    return quick_sort(less) + equal + quick_sort(greater)",
        "test_code": "from solution import quick_sort\n\ndef test_quick_sort_empty():\n    assert quick_sort([]) == []\n\ndef test_quick_sort_single_element():\n    assert quick_sort([5]) == [5]\n\ndef test_quick_sort_positive_numbers():\n    assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\n\ndef test_quick_sort_negative_numbers():\n    assert quick_sort([-3, -6, -8, -10, -1, -2, -1]) == [-10, -8, -6, -3, -2, -1, -1]\n\ndef test_quick_sort_mixed_numbers():\n    assert quick_sort([-3, 6, -8, 10, -1, 2, 1, 0]) == [-8, -3, -1, 0, 1, 2, 6, 10]\n\ndef test_quick_sort_with_duplicates():\n    assert quick_sort([8, 8, 8, 8, 5, 3, 2]) == [2, 3, 5, 8, 8, 8, 8]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000068",
      "row_id": 68,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to count the trailing zeros in a given number.",
    "response": "def count_trailing_zeros(number):\n    \"\"\"\n    Counts and returns the number of trailing zeros in the given integer.\n    \"\"\"\n    if number == 0:\n        return 1  # Special case where the number itself is 0\n    count = 0\n    while number % 10 == 0:\n        count += 1\n        number //= 10\n    return count",
    "test_code": "def test_count_trailing_zeros():\n    assert count_trailing_zeros(1000) == 3\n    assert count_trailing_zeros(123000) == 3\n    assert count_trailing_zeros(123) == 0\n    assert count_trailing_zeros(0) == 1",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def count_trailing_zeros(number):\n    \"\"\"\n    Counts and returns the number of trailing zeros in the given integer.\n    \"\"\"\n    if number == 0:\n        return 1  # Special case where the number itself is 0\n    count = 0\n    while number % 10 == 0:\n        count += 1\n        number //= 10\n    return count",
        "test_code": "def test_count_trailing_zeros():\n    assert count_trailing_zeros(1000) == 3\n    assert count_trailing_zeros(123000) == 3\n    assert count_trailing_zeros(123) == 0\n    assert count_trailing_zeros(0) == 1",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def count_trailing_zeros(n):\n    \"\"\"\n    Returns the count of trailing zeros in the given number n.\n    \"\"\"\n    count = 0\n    while n % 10 == 0 and n != 0:\n        count += 1\n        n //= 10\n    return count",
        "test_code": "from solution import count_trailing_zeros\n\ndef test_trailing_zeros_grade():\n    assert count_trailing_zeros(1002000) == 3\n    assert count_trailing_zeros(10500) == 2\n    assert count_trailing_zeros(100005) == 1\n    assert count_trailing_zeros(123) == 0\n    assert count_trailing_zeros(0) == 1\n    assert count_trailing_zeros(10000000000000000000) == 19",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def count_trailing_zeros(number: int) -> int:\n    \"\"\"\n    Counts the number of trailing 0 bits in the binary representation of a given integer.\n    \"\"\"\n    count = 0\n    while number and number % 2 == 0:\n        number >>= 1\n        count += 1\n    return count",
        "test_code": "import pytest\n\ndef test_count_trailing_zeros():\n    assert count_trailing_zeros(100) == 2\n    assert count_trailing_zeros(7) == 0\n    assert count_trailing_zeros(1024) == 10\n    assert count_trailing_zeros(2048) == 11\n    assert count_trailing_zeros(5) == 0\n\ndef test_count_trailing_zeros_large_number():\n    assert count_trailingzeros(16777216) == 24",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000069",
      "row_id": 69,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the sum of all the multiples of 3 or 5 below 1000.",
    "response": "def sum_of_multiples():\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below 1000.\n    \"\"\"\n    return sum(i for i in range(1000) if i % 3 == 0 or i % 5 == 0)",
    "test_code": "from solution import sum_of_multiples\n\ndef test_sum_of_multiples_1000():\n    assert sum_of_multiples() == 233168",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def sum_of_multiples():\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below 1000.\n    \"\"\"\n    return sum(i for i in range(1000) if i % 3 == 0 or i % 5 == 0)",
        "test_code": "from solution import sum_of_multiples\n\ndef test_sum_of_multiples():\n    assert sum_of_multiples() == 233168",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def sum_of_multiples():\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below 1000.\n    \"\"\"\n    return sum(i for i in range(1000) if i % 3 == 0 or i % 5 == 0)",
        "test_code": "from solution import sum_of_multiples\n\ndef test_sum_of_multiples_1000():\n    assert sum_of_multiples() == 233168",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000071",
      "row_id": 71,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to perform a binary search on a sorted list of integers. The function should return the index of the target value if it is found, or -1 if it is not found. The list may not be empty.",
    "response": "def binary_search(arr, target):\n    \"\"\"\n    Perform a binary search on a sorted list of integers.\n    Returns the index of the target value if found, otherwise -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    "test_code": "from solution import binary_search\n\ndef test_binary_search_positive():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([10, 20, 30, 40, 50], 40) == 3\n\ndef test_binary_search_not_found():\n    assert binary_search([1, 2, 3, 4, 5], 6) == -1\n    assert binary_search([10, 20, 30, 40, 50], 7) == -1\n\ndef test_binary_search_single_element():\n    assert binary_search([5], 5) == 0\n    assert binary_search([5], 4) == -1\n\ndef test_binary_search_empty_list():\n    assert binary_search([], 1) == -1\n    assert binary_search([], 2) == -1\n\ndef test_binary_search_edge_cases():\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 9",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def binary_search(arr, target):\n    \"\"\"\n    Performs a binary search on a sorted list of integers to find the index of the target value.\n    Returns the index of the target value if found, or -1 if the target is not present.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
        "test_code": "def test_binary_search():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([1, 2, 3, 4, 5], 6) == -1\n    assert binary_search([1], 1) == 0\n    assert binary_search([1, 3, 5], 3) == 1\n    assert binary_search([1, 3, 5], 2) == -1\n    assert binary_search([1, 2, 3, 4, 5, 5, 6], 5) == 4  # Duplicate values in the list\n    assert binary_search([1, 2, 3, 4, 5], -1) == -1  # Target not in the list\n    assert binary_search([10, 20, 30, 40, 50], 30) == 2  # Middle element\n    assert binary_search([10, 20, 30, 40, 50], 25) == -1  # Element not found in the middle range",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def binary_search(sorted_list, target):\n    \"\"\"\n    Performs a binary search on a sorted list to find the target value.\n    Returns the index of the target if found, otherwise returns -1.\n    \"\"\"\n    left, right = 0, len(sorted_list) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if sorted_list[mid] < target:\n            left = mid + 1\n        elif sorted_list[mid] > target:\n            right = mid - 1\n        else:\n            return mid\n    return -1",
        "test_code": "from solution import binary_search\n\ndef test_binary_search_found():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([1, 2, 3, 4, 5], 4) == 3\n    assert binary_search([-5, -3, 0, 3, 7, 8, 9], 7) == 5\n    assert binary_search([10, 20, 30, 40, 50], 30) == 2\n\ndef test_binary_search_not_found():\n    assert binary_search([1, 2, 3, 4, 5], 6) == -1\n    assert binary_search([-5, -3, 0, 3, 7, 8, 9], 4) == -1\n    assert binary_search([1, 3, 5, 7], 2) == -1\n\ndef test_binary_search_empty_list():\n    assert binary_search([], 1) == -1",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def binary_search(arr, target):\n    \"\"\"\n    Perform a binary search on a sorted list of integers.\n    Returns the index of the target value if found, otherwise -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
        "test_code": "from solution import binary_search\n\ndef test_binary_search_positive():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([10, 20, 30, 40, 50], 40) == 3\n\ndef test_binary_search_not_found():\n    assert binary_search([1, 2, 3, 4, 5], 6) == -1\n    assert binary_search([10, 20, 30, 40, 50], 7) == -1\n\ndef test_binary_search_single_element():\n    assert binary_search([5], 5) == 0\n    assert binary_search([5], 4) == -1\n\ndef test_binary_search_empty_list():\n    assert binary_search([], 1) == -1\n    assert binary_search([], 2) == -1\n\ndef test_binary_search_edge_cases():\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0\n    assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 9",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      0,
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000073",
      "row_id": 73,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to check if a given number is perfect square or not. The function should take an integer as input and return True if the number is a perfect square, False otherwise.",
    "response": "def is_perfect_square(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect square.\n    \n    Args:\n    num (int): The number to check\n    \n    Returns:\n    bool: True if num is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    root = int(num ** 0.5)\n    return root * root == num",
    "test_code": "import pytest\nfrom solution import is_perfect_square\n\ndef test_is_perfect_square_positive_perfect_square():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(9) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n\ndef test_is_perfect_square_negative_number():\n    assert is_perfect_square(-4) == False\n\ndef test_is_perfect_square_non_perfect_square():\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(5) == False\n    assert is_perfect_square(6) == False\n    assert is_perfect_square(7) == False\n\ndef test_is_perfect_square_zero():\n    assert is_perfect_square(0) == True\n\ndef test_is_perfect_square_large_number():\n    assert is_perfect_square(15625) == True\n    assert is_perfect_square(15626) == False",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "import math\n\ndef is_perfect_square(n):\n    \"\"\"\n    Check if a given number is a perfect square.\n    \"\"\"\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return n == root * root",
        "test_code": "import math\nfrom solution import is_perfect_square\n\ndef test_is_perfect_square_positive():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(25) == True\n\ndef test_is_perfect_square_negative():\n    assert is_perfect_square(-1) == False\n    assert is_perfect_square(-4) == False\n\ndef test_is_perfect_square_non_perfect_square():\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(10) == False\n    assert is_perfect_square(15) == False\n\ndef test_is_perfect_square_large_number():\n    assert is_perfect_square(169) == True\n    assert is_perfect_square(180) == False\n\ndef test_is_perfect_square_zero():\n    assert is_perfect_square(0) == True\n\ndef test_is_perfect_square_one():\n    assert is_perfect_square(1) == True",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "import math\n\ndef is_perfect_square(n):\n    \"\"\"\n    Checks if the given number is a perfect square.\n    \n    Arguments:\n    n -- an integer\n    \n    Returns:\n    True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return n == root * root",
        "test_code": "import pytest\nfrom solution import is_perfect_square\n\ndef test_perfect_square_positive_numbers():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(9) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n\ndef test_perfect_square_zero():\n    assert is_perfect_square(0) == True\n\ndef test_perfect_square_negative_numbers():\n    assert is_perfect_square(-1) == False\n    assert is_perfect_square(-4) == False\n    assert is_perfect_square(-9) == False\n\ndef test_perfect_square_non_square_numbers():\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(5) == False\n    assert is_perfect_square(6) == False\n    assert is_perfect_square(7) == False\n    assert is_perfect_square(8) == False\n    assert is_perfect_square(10) == False\n\ndef test_perfect_square_large_numbers():\n    assert is_perfect_square(2601) == True\n    assert is_perfect_square(44100) == True\n    assert is_perfect_square(15241383936) == True",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_perfect_square(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect square.\n    \n    Args:\n    num (int): The number to check\n    \n    Returns:\n    bool: True if num is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    root = int(num ** 0.5)\n    return root * root == num",
        "test_code": "import pytest\nfrom solution import is_perfect_square\n\ndef test_is_perfect_square_positive_perfect_square():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(9) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n\ndef test_is_perfect_square_negative_number():\n    assert is_perfect_square(-4) == False\n\ndef test_is_perfect_square_non_perfect_square():\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(5) == False\n    assert is_perfect_square(6) == False\n    assert is_perfect_square(7) == False\n\ndef test_is_perfect_square_zero():\n    assert is_perfect_square(0) == True\n\ndef test_is_perfect_square_large_number():\n    assert is_perfect_square(15625) == True\n    assert is_perfect_square(15626) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000074",
      "row_id": 74,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to check if a number is perfect or not.",
    "response": "def is_perfect_number(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect number.\n    A perfect number is a positive integer that is equal to the sum of its proper divisors,\n    excluding the number itself.\n    \"\"\"\n    if num < 1:\n        return False\n    divisors_sum = 1  # 1 is a divisor for all positive integers\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            divisors_sum += i\n            if i != num // i:  # add the quotient only if it's different from i\n                divisors_sum += num // i\n    return divisors_sum == num",
    "test_code": "import pytest\n\ndef test_is_perfect_number():\n    assert is_perfect_number(6) == True  # 1+2+3 = 6\n    assert is_perfect_number(28) == True  # 1+2+4+7+14 = 28\n    assert is_perfect_number(496) == True  # 1+2+4+8+16+31+62+124+248 = 496\n    assert is_perfect_number(8128) == True  # 1+2+4+8+16+32+64+127+254+508+1016+2032+4064 = 8128\n    assert is_perfect_number(12) == False  # 1+2+3+4+6 = 16\n    assert is_perfect_number(10) == False  # 1+2+5 = 8\n    assert is_perfect_number(0) == False  # 0 is not a perfect number\n    assert is_perfect_number(-28) == False  # Negative numbers are not considered perfect",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def is_perfect_number(number):\n    \"\"\"\n    Returns True if the given number is a perfect number, False otherwise.\n    A perfect number is a positive integer that is equal to the sum of its proper divisors.\n    \"\"\"\n    if number <= 1:\n        return False\n    divisors_sum = sum([i for i in range(1, number) if number % i == 0])\n    return divisors_sum == number",
        "test_code": "from solution import is_perfect_number\n\ndef test_is_perfect_number_small():\n    assert not is_perfect_number(1)\n    assert is_perfect_number(6)  # 1 + 2 + 3 = 6\n    assert is_perfect_number(28) # 1 + 2 + 4 + 7 + 14 = 28\n\ndef test_is_perfect_number_large():\n    assert not is_perfect_number(100)\n    assert is_perfect_number(496) # 1 + 2 + 4 + 8 + 16 + 31 + 62 + 124 + 248 = 496\n    assert not is_perfect_number(8128) # This is a known perfect number, but not in the range where we expect false negatives\n\ndef test_is_perfect_number_negative():\n    assert not is_perfect_number(-28)\n\ndef test_is_perfect_number_zero():\n    assert not is_perfect_number(0)",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def is_perfect_number(n):\n    \"\"\"\n    Returns True if n is a perfect number, False otherwise.\n    A perfect number is a positive integer that is equal to the sum of its proper divisors,\n    excluding the number itself. For example, 6 is a perfect number because 1 + 2 + 3 = 6.\n    \"\"\"\n    if n < 1:\n        return False\n    divisors_sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            divisors_sum += i\n    return divisors_sum == n",
        "test_code": "from solution import is_perfect_number\n\ndef test_is_perfect_number_six():\n    assert is_perfect_number(6) == True\n\ndef test_is_perfect_number_twenty_eight():\n    assert is_perfect_number(28) == True\n\ndef test_is_not_perfect_number_four():\n    assert is_perfect_number(4) == False\n\ndef test_is_not_perfect_number_negative_numbers():\n    assert is_perfect_number(-6) == False\n\ndef test_is_not_perfect_number_zero():\n    assert is_perfect_number(0) == False\n\ndef test_is_not_perfect_number_one():\n    assert is_perfect_number(1) == False\n\ndef test_is_not_perfect_number_large_number():\n    assert is_perfect_number(496) == True\n    assert is_perfect_number(8128) == True\n    assert is_perfect_number(33550336) == True\n    assert is_perfect_number(8589869056) == True\n    assert is_perfect_number(137438691328) == True\n    assert is_perfect_number(2305843008139952128) == True\n\ndef test_is_not_perfect_number_other_numbers():\n    assert is_perfect_number(5) == False\n    assert is_perfect_number(10) == False\n    assert is_perfect_number(15) == False\n    assert is_perfect_number(18) == False\n    assert is_perfect_number(20) == False\n    assert is_perfect_number(21) == False",
        "test_result": "Fail - Timed Out",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_perfect_number(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect number.\n    A perfect number is a positive integer that is equal to the sum of its proper divisors,\n    excluding the number itself.\n    \"\"\"\n    if num < 1:\n        return False\n    divisors_sum = 1  # 1 is a divisor for all positive integers\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            divisors_sum += i\n            if i != num // i:  # add the quotient only if it's different from i\n                divisors_sum += num // i\n    return divisors_sum == num",
        "test_code": "import pytest\n\ndef test_is_perfect_number():\n    assert is_perfect_number(6) == True  # 1+2+3 = 6\n    assert is_perfect_number(28) == True  # 1+2+4+7+14 = 28\n    assert is_perfect_number(496) == True  # 1+2+4+8+16+31+62+124+248 = 496\n    assert is_perfect_number(8128) == True  # 1+2+4+8+16+32+64+127+254+508+1016+2032+4064 = 8128\n    assert is_perfect_number(12) == False  # 1+2+3+4+6 = 16\n    assert is_perfect_number(10) == False  # 1+2+5 = 8\n    assert is_perfect_number(0) == False  # 0 is not a perfect number\n    assert is_perfect_number(-28) == False  # Negative numbers are not considered perfect",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      0,
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000075",
      "row_id": 75,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the number of unique elements in a given list. thoughts to solve: First, recognize that unique elements are those that appear only once in the list. One could iterate through the list and for each element, count how many times it appears. If it appears exactly once, it's a unique element. Another approach could be to use a data structure that inherently prevents duplicates, such as a set. A set only stores unique elements, so if a list is converted to a set, the length of the set will be the number of unique elements.",
    "response": "def count_unique_elements(lst):\n    \"\"\"\n    Returns the number of unique elements in a given list.\n    \n    Parameters:\n    lst (list): The input list containing elements.\n    \n    Returns:\n    int: The number of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    return len(unique_elements)",
    "test_code": "from solution import count_unique_elements\n\ndef test_count_unique_elements_empty_list():\n    assert count_unique_elements([]) == 0\n\ndef test_count_unique_elements_single_element():\n    assert count_unique_elements([1]) == 1\n\ndef test_count_unique_elements_duplicate_elements():\n    assert count_unique_elements([1, 2, 3, 4, 5]) == 5\n\ndef test_count_unique_elements_with_duplicates():\n    assert count_unique_elements([1, 2, 2, 3, 4, 4, 5]) == 5\n\ndef test_count_unique_elements_same_elements():\n    assert count_unique_elements([1, 1, 1, 1, 1]) == 1",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def count_unique_elements(lst):\n    \"\"\"\n    Returns the number of unique elements in the given list.\n    \"\"\"\n    unique_elements = set(lst)\n    return len(unique_elements)",
        "test_code": "from solution import count_unique_elements\n\ndef test_count_unique_elements():\n    assert count_unique_elements([1, 2, 3, 2, 4]) == 4\n\ndef test_count_unique_elements_empty_list():\n    assert count_unique_elements([]) == 0\n\ndef test_count_unique_elements_duplicates():\n    assert count_unique_elements([1, 2, 2, 3, 3, 3]) == 2\n\ndef test_count_unique_elements_single_unique_element():\n    assert count_unique_elements([1, 1, 1, 1, 1]) == 1\n\ndef test_count_unique_elements_all_unique():\n    assert count_unique_elements([1, 2, 3, 4, 5]) == 5",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def count_unique_elements(lst):\n    \"\"\"\n    Returns the number of unique elements in the given list.\n    \"\"\"\n    unique_elements = set(lst)\n    return len(unique_elements)",
        "test_code": "from solution import count_unique_elements\n\ndef test_count_unique_elements_empty_list():\n    assert count_unique_elements([]) == 0\n\ndef test_count_unique_elements_single_repeating_elements():\n    assert count_unique_elements([1, 1, 1, 2, 2, 3]) == 3\n    assert count_unique_elements([2, 2, 2, 2]) == 1\n\ndef test_count_unique_elements_distinct_elements():\n    assert count_unique_elements([10, 20, 30, 40, 50]) == 5\n\ndef test_count_unique_elements_mixed_elements():\n    assert count_unique_elements([1, 2, 3, 2, 4, 5, 1, 3]) == 3\n    assert count_unique_elements([1, 1, 1, 1, 1]) == 1",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def count_unique_elements(lst):\n    \"\"\"\n    Returns the number of unique elements in a given list.\n    \n    Parameters:\n    lst (list): The input list containing elements.\n    \n    Returns:\n    int: The number of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    return len(unique_elements)",
        "test_code": "from solution import count_unique_elements\n\ndef test_count_unique_elements_empty_list():\n    assert count_unique_elements([]) == 0\n\ndef test_count_unique_elements_single_element():\n    assert count_unique_elements([1]) == 1\n\ndef test_count_unique_elements_duplicate_elements():\n    assert count_unique_elements([1, 2, 3, 4, 5]) == 5\n\ndef test_count_unique_elements_with_duplicates():\n    assert count_unique_elements([1, 2, 2, 3, 4, 4, 5]) == 5\n\ndef test_count_unique_elements_same_elements():\n    assert count_unique_elements([1, 1, 1, 1, 1]) == 1",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      0,
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000081",
      "row_id": 81,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to calculate the area of a circle given its radius.",
    "response": "import math\n\ndef area_of_circle(radius):\n    \"\"\"\n    Returns the area of a circle given its radius.\n    \"\"\"\n    return math.pi * (radius ** 2)",
    "test_code": "from solution import area_of_circle\n\ndef test_area_of_circle_positive_radius():\n    assert abs(area_of_circle(1) - math.pi) < 1e-9\n    assert abs(area_of_circle(2) - (4 * math.pi)) < 1e-9\n\ndef test_area_of_circle_zero_radius():\n    assert area_of_circle(0) == 0.0\n\ndef test_area_of_circle_negative_radius():\n    assert abs(area_of_circle(-1) - math.pi) < 1e-9\n\ndef test_area_of_circle_large_radius():\n    assert abs(area_of_circle(10) - (100 * math.pi)) < 1e-9",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "import math\n\ndef calculate_circle_area(radius):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n    \n    Args:\n    radius (float): The radius of the circle.\n\n    Returns:\n    float: The area of the circle.\n    \"\"\"\n    return math.pi * (radius ** 2)",
        "test_code": "import pytest\nfrom solution import calculate_circle_area\n\ndef test_area_with_radius_one():\n    assert abs(calculate_circle_area(1) - math.pi) < 1e-9\n\ndef test_area_with_radius_zero():\n    assert calculate_circle_area(0) == 0\n\ndef test_area_with_radius_negative():\n    assert abs(calculate_circle_area(-2) - (math.pi * (2 ** 2))) < 1e-9\n\ndef test_area_with_large_radius():\n    assert abs(calculate_circle_area(5) - (math.pi * (5 ** 2))) < 1e-9\n\ndef test_area_with_decimal_radius():\n    assert abs(calculate_circle_area(1.5) - (math.pi * (1.5 ** 2))) < 1e-9",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "import math\n\ndef calculate_circle_area(radius):\n    \"\"\"\n    Calculates the area of a circle given its radius.\n    \n    Parameters:\n    radius (float): The radius of the circle.\n    \n    Returns:\n    float: The area of the circle.\n    \"\"\"\n    return math.pi * (radius ** 2)",
        "test_code": "import math\nfrom solution import calculate_circle_area\n\ndef test_circle_area():\n    assert abs(calculate_circle_area(0) - 0) < 1e-6\n    assert abs(calculate_circle_area(1) - math.pi) < 1e-6\n    assert abs(calculate_circle_area(2) - (math.pi * 4)) < 1e-6\n    assert abs(calculate_circle_area(5) - (math.pi * 25)) < 1e-6",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "import math\n\ndef area_of_circle(radius):\n    \"\"\"\n    Returns the area of a circle given its radius.\n    \"\"\"\n    return math.pi * (radius ** 2)",
        "test_code": "from solution import area_of_circle\n\ndef test_area_of_circle_positive_radius():\n    assert abs(area_of_circle(1) - math.pi) < 1e-9\n    assert abs(area_of_circle(2) - (4 * math.pi)) < 1e-9\n\ndef test_area_of_circle_zero_radius():\n    assert area_of_circle(0) == 0.0\n\ndef test_area_of_circle_negative_radius():\n    assert abs(area_of_circle(-1) - math.pi) < 1e-9\n\ndef test_area_of_circle_large_radius():\n    assert abs(area_of_circle(10) - (100 * math.pi)) < 1e-9",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000083",
      "row_id": 83,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the number of times a specified value appears in a list. Here's a sample list: [1, 2, 3, 4, 5, 2, 2, 3]",
    "response": "def count_value_occurrences(lst, value):\n    \"\"\"\n    Returns the number of times 'value' appears in 'lst'.\n    \"\"\"\n    return lst.count(value)",
    "test_code": "from solution import count_value_occurrences\n\ndef test_count_value_occurrences():\n    assert count_value_occurrences([1, 2, 3, 4, 5, 2, 2, 3], 2) == 3\n    assert count_value_occurrences([1, 2, 3, 4, 5, 2, 2, 3], 7) == 0\n    assert count_value_occurrences([1, 1, 1, 1, 1], 1) == 5\n    assert count_value_occurrences([], 3) == 0",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def count_value_occurrences(lst, value):\n    \"\"\"\n    Returns the number of times a specified value appears in a list.\n    \"\"\"\n    return lst.count(value)",
        "test_code": "from solution import count_value_occurrences\n\ndef test_count_value_occurrences():\n    assert count_value_occurrences([1, 2, 3, 4, 5, 2, 2, 3], 2) == 3\n    assert count_value_occurrences([1, 1, 1, 1], 1) == 4\n    assert count_value_occurrences([1, 2, 3, 4, 5], 6) == 0\n    assert count_value_occurrences([], 1) == 0",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def count_value_occurrences(lst, value):\n    \"\"\"\n    Returns the number of times 'value' appears in 'lst'.\n    \"\"\"\n    return lst.count(value)",
        "test_code": "from solution import count_value_occurrences\n\ndef test_count_value_occurrences():\n    assert count_value_occurrences([1, 2, 3, 4, 5, 2, 2, 3], 2) == 3\n    assert count_value_occurrences([1, 2, 3, 4, 5, 2, 2, 3], 7) == 0\n    assert count_value_occurrences([1, 1, 1, 1, 1], 1) == 5\n    assert count_value_occurrences([], 3) == 0",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000084",
      "row_id": 84,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the minimum element in an array. You should also handle the case when the array is empty.",
    "response": "def find_minimum(arr):\n    \"\"\"\n    Returns the minimum element in the array arr.\n    If the array is empty, returns None.\n    \"\"\"\n    if not arr:\n        return None\n    return min(arr)",
    "test_code": "from solution import find_minimum\n\ndef test_find_minimum_non_empty_array():\n    assert find_minimum([3, 1, 4, 1, 5, 9]) == 1\n\ndef test_find_minimum_single_element_array():\n    assert find_minimum([10]) == 10\n\ndef test_find_minimum_empty_array():\n    assert find_minimum([]) == None\n\ndef test_find_minimum_negative_numbers():\n    assert find_minimum([-5, -1, -6]) == -6\n\ndef test_find_minimum_with_duplicate_minimum():\n    assert find_minimum([2, 2, 3, 1, 2]) == 1",
    "trials": {
      "trial_qwen2.5_2": {
        "solution_code": "def find_minimum(arr):\n    \"\"\"\n    Returns the minimum element in the array arr.\n    If the array is empty, returns None.\n    \"\"\"\n    if not arr:\n        return None\n    return min(arr)",
        "test_code": "from solution import find_minimum\n\ndef test_find_minimum_non_empty_array():\n    assert find_minimum([3, 1, 4, 1, 5, 9]) == 1\n\ndef test_find_minimum_single_element_array():\n    assert find_minimum([10]) == 10\n\ndef test_find_minimum_empty_array():\n    assert find_minimum([]) == None\n\ndef test_find_minimum_negative_numbers():\n    assert find_minimum([-5, -1, -6]) == -6\n\ndef test_find_minimum_with_duplicate_minimum():\n    assert find_minimum([2, 2, 3, 1, 2]) == 1",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000086",
      "row_id": 86,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to calculate the factorial of a given number. The function should take an integer as input and return the factorial of that integer. Additionally, the function should handle edge cases such as negative numbers and zero.",
    "response": "def factorial(n):\n    \"\"\"\n    Returns the factorial of n. If n is a negative integer, the function returns None.\n    For n=0, the function returns 1 as the factorial of 0 is 1.\n    \"\"\"\n    if n < 0:\n        return None\n    elif n == 0:\n        return 1\n    else:\n        result = 1\n        for i in range(1, n + 1):\n            result *= i\n        return result",
    "test_code": "from solution import factorial\n\ndef test_factorial_positive_numbers():\n    assert factorial(5) == 120\n    assert factorial(3) == 6\n    assert factorial(1) == 1\n\ndef test_factorial_zero():\n    assert factorial(0) == 1\n\ndef test_factorial_negative_numbers():\n    assert factorial(-1) is None\n    assert factorial(-5) is None\n\ndef test_factorial_large_number():\n    assert factorial(10) == 3628800",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def factorial(n):\n    \"\"\"\n    Calculates the factorial of a given number n.\n    :param n: integer\n    :return: factorial of n\n    \n    Handles edge cases:\n    - Factorial of 0 is 1\n    - Factorial is not defined for negative numbers, returns None\n    \"\"\"\n    if n < 0:\n        return None\n    elif n == 0:\n        return 1\n    else:\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result",
        "test_code": "from solution import factorial\n\ndef test_factorial_zero():\n    assert factorial(0) == 1\n\ndef test_factorial_positive_numbers():\n    assert factorial(5) == 120\n    assert factorial(3) == 6\n    assert factorial(1) == 1\n\ndef test_factorial_negative_numbers():\n    assert factorial(-1) is None\n\ndef test_factorial_large_number():\n    assert factorial(10) == 3628800",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a given number.\n    \n    Args:\n    n (int): The input number for which the factorial is to be calculated.\n    \n    Returns:\n    int: The factorial of the input number. Returns 1 for n=0 and raises ValueError for negative inputs.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if n == 0:\n        return 1\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result",
        "test_code": "import pytest\nfrom solution import factorial\n\ndef test_factorial_positive_numbers():\n    assert factorial(5) == 120\n    assert factorial(3) == 6\n    assert factorial(1) == 1\n\ndef test_factorial_zero():\n    assert factorial(0) == 1\n\ndef test_factorial_negative_numbers():\n    with pytest.raises(ValueError):\n        factorial(-1)\n\ndef test_factorial_large_number():\n    assert factorial(10) == 3628800",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def factorial(n):\n    \"\"\"\n    Returns the factorial of n. If n is a negative integer, the function returns None.\n    For n=0, the function returns 1 as the factorial of 0 is 1.\n    \"\"\"\n    if n < 0:\n        return None\n    elif n == 0:\n        return 1\n    else:\n        result = 1\n        for i in range(1, n + 1):\n            result *= i\n        return result",
        "test_code": "from solution import factorial\n\ndef test_factorial_positive_numbers():\n    assert factorial(5) == 120\n    assert factorial(3) == 6\n    assert factorial(1) == 1\n\ndef test_factorial_zero():\n    assert factorial(0) == 1\n\ndef test_factorial_negative_numbers():\n    assert factorial(-1) is None\n    assert factorial(-5) is None\n\ndef test_factorial_large_number():\n    assert factorial(10) == 3628800",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000089",
      "row_id": 89,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find all prime numbers within a given range (inclusive). The function should return a list of all prime numbers within the range.",
    "response": "def find_primes_in_range(start, end):\n    \"\"\"\n    Returns a list of all prime numbers within the given range [start, end].\n    \"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [num for num in range(start, end + 1) if is_prime(num)]\n    return primes",
    "test_code": "from solution import find_primes_in_range\n\ndef test_find_primes_in_range():\n    assert find_primes_in_range(5, 10) == [5, 7]\n    assert find_primes_in_range(10, 15) == [11, 13]\n    assert find_primes_in_range(20, 25) == [23]\n    assert find_primes_in_range(1, 5) == [2, 3, 5]\n    assert find_primes_in_range(14, 14) == []\n    assert find_primes_in_range(30, 40) == [31, 37]\n    assert find_primes_in_range(50, 60) == [53, 59]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def is_prime(n):\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef find_primes_in_range(start, end):\n    \"\"\"\n    Returns a list of all prime numbers within the given range [start, end] inclusive.\n    \"\"\"\n    return [n for n in range(start, end + 1) if is_prime(n)]",
        "test_code": "from solution import is_prime, find_primes_in_range\n\ndef test_is_prime():\n    assert is_prime(2) == True\n    assert is_prime(3) == True\n    assert is_prime(4) == False\n    assert is_prime(5) == True\n    assert is_prime(6) == False\n    assert is_prime(29) == True\n    assert is_prime(30) == False\n\ndef test_find_primes_in_range():\n    assert find_primes_in_range(5, 15) == [5, 7, 11, 13]\n    assert find_primes_in_range(1, 10) == [2, 3, 5, 7]\n    assert find_primes_in_range(20, 22) == []\n    assert find_primes_in_range(14, 14) == []\n    assert find_primes_in_range(11, 11) == [11]\n    assert find_primes_in_range(10, 20) == [11, 13, 17, 19]\n\ndef test_find_primes_in_range_edge_cases():\n    assert find_primes_in_range(0, 5) == [2, 3, 5]\n    assert find_primes_in_range(5, 0) == []\n    assert find_primes_in_range(0, 0) == []",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def find_primes_in_range(start, end):\n    \"\"\"\n    Returns a list of all prime numbers within the given range [start, end].\n    \"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [num for num in range(start, end + 1) if is_prime(num)]\n    return primes",
        "test_code": "from solution import find_primes_in_range\n\ndef test_find_primes_in_range():\n    assert find_primes_in_range(5, 10) == [5, 7]\n    assert find_primes_in_range(10, 15) == [11, 13]\n    assert find_primes_in_range(20, 25) == [23]\n    assert find_primes_in_range(1, 5) == [2, 3, 5]\n    assert find_primes_in_range(14, 14) == []\n    assert find_primes_in_range(30, 40) == [31, 37]\n    assert find_primes_in_range(50, 60) == [53, 59]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_primes_in_range(start, end):\n    \"\"\"\n    Returns a list of all prime numbers between start and end inclusive.\n    \"\"\"\n    primes = []\n    for num in range(start, end + 1):\n        if is_prime(num):\n            primes.append(num)\n    return primes",
        "test_code": "def test_find_primes_in_range():\n    assert find_primes_in_range(5, 11) == [5, 7, 11]\n    assert find_primes_in_range(14, 19) == [17, 19]\n    assert find_primes_in_range(22, 29) == [23, 29]\n    assert find_primes_in_range(1, 3) == [2, 3]\n    assert find_primes_in_range(100, 104) == []\n    assert find_primes_in_range(75, 80) == [79]",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      0
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000091",
      "row_id": 91,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to sort a list of tuples by the second item in each tuple. The function should take a list of tuples as input and return the sorted list in ascending order based on the second item of each tuple. If the second item is the same for multiple tuples, the tuples should be sorted by their first item in ascending order.",
    "response": "def sort_tuples(lst):\n    \"\"\"\n    Sorts a list of tuples by the second item, then by the first item if the second items are equal.\n    \"\"\"\n    return sorted(lst, key=lambda x: (x[1], x[0]))",
    "test_code": "def test_sort_tuples():\n    assert sort_tuples([(1, 3), (4, 1), (5, 2), (3, 2)]) == [(4, 1), (3, 2), (5, 2), (1, 3)]\n    assert sort_tuples([(2, 2), (3, 1), (1, 2), (4, 1)]) == [(3, 1), (4, 1), (1, 2), (2, 2)]\n    assert sort_tuples([(1, 5), (2, 4), (3, 4)]) == [(2, 4), (3, 4), (1, 5)]\n    assert sort_tuples([(1, 1), (2, 2), (3, 1)]) == [(1, 1), (3, 1), (2, 2)]\n    assert sort_tuples([(10, 10), (5, 5), (7, 8)]) == [(5, 5), (7, 8), (10, 10)]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def sort_tuples_list(tuples_list):\n    \"\"\"\n    Sorts a list of tuples based on the second item in each tuple in ascending order.\n    If two tuples have the same second item, they are sorted by their first item in ascending order.\n    \"\"\"\n    return sorted(tuples_list, key=lambda x: (x[1], x[0]))",
        "test_code": "from solution import sort_tuples_list\n\ndef test_sort_tuples_list():\n    assert sort_tuples_list([(1, 3), (4, 1), (5, 2), (3, 2)]) == [(4, 1), (3, 2), (5, 2), (1, 3)]\n    assert sort_tuples_list([(2, 5), (3, 4), (1, 4), (4, 5)]) == [(1, 4), (3, 4), (2, 5), (4, 5)]\n    assert sort_tuples_list([(2, 2), (3, 2), (1, 2)]) == [(1, 2), (2, 2), (3, 2)]\n    assert sort_tuples_list([(4, 10), (5, 2), (1, 3)]) == [(1, 3), (5, 2), (4, 10)]\n    assert sort_tuples_list([]) == []\n    assert sort_tuples_list([(1, 1)]) == [(1, 1)]",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def sort_tuples_by_second_item(tuples_list):\n    \"\"\"\n    Sorts a list of tuples based on the second item in each tuple in ascending order.\n    If two tuples have the same second item, it sorts them by the first item in ascending order.\n    \n    :param tuples_list: List of tuples to be sorted\n    :return: Sorted list of tuples\n    \"\"\"\n    return sorted(tuples_list, key=lambda x: (x[1], x[0]))",
        "test_code": "from solution import sort_tuples_by_second_item\n\ndef test_sort_tuples_by_second_item():\n    assert sort_tuples_by_second_item([(1, 3), (4, 1), (5, 2), (3, 2)]) == [(4, 1), (5, 2), (3, 2), (1, 3)]\n    assert sort_tuples_by_second_item([(2, 2), (3, 1), (1, 1)]) == [(3, 1), (1, 1), (2, 2)]\n    assert sort_tuples_by_second_item([(1, 1), (2, 1), (3, 1)]) == [(1, 1), (2, 1), (3, 1)]\n    assert sort_tuples_by_second_item([(4, 2), (5, 2), (2, 1)]) == [(2, 1), (4, 2), (5, 2)]",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def sort_tuples(lst):\n    \"\"\"\n    Sorts a list of tuples by the second item, then by the first item if the second items are equal.\n    \"\"\"\n    return sorted(lst, key=lambda x: (x[1], x[0]))",
        "test_code": "def test_sort_tuples():\n    assert sort_tuples([(1, 3), (4, 1), (5, 2), (3, 2)]) == [(4, 1), (3, 2), (5, 2), (1, 3)]\n    assert sort_tuples([(2, 2), (3, 1), (1, 2), (4, 1)]) == [(3, 1), (4, 1), (1, 2), (2, 2)]\n    assert sort_tuples([(1, 5), (2, 4), (3, 4)]) == [(2, 4), (3, 4), (1, 5)]\n    assert sort_tuples([(1, 1), (2, 2), (3, 1)]) == [(1, 1), (3, 1), (2, 2)]\n    assert sort_tuples([(10, 10), (5, 5), (7, 8)]) == [(5, 5), (7, 8), (10, 10)]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      0,
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000092",
      "row_id": 92,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the smallest number in an array of integers.",
    "response": "def find_smallest_number(arr):\n    \"\"\"\n    Returns the smallest number in an array of integers.\n    \n    Parameters:\n    arr (list of int): The array of integers.\n    \n    Returns:\n    int: The smallest number in the array.\n    \"\"\"\n    if not arr:  # Check if the array is empty\n        return None\n    smallest = arr[0]\n    for num in arr:\n        if num < smallest:\n            smallest = num\n    return smallest",
    "test_code": "import pytest\n\ndef test_find_smallest_number_with_positive_numbers():\n    arr = [4, 2, 9, 7, 5, 6]\n    assert find_smallest_number(arr) == 2\n\ndef test_find_smallest_number_with_negative_numbers():\n    arr = [-5, -2, -6, -1, -3]\n    assert find_smallest_number(arr) == -6\n\ndef test_find_smallest_number_with_mixed_sign_numbers():\n    arr = [2, -3, 5, -1, 0, -4]\n    assert find_smallest_number(arr) == -4\n\ndef test_find_smallest_number_with_single_element():\n    arr = [7]\n    assert find_smallest_number(arr) == 7\n\ndef test_find_smallest_number_with_empty_array():\n    arr = []\n    assert find_smallest_number(arr) is None\n\ndef test_find_smallest_number_with_duplicate_numbers():\n    arr = [3, 3, 3, 3, 3]\n    assert find_smallest_number(arr) == 3",
    "trials": {
      "trial_qwen2.5_1": {
        "solution_code": "def find_smallest_number(arr):\n    \"\"\"\n    Returns the smallest number in the given array of integers.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array must not be empty\")\n    smallest = arr[0]\n    for num in arr:\n        if num < smallest:\n            smallest = num\n    return smallest",
        "test_code": "from solution import find_smallest_number\n\ndef test_find_smallest_number_positive_integers():\n    assert find_smallest_number([3, 1, 4, 1, 5, 9]) == 1\n\ndef test_find_smallest_number_single_element():\n    assert find_smallest_number([42]) == 42\n\ndef test_find_smallest_number_negative_integers():\n    assert find_smallest_number([-5, -2, -10, -1]) == -10\n\ndef test_find_smallest_number_empty_array():\n    with pytest.raises(ValueError):\n        find_smallest_number([])\n\ndef test_find_smallest_number_mixed_signs():\n    assert find_smallest_number([-1, 1, -3, 3, -2, 2]) == -3",
        "test_result": "Fail",
        "test_coverage": 88.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def find_smallest_number(arr):\n    \"\"\"\n    Returns the smallest number in an array of integers.\n    \n    Parameters:\n    arr (list of int): The array of integers.\n    \n    Returns:\n    int: The smallest number in the array.\n    \"\"\"\n    if not arr:  # Check if the array is empty\n        return None\n    smallest = arr[0]\n    for num in arr:\n        if num < smallest:\n            smallest = num\n    return smallest",
        "test_code": "import pytest\n\ndef test_find_smallest_number_with_positive_numbers():\n    arr = [4, 2, 9, 7, 5, 6]\n    assert find_smallest_number(arr) == 2\n\ndef test_find_smallest_number_with_negative_numbers():\n    arr = [-5, -2, -6, -1, -3]\n    assert find_smallest_number(arr) == -6\n\ndef test_find_smallest_number_with_mixed_sign_numbers():\n    arr = [2, -3, 5, -1, 0, -4]\n    assert find_smallest_number(arr) == -4\n\ndef test_find_smallest_number_with_single_element():\n    arr = [7]\n    assert find_smallest_number(arr) == 7\n\ndef test_find_smallest_number_with_empty_array():\n    arr = []\n    assert find_smallest_number(arr) is None\n\ndef test_find_smallest_number_with_duplicate_numbers():\n    arr = [3, 3, 3, 3, 3]\n    assert find_smallest_number(arr) == 3",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000093",
      "row_id": 93,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to remove the duplicates from a list while preserving the original order of elements.",
    "response": "def remove_duplicates_preserve_order(lst):\n    \"\"\"\n    Removes duplicates from a list while preserving the original order of elements.\n    \n    :param lst: List from which duplicates are to be removed.\n    :return: A new list with duplicates removed.\n    \"\"\"\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result",
    "test_code": "def test_remove_duplicates_preserve_order():\n    assert remove_duplicates_preserve_order([1, 2, 3, 1, 2, 5]) == [1, 2, 3, 5]\n    assert remove_duplicates_preserve_order(['a', 'b', 'a', 'c', 'b']) == ['a', 'b', 'c']\n    assert remove_duplicates_preserve_order([1, 1, 1, 1, 1]) == [1]\n    assert remove_duplicates_preserve_order([]) == []\n    assert remove_duplicates_preserve_order([5, 4, 3, 2, 1, 4, 3]) == [5, 4, 3, 2, 1]\n\ndef test_remove_duplicates_with_duplicates_inside_tuple():\n    # This tests for a potential pitfall with immutable types, where a mutable object might be stored in the list.\n    test_list = [1, (2, 3), 'a', (2, 3), 'b', 1]\n    expected_result = [1, (2, 3), 'a', 'b']\n    assert remove_duplicates_preserve_order(test_list) == expected_result\n\ndef test_remove_duplicates_with_tuple_elements_in_list():\n    # Test with a list that contains tuples\n    test_list = [(1,), (2,), (1,), (3,), (2,)]\n    expected_result = [(1,), (2,), (3,)]\n    assert remove_duplicates_preserve_order(test_list) == expected_result",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def remove_duplicates_preserve_order(items):\n    \"\"\"\n    Removes duplicates from a list while preserving the original order of elements.\n    Args:\n    items (list): The list from which to remove duplicates.\n    \n    Returns:\n    list: A new list with duplicates removed and original order preserved.\n    \"\"\"\n    seen = set()\n    unique_items = []\n    for item in items:\n        if item not in seen:\n            seen.add(item)\n            unique_items.append(item)\n    return unique_items",
        "test_code": "from solution import remove_duplicates_preserve_order\n\ndef test_remove_duplicates_preserve_order_with_duplicates():\n    assert remove_duplicates_preserve_order([1, 2, 3, 2, 1]) == [1, 2, 3]\n\ndef test_remove_duplicates_preserve_order_empty_list():\n    assert remove_duplicates_preserve_order([]) == []\n\ndef test_remove_duplicates_preserve_order_single_element():\n    assert remove_duplicates_preserve_order([5]) == [5]\n\ndef test_remove_duplicates_preserve_order_no_duplicates():\n    assert remove_duplicates_preserve_order([1, 2, 3, 4]) == [1, 2, 3, 4]\n\ndef test_remove_duplicates_preserve_order_with_negative_numbers():\n    assert remove_duplicates_preserve_order([-1, -2, -3, -2, -1, 0]) == [-1, -2, -3, 0]\n\ndef test_remove_duplicates_preserve_order_with_duplicates_and_zeros():\n    assert remove_duplicates_preserve_order([1, 2, 3, 2, 1, 0, 0, 3, 4]) == [1, 2, 3, 0, 4]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def remove_duplicates_preserve_order(input_list):\n    \"\"\"\n    Removes duplicates from a list while preserving the original order of elements.\n    \n    :param input_list: List from which to remove duplicates.\n    :return: A new list with duplicates removed and original order preserved.\n    \"\"\"\n    seen = set()\n    result = []\n    for item in input_list:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result",
        "test_code": "from solution import remove_duplicates_preserve_order\n\ndef test_remove_duplicates_with_duplicates():\n    assert remove_duplicates_preserve_order([1, 2, 3, 2, 1, 5, 6, 5, 5, 3]) == [1, 2, 3, 5, 6]\n\ndef test_remove_duplicates_empty_list():\n    assert remove_duplicates_preserve_order([]) == []\n\ndef test_remove_duplicates_single_element():\n    assert remove_duplicates_preserve_order([42]) == [42]\n\ndef test_remove_duplicates_no_duplicates():\n    assert remove_duplicates_preserve_order([1, 3, 5, 7, 9]) == [1, 3, 5, 7, 9]\n\ndef test_remove_duplicates_with_negatives():\n    assert remove_duplicates_preserve_order([-1, -4, -1, -3, 0, -3, 2, -1, 2]) == [-1, -4, -3, 0, 2]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def remove_duplicates_preserve_order(lst):\n    \"\"\"\n    Removes duplicates from a list while preserving the original order of elements.\n    \n    :param lst: List from which duplicates are to be removed.\n    :return: A new list with duplicates removed.\n    \"\"\"\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result",
        "test_code": "def test_remove_duplicates_preserve_order():\n    assert remove_duplicates_preserve_order([1, 2, 3, 1, 2, 5]) == [1, 2, 3, 5]\n    assert remove_duplicates_preserve_order(['a', 'b', 'a', 'c', 'b']) == ['a', 'b', 'c']\n    assert remove_duplicates_preserve_order([1, 1, 1, 1, 1]) == [1]\n    assert remove_duplicates_preserve_order([]) == []\n    assert remove_duplicates_preserve_order([5, 4, 3, 2, 1, 4, 3]) == [5, 4, 3, 2, 1]\n\ndef test_remove_duplicates_with_duplicates_inside_tuple():\n    # This tests for a potential pitfall with immutable types, where a mutable object might be stored in the list.\n    test_list = [1, (2, 3), 'a', (2, 3), 'b', 1]\n    expected_result = [1, (2, 3), 'a', 'b']\n    assert remove_duplicates_preserve_order(test_list) == expected_result\n\ndef test_remove_duplicates_with_tuple_elements_in_list():\n    # Test with a list that contains tuples\n    test_list = [(1,), (2,), (1,), (3,), (2,)]\n    expected_result = [(1,), (2,), (3,)]\n    assert remove_duplicates_preserve_order(test_list) == expected_result",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000097",
      "row_id": 97,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to calculate the Fibonacci sequence up to a certain number of terms.",
    "response": "def fibonacci(n):\n    \"\"\"\n    Returns the first n terms of the Fibonacci sequence.\n    The Fibonacci sequence is a series of numbers where each number is the sum \n    of the two preceding ones, usually starting with 0 and 1.\n    \n    Parameters:\n    n (int): The number of terms in the Fibonacci sequence to generate.\n    \n    Returns:\n    list: A list containing the first n terms of the Fibonacci sequence.\n    \"\"\"\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    \n    sequence = [0, 1]\n    for i in range(2, n):\n        next_value = sequence[-1] + sequence[-2]\n        sequence.append(next_value)\n    \n    return sequence",
    "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero_terms():\n    assert fibonacci(0) == []\n\ndef test_fibonacci_one_term():\n    assert fibonacci(1) == [0]\n\ndef test_fibonacci_two_terms():\n    assert fibonacci(2) == [0, 1]\n\ndef test_fibonacci_five_terms():\n    assert fibonacci(5) == [0, 1, 1, 2, 3]\n\ndef test_fibonacci_ten_terms():\n    assert fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]",
    "trials": {
      "trial_qwen2.5_1": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the first n terms of the Fibonacci sequence.\n    The Fibonacci sequence is a series of numbers where each number is the sum \n    of the two preceding ones, usually starting with 0 and 1.\n    \n    Parameters:\n    n (int): The number of terms in the Fibonacci sequence to generate.\n    \n    Returns:\n    list: A list containing the first n terms of the Fibonacci sequence.\n    \"\"\"\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    \n    sequence = [0, 1]\n    for i in range(2, n):\n        next_value = sequence[-1] + sequence[-2]\n        sequence.append(next_value)\n    \n    return sequence",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero_terms():\n    assert fibonacci(0) == []\n\ndef test_fibonacci_one_term():\n    assert fibonacci(1) == [0]\n\ndef test_fibonacci_two_terms():\n    assert fibonacci(2) == [0, 1]\n\ndef test_fibonacci_five_terms():\n    assert fibonacci(5) == [0, 1, 1, 2, 3]\n\ndef test_fibonacci_ten_terms():\n    assert fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number and a list of the first n Fibonacci numbers.\n    \"\"\"\n    if n <= 0:\n        return 0, []\n    elif n == 1:\n        return 1, [0]\n    elif n == 2:\n        return 1, [0, 1]\n    \n    fib_sequence = [0, 1]\n    for i in range(2, n):\n        next_value = fib_sequence[-1] + fib_sequence[-2]\n        fib_sequence.append(next_value)\n    \n    return fib_sequence[-1], fib_sequence",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero_terms():\n    assert fibonacci(0) == (0, [])\n\ndef test_fibonacci_one_term():\n    assert fibonacci(1) == (1, [0])\n\ndef test_fibonacci_two_terms():\n    assert fibonacci(2) == (1, [0, 1])\n\ndef test_fibonacci_five_terms():\n    assert fibonacci(5) == (5, [0, 1, 1, 2, 3])\n\ndef test_fibonacci.twenty_terms():\n    assert fibonacci(20) == (6765, [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181])",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000098",
      "row_id": 98,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to iterate over a list and print each number.",
    "response": "def print_numbers(numbers):\n    \"\"\"\n    Iterates over a list and prints each number.\n    \"\"\"\n    for num in numbers:\n        print(num)",
    "test_code": "from solution import print_numbers\n\ndef test_print_numbers():\n    # Create a temporary file to capture print output\n    import io\n    import contextlib\n\n    captured_output = io.StringIO()  # Create StringIO object\n    with contextlib.redirect_stdout(captured_output):  # Redirect stdout to StringIO object\n        print_numbers([1, 2, 3, 4, 5])\n    output = captured_output.getvalue().strip().split('\\n')\n    assert output == ['1', '2', '3', '4', '5']\n\ndef test_print_numbers_with_empty_list():\n    import io\n    import contextlib\n    captured_output = io.StringIO()\n    with contextlib.redirect_stdout(captured_output):\n        print_numbers([])\n    output = captured_output.getvalue().strip()\n    assert output == ''",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def print_numbers(numbers):\n    \"\"\"\n    Iterates over a list and prints each number.\n    \"\"\"\n    for num in numbers:\n        print(num)",
        "test_code": "from solution import print_numbers\n\ndef test_print_numbers():\n    # Create a temporary file to capture print output\n    import io\n    import contextlib\n\n    captured_output = io.StringIO()  # Create StringIO object\n    with contextlib.redirect_stdout(captured_output):  # Redirect stdout to StringIO object\n        print_numbers([1, 2, 3, 4, 5])\n    output = captured_output.getvalue().strip().split('\\n')\n    assert output == ['1', '2', '3', '4', '5']\n\ndef test_print_numbers_with_empty_list():\n    import io\n    import contextlib\n    captured_output = io.StringIO()\n    with contextlib.redirect_stdout(captured_output):\n        print_numbers([])\n    output = captured_output.getvalue().strip()\n    assert output == ''",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def print_numbers(numbers_list):\n    \"\"\"\n    Iterates over a list of numbers and prints each number.\n    \"\"\"\n    for number in numbers_list:\n        print(number)",
        "test_code": "def test_print_numbers():\n    # Test with a simple list of numbers\n    with capture_stdout(print_numbers, [1, 2, 3]) as output:\n        assert output == \"1\\n2\\n3\\n\"\n\n    # Test with an empty list\n    with capture_stdout(print_numbers, []) as output:\n        assert output == \"\"\n\n    # Test with a list containing a single number\n    with capture_stdout(print_numbers, [42]) as output:\n        assert output == \"42\\n\"",
        "test_result": "Fail",
        "test_coverage": 33.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def print_numbers(numbers):\n    \"\"\"\n    Iterates over a list of numbers and prints each one.\n    \"\"\"\n    for number in numbers:\n        print(number)",
        "test_code": "def test_print_numbers():\n    with test_script capturing print output as output:\n        print_numbers([1, 2, 3])\n    assert output == '1\\n2\\n3\\n'\n\ndef test_empty_list():\n    with test_script capturing print output as output:\n        print_numbers([])\n    assert output == ''\n\ndef test_mixed_sign_numbers():\n    with test_script capturing print output as output:\n        print_numbers([-1, 0, 1])\n    assert output == '-1\\n0\\n1\\n'",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000101",
      "row_id": 101,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to perform insertion sort on a list of integers. Please make sure to provide detailed comments explaining each part of your code.",
    "response": "def insertion_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the insertion sort algorithm.\n    \n    This algorithm iterates through the list, and for each element, it finds the correct\n    position within the sorted portion of the list and inserts it there. The algorithm\n    keeps growing the sorted portion of the list until the entire list is sorted.\n    \n    Args:\n        arr (list of int): The list of integers to sort.\n    \n    Returns:\n        list of int: The sorted list of integers.\n    \"\"\"\n    # Traverse through 1 to len(arr)\n    for i in range(1, len(arr)):\n        \n        # Store the current element\n        current_value = arr[i]\n        \n        # Initialize the position where the current element needs to be inserted\n        position = i\n        \n        # Move elements of arr[0..i-1], that are greater than current_value,\n        # to one position ahead of their current position\n        while position > 0 and arr[position - 1] > current_value:\n            arr[position] = arr[position - 1]\n            position -= 1\n        \n        # Insert the current element into its correct position\n        arr[position] = current_value\n    \n    return arr",
    "test_code": "from solution import insertion_sort\n\ndef test_insertion_sort_positive_numbers():\n    arr = [9, 5, 1, 4, 3]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [1, 3, 4, 5, 9]\n\ndef test_insertion_sort_negative_numbers():\n    arr = [-5, -9, -3, -4]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [-9, -5, -4, -3]\n\ndef test_insertion_sort_mixed_numbers():\n    arr = [0, -1, 5, -2, 3]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [-2, -1, 0, 3, 5]\n\ndef test_insertion_sort_empty_list():\n    arr = []\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == []\n\ndef test_insertion_sort_already_sorted():\n    arr = [1, 2, 3, 4, 5]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [1, 2, 3, 4, 5]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def insertion_sort(arr):\n    \"\"\"\n    Perform insertion sort on a list of integers.\n    \n    Parameters:\n    arr (list): The list of integers to be sorted.\n    \n    Returns:\n    list: The sorted list of integers.\n    \n    Explanation:\n    1. Iterate over the array starting from the second element (index 1).\n    2. For each element, compare it with the elements before it to place it in the correct position.\n    3. If the current element is smaller than the previous element, swap them.\n    4. Continue this process until the current element is in the correct sorted position.\n    5. Repeat the process for all elements in the array.\n    \"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        # Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr",
        "test_code": "from solution import insertion_sort\n\ndef test_insertion_sort_positive_numbers():\n    assert insertion_sort([4, 5, 2, 6, 1, 3]) == [1, 2, 3, 4, 5, 6]\n\ndef test_insertion_sort_already_sorted():\n    assert insertion_sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n\ndef test_insertion_sort_negative_numbers():\n    assert insertion_sort([-2, -5, -4, -3, -1]) == [-5, -4, -3, -2, -1]\n\ndef test_insertion_sort_mixed_sign_numbers():\n    assert insertion_sort([-1, 3, -2, 5, 0]) == [-2, -1, 0, 3, 5]\n\ndef test_insertion_sort_duplicate_numbers():\n    assert insertion_sort([4, 2, 4, 2, 1]) == [1, 2, 2, 4, 4]\n\ndef test_insertion_sort_empty_list():\n    assert insertion_sort([]) == []\n\ndef test_insertion_sort_single_element():\n    assert insertion_sort([5]) == [5]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def insertion_sort(arr):\n    \"\"\"\n    Sorts an array of integers using the insertion sort algorithm.\n    \n    This algorithm works by iterating over the elements, and for each element, \n    shifting the already sorted elements to the right to make space for the \n    new element and inserting the element in the correct position.\n    \n    Parameters:\n    - arr: List[int], the list of integers to be sorted.\n    \n    Returns:\n    - List[int], the sorted list.\n    \"\"\"\n    # Loop through 1 to len(arr)\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        # Move elements of arr[0..i-1], that are greater than key, \n        # to one position ahead of their current position\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr",
        "test_code": "import pytest\n\ndef test_insertion_sort_empty_list():\n    assert insertion_sort([]) == []\n\ndef test_insertion_sort_sorted_list():\n    assert insertion_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_insertion_sort_reverse_sorted_list():\n    assert insertion_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n\ndef test_insertion_sort_with_duplicates():\n    assert insertion_sort([4, 3, 2, 5, 3, 5]) == [2, 3, 3, 4, 5, 5]\n\ndef test_insertion_sort_random_list():\n    assert insertion_sort([3, 6, 1, 8, 4]) == [1, 3, 4, 6, 8]\n\ndef test_insertion_sort_negative_numbers():\n    assert insertion_sort([-5, -2, -3, -1]) == [-5, -3, -2, -1]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def insertion_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the insertion sort algorithm.\n    \n    This algorithm iterates through the list, and for each element, it finds the correct\n    position within the sorted portion of the list and inserts it there. The algorithm\n    keeps growing the sorted portion of the list until the entire list is sorted.\n    \n    Args:\n        arr (list of int): The list of integers to sort.\n    \n    Returns:\n        list of int: The sorted list of integers.\n    \"\"\"\n    # Traverse through 1 to len(arr)\n    for i in range(1, len(arr)):\n        \n        # Store the current element\n        current_value = arr[i]\n        \n        # Initialize the position where the current element needs to be inserted\n        position = i\n        \n        # Move elements of arr[0..i-1], that are greater than current_value,\n        # to one position ahead of their current position\n        while position > 0 and arr[position - 1] > current_value:\n            arr[position] = arr[position - 1]\n            position -= 1\n        \n        # Insert the current element into its correct position\n        arr[position] = current_value\n    \n    return arr",
        "test_code": "from solution import insertion_sort\n\ndef test_insertion_sort_positive_numbers():\n    arr = [9, 5, 1, 4, 3]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [1, 3, 4, 5, 9]\n\ndef test_insertion_sort_negative_numbers():\n    arr = [-5, -9, -3, -4]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [-9, -5, -4, -3]\n\ndef test_insertion_sort_mixed_numbers():\n    arr = [0, -1, 5, -2, 3]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [-2, -1, 0, 3, 5]\n\ndef test_insertion_sort_empty_list():\n    arr = []\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == []\n\ndef test_insertion_sort_already_sorted():\n    arr = [1, 2, 3, 4, 5]\n    sorted_arr = insertion_sort(arr)\n    assert sorted_arr == [1, 2, 3, 4, 5]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000106",
      "row_id": 106,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the common elements between two lists, and return a new list containing these common elements.",
    "response": "def find_common_elements(list1, list2):\n    \"\"\"\n    Returns a new list containing elements common to both input lists.\n    \"\"\"\n    set1 = set(list1)\n    set2 = set(list2)\n    common_elements = set1.intersection(set2)\n    return list(common_elements)",
    "test_code": "from solution import find_common_elements\n\ndef test_find_common_elements():\n    assert find_common_elements([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n\ndef test_find_common_elements_with_no_common():\n    assert find_common_elements([1, 2, 3], [4, 5, 6]) == []\n\ndef test_find_common_elements_with_duplicates():\n    assert find_common_elements([1, 2, 2, 3], [2, 2, 3, 4]) == [2, 3]\n\ndef test_find_common_elements_with_empty_lists():\n    assert find_common_elements([], [1, 2, 3]) == []\n    assert find_common_elements([1, 2, 3], []) == []",
    "trials": {
      "trial_qwen2.5_1": {
        "solution_code": "def find_common_elements(list1, list2):\n    \"\"\"\n    Returns a new list containing the common elements between two input lists.\n    \"\"\"\n    return list(set(list1) & set(list2))",
        "test_code": "def test_find_common_elements():\n    assert find_common_elements([1, 2, 3, 4], [3, 4, 5, 6]) == [3, 4]\n    assert find_common_elements(['apple', 'banana', 'cherry'], ['banana', 'date', 'fig']) == ['banana']\n    assert find_common_elements([], [1, 2, 3]) == []\n    assert find_common_elements([1, 2, 3], []) == []\n    assert find_common_elements([10, 20, 30], [10, 40, 50]) == [10]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def find_common_elements(list1, list2):\n    \"\"\"\n    Returns a new list containing elements common to both input lists.\n    \"\"\"\n    set1 = set(list1)\n    set2 = set(list2)\n    common_elements = set1.intersection(set2)\n    return list(common_elements)",
        "test_code": "from solution import find_common_elements\n\ndef test_find_common_elements():\n    assert find_common_elements([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n\ndef test_find_common_elements_with_no_common():\n    assert find_common_elements([1, 2, 3], [4, 5, 6]) == []\n\ndef test_find_common_elements_with_duplicates():\n    assert find_common_elements([1, 2, 2, 3], [2, 2, 3, 4]) == [2, 3]\n\ndef test_find_common_elements_with_empty_lists():\n    assert find_common_elements([], [1, 2, 3]) == []\n    assert find_common_elements([1, 2, 3], []) == []",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000109",
      "row_id": 109,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to determine if a given number is a prime number. If it is, return True; otherwise, return False.",
    "response": "def is_prime(n):\n    \"\"\"\n    Determines if a given number n is a prime number.\n    Returns True if n is a prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
    "test_code": "from solution import is_prime\n\ndef test_is_prime_with_prime_number():\n    assert is_prime(2) == True\n    assert is_prime(3) == True\n    assert is_prime(5) == True\n    assert is_prime(11) == True\n\ndef test_is_prime_with_non_prime_number():\n    assert is_prime(4) == False\n    assert is_prime(9) == False\n    assert is_prime(15) == False\n    assert is_prime(100) == False\n\ndef test_is_prime_with_edge_cases():\n    assert is_prime(1) == False\n    assert is_prime(0) == False\n    assert is_prime(-3) == False\n    assert is_prime(-1) == False",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def is_prime(n):\n    \"\"\"\n    Determines if a given number n is a prime number.\n    Returns True if n is a prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
        "test_code": "from solution import is_prime\n\ndef test_is_prime_with_prime_number():\n    assert is_prime(2) == True\n    assert is_prime(3) == True\n    assert is_prime(5) == True\n    assert is_prime(11) == True\n\ndef test_is_prime_with_non_prime_number():\n    assert is_prime(4) == False\n    assert is_prime(9) == False\n    assert is_prime(15) == False\n    assert is_prime(100) == False\n\ndef test_is_prime_with_edge_cases():\n    assert is_prime(1) == False\n    assert is_prime(0) == False\n    assert is_prime(-3) == False\n    assert is_prime(-1) == False",
        "test_result": "Pass",
        "test_coverage": 77.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def is_prime(n):\n    \"\"\"\n    Returns True if the given number is a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
        "test_code": "from solution import is_prime\n\ndef test_is_prime_two():\n    assert is_prime(2) == True\n\ndef test_is_prime_three():\n    assert is_prime(3) == True\n\ndef test_is_prime_four():\n    assert is_prime(4) == False\n\ndef test_is_prime_negative_number():\n    assert is_prime(-7) == False\n\ndef test_is_prime_large_number():\n    assert is_prime(11227278127) == True\n\ndef test_is_prime_seven():\n    assert is_prime(7) == True\n\ndef test_is_prime_eight_to_fifteen():\n    for i in range(8, 16):\n        assert is_prime(i) == False\n\ndef test_is_prime_big_prime():\n    assert is_prime(2999999937) == True\n\ndef test_is_prime_non_prime():\n    assert is_prime(15) == False",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_prime(n):\n    \"\"\"\n    Returns True if n is a prime number, otherwise returns False.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
        "test_code": "from solution import is_prime\n\ndef test_is_prime_with_primes():\n    assert is_prime(2) == True\n    assert is_prime(3) == True\n    assert is_prime(5) == True\n    assert is_prime(7) == True\n\ndef test_is_prime_with_non_primes():\n    assert is_prime(4) == False\n    assert is_prime(6) == False\n    assert is_prime(8) == False\n    assert is_prime(9) == False\n    assert is_prime(10) == False\n\ndef test_is_prime_edge_cases():\n    assert is_prime(1) == False\n    assert is_prime(2) == True\n    assert is_prime(-3) == False\n\ndef test_is_prime_large_numbers():\n    assert is_prime(9973) == True\n    assert is_prime(9975) == False\n    assert is_prime(9991) == True\n    assert is_prime(9999) == False",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000114",
      "row_id": 114,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the minimum element in a list.",
    "response": "def find_min_element(lst):\n    \"\"\"\n    Returns the minimum element in the list lst.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    The minimum element in the list.\n    \"\"\"\n    if not lst:  # Check if the list is empty\n        return None\n    min_element = lst[0]\n    for element in lst[1:]:\n        if element < min_element:\n            min_element = element\n    return min_element",
    "test_code": "from solution import find_min_element\n\ndef test_find_min_element_positive_numbers():\n    assert find_min_element([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == 1\n\ndef test_find_min_element_negative_numbers():\n    assert find_min_element([-7, -3, -1, -4, -2]) == -7\n\ndef test_find_min_element_mixed_sign_numbers():\n    assert find_min_element([-1, 0, 1, -2, 2]) == -2\n\ndef test_find_min_element_single_element():\n    assert find_min_element([42]) == 42\n\ndef test_find_min_element_empty_list():\n    assert find_min_element([]) == None\n\ndef test_find_min_element_with_zeros():\n    assert find_min_element([0, 2, 0, 1]) == 0",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def find_minimum(lst):\n    \"\"\"\n    Returns the minimum element in the given list.\n    \"\"\"\n    if not lst:  # check if the list is empty\n        return None\n    \n    min_element = lst[0]\n    for element in lst[1:]:\n        if element < min_element:\n            min_element = element\n            \n    return min_element",
        "test_code": "from solution import find_minimum\n\ndef test_find_minimum_with_positive_numbers():\n    assert find_minimum([3, 1, 4, 1, 5, 9]) == 1\n\ndef test_find_minimum_with_negative_numbers():\n    assert find_minimum([-2, -3, -1, -4]) == -4\n\ndef test_find_minimum_with_mixed_numbers():\n    assert find_minimum([-5, 0, 5, -1, 10]) == -5\n\ndef test_find_minimum_with_empty_list():\n    assert find_minimum([]) is None\n\ndef test_find_minimum_with_single_element():\n    assert find_minimum([42]) == 42",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def find_min_element(lst):\n    \"\"\"\n    Returns the minimum element in the list lst.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    The minimum element in the list.\n    \"\"\"\n    if not lst:  # Check if the list is empty\n        return None\n    min_element = lst[0]\n    for element in lst[1:]:\n        if element < min_element:\n            min_element = element\n    return min_element",
        "test_code": "from solution import find_min_element\n\ndef test_find_min_element_positive_numbers():\n    assert find_min_element([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == 1\n\ndef test_find_min_element_negative_numbers():\n    assert find_min_element([-7, -3, -1, -4, -2]) == -7\n\ndef test_find_min_element_mixed_sign_numbers():\n    assert find_min_element([-1, 0, 1, -2, 2]) == -2\n\ndef test_find_min_element_single_element():\n    assert find_min_element([42]) == 42\n\ndef test_find_min_element_empty_list():\n    assert find_min_element([]) == None\n\ndef test_find_min_element_with_zeros():\n    assert find_min_element([0, 2, 0, 1]) == 0",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def find_minimum(lst):\n    \"\"\"\n    Returns the minimum element from the provided list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List is empty\")\n    min_element = lst[0]\n    for element in lst:\n        if element < min_element:\n            min_element = element\n    return min_element",
        "test_code": "from solution import find_minimum\n\ndef test_find_minimum_empty_list():\n    assert find_minimum([]) == ValueError\n\ndef test_find_minimum_with_positive_numbers():\n    assert find_minimum([3, 1, 4, 1, 5, 9]) == 1\n\ndef test_find_minimum_with_negative_numbers():\n    assert find_minimum([-7, -3, -1, -5, -9]) == -9\n\ndef test_find_minimum_with_mixed_sign_numbers():\n    assert find_minimum([-2, 3, -1, 4, 1]) == -2\n\ndef test_find_minimum_single_element_list():\n    assert find_minimum([42]) == 42",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      0
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000118",
      "row_id": 118,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to merge two dictionaries. If the same key exists in both dictionaries, their values should be summed. If not, the value from the second dictionary should simply be added to the result.",
    "response": "def merge_and_sum_dictionaries(dict1, dict2):\n    \"\"\"\n    Merges two dictionaries. If the same key exists in both, sums their values. \n    If not, from the second dictionary, the value should be added to the result.\n    \"\"\"\n    result = {**dict1}  # Start with the first dictionary's keys and values\n    for key, value in dict2.items():\n        result[key] = result.get(key, 0) + value  # Sum or add the new value\n    return result",
    "test_code": "from solution import merge_and_sum_dictionaries\n\ndef test_merge_and_sum_dictionaries_empty_dicts():\n    assert merge_and_sum_dictionaries({}, {}) == {}\n\ndef test_merge_and_sum_dictionaries_no_overlap():\n    assert merge_and_sum_dictionaries({'a': 1, 'b': 2}, {'c': 3, 'd': 4}) == {'a': 1, 'b': 2, 'c': 3, 'd': 4}\n\ndef test_merge_and_sum_dictionaries_overlap_same_value():\n    assert merge_and_sum_dictionaries({'a': 1, 'b': 2}, {'a': 1, 'b': 2}) == {'a': 2, 'b': 4}\n\ndef test_merge_and_sum_dictionaries_overlap_different_values():\n    assert merge_and_sum_dictionaries({'a': 1, 'b': 2}, {'a': 3, 'b': 4}) == {'a': 4, 'b': 6}\n\ndef test_merge_and_sum_dictionaries_within_a_single_dict():\n    assert merge_and_sum_dictionaries({'a': 1, 'b': 2, 'c': 3}, {'b': 5, 'c': 7, 'd': 9}) == {'a': 1, 'b': 7, 'c': 10, 'd': 9}",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def merge_and_sum_dicts(dict1, dict2):\n    \"\"\"\n    Merges two dictionaries. If a key is present in both, sums their values.\n    If a key is only present in one dictionary, its value is taken as is.\n    \"\"\"\n    # Sum the values of keys that are present in both dictionaries\n    for key in dict2:\n        if key in dict1:\n            dict1[key] += dict2[key]\n        else:\n            dict1[key] = dict2[key]\n    return dict1",
        "test_code": "from solution import merge_and_sum_dicts\n\ndef test_merge_and_sum_dicts():\n    dict1 = {'a': 1, 'b': 2, 'c': 3}\n    dict2 = {'b': 3, 'c': 4, 'd': 5}\n    result = merge_and_sum_dicts(dict1, dict2)\n    expected = {'a': 1, 'b': 5, 'c': 7, 'd': 5}\n    assert result == expected\n\ndef test_merge_and_sum_dicts_with_same_key():\n    dict1 = {'x': 10, 'y': 20}\n    dict2 = {'x': 5, 'y': 30}\n    result = merge_and_sum_dicts(dict1, dict2)\n    expected = {'x': 15, 'y': 50}\n    assert result == expected\n\ndef test_merge_and_sum_dicts_addition():\n    dict1 = {'p': 100}\n    dict2 = {'q': 200}\n    result = merge_and_sum_dicts(dict1, dict2)\n    expected = {'p': 100, 'q': 200}\n    assert result == expected",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def merge_dictionaries(dict1, dict2):\n    \"\"\"\n    Merges two dictionaries. If the same key exists in both dictionaries,\n    their values will be summed up. If not, the value from the second dictionary\n    will simply be added to the result.\n    \"\"\"\n    merged_dict = dict1.copy()  # Start with a copy of the first dictionary\n    for key, value in dict2.items():\n        merged_dict[key] = merged_dict.get(key, 0) + value\n    return merged_dict",
        "test_code": "from solution import merge_dictionaries\n\ndef test_merge_dictionaries_same_key():\n    assert merge_dictionaries({'a': 1, 'b': 2}, {'b': 3, 'c': 4}) == {'a': 1, 'b': 5, 'c': 4}\n\ndef test_merge_dictionaries_no_overlap():\n    assert merge_dictionaries({'a': 1, 'b': 2}, {'c': 3, 'd': 4}) == {'a': 1, 'b': 2, 'c': 3, 'd': 4}\n\ndef test_merge_dictionaries_with_zeros():\n    assert merge_dictionaries({'x': 0, 'y': 0}, {'y': 1, 'z': 2}) == {'x': 0, 'y': 1, 'z': 2}\n\ndef test_merge_dictionaries_negative_values():\n    assert merge_dictionaries({'a': -2, 'b': -3}, {'b': -1, 'c': -5}) == {'a': -2, 'b': -4, 'c': -5}",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def merge_and_sum_dictionaries(dict1, dict2):\n    \"\"\"\n    Merges two dictionaries. If the same key exists in both, sums their values. \n    If not, from the second dictionary, the value should be added to the result.\n    \"\"\"\n    result = {**dict1}  # Start with the first dictionary's keys and values\n    for key, value in dict2.items():\n        result[key] = result.get(key, 0) + value  # Sum or add the new value\n    return result",
        "test_code": "from solution import merge_and_sum_dictionaries\n\ndef test_merge_and_sum_dictionaries_empty_dicts():\n    assert merge_and_sum_dictionaries({}, {}) == {}\n\ndef test_merge_and_sum_dictionaries_no_overlap():\n    assert merge_and_sum_dictionaries({'a': 1, 'b': 2}, {'c': 3, 'd': 4}) == {'a': 1, 'b': 2, 'c': 3, 'd': 4}\n\ndef test_merge_and_sum_dictionaries_overlap_same_value():\n    assert merge_and_sum_dictionaries({'a': 1, 'b': 2}, {'a': 1, 'b': 2}) == {'a': 2, 'b': 4}\n\ndef test_merge_and_sum_dictionaries_overlap_different_values():\n    assert merge_and_sum_dictionaries({'a': 1, 'b': 2}, {'a': 3, 'b': 4}) == {'a': 4, 'b': 6}\n\ndef test_merge_and_sum_dictionaries_within_a_single_dict():\n    assert merge_and_sum_dictionaries({'a': 1, 'b': 2, 'c': 3}, {'b': 5, 'c': 7, 'd': 9}) == {'a': 1, 'b': 7, 'c': 10, 'd': 9}",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000120",
      "row_id": 120,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the maximum number in an array using recursion.",
    "response": "def find_max_recursive(arr, n):\n    \"\"\"\n    Uses recursion to find the maximum number in the array.\n    \n    Args:\n    arr: List of integers.\n    n: Number of elements in the array to consider for finding the maximum.\n    \n    Returns:\n    The maximum number in the array.\n    \"\"\"\n    if n == 1:\n        return arr[0]\n    max_of_rest = find_max_recursive(arr, n-1)\n    return max(arr[n-1], max_of_rest)",
    "test_code": "def test_find_max_recursive():\n    assert find_max_recursive([1, 3, 5, 7, 9], 5) == 9\n    assert find_max_recursive([10], 1) == 10\n    assert find_max_recursive([5, 3, 8, 6, 2], 5) == 8\n    assert find_max_recursive([-1, -3, -2, -5, -7], 5) == -1\n    assert find_max_recursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 10",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def find_max_recursive(arr, n):\n    \"\"\"\n    Uses recursion to find the maximum number in the array.\n    \n    Args:\n    arr: List of integers.\n    n: Number of elements in the array to consider for finding the maximum.\n    \n    Returns:\n    The maximum number in the array.\n    \"\"\"\n    if n == 1:\n        return arr[0]\n    max_of_rest = find_max_recursive(arr, n-1)\n    return max(arr[n-1], max_of_rest)",
        "test_code": "def test_find_max_recursive():\n    assert find_max_recursive([1, 3, 5, 7, 9], 5) == 9\n    assert find_max_recursive([10], 1) == 10\n    assert find_max_recursive([5, 3, 8, 6, 2], 5) == 8\n    assert find_max_recursive([-1, -3, -2, -5, -7], 5) == -1\n    assert find_max_recursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 10",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def find_max_recursive(arr):\n    \"\"\"\n    Recursively find the maximum number in an array.\n    \n    :param arr: List of numbers\n    :return: Maximum number in the array\n    \"\"\"\n    if len(arr) == 1:\n        return arr[0]\n    else:\n        sub_max = find_max_recursive(arr[1:])\n        return arr[0] if arr[0] > sub_max else sub_max",
        "test_code": "from solution import find_max_recursive\n\ndef test_find_max_recursive_empty():\n    assert find_max_recursive([]) == None\n\ndef test_find_max_recursive_positive():\n    assert find_max_recursive([1, 5, 3, 9, 2]) == 9\n\ndef test_find_max_recursive_negative():\n    assert find_max_recursive([-1, -5, -3, -9, -2]) == -1\n\ndef test_find_max_recursive_mixed():\n    assert find_max_recursive([1, -5, 3, -9, 2]) == 3\n\ndef test_find_max_recursive_single_element():\n    assert find_max_recursive([42]) == 42",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def find_max_recursive(arr, n):\n    \"\"\"\n    Returns the maximum number in an array using recursion.\n    \n    :param arr: List of integers\n    :param n: Number of elements in the array to consider\n    :return: Maximum integer in the array\n    \"\"\"\n    # Base case: if the array has only one element\n    if n == 1:\n        return arr[0]\n    \n    # Recursive case: find the maximum in the rest of the array\n    max_in_rest = find_max_recursive(arr, n-1)\n    \n    # Return the greater of the last element and the max of the rest\n    return max(arr[n-1], max_in_rest)",
        "test_code": "def test_find_max_recursive():\n    assert find_max_recursive([1, 2, 3, 4, 5], 5) == 5\n    assert find_max_recursive([-10, -2, -3, -1], 4) == -1\n    assert find_max_recursive([100], 1) == 100\n    assert find_max_recursive([5, 3, 8, 20, -1, 0], 6) == 20\n\ndef test_single_element():\n    assert find_max_recursive([42], 1) == 42\n\ndef test_empty_array():\n    try:\n        find_max_recursive([], 0)\n    except ValueError as e:\n        assert str(e) == \"Array must contain at least one element.\"\n    else:\n        assert False, \"Expected ValueError for empty array\"\n\ndef test_all Negative():\n    assert find_max_recursive([-5, -10, -3, -4], 4) == -3",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000122",
      "row_id": 122,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the single number in a list where every other number appears exactly twice. The function should have a linear time complexity and use constant space.",
    "response": "def single_number(nums):\n    \"\"\"\n    Find the single number in a list where every other number appears exactly twice.\n    Assumes one and only one number appears once and all others appear twice.\n    Returns the number that appears exactly once.\n\n    Args:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The integer that appears exactly once.\n    \"\"\"\n    unique = 0\n    for num in nums:\n        unique ^= num\n    return unique",
    "test_code": "from solution import single_number\n\ndef test_single_number():\n    assert single_number([2, 2, 1]) == 1\n    assert single_number([4, 1, 2, 1, 2]) == 4\n    assert single_number([8]) == 8\n    assert single_number([7, 3, 5, 3, 7, 5, 6]) == 6",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def single_number(nums):\n    \"\"\"\n    Find the single number in a list where every other number appears exactly twice.\n    Assumes one and only one number appears once and all others appear twice.\n    Returns the number that appears exactly once.\n\n    Args:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The integer that appears exactly once.\n    \"\"\"\n    unique = 0\n    for num in nums:\n        unique ^= num\n    return unique",
        "test_code": "from solution import single_number\n\ndef test_single_number():\n    assert single_number([2, 2, 1]) == 1\n    assert single_number([4, 1, 2, 1, 2]) == 4\n    assert single_number([8]) == 8\n    assert single_number([7, 3, 5, 3, 7, 5, 6]) == 6",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def single_number(nums):\n    \"\"\"\n    Returns the single number in a list where every other number appears exactly twice.\n    \"\"\"\n    single = 0\n    for num in nums:\n        single ^= num\n    return single",
        "test_code": "import pytest\n\ndef test_single_number():\n    assert single_number([2, 2, 1]) == 1\n    assert single_number([4, 1, 2, 1, 2]) == 4\n    assert single_number([1]) == 1\n    assert single_number([0, 1, 0]) == 1\n    nums = [7, 3, 5, 3, 7, 5, 1, 1, 6]\n    assert single_number(nums) == 6\n\ndef test_single_number_against_duplicates():\n    assert single_number([2, 2, 2, 3, 3, 3, 4]) == 4\n    assert single_number([5, 5, 5, 5, 5, 5, 7]) == 7",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000124",
      "row_id": 124,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to check if a list of numbers is sorted in ascending order.",
    "response": "def is_sorted_ascending(numbers):\n    \"\"\"\n    Returns True if the list of numbers is sorted in ascending order, else False.\n    \"\"\"\n    return all(numbers[i] <= numbers[i + 1] for i in range(len(numbers) - 1))",
    "test_code": "from solution import is_sorted_ascending\n\ndef test_is_sorted_ascending_positive():\n    assert is_sorted_ascending([1, 2, 3, 4, 5]) == True\n\ndef test_is_sorted_ascending_with_equal_elements():\n    assert is_sorted_ascending([1, 1, 2, 3, 4]) == True\n\ndef test_is_sorted_ascending_negative():\n    assert is_sorted_ascending([5, 3, 2, 1]) == False\n\ndef test_is_sorted_ascending_single_element():\n    assert is_sorted_ascending([5]) == True\n\ndef test_is_sorted_ascending_empty_list():\n    assert is_sorted_ascending([]) == True\n\ndef test_is_sorted_ascending_mixed():\n    assert is_sorted_ascending([1, 2, 3, 2, 5]) == False",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def is_sorted_ascending(numbers_list):\n    \"\"\"\n    Returns True if the list is sorted in ascending order, otherwise False.\n    \"\"\"\n    return all(numbers_list[i] <= numbers_list[i + 1] for i in range(len(numbers_list) - 1))",
        "test_code": "from solution import is_sorted_ascending\n\ndef test_is_sorted_ascending_with_sorted_list():\n    assert is_sorted_ascending([1, 2, 3, 4, 5]) == True\n\ndef test_is_sorted_ascending_with_unsorted_list():\n    assert is_sorted_ascending([5, 3, 1]) == False\n\ndef test_is_sorted_ascending_with_empty_list():\n    assert is_sorted_ascending([]) == True\n\ndef test_is_sorted_ascending_with_single_element_list():\n    assert is_sorted_ascending([42]) == True\n\ndef test_is_sorted_ascending_with_consecutive_equal_elements():\n    assert is_sorted_ascending([1, 1, 2, 2, 3]) == True\n\ndef test_is_sorted_ascending_with_mixed_elements():\n    assert is_sorted_ascending([3, 1, 2, 4, 5]) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def is_ascending(lst):\n    \"\"\"\n    Returns True if the list is sorted in ascending order, otherwise False.\n    \"\"\"\n    return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1))",
        "test_code": "def test_is_ascending():\n    assert is_ascending([1, 2, 3, 4, 5]) == True\n    assert is_ascending([10, 20, 20, 30, 40]) == True\n    assert is_ascending([5, 4, 3, 2, 1]) == False\n    assert is_ascending([1, 2, 3, 3, 4, 5]) == True\n    assert is_ascending([1, 2, 3, 5, 4]) == False\n    assert is_ascending([]) == True\n    assert is_ascending([7]) == True\n    assert is_ascending([1, 3, 2]) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_sorted_ascending(numbers):\n    \"\"\"\n    Returns True if the list of numbers is sorted in ascending order, else False.\n    \"\"\"\n    return all(numbers[i] <= numbers[i + 1] for i in range(len(numbers) - 1))",
        "test_code": "from solution import is_sorted_ascending\n\ndef test_is_sorted_ascending_positive():\n    assert is_sorted_ascending([1, 2, 3, 4, 5]) == True\n\ndef test_is_sorted_ascending_with_equal_elements():\n    assert is_sorted_ascending([1, 1, 2, 3, 4]) == True\n\ndef test_is_sorted_ascending_negative():\n    assert is_sorted_ascending([5, 3, 2, 1]) == False\n\ndef test_is_sorted_ascending_single_element():\n    assert is_sorted_ascending([5]) == True\n\ndef test_is_sorted_ascending_empty_list():\n    assert is_sorted_ascending([]) == True\n\ndef test_is_sorted_ascending_mixed():\n    assert is_sorted_ascending([1, 2, 3, 2, 5]) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000126",
      "row_id": 126,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the diameter of a binary tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree.",
    "response": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef diameter_of_binary_tree(root: TreeNode) -> int:\n    \"\"\"\n    Returns the diameter of the binary tree.\n    \"\"\"\n    def height(node: TreeNode) -> int:\n        if not node:\n            return 0\n        return 1 + max(height(node.left), height(node.right))\n    \n    if not root:\n        return 0\n    max_diameter = 0\n    def dfs(node: TreeNode) -> int:\n        nonlocal max_diameter\n        if not node:\n            return 0\n        left_height = height(node.left)\n        right_height = height(node.right)\n        max_diameter = max(max_diameter, left_height + right_height)\n        return 1 + max(left_height, right_height)\n    \n    dfs(root)\n    return max_diameter",
    "test_code": "import pytest\nfrom solution import diameter_of_binary_tree, TreeNode\n\n# Helper function to create a binary tree\ndef create_tree(arr: list) -> TreeNode:\n    if not arr:\n        return None\n    nodes = [None if val is None else TreeNode(val) for val in arr]\n    kids = nodes[::-1]\n    root = kids.pop()\n    for node in nodes:\n        if node:\n            if kids:\n                node.left = kids.pop()\n            if kids:\n                node.right = kids.pop()\n    return root\n\ndef test_diameter_of_binary_tree_example1():\n    tree = create_tree([1, 2, 3, 4, 5])\n    assert diameter_of_binary_tree(tree) == 3\n\ndef test_diameter_of_binary_tree_example2():\n    tree = create_tree([1, 2, 3, 4, None, 5])\n    assert diameter_of_binary_tree(tree) == 4\n\ndef test_diameter_of_binary_tree_single_node():\n    tree = create_tree([1])\n    assert diameter_of_binary_tree(tree) == 0\n\ndef test_diameter_of_binary_tree_empty_tree():\n    tree = None\n    assert diameter_of_binary_tree(tree) == 0\n\ndef test_diameter_of_binary_tree_max_depth():\n    tree = create_tree([1, 2, 3, None, 4, 5, 6, 7, 8, 9])\n    assert diameter_of_binary_tree(tree) == 6\n\ndef test_diameter_of_binary_tree_unbalanced_tree():\n    tree = create_tree([1, 2, 3, 4, 5, None, 7])\n    assert diameter_of_binary_tree(tree) == 4",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef diameter_of_binary_tree(root: TreeNode) -> int:\n    \"\"\"\n    Returns the diameter of the binary tree.\n    \"\"\"\n    def height(node: TreeNode) -> int:\n        if not node:\n            return 0\n        return 1 + max(height(node.left), height(node.right))\n    \n    if not root:\n        return 0\n    max_diameter = 0\n    def dfs(node: TreeNode) -> int:\n        nonlocal max_diameter\n        if not node:\n            return 0\n        left_height = height(node.left)\n        right_height = height(node.right)\n        max_diameter = max(max_diameter, left_height + right_height)\n        return 1 + max(left_height, right_height)\n    \n    dfs(root)\n    return max_diameter",
        "test_code": "import pytest\nfrom solution import diameter_of_binary_tree, TreeNode\n\n# Helper function to create a binary tree\ndef create_tree(arr: list) -> TreeNode:\n    if not arr:\n        return None\n    nodes = [None if val is None else TreeNode(val) for val in arr]\n    kids = nodes[::-1]\n    root = kids.pop()\n    for node in nodes:\n        if node:\n            if kids:\n                node.left = kids.pop()\n            if kids:\n                node.right = kids.pop()\n    return root\n\ndef test_diameter_of_binary_tree_example1():\n    tree = create_tree([1, 2, 3, 4, 5])\n    assert diameter_of_binary_tree(tree) == 3\n\ndef test_diameter_of_binary_tree_example2():\n    tree = create_tree([1, 2, 3, 4, None, 5])\n    assert diameter_of_binary_tree(tree) == 4\n\ndef test_diameter_of_binary_tree_single_node():\n    tree = create_tree([1])\n    assert diameter_of_binary_tree(tree) == 0\n\ndef test_diameter_of_binary_tree_empty_tree():\n    tree = None\n    assert diameter_of_binary_tree(tree) == 0\n\ndef test_diameter_of_binary_tree_max_depth():\n    tree = create_tree([1, 2, 3, None, 4, 5, 6, 7, 8, 9])\n    assert diameter_of_binary_tree(tree) == 6\n\ndef test_diameter_of_binary_tree_unbalanced_tree():\n    tree = create_tree([1, 2, 3, 4, 5, None, 7])\n    assert diameter_of_binary_tree(tree) == 4",
        "test_result": "Pass",
        "test_coverage": 95.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef diameter_of_binary_tree(root: TreeNode) -> int:\n    \"\"\"\n    Returns the diameter of a binary tree.\n    \"\"\"\n    def height(node):\n        if not node:\n            return 0\n        left_height = height(node.left)\n        right_height = height(node.right)\n        nonlocal diameter\n        diameter = max(diameter, left_height + right_height)\n        return max(left_height, right_height) + 1\n\n    diameter = 0\n    height(root)\n    return diameter",
        "test_code": "from solution import diameter_of_binary_tree, TreeNode\n\ndef test_diameter_of_binary_tree():\n    # Constructing a tree\n    #       1\n    #      / \\\n    #     2   3\n    #    / \\\n    #   4   5\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    \n    assert diameter_of_binary_tree(root) == 3\n\n    # Constructing another tree\n    #          1\n    #         /\n    #        2\n    #       /\n    #      3\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.left.left = TreeNode(3)\n    \n    assert diameter_of_binary_tree(root) == 3\n\n    # Single node tree\n    root = TreeNode(1)\n    assert diameter_of_binary_tree(root) == 0\n\n    # Empty tree\n    assert diameter_of_binary_tree(None) == 0",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef diameter_of_binary_tree(root: TreeNode) -> int:\n    \"\"\"\n    Returns the diameter of a binary tree.\n    \"\"\"\n    def height(node):\n        if not node:\n            return 0\n        left_height = height(node.left)\n        right_height = height(node.right)\n        nonlocal diameter\n        # The diameter could be stored in the height of nodes.\n        diameter = max(diameter, left_height + right_height)\n        return 1 + max(left_height, right_height)\n\n    diameter = 0\n    height(root)\n    return diameter",
        "test_code": "from solution import diameter_of_binary_tree, TreeNode\n\ndef create_tree(*values):\n    \"\"\"Helper function to create a binary tree from values.\"\"\"\n    if not values:\n        return None\n    nodes = [None if val is None else TreeNode(val) for val in values]\n    kids = nodes[::-1]\n    root = kids.pop()\n    for node in nodes:\n        if node:\n            if kids: node.left  = kids.pop()\n            if kids: node.right = kids.pop()\n    return root\n\ndef test_diameter_of_binary_tree():\n    # Construct a tree\n    tree = create_tree(1, 2, 3, 4, 5)\n    assert diameter_of_binary_tree(tree) == 3\n\n    # Construct another tree\n    tree = create_tree(1, 2, 3, None, 4, 5)\n    assert diameter_of_binary_tree(tree) == 4\n\n    # Perfect binary tree\n    tree = create_tree(1, 2, 3, 4, 5, 6)\n    assert diameter_of_binary_tree(tree) == 5\n\n    # A tree with a single node\n    assert diameter_of_binary_tree(TreeNode(1)) == 0\n\n    # A tree with no nodes\n    assert diameter_of_binary_tree(None) == 0",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000132",
      "row_id": 132,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to multiply a number by 3 and return the result.",
    "response": "def multiply_by_three(number):\n    \"\"\"\n    Multiplies the given number by 3 and returns the result.\n    \"\"\"\n    return number * 3",
    "test_code": "from solution import multiply_by_three\n\ndef test_multiply_by_three_positive_numbers():\n    assert multiply_by_three(2) == 6\n\ndef test_multiply_by_three_with_zero():\n    assert multiply_by_three(0) == 0\n\ndef test_multiply_by_three_negative_numbers():\n    assert multiply_by_three(-1) == -3\n\ndef test_multiply_by_three_large_number():\n    assert multiply_by_three(100) == 300",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def multiply_by_three(number):\n    \"\"\"\n    Multiplies the given number by 3 and returns the result.\n    \"\"\"\n    return number * 3",
        "test_code": "from solution import multiply_by_three\n\ndef test_multiply_by_three_positive_numbers():\n    assert multiply_by_three(2) == 6\n\ndef test_multiply_by_three_with_zero():\n    assert multiply_by_three(0) == 0\n\ndef test_multiply_by_three_negative_numbers():\n    assert multiply_by_three(-1) == -3\n\ndef test_multiply_by_three_large_number():\n    assert multiply_by_three(100) == 300",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def multiply_by_three(number):\n    \"\"\"\n    Multiplies the given number by 3 and returns the result.\n    \"\"\"\n    return number * 3",
        "test_code": "from solution import multiply_by_three\n\ndef test_multiply_by_three_positive_numbers():\n    assert multiply_by_three(4) == 12\n\ndef test_multiply_by_three_zero():\n    assert multiply_by_three(0) == 0\n\ndef test_multiply_by_three_negative_numbers():\n    assert multiply_by_three(-3) == -9\n\ndef test_multiply_by_three DECIMAL():\n    assert multiply_by_three(2.5) == 7.5",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000133",
      "row_id": 133,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to create a queue using a list with two methods: enqueue and dequeue. The enqueue method adds an element to the end of the queue, and the dequeue method removes the element from the front of the queue.",
    "response": "def enqueue(queue, item):\n    \"\"\"\n    Adds an item to the end of the queue.\n    \"\"\"\n    queue.append(item)\n\ndef dequeue(queue):\n    \"\"\"\n    Removes and returns the item from the front of the queue.\n    If the queue is empty, returns None.\n    \"\"\"\n    if len(queue) > 0:\n        return queue.pop(0)\n    else:\n        return None",
    "test_code": "from solution import enqueue, dequeue\n\ndef test_enqueue_dequeue():\n    queue = []\n    enqueue(queue, 1)\n    enqueue(queue, 2)\n    assert dequeue(queue) == 1\n    assert dequeue(queue) == 2\n    assert dequeue(queue) is None\n\ndef test_enqueue():\n    queue = []\n    enqueue(queue, 1)\n    assert queue == [1]\n    enqueue(queue, 2)\n    assert queue == [1, 2]\n\ndef test_dequeue_empty_queue():\n    queue = []\n    assert dequeue(queue) is None",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "class Queue:\n    \"\"\"\n    A basic queue implementation using a list.\n    Methods:\n        enqueue(item): Adds an item to the end of the queue.\n        dequeue(): Removes and returns the item from the front of the queue.\n    \"\"\"\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        self.items.append(item)\n\n    def dequeue(self):\n        if not self.is_empty():\n            return self.items.pop(0)\n        raise IndexError(\"pop from empty queue\")\n\n    def is_empty(self):\n        return len(self.items) == 0\n\n    def size(self):\n        return len(self.items)",
        "test_code": "def test_queue_operations():\n    q = Queue()\n    assert q.is_empty() == True\n    assert q.size() == 0\n\n    q.enqueue(1)\n    q.enqueue(2)\n    assert q.dequeue() == 1\n    assert q.dequeue() == 2\n    assert q.is_empty() == True\n    assert q.size() == 0\n\n    q.enqueue(3)\n    q.enqueue(4)\n    q.enqueue(5)\n    assert q.dequeue() == 3\n    assert q.dequeue() == 4\n    assert q.dequeue() == 5\n    assert q.is_empty() == True\n    assert q.size() == 0\n\n    try:\n        q.dequeue()\n        assert False, \"Expected an IndexError but did not raise\"\n    except IndexError:\n        assert True\n\n    try:\n        q.dequeue()\n        assert False, \"Expected an IndexError but did not raise\"\n    except IndexError:\n        assert True\n\n# The following tests are designed to ensure that enqueue and dequeue work with any type of item.\ndef test_enqueue_dequeue_with_different_types():\n    q = Queue()\n    q.enqueue(1)\n    q.enqueue(\"2\")\n    assert q.dequeue() == 1\n    assert q.dequeue() == \"2\"\n\n    q.enqueue({\"key\": \"value\"})\n    q.enqueue([1, 2, 3])\n    assert q.dequeue() == {\"key\": \"value\"}\n    assert q.dequeue() == [1, 2, 3]\n\n    try:\n        q.dequeue()\n        assert False, \"Expected an IndexError but did not raise\"\n    except IndexError:\n        assert True\n\n    try:\n        q.dequeue()\n        assert False, \"Expected an IndexError but did not raise\"\n    except IndexError:\n        assert True",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "class Queue:\n    \"\"\"\n    Queue implementation using a list with enqueue and dequeue methods.\n    \"\"\"\n    def __init__(self):\n        self.queue = []\n\n    def enqueue(self, item):\n        \"\"\"\n        Adds an element to the end of the queue.\n        \"\"\"\n        self.queue.append(item)\n\n    def dequeue(self):\n        \"\"\"\n        Removes the element from the front of the queue. Returns None if the queue is empty.\n        \"\"\"\n        if self.is_empty():\n            return None\n        return self.queue.pop(0)\n\n    def is_empty(self):\n        \"\"\"\n        Checks if the queue is empty.\n        \"\"\"\n        return len(self.queue) == 0",
        "test_code": "import pytest\n\ndef test_queue_empty():\n    queue = Queue()\n    assert queue.is_empty()\n    assert queue.dequeue() is None\n\ndef test_queue_enqueue():\n    queue = Queue()\n    queue.enqueue(1)\n    queue.enqueue(2)\n    assert not queue.is_empty()\n    assert queue.queue == [1, 2]\n\ndef test_queue_enqueue_multiple():\n    queue = Queue()\n    queue.enqueue(1)\n    queue.enqueue(2)\n    queue.enqueue(3)\n    assert queue.queue == [1, 2, 3]\n\ndef test_queue_dequeue():\n    queue = Queue()\n    queue.enqueue(1)\n    queue.enqueue(2)\n    queue.enqueue(3)\n    assert queue.dequeue() == 1\n    assert queue.queue == [2, 3]\n\ndef test_queue_dequeue_empty():\n    queue = Queue()\n    assert queue.dequeue() is None\n\ndef test_queue_dequeue_multi_times():\n    queue = Queue()\n    queue.enqueue(1)\n    queue.enqueue(2)\n    queue.enqueue(3)\n    assert queue.dequeue() == 1\n    assert queue.dequeue() == 2\n    assert queue.dequeue() == 3\n    assert queue.is_empty()",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def enqueue(queue, item):\n    \"\"\"\n    Adds an item to the end of the queue.\n    \"\"\"\n    queue.append(item)\n\ndef dequeue(queue):\n    \"\"\"\n    Removes and returns the item from the front of the queue.\n    If the queue is empty, returns None.\n    \"\"\"\n    if len(queue) > 0:\n        return queue.pop(0)\n    else:\n        return None",
        "test_code": "from solution import enqueue, dequeue\n\ndef test_enqueue_dequeue():\n    queue = []\n    enqueue(queue, 1)\n    enqueue(queue, 2)\n    assert dequeue(queue) == 1\n    assert dequeue(queue) == 2\n    assert dequeue(queue) is None\n\ndef test_enqueue():\n    queue = []\n    enqueue(queue, 1)\n    assert queue == [1]\n    enqueue(queue, 2)\n    assert queue == [1, 2]\n\ndef test_dequeue_empty_queue():\n    queue = []\n    assert dequeue(queue) is None",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000136",
      "row_id": 136,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the maximum sum of a subarray within a given array. This is known as the maximum subarray problem. You should use Kadane's algorithm to implement this.",
    "response": "def max_subarray_kadane(arr):\n    \"\"\"\n    Find the maximum sum of a subarray within the given array using Kadane's algorithm.\n    \"\"\"\n    max_current = max_global = arr[0]\n    for num in arr[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global",
    "test_code": "from solution import max_subarray_kadane\n\ndef test_max_subarray_kadane():\n    assert max_subarray_kadane([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6, \"Test Case 1 Failed\"\n    assert max_subarray_kadane([1]) == 1, \"Test Case 2 Failed\"\n    assert max_subarray_kadane([-1, -2, -3, -4]) == -1, \"Test Case 3 Failed\"\n    assert max_subarray_kadane([5, 4, -1, 7, 8]) == 23, \"Test Case 4 Failed\"",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def max_subarray_kadane(arr):\n    \"\"\"\n    Finds the maximum sum of a contiguous subarray within a one-dimensional array of numbers.\n    This implementation uses Kadane's algorithm.\n    \"\"\"\n    max_current = max_global = arr[0]\n    for num in arr[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global",
        "test_code": "from solution import max_subarray_kadane\n\ndef test_max_subarray_kadane_positive():\n    assert max_subarray_kadane([1, 2, 3, -2, 5]) == 9\n\ndef test_max_subarray_kadane_single_negative():\n    assert max_subarray_kadane([-1]) == -1\n\ndef test_max_subarray_kadane_all_negative():\n    assert max_subarray_kadane([-2, -3, -1, -5]) == -1\n\ndef test_max_subarray_kadane_random():\n    assert max_subarray_kadane([2, 3, -2, 1, -5, 4, -3]) == 6\n\ndef test_max_subarray_kadane_mixed():\n    assert max_subarray_kadane([5, -2, 3, 4, -1, 2, 1, -5, 4]) == 10\n\ndef test_max_subarray_kadane_empty():\n    assert max_subarray_kadane([]) == 0",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def max_subarray_sum(arr):\n    \"\"\"\n    Returns the maximum sum of a contiguous subarray within the one-dimensional array of numbers.\n    Uses Kadane's algorithm to solve the maximum subarray problem.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    max_current = max_global = arr[0]\n    for num in arr[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n            \n    return max_global",
        "test_code": "from solution import max_subarray_sum\n\ndef test_max_subarray_sum_single_element():\n    assert max_subarray_sum([1]) == 1\n\ndef test_max_subarray_sum_positive_numbers():\n    assert max_subarray_sum([1, 2, 3, 4]) == 10\n\ndef test_max_subarray_sum_mixed_negative_and_positive_numbers():\n    assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\n\ndef test_max_subarray_sum_all_negative_numbers():\n    assert max_subarray_sum([-1, -2, -3, -4]) == -1\n\ndef test_max_subarray_sum_empty_array():\n    assert max_subarray_sum([]) == 0\n\ndef test_max_subarray_sum_single_negative_number():\n    assert max_subarray_sum([-5]) == -5\n\ndef test_max_subarray_sum_alternating_signs():\n    assert max_subarray_sum([1, -1, 1, -1, 3]) == 3\n\ndef test_max_subarray_sum_with_zero():\n    assert max_subarray_sum([0, 1, -1, 2, -3, 4, 0, -4, 5]) == 6",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def max_subarray_kadane(arr):\n    \"\"\"\n    Find the maximum sum of a subarray within the given array using Kadane's algorithm.\n    \"\"\"\n    max_current = max_global = arr[0]\n    for num in arr[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global",
        "test_code": "from solution import max_subarray_kadane\n\ndef test_max_subarray_kadane():\n    assert max_subarray_kadane([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6, \"Test Case 1 Failed\"\n    assert max_subarray_kadane([1]) == 1, \"Test Case 2 Failed\"\n    assert max_subarray_kadane([-1, -2, -3, -4]) == -1, \"Test Case 3 Failed\"\n    assert max_subarray_kadane([5, 4, -1, 7, 8]) == 23, \"Test Case 4 Failed\"",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      0,
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000139",
      "row_id": 139,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to check if a list of integers contains the number 5. If it does, return the index of the first occurrence of 5, otherwise, return -1.",
    "response": "def find_index_of_five(numbers):\n    \"\"\"\n    Returns the index of the first occurrence of the number 5 in the list.\n    If 5 is not found, returns -1.\n    \"\"\"\n    try:\n        return numbers.index(5)\n    except ValueError:\n        return -1",
    "test_code": "def test_find_index_of_five():\n    assert find_index_of_five([1, 2, 3, 4, 5, 6]) == 4\n    assert find_index_of_five([1, 5, 2, 3, 4, 6]) == 1\n    assert find_index_of_five([1, 2, 3, 4, 6]) == -1\n    assert find_index_of_five([5, 1, 2, 3, 4, 6]) == 0\n    assert find_index_of_five([]) == -1",
    "trials": {
      "trial_qwen2.5_1": {
        "solution_code": "def find_index_of_five(numbers):\n    \"\"\"\n    Returns the index of the first occurrence of the number 5 in the list.\n    If 5 is not found, returns -1.\n    \"\"\"\n    try:\n        return numbers.index(5)\n    except ValueError:\n        return -1",
        "test_code": "def test_find_index_of_five():\n    assert find_index_of_five([1, 2, 3, 4, 5, 6]) == 4\n    assert find_index_of_five([1, 5, 2, 3, 4, 6]) == 1\n    assert find_index_of_five([1, 2, 3, 4, 6]) == -1\n    assert find_index_of_five([5, 1, 2, 3, 4, 6]) == 0\n    assert find_index_of_five([]) == -1",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000140",
      "row_id": 140,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the maximum product of a triplet in an array. The array can contain both positive and negative numbers. The function should return the maximum product of any three numbers in the array.",
    "response": "def max_triplet_product(arr):\n    \"\"\"\n    Finds and returns the maximum product that can be obtained from any three elements in the array.\n    \"\"\"\n    if len(arr) < 3:\n        raise ValueError(\"The input array must contain at least three elements.\")\n\n    # Sort the array to make it easier to find the maximum product\n    arr.sort()\n\n    # The maximum product can be either:\n    # 1. The product of the three largest numbers\n    # 2. The product of the two smallest (potentially negative) numbers and the largest number\n    n = len(arr)\n    return max(arr[0] * arr[1] * arr[n-1], arr[n-3] * arr[n-2] * arr[n-1])",
    "test_code": "import pytest\nfrom solution import max_triplet_product\n\ndef test_max_triplet_product_with_positive_numbers():\n    assert max_triplet_product([1, 2, 3]) == 6\n\ndef test_max_triplet_product_with_mixed_numbers():\n    assert max_triplet_product([1, 10, -5, 1, -100]) == 5000  # -5 * -100 * 10\n\ndef test_max_triplet_product_with_negative_numbers():\n    assert max_triplet_product([-1, -2, -3, -4]) == -6\n\ndef test_max_triplet_product_with_zero():\n    assert max_triplet_product([0, 0, 0]) == 0\n\ndef test_max_triplet_product_with_small_array():\n    with pytest.raises(ValueError):\n        max_triplet_product([1, 2])\n\ndef test_max_triplet_product_with_larger_numbers():\n    assert max_triplet_product([0, -2, -8, -7, 0]) == 0  # 0 * 0 * -7\n    assert max_triplet_product([-5, -4, 2, 2]) == 40  # -5 * -4 * 2",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def max_triplet_product(arr):\n    \"\"\"\n    Finds and returns the maximum product that can be obtained from any three elements in the array.\n    \"\"\"\n    if len(arr) < 3:\n        raise ValueError(\"The input array must contain at least three elements.\")\n\n    # Sort the array to make it easier to find the maximum product\n    arr.sort()\n\n    # The maximum product can be either:\n    # 1. The product of the three largest numbers\n    # 2. The product of the two smallest (potentially negative) numbers and the largest number\n    n = len(arr)\n    return max(arr[0] * arr[1] * arr[n-1], arr[n-3] * arr[n-2] * arr[n-1])",
        "test_code": "import pytest\nfrom solution import max_triplet_product\n\ndef test_max_triplet_product_with_positive_numbers():\n    assert max_triplet_product([1, 2, 3]) == 6\n\ndef test_max_triplet_product_with_mixed_numbers():\n    assert max_triplet_product([1, 10, -5, 1, -100]) == 5000  # -5 * -100 * 10\n\ndef test_max_triplet_product_with_negative_numbers():\n    assert max_triplet_product([-1, -2, -3, -4]) == -6\n\ndef test_max_triplet_product_with_zero():\n    assert max_triplet_product([0, 0, 0]) == 0\n\ndef test_max_triplet_product_with_small_array():\n    with pytest.raises(ValueError):\n        max_triplet_product([1, 2])\n\ndef test_max_triplet_product_with_larger_numbers():\n    assert max_triplet_product([0, -2, -8, -7, 0]) == 0  # 0 * 0 * -7\n    assert max_triplet_product([-5, -4, 2, 2]) == 40  # -5 * -4 * 2",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def max_product_of_triplet(arr):\n    \"\"\"\n    Returns the maximum product that can be obtained by multiplying any three elements from the array.\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    # The maximum product can be either (the product of the three largest numbers) \n    # or (the product of the two smallest numbers (which could be negative) and the largest number).\n    return max(arr[0] * arr[1] * arr[n-1], arr[n-3] * arr[n-2] * arr[n-1])",
        "test_code": "import pytest\n\ndef test_max_product_of_triplet_positive_numbers():\n    assert max_product_of_triplet([1, 2, 3]) == 6\n\ndef test_max_product_of_triplet_negative_numbers():\n    assert max_product_of_triplet([-10, -10, 5, 2]) == 500\n\ndef test_max_product_of_triplet_mixed_numbers():\n    assert max_product_of_triplet([-1, -2, -3, -4]) == -6\n\ndef test_max_product_of_triplet_with_zeross():\n    assert max_product_of_triplet([-1, -1, 0, 2, 3]) == 6\n\ndef test_max_product_of_triplet_edge_cases():\n    assert max_product_of_triplet([1, 2]) == 2\n    assert max_product_of_triplet([1]) == 1\n    assert max_product_of_triplet([-1]) == -1",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def max_product_of_triplet(arr):\n    \"\"\"\n    Returns the maximum product of a triplet in the array.\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    # The maximum product can be either:\n    # 1. Product of the three largest numbers\n    # 2. Product of the two smallest (which could be negative) and the largest number\n    return max(arr[0] * arr[1] * arr[n-1], arr[n-3] * arr[n-2] * arr[n-1])",
        "test_code": "def test_max_product_of_triplet():\n    assert max_product_of_triplet([1, 2, 3]) == 6\n    assert max_product_of_triplet([-1, -2, -3]) == -6\n    assert max_product_of_triplet([-100, -200, 5, 1, 2]) == 20000\n    assert max_product_of_triplet([-2, -3, 4, -5, -6, 1]) == 60\n    assert max_product_of_triplet([1, -4, 3, -6, 7, 0]) == 168\n    assert max_product_of_triplet([0, 2, 3, -5, 1, 4]) == 60\n    assert max_product_of_triplet([10, -20, 2, -3, 4, -5, 5]) == 1000",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000144",
      "row_id": 144,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to sort a list of integers using the Bubble sort algorithm.",
    "response": "def bubble_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the Bubble sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Create a flag that will allow the function to terminate early if there's nothing left to sort\n        already_sorted = True\n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                # Swap if the element found is greater than the next element\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                already_sorted = False\n        # If there were no swaps during the last iteration, the array is already sorted, and we can terminate\n        if already_sorted:\n            break\n    return arr",
    "test_code": "import pytest\nfrom solution import bubble_sort\n\ndef test_bubble_sort_empty_list():\n    assert bubble_sort([]) == []\n\ndef test_bubble_sort_single_element():\n    assert bubble_sort([5]) == [5]\n\ndef test_bubble_sort_sorted_list():\n    assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_reverse_sorted_list():\n    assert bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_unsorted_list():\n    assert bubble_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n\ndef test_bubble_sort_with_negative_numbers():\n    assert bubble_sort([-2, -5, -45, 0, 2, -1, 3]) == [-45, -5, -2, -1, 0, 2, 3]\n\ndef test_bubble_sort_duplicate_numbers():\n    assert bubble_sort([2, 3, 1, 3, 2]) == [1, 2, 2, 3, 3]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def bubble_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the Bubble sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr",
        "test_code": "``\nfrom solution import bubble_sort\n\ndef test_bubble_sort_empty_list():\n    assert bubble_sort([]) == []\n\ndef test_bubble_sort_single_element():\n    assert bubble_sort([5]) == [5]\n\ndef test_bubble_sort_sorted_list():\n    assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_reverse_sorted_list():\n    assert bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_random_list():\n    assert bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90]\n\ndef test_bubble_sort_with_duplicates():\n    assert bubble_sort([64, 34, 25, 12, 22, 11, 11, 90, 22]) == [11, 11, 12, 22, 22, 25, 34, 64, 90]",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def bubble_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the Bubble sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Create a flag that will allow the function to terminate early if there's nothing left to sort\n        already_sorted = True\n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                # Swap if the element found is greater than the next element\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                already_sorted = False\n        # If there were no swaps during the last iteration, the array is already sorted, and we can terminate\n        if already_sorted:\n            break\n    return arr",
        "test_code": "import pytest\nfrom solution import bubble_sort\n\ndef test_bubble_sort_empty_list():\n    assert bubble_sort([]) == []\n\ndef test_bubble_sort_single_element():\n    assert bubble_sort([5]) == [5]\n\ndef test_bubble_sort_sorted_list():\n    assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_reverse_sorted_list():\n    assert bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n\ndef test_bubble_sort_unsorted_list():\n    assert bubble_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n\ndef test_bubble_sort_with_negative_numbers():\n    assert bubble_sort([-2, -5, -45, 0, 2, -1, 3]) == [-45, -5, -2, -1, 0, 2, 3]\n\ndef test_bubble_sort_duplicate_numbers():\n    assert bubble_sort([2, 3, 1, 3, 2]) == [1, 2, 2, 3, 3]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def bubble_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the Bubble Sort algorithm.\n    \n    Parameters:\n    arr (list of int): The list of integers to be sorted.\n    \n    Returns:\n    list of int: The sorted list of integers.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Create a flag that will allow the function to terminate early if there's nothing left to sort\n        already_sorted = True\n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                # Swap the elements\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                # Since we had to swap two elements, we set the flag to True so the algorithm doesn't finish prematurely\n                already_sorted = False\n        # If there were no swaps during the last iteration, the array is already sorted, and we can terminate\n        if already_sorted:\n            break\n    return arr",
        "test_code": "from solution import bubble_sort\n\ndef test_bubble_sort_empty_list():\n    assert bubble_sort([]) == []\n\ndef test_bubble_sort_single_element():\n    assert bubble_sort([5]) == [5]\n\ndef test_bubble_sort_positive_numbers():\n    assert bubble_sort([34, 12, 24, 9, 5]) == [5, 9, 12, 24, 34]\n\ndef test_bubble_sort_negative_numbers():\n    assert bubble_sort([34, -34, 12, -12, 24, -24, 9, -9, 5, -5]) == [-34, -24, -12, -9, -5, 5, 9, 12, 24, 34]\n\ndef test_bubble_sort_mixed_sign_numbers():\n    assert bubble_sort([34, -34, 0, -5, 9, 5, -9, 12, 24, -24, 17, -17]) == [-34, -24, -17, -9, -5, 0, 5, 9, 12, 17, 24, 34]\n\ndef test_bubble_sort already_sorted():\n    assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000145",
      "row_id": 145,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to determine if a given number is a power of two. A number is a power of two if it can be represented as 2^k where k is a non-negative integer. Assume the input is always a valid integer, both positive and negative, but negative numbers should be immediately determined as not powers of two.",
    "response": "def is_power_of_two(n):\n    \"\"\"\n    Returns True if n is a power of two, otherwise False.\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0",
    "test_code": "def test_is_power_of_two():\n    assert not is_power_of_two(-4)\n    assert not is_power_of_two(0)\n    assert is_power_of_two(1)\n    assert is_power_of_two(2)\n    assert is_power_of_two(4)\n    assert not is_power_of_two(3)\n    assert is_power_of_two(8)\n    assert not is_power_of_two(15)\n    assert is_power_of_two(16)\n    assert is_power_of_two(32)",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def is_power_of_two(n):\n    \"\"\"\n    Returns True if n is a power of two, otherwise returns False.\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0",
        "test_code": "def test_is_power_of_two():\n    assert is_power_of_two(1) == True\n    assert is_power_of_two(2) == True\n    assert is_power_of_two(4) == True\n    assert is_power_of_two(3) == False\n    assert is_power_of_two(16) == True\n    assert is_power_of_two(-2) == False\n    assert is_power_of_two(0) == False\n    assert is_power_of_two(1024) == True\n    assert is_power_of_two(1023) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def is_power_of_two(n):\n    \"\"\"\n    Returns True if n is a power of two, otherwise False.\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0",
        "test_code": "def test_is_power_of_two():\n    assert not is_power_of_two(-4)\n    assert not is_power_of_two(0)\n    assert is_power_of_two(1)\n    assert is_power_of_two(2)\n    assert is_power_of_two(4)\n    assert not is_power_of_two(3)\n    assert is_power_of_two(8)\n    assert not is_power_of_two(15)\n    assert is_power_of_two(16)\n    assert is_power_of_two(32)",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_power_of_two(n: int) -> bool:\n    \"\"\"\n    Checks if the given number n is a power of two.\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0",
        "test_code": "import pytest\n\ndef test_is_power_of_two_positive():\n    assert is_power_of_two(1) is True\n    assert is_power_of_two(2) is True\n    assert is_power_of_two(4) is True\n    assert is_power_of_two(16) is True\n\ndef test_is_power_of_two_not_positive():\n    assert is_power_of_two(0) is False\n    assert is_power_of_two(-2) is False\n    assert is_power_of_two(-4) is False\n\ndef test_is_power_of_two_large_values():\n    assert is_power_of_two(1048576) is True  # 2^20\n    assert is_power_of_two(2097152) is False  # 2^21 - 1 is not a power of two\n\ndef test_is_power_of_two_edge_cases():\n    assert is_power_of_two(3) is False\n    assert is_power_of_two(8) is True\n    assert is_power_of_two(1023) is False  # 2^10 - 1 is not a power of two",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      0
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000150",
      "row_id": 150,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to convert a decimal number to binary without using Python's built-in bin() function. Walk me through the process and the code.",
    "response": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Converts a decimal number to its binary representation without using Python's built-in bin() function.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    binary = []\n    while n > 0:\n        binary.append(str(n % 2))\n        n = n // 2\n    binary.reverse()\n    return ''.join(binary)",
    "test_code": "def test_decimal_to_binary():\n    assert decimal_to_binary(0) == '0'\n    assert decimal_to_binary(1) == '1'\n    assert decimal_to_binary(2) == '10'\n    assert decimal_to_binary(3) == '11'\n    assert decimal_to_binary(4) == '100'\n    assert decimal_to_binary(5) == '101'\n    assert decimal_to_binary(14) == '1110'\n    assert decimal_to_binary(255) == '11111111'\n    assert decimal_to_binary(256) == '100000000'\n    assert decimal_to_binary(1023) == '1111111111'\n\ndef test_single_digit():\n    assert decimal_to_binary(1) == '1'\n    assert decimal_to_binary(9) == '1001'",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Converts a decimal number to its binary representation without using the built-in bin function.\n    \n    Parameters:\n    n (int): The decimal number to be converted.\n    \n    Returns:\n    str: The binary representation of the decimal number.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    binary_str = \"\"\n    while n > 0:\n        remainder = n % 2  # Find the remainder when n is divided by 2\n        binary_str = str(remainder) + binary_str  # Prepend the remainder to the binary string\n        n = n // 2  # Divide n by 2 and take the floor\n    return binary_str",
        "test_code": "def test_decimal_to_binary():\n    assert decimal_to_binary(0) == \"0\"\n    assert decimal_to_binary(1) == \"1\"\n    assert decimal_to_binary(5) == \"101\"\n    assert decimal_to_binary(10) == \"1010\"\n    assert decimal_to_binary(255) == \"11111111\"\n    assert decimal_to_binary(256) == \"100000000\"",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "To convert a decimal number to binary without using Python's built-in `bin()` function, we can use the following approach:\n\n1. Define a function `decimal_to_binary` that takes a decimal number as input.\n2. Initialize an empty string to store the binary representation.\n3. Use a while loop to divide the decimal number by 2 and get the remainder. Append the remainder to the string.\n4. Continue the process until the decimal number becomes 0.\n5. Reverse the string of remainders to get the correct binary representation.\n\ndef decimal_to_binary(decimal_number):\n    \"\"\"\n    Converts a decimal number to binary without using Python's built-in bin() function.\n    \"\"\"\n    if decimal_number == 0:\n        return \"0\"\n    \n    binary = \"\"\n    while decimal_number > 0:\n        remainder = decimal_number % 2\n        binary += str(remainder)\n        decimal_number = decimal_number // 2\n    \n    return binary[::-1]",
        "test_code": "from solution import decimal_to_binary\n\ndef test_decimal_to_binary():\n    assert decimal_to_binary(10) == \"1010\"\n    assert decimal_to_binary(0) == \"0\"\n    assert decimal_to_binary(19) == \"10011\"\n    assert decimal_to_binary(255) == \"11111111\"\n    assert decimal_to_binary(4095) == \"111111111111\"\n    assert decimal_to_binary(2) == \"10\"\n    assert decimal_to_binary(1) == \"1\"\n    assert decimal_to_binary(2147483647) == \"1111111111111111111111111111111\"",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Converts a decimal number to its binary representation without using Python's built-in bin() function.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    binary = []\n    while n > 0:\n        binary.append(str(n % 2))\n        n = n // 2\n    binary.reverse()\n    return ''.join(binary)",
        "test_code": "def test_decimal_to_binary():\n    assert decimal_to_binary(0) == '0'\n    assert decimal_to_binary(1) == '1'\n    assert decimal_to_binary(2) == '10'\n    assert decimal_to_binary(3) == '11'\n    assert decimal_to_binary(4) == '100'\n    assert decimal_to_binary(5) == '101'\n    assert decimal_to_binary(14) == '1110'\n    assert decimal_to_binary(255) == '11111111'\n    assert decimal_to_binary(256) == '100000000'\n    assert decimal_to_binary(1023) == '1111111111'\n\ndef test_single_digit():\n    assert decimal_to_binary(1) == '1'\n    assert decimal_to_binary(9) == '1001'",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000151",
      "row_id": 151,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to determine whether a number is even or odd without using if else statements. You can use bitwise operators only.",
    "response": "def is_even(number):\n    \"\"\"\n    Returns True if the number is even, False otherwise, using bitwise operations only.\n    \"\"\"\n    return (number & 1) == 0",
    "test_code": "def test_is_even():\n    assert is_even(2) == True\n    assert is_even(3) == False\n    assert is_even(0) == True\n    assert is_even(-4) == True\n    assert is_even(-3) == False\n\ndef test_is_odd():\n    assert is_even(1) == False\n    assert is_even(-1) == False\n    assert is_even(-5) == False",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def is_even(number):\n    \"\"\"\n    Returns True if the number is even, False otherwise.\n    Uses bitwise AND operator to determine if the number is even.\n    \"\"\"\n    return (number & 1) == 0",
        "test_code": "from solution import is_even\n\ndef test_is_even():\n    assert is_even(4) is True\n    assert is_even(5) is False\n    assert is_even(0) is True\n    assert is_even(-2) is True\n    assert is_even(-3) is False\n\ndef test_is_odd():\n    assert is_even(3) is False\n    assert is_even(-1) is False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_even(number):\n    \"\"\"\n    Returns True if the number is even, False otherwise, using bitwise operations only.\n    \"\"\"\n    return (number & 1) == 0",
        "test_code": "def test_is_even():\n    assert is_even(2) == True\n    assert is_even(3) == False\n    assert is_even(0) == True\n    assert is_even(-4) == True\n    assert is_even(-3) == False\n\ndef test_is_odd():\n    assert is_even(1) == False\n    assert is_even(-1) == False\n    assert is_even(-5) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000152",
      "row_id": 152,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to convert a given string into a list of words. Splitting can be done based on multiple characters. For instance, splitting can be done using the characters ',', '.', and ' ' (space). How would you approach this problem?",
    "response": "def split_string_into_words(s: str):\n    \"\"\"\n    Splits a given string into words based on the delimiters: ',', '.', and ' '.\n    \"\"\"\n    delimiters = [',', '.', ' ']\n    words = []\n    current_word = ''\n    for char in s:\n        if char in delimiters:\n            if current_word:  # If there is a non-empty word to add\n                words.append(current_word)\n                current_word = ''\n        else:\n            current_word += char\n    if current_word:  # Add the last word if any\n        words.append(current_word)\n    return words",
    "test_code": "def test_split_string_into_words():\n    assert split_string_into_words(\"Hello, world. This is a test.\") == [\"Hello\", \"world\", \"This\", \"is\", \"a\", \"test\"]\n    assert split_string_into_words(\"Split,these,words,using,multiple,delimiters.\") == [\"Split\", \"these\", \"words\", \"using\", \"multiple\", \"delimiters\"]\n    assert split_string_into_words(\"NoDelimitersHere\") == [\"NoDelimitersHere\"]\n    assert split_string_into_words(\"Trailing,separator,\") == [\"Trailing\", \"separator\"]\n    assert split_string_into_words(\"Leading,separator,,Leading,combinations,of,delimiters., \") == [\"Leading\", \"separator\", \"Leading\", \"combinations\", \"of\", \"delimiters\"]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def split_string_into_words(s):\n    \"\"\"\n    Splits the given string into words based on the delimiters ',', '.', and ' '.\n    Args:\n    s (str): The input string to split.\n    \n    Returns:\n    list: A list of words from the input string.\n    \"\"\"\n    delimiters = [',', '.', ' ']\n    words = []\n    current_word = ''\n    for char in s:\n        if char not in delimiters:\n            current_word += char\n        else:\n            if current_word:\n                words.append(current_word)\n                current_word = ''\n    if current_word:  # Append the last word if it exists\n        words.append(current_word)\n    return words",
        "test_code": "from solution import split_string_into_words\n\ndef test_split_string_into_words():\n    assert split_string_into_words(\"Hello, world. This is a test.\") == [\"Hello\", \"world\", \"This\", \"is\", \"a\", \"test\"]\n    assert split_string_into_words(\"Split,these,words...using,.delimiters\") == [\"Split\", \"these\", \"words\", \"using\", \"delimiters\"]\n    assert split_string_into_words(\"OneWord\") == [\"OneWord\"]\n    assert split_string_into_words(\",,,.  ..\") == []\n    assert split_string_into_words(\"\") == []\n    assert split_string_into_words(\"a,b.c d\") == [\"a\", \"b\", \"c\", \"d\"]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "import re\n\ndef split_string_into_words(input_string):\n    \"\"\"\n    Splits the input string based on ',', '.', and ' ' (space) and returns a list of words.\n    \"\"\"\n    return re.split(r'[ ,.]+', input_string)",
        "test_code": "from solution import split_string_into_words\n\ndef test_split_string_into_words():\n    test_string = \"Hello, world. This is a test.\"\n    expected_output = [\"Hello\", \"world\", \"This\", \"is\", \"a\", \"test\"]\n    assert split_string_into_words(test_string) == expected_output\n\ndef test_split_string_with_multiple_delimiters():\n    test_string = \"One, two, three. Four five six\"\n    expected_output = [\"One\", \"two\", \"three\", \"Four\", \"five\", \"six\"]\n    assert split_string_into_words(test_string) == expected_output\n\ndef test_split_empty_string():\n    test_string = \"\"\n    expected_output = []\n    assert split_string_into_words(test_string) == expected_output\n\ndef test_split_string_with_no_delimiters():\n    test_string = \"OnetwothreeFourfivesix\"\n    expected_output = [\"OnetwothreeFourfivesix\"]\n    assert split_string_into_words(test_string) == expected_output\n\ndef test_split_string_with_only_delimiters():\n    test_string = \",,.   ...  \"\n    expected_output = []\n    assert split_string_into_words(test_string) == expected_output\n\ndef test_split_string_with_tab_and_newline():\n    test_string = \"Line1\\tLine2\\nLine3\"\n    expected_output = [\"Line1\", \"Line2\", \"Line3\"]\n    assert split_string_into_words(test_string) == expected_output",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def split_string_into_words(s: str):\n    \"\"\"\n    Splits a given string into words based on the delimiters: ',', '.', and ' '.\n    \"\"\"\n    delimiters = [',', '.', ' ']\n    words = []\n    current_word = ''\n    for char in s:\n        if char in delimiters:\n            if current_word:  # If there is a non-empty word to add\n                words.append(current_word)\n                current_word = ''\n        else:\n            current_word += char\n    if current_word:  # Add the last word if any\n        words.append(current_word)\n    return words",
        "test_code": "def test_split_string_into_words():\n    assert split_string_into_words(\"Hello, world. This is a test.\") == [\"Hello\", \"world\", \"This\", \"is\", \"a\", \"test\"]\n    assert split_string_into_words(\"Split,these,words,using,multiple,delimiters.\") == [\"Split\", \"these\", \"words\", \"using\", \"multiple\", \"delimiters\"]\n    assert split_string_into_words(\"NoDelimitersHere\") == [\"NoDelimitersHere\"]\n    assert split_string_into_words(\"Trailing,separator,\") == [\"Trailing\", \"separator\"]\n    assert split_string_into_words(\"Leading,separator,,Leading,combinations,of,delimiters., \") == [\"Leading\", \"separator\", \"Leading\", \"combinations\", \"of\", \"delimiters\"]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000154",
      "row_id": 154,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to to count the number of times a character appears in a string",
    "response": "def char_count(text, character):\n    \"\"\"\n    Returns the number of times a character appears in a string.\n    \"\"\"\n    return text.count(character)",
    "test_code": "from solution import char_count\n\ndef test_char_count_single_character():\n    assert char_count(\"hello\", \"l\") == 2\n\ndef test_char_count_multiple_characters():\n    assert char_count(\"banana\", \"a\") == 3\n\ndef test_char_count_empty_string():\n    assert char_count(\"\", \"a\") == 0\n\ndef test_char_count_with_whitespace():\n    assert char_count(\"hello world\", \" \") == 1\n\ndef test_char_count_case_sensitive():\n    assert char_count(\"Hello\", \"h\") == 0\n    assert char_count(\"Hello\", \"H\") == 1\n\ndef test_char_count_special_characters():\n    assert char_count(\"hello@world\", \"@\") == 1",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def count_char_in_string(s, char):\n    \"\"\"\n    Returns the number of times a character appears in a string.\n    Args:\n    s (str): The string to search in.\n    char (str): The character to count.\n    \n    Returns:\n    int: The count of the character in the string.\n    \"\"\"\n    return s.count(char)",
        "test_code": "from solution import count_char_in_string\n\ndef test_count_char_in_string():\n    assert count_char_in_string(\"hello world\", \"l\") == 3\n    assert count_char_in_string(\"aaaabbb\", \"a\") == 4\n    assert count_char_in_string(\"python programming\", \"p\") == 2\n    assert count_char_in_string(\"test case\", \"z\") == 0\n\ndef test_count_char_in_empty_string():\n    assert count_char_in_string(\"\", \"a\") == 0\n\ndef test_count_char_case_insensitive():\n    assert count_char_in_string(\"Hello World\", \"h\") == 1",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def char_count(text, character):\n    \"\"\"\n    Returns the number of times a character appears in a string.\n    \"\"\"\n    return text.count(character)",
        "test_code": "from solution import char_count\n\ndef test_char_count_single_character():\n    assert char_count(\"hello\", \"l\") == 2\n\ndef test_char_count_multiple_characters():\n    assert char_count(\"banana\", \"a\") == 3\n\ndef test_char_count_empty_string():\n    assert char_count(\"\", \"a\") == 0\n\ndef test_char_count_with_whitespace():\n    assert char_count(\"hello world\", \" \") == 1\n\ndef test_char_count_case_sensitive():\n    assert char_count(\"Hello\", \"h\") == 0\n    assert char_count(\"Hello\", \"H\") == 1\n\ndef test_char_count_special_characters():\n    assert char_count(\"hello@world\", \"@\") == 1",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def count_char_in_string(char, string):\n    \"\"\"\n    Counts the number of times a character appears in a string.\n    \n    Parameters:\n    char (str): The character to count.\n    string (str): The string in which to count the character.\n    \n    Returns:\n    int: The number of times the character appears in the string.\n    \"\"\"\n    return string.count(char)",
        "test_code": "from solution import count_char_in_string\n\ndef test_count_char_in_string_with_matching_chars():\n    assert count_char_in_string('a', 'banana') == 3\n    assert count_char_in_string('n', 'superman') == 2\n    assert count_char_in_string('z', 'zzzzz') == 5\n\ndef test_count_char_in_string_with_no_matching_chars():\n    assert count_char_in_string('x', 'hello') == 0\n    assert count_char_in_string('!', 'abc') == 0\n\ndef test_count_char_in_string_with_empty_string():\n    assert count_char_in_string('d', '') == 0\n\ndef test_count_char_in_string_case_insensitive():\n    assert count_char_in_string('a', 'AaAaA') == 3\n    assert count_char_in_string('A', 'AaAaA') == 3\n\ndef test_count_char_in_string_space():\n    assert count_char_in_string(' ', 'Hello world') == 1",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000158",
      "row_id": 158,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to reverse a string without using extra space.",
    "response": "def reverse_string(s):\n    \"\"\"\n    Reverses the given string s without using extra space.\n    \"\"\"\n    s = list(s)  # Convert string to list to allow in-place modification\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]  # Swap characters\n        left, right = left + 1, right - 1\n    return ''.join(s)  # Convert list back to string",
    "test_code": "from solution import reverse_string\n\ndef test_reverse_string_positive():\n    assert reverse_string(\"hello\") == \"olleh\"\n\ndef test_reverse_string_empty():\n    assert reverse_string(\"\") == \"\"\n\ndef test_reverse_string_single_char():\n    assert reverse_string(\"a\") == \"a\"\n\ndef test_reverse_string_whitespace():\n    assert reverse_string(\"   \") == \"   \"\n\ndef test_reverse_string_with_punctuation():\n    assert reverse_string(\"hello, world!\") == \"!dlrow ,olleh\"\n\ndef test_reverse_string_special_chars():\n    assert reverse_string(\"!@#\") == \"#@!\"",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def reverse_string(s):\n    \"\"\"\n    Reverses the given string `s` without using extra space.\n    \n    Args:\n    s (str): The string to be reversed.\n\n    Returns:\n    str: The reversed string.\n    \"\"\"\n    return s[::-1]",
        "test_code": "from solution import reverse_string\n\ndef test_reverse_string_empty():\n    assert reverse_string(\"\") == \"\"\n\ndef test_reverse_string_single_char():\n    assert reverse_string(\"a\") == \"a\"\n\ndef test_reverse_string_regular():\n    assert reverse_string(\"hello\") == \"olleh\"\n\ndef test_reverse_string_with_spaces():\n    assert reverse_string(\"hello world\") == \"dlrow olleh\"\n\ndef test_reverse_string_special_chars():\n    assert reverse_string(\"!!hello!!\") == \"!!olleh!!\"\n    assert reverse_string(\"!hello-123! nguy\u00ean!\") == \"!nghi\u00ean grievances-321 olleh!\"",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def reverse_string(s):\n    \"\"\"\n    Reverses the given string without using extra space.\n    \n    :param s: The input string to be reversed\n    :return: The reversed string\n    \"\"\"\n    # Convert string to list of characters since strings are immutable in Python\n    str_list = list(s)\n    start, end = 0, len(str_list) - 1\n    while start < end:\n        # Swap characters at start and end positions\n        str_list[start], str_list[end] = str_list[end], str_list[start]\n        start += 1\n        end -= 1\n    # Convert list of characters back to string\n    return ''.join(str_list)",
        "test_code": "from solution import reverse_string\n\ndef test_reverse_string_empty():\n    assert reverse_string(\"\") == \"\"\n\ndef test_reverse_string_single_char():\n    assert reverse_string(\"a\") == \"a\"\n\ndef test_reverse_string_normal():\n    assert reverse_string(\"hello\") == \"olleh\"\n\ndef test_reverse_string_with_spaces():\n    assert reverse_string(\"hello world\") == \"dlrow olleh\"\n\ndef test_reverse_string_special_chars():\n    assert reverse_string(\"!@#$%^&*()\") == \")(*&^%$#@!\"",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def reverse_string(s):\n    \"\"\"\n    Reverses the given string s without using extra space.\n    \"\"\"\n    s = list(s)  # Convert string to list to allow in-place modification\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]  # Swap characters\n        left, right = left + 1, right - 1\n    return ''.join(s)  # Convert list back to string",
        "test_code": "from solution import reverse_string\n\ndef test_reverse_string_positive():\n    assert reverse_string(\"hello\") == \"olleh\"\n\ndef test_reverse_string_empty():\n    assert reverse_string(\"\") == \"\"\n\ndef test_reverse_string_single_char():\n    assert reverse_string(\"a\") == \"a\"\n\ndef test_reverse_string_whitespace():\n    assert reverse_string(\"   \") == \"   \"\n\ndef test_reverse_string_with_punctuation():\n    assert reverse_string(\"hello, world!\") == \"!dlrow ,olleh\"\n\ndef test_reverse_string_special_chars():\n    assert reverse_string(\"!@#\") == \"#@!\"",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000159",
      "row_id": 159,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to filter out all even numbers from a list, which also handles both positive and negative integers.",
    "response": "def filter_even_numbers(numbers):\n    \"\"\"\n    Returns a new list containing only the odd numbers from the input list.\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]",
    "test_code": "from solution import filter_even_numbers\n\ndef test_filter_even_numbers_empty_list():\n    assert filter_even_numbers([]) == []\n\ndef test_filter_even_numbers_all_even():\n    assert filter_even_numbers([2, -4, 0, 6]) == []\n\ndef test_filter_even_numbers_all_odd():\n    assert filter_even_numbers([-1, 3, 5, 7]) == [-1, 3, 5, 7]\n\ndef test_filter_even_numbers_mixed():\n    assert filter_even_numbers([-2, -1, 0, 1, 2, 3]) == [-1, 1, 3]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def filter_even_numbers(numbers):\n    \"\"\"\n    Returns a new list containing only the odd numbers from the input list.\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]",
        "test_code": "from solution import filter_even_numbers\n\ndef test_filter_even_numbers_empty_list():\n    assert filter_even_numbers([]) == []\n\ndef test_filter_even_numbers_all_even():\n    assert filter_even_numbers([2, -4, 0, 6]) == []\n\ndef test_filter_even_numbers_all_odd():\n    assert filter_even_numbers([-1, 3, 5, 7]) == [-1, 3, 5, 7]\n\ndef test_filter_even_numbers_mixed():\n    assert filter_even_numbers([-2, -1, 0, 1, 2, 3]) == [-1, 1, 3]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      }
    },
    "pass_sequence": [
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000162",
      "row_id": 162,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to parse and extract specific data from XML using `xml.etree.ElementTree`",
    "response": "import xml.etree.ElementTree as ET\n\ndef extract_data_from_xml(xml_string, tag_name):\n    \"\"\"\n    Parses the provided XML string and extracts the text content of the first occurrence of the specified tag.\n\n    :param xml_string: The XML data as a string.\n    :param tag_name: The name of the tag to extract the text from.\n    :return: The text content of the first <tag_name> element or None if not found.\n    \"\"\"\n    root = ET.fromstring(xml_string)\n    tag = root.find(tag_name)\n    if tag is not None:\n        return tag.text\n    return None",
    "test_code": "import xml.etree.ElementTree as ET\nfrom solution import extract_data_from_xml\n\ndef test_extract_data_from_xml():\n    xml_string = '<root><data>extract this</data><ignore>other text</ignore></root>'\n    assert extract_data_from_xml(xml_string, 'data') == 'extract this'\n\ndef test_extract_nonexistent_tag():\n    xml_string = '<root><data>extract this</data><ignore>other text</ignore></root>'\n    assert extract_data_from_xml(xml_string, 'nonexistent') is None\n\ndef test_multiple_elements_same_tag():\n    xml_string = '<root><data>text1</data><data>text2</data></root>'\n    assert extract_data_from_xml(xml_string, 'data') == 'text1'  # Only the first one is extracted\n\ndef test_empty_xml():\n    xml_string = '<root></root>'\n    assert extract_data_from_xml(xml_string, 'data') is None",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "import xml.etree.ElementTree as ET\n\ndef extract_data_from_xml(xml_string, tag_name):\n    \"\"\"\n    Parses the XML string and extracts the text content of elements with the specified tag name.\n    \n    :param xml_string: The XML content as a string.\n    :param tag_name: The tag name of the elements to extract.\n    :return: A list of text contents of the found elements.\n    \"\"\"\n    root = ET.fromstring(xml_string)\n    extracted_data = [element.text for element in root.findall(tag_name)]\n    return extracted_data",
        "test_code": "import xml.etree.ElementTree as ET\nfrom solution import extract_data_from_xml\n\ndef test_extract_data_from_xml():\n    test_xml = '''\n    <root>\n        <data>First Data</data>\n        <data>Second Data</data>\n    </root>\n    '''\n    expected_output = ['First Data', 'Second Data']\n    assert extract_data_from_xml(test_xml, 'data') == expected_output\n\ndef test_extract_empty_xml():\n    test_xml = ''\n    expected_output = []\n    assert extract_data_from_xml(test_xml, 'data') == expected_output\n\ndef test_extract_no_matching_tag():\n    test_xml = '''\n    <root>\n        <info>Some Info</info>\n    </root>\n    '''\n    expected_output = []\n    assert extract_data_from_xml(test_xml, 'data') == expected_output\n\ndef test_extract_with_whitespace():\n    test_xml = '''\n    <root>\n        <data>\\n\\tFirst Data\\n</data>\n        <data>\\nSecond Data\\n</data>\n    </root>\n    '''\n    expected_output = ['First Data', 'Second Data']\n    assert extract_data_from_xml(test_xml, 'data') == expected_output\n\ndef test_extract_empty_tag():\n    test_xml = '''\n    <root>\n        <data></data>\n        <data>Empty Data</data>\n    </root>\n    '''\n    expected_output = ['Empty Data']\n    assert extract_data_from_xml(test_xml, 'data') == expected_output",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "import xml.etree.ElementTree as ET\n\ndef extract_data_from_xml(xml_string, tag_name):\n    \"\"\"\n    Parses the provided XML string and extracts the text content of the first occurrence of the specified tag.\n\n    :param xml_string: The XML data as a string.\n    :param tag_name: The name of the tag to extract the text from.\n    :return: The text content of the first <tag_name> element or None if not found.\n    \"\"\"\n    root = ET.fromstring(xml_string)\n    tag = root.find(tag_name)\n    if tag is not None:\n        return tag.text\n    return None",
        "test_code": "import xml.etree.ElementTree as ET\nfrom solution import extract_data_from_xml\n\ndef test_extract_data_from_xml():\n    xml_string = '<root><data>extract this</data><ignore>other text</ignore></root>'\n    assert extract_data_from_xml(xml_string, 'data') == 'extract this'\n\ndef test_extract_nonexistent_tag():\n    xml_string = '<root><data>extract this</data><ignore>other text</ignore></root>'\n    assert extract_data_from_xml(xml_string, 'nonexistent') is None\n\ndef test_multiple_elements_same_tag():\n    xml_string = '<root><data>text1</data><data>text2</data></root>'\n    assert extract_data_from_xml(xml_string, 'data') == 'text1'  # Only the first one is extracted\n\ndef test_empty_xml():\n    xml_string = '<root></root>'\n    assert extract_data_from_xml(xml_string, 'data') is None",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "import xml.etree.ElementTree as ET\n\ndef extract_data_from_xml(xml_string, tag_name):\n    \"\"\"\n    Parses the provided XML string and extracts the text associated with the specified tag.\n    \n    Args:\n        xml_string (str): The XML data as a string.\n        tag_name (str): The tag name whose value is to be extracted.\n    \n    Returns:\n        list: A list of text values for the specified tag. Returns an empty list if the tag is not found.\n    \"\"\"\n    root = ET.fromstring(xml_string)\n    return [node.text for node in root.iter(tag_name)]",
        "test_code": "import xml.etree.ElementTree as ET\nfrom solution import extract_data_from_xml\n\ndef test_extract_data_from_xml():\n    xml_data = '''<data>\n                    <country name=\"Liechtenstein\">\n                        < Ranking >2</ Ranking >\n                        <year>2008</ year>\n                        <gdppc>141100</ gdppc>\n                    </country>\n                    <country name=\"Singapore\">\n                        < Ranking >4</ Ranking >\n                        <year>2011</ year>\n                        <gdppc>59900</ gdppc>\n                    </country>\n                </data>'''\n    expected_output = ['2', '4']\n    assert extract_data_from_xml(xml_data, ' Ranking ') == expected_output\n\ndef test_extract_nonexistent_tag():\n    xml_data = '''<data>\n                    <country name=\"Liechtenstein\">\n                        < Ranking >2</ Ranking >\n                        <year>2008</ year>\n                        <gdppc>141100</ gdppc>\n                    </country>\n                    <country name=\"Singapore\">\n                        < Ranking >4</ Ranking >\n                        <year>2011</ year>\n                        <gdppc>59900</ gdppc>\n                    </country>\n                </data>'''\n    expected_output = []\n    assert extract_data_from_xml(xml_data, 'nonexistent_tag') == expected_output\n\ndef test_extract_data_with_whitespace():\n    xml_data = '''<data>\n                    <country name=\"Liechtenstein\">\n                        < Ranking >  2  </ Ranking >\n                    </country>\n                </data>'''\n    expected_output = ['  2  ']\n    assert extract_data_from_xml(xml_data, ' Ranking ') == expected_output\n\ndef test_empty_xml():\n    xml_data = '<empty></empty>'\n    expected_output = []\n    assert extract_data_from_xml(xml_data, 'nonexistent_tag') == expected_output",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000168",
      "row_id": 168,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the sum of the first `n` natural numbers.",
    "response": "def sum_of_n_natural_numbers(n):\n    \"\"\"\n    Returns the sum of the first n natural numbers.\n    \"\"\"\n    return n * (n + 1) // 2",
    "test_code": "def test_sum_of_n_natural_numbers():\n    assert sum_of_n_natural_numbers(1) == 1\n    assert sum_of_n_natural_numbers(2) == 3\n    assert sum_of_n_natural_numbers(3) == 6\n    assert sum_of_n_natural_numbers(10) == 55\n    assert sum_of_n_natural_numbers(100) == 5050\n    assert sum_of_n_natural_numbers(0) == 0",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def sum_of_natural_numbers(n):\n    \"\"\"\n    Returns the sum of the first n natural numbers.\n    \n    Args:\n    n (int): The number of initial natural numbers to sum.\n    \n    Returns:\n    int: The sum of the first n natural numbers.\n    \"\"\"\n    return n * (n + 1) // 2",
        "test_code": "from solution import sum_of_natural_numbers\n\ndef test_sum_of_natural_numbers_with_1():\n    assert sum_of_natural_numbers(1) == 1\n\ndef test_sum_of_natural_numbers_with_5():\n    assert sum_of_natural_numbers(5) == 15\n\ndef test_sum_of_natural_numbers_with_10():\n    assert sum_of_natural_numbers(10) == 55\n\ndef test_sum_of_natural_numbers_with_0():\n    assert sum_of_natural_numbers(0) == 0\n\ndef test_sum_of_natural_numbers_with_negative_number():\n    assert sum_of_natural_numbers(-1) == 0",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def sum_of_naturals(n):\n    \"\"\"\n    Returns the sum of the first n natural numbers.\n    \"\"\"\n    return n * (n + 1) // 2",
        "test_code": "from solution import sum_of_naturals\n\ndef test_sum_of_naturals_positive_numbers():\n    assert sum_of_naturals(5) == 15\n\ndef test_sum_of_naturals_zero():\n    assert sum_of_naturals(0) == 0\n\ndef test_sum_of_naturals_one():\n    assert sum_of_naturals(1) == 1\n\ndef test_sum_of_naturals_large_number():\n    assert sum_of_naturals(100) == 5050",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def sum_of_n_natural_numbers(n):\n    \"\"\"\n    Returns the sum of the first n natural numbers.\n    \"\"\"\n    return n * (n + 1) // 2",
        "test_code": "def test_sum_of_n_natural_numbers():\n    assert sum_of_n_natural_numbers(1) == 1\n    assert sum_of_n_natural_numbers(2) == 3\n    assert sum_of_n_natural_numbers(3) == 6\n    assert sum_of_n_natural_numbers(10) == 55\n    assert sum_of_n_natural_numbers(100) == 5050\n    assert sum_of_n_natural_numbers(0) == 0",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000170",
      "row_id": 170,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to print the first nth Fibonacci numbers in the format `[F(1), F(2), F(3), ..., F(n)]`.",
    "response": "def fibonacci(n):\n    \"\"\"\n    Returns the first n Fibonacci numbers as a list.\n    \"\"\"\n    if n < 1:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    \n    fib_sequence = [0, 1]\n    for i in range(2, n):\n        next_fib = fib_sequence[-1] + fib_sequence[-2]\n        fib_sequence.append(next_fib)\n    \n    return fib_sequence",
    "test_code": "from solution import fibonacci\n\ndef test_fibonacci_positive():\n    assert fibonacci(5) == [0, 1, 1, 2, 3]\n\ndef test_fibonacci_single():\n    assert fibonacci(1) == [0]\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == [0, 1]\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == []\n\ndef test_fibonacci_negative():\n    assert fibonacci(-5) == []",
    "trials": {
      "trial_qwen2.5_1": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the first n Fibonacci numbers as a list.\n    \"\"\"\n    if n < 1:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    \n    fib_sequence = [0, 1]\n    for i in range(2, n):\n        next_fib = fib_sequence[-1] + fib_sequence[-2]\n        fib_sequence.append(next_fib)\n    \n    return fib_sequence",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_positive():\n    assert fibonacci(5) == [0, 1, 1, 2, 3]\n\ndef test_fibonacci_single():\n    assert fibonacci(1) == [0]\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == [0, 1]\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == []\n\ndef test_fibonacci_negative():\n    assert fibonacci(-5) == []",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000175",
      "row_id": 175,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the minimum number of deletions required to make a string a palindrome.",
    "response": "def min_deletions_to_palindrome(s: str) -> int:\n    \"\"\"\n    Returns the minimum number of deletions required to make a string a palindrome.\n    \"\"\"\n    n = len(s)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill dp table\n    for gap in range(1, n):\n        for i in range(n - gap):\n            j = i + gap\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1\n                \n    return dp[0][n - 1]",
    "test_code": "def test_min_deletions_to_palindrome():\n    assert min_deletions_to_palindrome(\"abc\") == 2\n    assert min_deletions_to_palindrome(\"abcba\") == 0\n    assert min_deletions_to_palindrome(\"abcd\") == 3\n    assert min_deletions_to_palindrome(\"aaa\") == 0\n    assert min_deletions_to_palindrome(\"abccba\") == 0\n    assert min_deletions_to_palindrome(\"ababc\") == 2\n    assert min_deletions_to_palindrome(\"aba\") == 0",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def min_deletions_to_palindrome(s: str) -> int:\n    \"\"\"\n    Returns the minimum number of deletions required to make a string a palindrome.\n    \"\"\"\n    n = len(s)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill dp table\n    for gap in range(1, n):\n        for i in range(n - gap):\n            j = i + gap\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1\n                \n    return dp[0][n - 1]",
        "test_code": "def test_min_deletions_to_palindrome():\n    assert min_deletions_to_palindrome(\"abc\") == 2\n    assert min_deletions_to_palindrome(\"abcba\") == 0\n    assert min_deletions_to_palindrome(\"abcd\") == 3\n    assert min_deletions_to_palindrome(\"aaa\") == 0\n    assert min_deletions_to_palindrome(\"abccba\") == 0\n    assert min_deletions_to_palindrome(\"ababc\") == 2\n    assert min_deletions_to_palindrome(\"aba\") == 0",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def min_deletions_to_palindrome(s):\n    \"\"\"\n    Returns the minimum number of deletions required to make the string a palindrome.\n    \"\"\"\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the dp table\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n    \n    return dp[0][n - 1]",
        "test_code": "def test_min_deletions_to_palindrome():\n    assert min_deletions_to_palindrome(\"abca\") == 1\n    assert min_deletions_to_palindrome(\"abcba\") == 0\n    assert min_deletions_to_palindrome(\"abcde\") == 4\n    assert min_deletions_to_palindrome(\"aaa\") == 0\n    assert min_deletions_to_palindrome(\"abccba\") == 0\n    assert min_deletions_to_palindrome(\"abcddcba\") == 1",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def min_deletions_to_palindrome(s):\n    \"\"\"\n    Returns the minimum number of deletions required to make the string a palindrome.\n    \"\"\"\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the dp table\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n    \n    return dp[0][n - 1]",
        "test_code": "from solution import min_deletions_to_palindrome\n\ndef test_min_deletions_to_palindrome():\n    assert min_deletions_to_palindrome(\"abdbca\") == 1\n    assert min_deletions_to_palindrome(\"cddpd\") == 2\n    assert min_deletions_to_palindrome(\"pqr\") == 2\n    assert min_deletions_to_palindrome(\"aaa\") == 0\n    assert min_deletions_to_palindrome(\"abc\") == 2\n    assert min_deletions_to_palindrome(\"abca\") == 1\n    assert min_deletions_to_palindrome(\"abcda\") == 1",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000176",
      "row_id": 176,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to sort an array using the Quick Sort algorithm.",
    "response": "def quick_sort(arr):\n    \"\"\"\n    Sorts an array using the Quick Sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        less_than_pivot = [x for x in arr[1:] if x <= pivot]\n        greater_than_pivot = [x for x in arr[1:] if x > pivot]\n        return quick_sort(less_than_pivot) + [pivot] + quick_sort(greater_than_pivot)",
    "test_code": "from solution import quick_sort\n\ndef test_quick_sort_empty_list():\n    assert quick_sort([]) == []\n\ndef test_quick_sort_single_element():\n    assert quick_sort([5]) == [5]\n\ndef test_quick_sort_positive_numbers():\n    arr = [3, 6, 8, 10, 1, 2, 1]\n    assert quick_sort(arr) == [1, 1, 2, 3, 6, 8, 10]\n\ndef test_quick_sort_negative_numbers():\n    arr = [-3, -6, -8, -10, -1, -2, -1]\n    assert quick_sort(arr) == [-10, -8, -6, -3, -2, -1, -1]\n\ndef test_quick_sort_mixed_sign_numbers():\n    arr = [3, -6, 8, -10, 1, -2, 1]\n    assert quick_sort(arr) == [-10, -6, -2, 1, 1, 3, 8]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def quick_sort(arr):\n    \"\"\"\n    Sorts an array using the Quick Sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        less = [x for x in arr[1:] if x <= pivot]\n        greater = [x for x in arr[1:] if x > pivot]\n        return quick_sort(less) + [pivot] + quick_sort(greater)",
        "test_code": "python\r\ndef test_quick_sort():\r\n    arr = [3, 6, 8, 10, 1, 2, 1]\r\n    sorted_arr = quick_sort(arr)\r\n    expected = [1, 1, 2, 3, 6, 8, 10]\r\n    assert sorted_arr == expected\r\n\r\ndef test_quick_sort_empty():\r\n    arr = []\r\n    sorted_arr = quick_sort(arr)\r\n    expected = []\r\n    assert sorted_arr == expected\r\n\r\ndef test_quick_sort_single_element():\r\n    arr = [5]\r\n    sorted_arr = quick_sort(arr)\r\n    expected = [5]\r\n    assert sorted_arr == expected\r\n\r\ndef test_quick_sort_negative_numbers():\r\n    arr = [3, -1, -12, 0, 15, 4]\r\n    sorted_arr = quick_sort(arr)\r\n    expected = [-12, -1, 0, 3, 4, 15]\r\n    assert sorted_arr == expected\r\n\r\ndef test_quick_sort_duplicate_elements():\r\n    arr = [4, 4, 4, 4, 4]\r\n    sorted_arr = quick_sort(arr)\r\n    expected = [4, 4, 4, 4, 4]\r\n    assert sorted_arr == expected\r\n\r\ndef test_quick_sort_already_sorted():\r\n    arr = [1, 2, 3, 4, 5]\r\n    sorted_arr = quick_sort(arr)\r\n    expected = [1, 2, 3, 4, 5]\r\n    assert sorted_arr == expected",
        "test_result": "Fail",
        "test_coverage": 14.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def quick_sort(arr):\n    \"\"\"\n    Sorts an array using the Quick Sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        less_than_pivot = [x for x in arr[1:] if x <= pivot]\n        greater_than_pivot = [x for x in arr[1:] if x > pivot]\n        return quick_sort(less_than_pivot) + [pivot] + quick_sort(greater_than_pivot)",
        "test_code": "from solution import quick_sort\n\ndef test_quick_sort_empty_list():\n    assert quick_sort([]) == []\n\ndef test_quick_sort_single_element():\n    assert quick_sort([5]) == [5]\n\ndef test_quick_sort_positive_numbers():\n    arr = [3, 6, 8, 10, 1, 2, 1]\n    assert quick_sort(arr) == [1, 1, 2, 3, 6, 8, 10]\n\ndef test_quick_sort_negative_numbers():\n    arr = [-3, -6, -8, -10, -1, -2, -1]\n    assert quick_sort(arr) == [-10, -8, -6, -3, -2, -1, -1]\n\ndef test_quick_sort_mixed_sign_numbers():\n    arr = [3, -6, 8, -10, 1, -2, 1]\n    assert quick_sort(arr) == [-10, -6, -2, 1, 1, 3, 8]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000177",
      "row_id": 177,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find all possible subsets of a set. You can return them as a list of lists.",
    "response": "def find_subsets(s: set):\n    \"\"\"\n    Returns all possible subsets of a given set s as a list of lists.\n    \"\"\"\n    subsets = [[]]\n    for elem in s:\n        # For each element in the set, create new subsets by adding the element to existing subsets.\n        new_subsets = [subset + [elem] for subset in subsets]\n        subsets.extend(new_subsets)\n    return subsets",
    "test_code": "from solution import find_subsets\n\ndef test_find_subsets_empty_set():\n    assert find_subsets(set()) == [[]]\n\ndef test_find_subsets_one_element():\n    assert find_subsets({1}) == [[], [1]]\n\ndef test_find_subsets_two_elements():\n    assert find_subsets({1, 2}) == [[], [1], [2], [1, 2]]\n\ndef test_find_subsets_three_elements():\n    assert find_subsets({1, 2, 3}) == [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n\ndef test_find_subsets_four_elements():\n    s = {1, 2, 3, 4}\n    subsets = find_subsets(s)\n    assert len(subsets) == 16  # 2^n where n is the number of elements in the set\n    assert set(map(tuple, subsets)) == set(map(tuple, [\n        [], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3],\n        [4], [1, 4], [2, 4], [1, 2, 4], [3, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]\n    ]))",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "from itertools import chain, combinations\n\ndef all_subsets(s):\n    \"\"\"\n    Returns a list of all possible subsets of the input set s.\n    \"\"\"\n    return list(chain.from_iterable(combinations(s, r) for r in range(len(s)+1)))",
        "test_code": "from solution import all_subsets\n\ndef test_all_subsets_empty_set():\n    assert all_subsets(set()) == [()]\n\ndef test_all_subsets_one_element():\n    assert all_subsets({1}) == [(), (1,)]\n\ndef test_all_subsets_two_elements():\n    assert all_subsets({1, 2}) == [(), (1,), (2,), (1, 2)]\n\ndef test_all_subsets_three_elements():\n    assert all_subsets({1, 2, 3}) == [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "from typing import List\n\ndef find_subsets(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Returns all possible subsets of the given list of numbers.\n    \"\"\"\n    subsets = [[]]\n    for num in nums:\n        subsets += [subset + [num] for subset in subsets]\n    return subsets",
        "test_code": "from solution import find_subsets\n\ndef test_find_subsets_empty():\n    assert find_subsets([]) == [[]]\n\ndef test_find_subsets_one_element():\n    assert find_subsets([1]) == [[], [1]]\n\ndef test_find_subsets_two_elements():\n    assert find_subsets([1, 2]) == [[], [1], [2], [1, 2]]\n\ndef test_find_subsets_three_elements():\n    assert find_subsets([1, 2, 3]) == [\n        [], \n        [1], \n        [2], \n        [1, 2], \n        [3], \n        [1, 3], \n        [2, 3], \n        [1, 2, 3]\n    ]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def find_subsets(s: set):\n    \"\"\"\n    Returns all possible subsets of a given set s as a list of lists.\n    \"\"\"\n    subsets = [[]]\n    for elem in s:\n        # For each element in the set, create new subsets by adding the element to existing subsets.\n        new_subsets = [subset + [elem] for subset in subsets]\n        subsets.extend(new_subsets)\n    return subsets",
        "test_code": "from solution import find_subsets\n\ndef test_find_subsets_empty_set():\n    assert find_subsets(set()) == [[]]\n\ndef test_find_subsets_one_element():\n    assert find_subsets({1}) == [[], [1]]\n\ndef test_find_subsets_two_elements():\n    assert find_subsets({1, 2}) == [[], [1], [2], [1, 2]]\n\ndef test_find_subsets_three_elements():\n    assert find_subsets({1, 2, 3}) == [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n\ndef test_find_subsets_four_elements():\n    s = {1, 2, 3, 4}\n    subsets = find_subsets(s)\n    assert len(subsets) == 16  # 2^n where n is the number of elements in the set\n    assert set(map(tuple, subsets)) == set(map(tuple, [\n        [], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3],\n        [4], [1, 4], [2, 4], [1, 2, 4], [3, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]\n    ]))",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000182",
      "row_id": 182,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to reverse a string. What are the concepts used here?",
    "response": "def reverse_string(s):\n    \"\"\"\n    Returns the reversed version of the input string s.\n    \"\"\"\n    return s[::-1]",
    "test_code": "def test_reverse_string():\n    assert reverse_string(\"hello\") == \"olleh\"\n    assert reverse_string(\"Python\") == \"nohtyP\"\n    assert reverse_string(\"\") == \"\"\n    assert reverse_string(\"a\") == \"a\"\n    assert reverse_string(\"12345\") == \"54321\"",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def reverse_string(s):\n    \"\"\"\n    Reverses the given string.\n    \"\"\"\n    return s[::-1]",
        "test_code": "from solution import reverse_string\n\ndef test_reverse_string_empty():\n    assert reverse_string(\"\") == \"\"\n\ndef test_reverse_string_single_char():\n    assert reverse_string(\"a\") == \"a\"\n\ndef test_reverse_string Normal():\n    assert reverse_string(\"hello\") == \"olleh\"\n\ndef test_reverse_string_with_spaces():\n    assert reverse_string(\"a b c\") == \"c b a\"\n\ndef test_reverse_string_special_chars():\n    assert reverse_string(\"!@#$%^&*()\") == \")(*&^%$#@!\"",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def reverse_string(s):\n    \"\"\"\n    Returns the reversed version of the input string s.\n    \"\"\"\n    return s[::-1]",
        "test_code": "def test_reverse_string():\n    assert reverse_string(\"hello\") == \"olleh\"\n    assert reverse_string(\"Python\") == \"nohtyP\"\n    assert reverse_string(\"\") == \"\"\n    assert reverse_string(\"a\") == \"a\"\n    assert reverse_string(\"12345\") == \"54321\"",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000183",
      "row_id": 183,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to sort a list of integers in ascending order using the quicksort algorithm. Each integer is in the range of [0, 100000].",
    "response": "def quicksort(arr):\n    \"\"\"\n    Sorts an array of integers in ascending order using the quicksort algorithm.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)",
    "test_code": "from solution import quicksort\n\ndef test_quicksort_empty_list():\n    assert quicksort([]) == []\n\ndef test_quicksort_single_element():\n    assert quicksort([5]) == [5]\n\ndef test_quicksort_sorted_list():\n    assert quicksort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_quicksort_reverse_sorted_list():\n    assert quicksort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n\ndef test_quicksort_random_list():\n    assert quicksort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\n\ndef test_quicksort_large_random_list():\n    import random\n    arr = [random.randint(0, 100000) for _ in range(1000)]\n    sorted_arr = sorted(arr)\n    assert quicksort(arr) == sorted_arr\n\ndef test_quicksort_with_duplicates():\n    assert quicksort([4, 2, 4, 8, 3, 2]) == [2, 2, 3, 4, 4, 8]",
    "trials": {
      "trial_qwen2.5_1": {
        "solution_code": "def quicksort(arr):\n    \"\"\"\n    Sorts an array of integers in ascending order using the quicksort algorithm.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)",
        "test_code": "from solution import quicksort\n\ndef test_quicksort_empty_list():\n    assert quicksort([]) == []\n\ndef test_quicksort_single_element():\n    assert quicksort([5]) == [5]\n\ndef test_quicksort_sorted_list():\n    assert quicksort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_quicksort_reverse_sorted_list():\n    assert quicksort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n\ndef test_quicksort_random_list():\n    assert quicksort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\n\ndef test_quicksort_large_random_list():\n    import random\n    arr = [random.randint(0, 100000) for _ in range(1000)]\n    sorted_arr = sorted(arr)\n    assert quicksort(arr) == sorted_arr\n\ndef test_quicksort_with_duplicates():\n    assert quicksort([4, 2, 4, 8, 3, 2]) == [2, 2, 3, 4, 4, 8]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      }
    },
    "pass_sequence": [
      1
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000184",
      "row_id": 184,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the smallest number that is a multiple of both given integers. To solve this, create a helper function to calculate the greatest common divisor (GCD) of two numbers and then use this helper function to find the least common multiple (LCM) of two numbers.",
    "response": "def gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two numbers using Euclid's algorithm.\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    \"\"\"\n    Returns the least common multiple (LCM) of two numbers.\n    \"\"\"\n    return abs(a * b) // gcd(a, b)",
    "test_code": "from solution import gcd, lcm\n\ndef test_gcd():\n    assert gcd(12, 18) == 6\n    assert gcd(7, 13) == 1\n    assert gcd(98, 56) == 14\n\ndef test_lcm():\n    assert lcm(12, 18) == 36\n    assert lcm(7, 13) == 91\n    assert lcm(98, 56) == 392\n\ndef test_lcm_with_gcd():\n    # LCM * GCD = |a*b|\n    a, b = 30, 45\n    assert lcm(a, b) * gcd(a, b) == abs(a * b)",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def gcd(a, b):\n    \"\"\"\n    Returns the greatest common divisor (GCD) of a and b using Euclid's algorithm.\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    \"\"\"\n    Returns the least common multiple (LCM) of a and b using the formula lcm(a, b) = abs(a*b) // gcd(a, b).\n    \"\"\"\n    return abs(a * b) // gcd(a, b)",
        "test_code": "from solution import gcd, lcm\n\ndef test_gcd():\n    assert gcd(3, 5) == 1\n    assert gcd(25, 15) == 5\n    assert gcd(100, 200) == 100\n\ndef test_lcm():\n    assert lcm(3, 5) == 15\n    assert lcm(25, 15) == 75\n    assert lcm(100, 200) == 200\n\ndef test_lcm_with_gcd():\n    assert lcm(2, 3) == 6  # LCM using gcd should match the direct calculation\n    assert lcm(12, 15) == 60\n    assert lcm(7, 14) == 14",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two numbers using Euclid's algorithm.\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    \"\"\"\n    Returns the least common multiple (LCM) of two numbers.\n    \"\"\"\n    return abs(a * b) // gcd(a, b)",
        "test_code": "from solution import gcd, lcm\n\ndef test_gcd():\n    assert gcd(12, 18) == 6\n    assert gcd(7, 13) == 1\n    assert gcd(98, 56) == 14\n\ndef test_lcm():\n    assert lcm(12, 18) == 36\n    assert lcm(7, 13) == 91\n    assert lcm(98, 56) == 392\n\ndef test_lcm_with_gcd():\n    # LCM * GCD = |a*b|\n    a, b = 30, 45\n    assert lcm(a, b) * gcd(a, b) == abs(a * b)",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def gcd(a, b):\n    \"\"\"\n    Returns the greatest common divisor of a and b using the Euclidean algorithm.\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    \"\"\"\n    Returns the least common multiple of a and b.\n    \"\"\"\n    return a * b // gcd(a, b)\n\ndef smallest_multiple(a, b):\n    \"\"\"\n    Returns the smallest number that is a multiple of both a and b.\n    \"\"\"\n    return lcm(a, b)",
        "test_code": "``\nfrom solution import gcd, lcm, smallest_multiple\n\ndef test_gcd():\n    assert gcd(8, 12) == 4\n    assert gcd(17, 13) == 1\n\ndef test_lcm():\n    assert lcm(8, 12) == 24\n    assert lcm(17, 13) == 221\n\ndef test_smallest_multiple():\n    assert smallest_multiple(10, 15) == 30\n    assert smallest_multiple(7, 5) == 35\n    assert smallest_multiple(21, 6) == 42\n    assert smallest_multiple(15, 17) == 255\n\ndef test_smallest_multiple_with_gcd():\n    assert smallest_multiple(10, 15) == lcm(10, 15)",
        "test_result": "Fail",
        "test_coverage": null,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      0
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000185",
      "row_id": 185,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to reverse a linked list using a stack data structure.",
    "response": "class ListNode:\n    \"\"\"Simple linked list node class.\"\"\"\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef reverse_linked_list(head):\n    \"\"\"\n    Reverses a linked list in-place using a stack to temporarily store nodes.\n    \n    :param head: ListNode, the head of the linked list to be reversed\n    :return: ListNode, the new head of the reversed linked list\n    \"\"\"\n    stack = []\n    current = head\n    while current:\n        stack.append(current)\n        current = current.next\n    \n    # If the list was empty, return None or the last node.\n    if not stack:\n        return None\n    \n    new_head = stack.pop()\n    current = new_head\n    while stack:\n        current.next = stack.pop()\n        current = current.next\n    current.next = None\n    \n    return new_head",
    "test_code": "from solution import ListNode, reverse_linked_list\n\ndef construct_linked_list(values):\n    \"\"\"Constructs a linked list from a list of values.\"\"\"\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for value in values[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\ndef to_list(node):\n    \"\"\"Converts a linked list to a list of values.\"\"\"\n    values = []\n    while node:\n        values.append(node.value)\n        node = node.next\n    return values\n\ndef test_reverse_linked_list():\n    # Test with a non-empty list\n    assert to_list(reverse_linked_list(construct_linked_list([1, 2, 3, 4]))) == [4, 3, 2, 1]\n\n    # Test with a single element\n    assert to_list(reverse_linked_list(construct_linked_list([5]))) == [5]\n\n    # Test with an empty list\n    assert to_list(reverse_linked_list(construct_linked_list([]))) == []\n\n    # Test with a negative number\n    assert to_list(reverse_linked_list(construct_linked_list([-5, 6, -7, 8]))) == [8, -7, 6, -5]\n\n    # Test with all negative numbers\n    assert to_list(reverse_linked_list(construct_linked_list([-1, -2, -3, -4]))) == [-4, -3, -2, -1]\n\n    # Test with repeated numbers\n    assert to_list(reverse_linked_list(construct_linked_list([1, 1, 1, 1]))) == [1, 1, 1, 1]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "class ListNode:\n    \"\"\"Simple linked list node class.\"\"\"\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef reverse_linked_list(head):\n    \"\"\"\n    Reverses a linked list in-place using a stack to temporarily store nodes.\n    \n    :param head: ListNode, the head of the linked list to be reversed\n    :return: ListNode, the new head of the reversed linked list\n    \"\"\"\n    stack = []\n    current = head\n    while current:\n        stack.append(current)\n        current = current.next\n    \n    # If the list was empty, return None or the last node.\n    if not stack:\n        return None\n    \n    new_head = stack.pop()\n    current = new_head\n    while stack:\n        current.next = stack.pop()\n        current = current.next\n    current.next = None\n    \n    return new_head",
        "test_code": "from solution import ListNode, reverse_linked_list\n\ndef construct_linked_list(values):\n    \"\"\"Constructs a linked list from a list of values.\"\"\"\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for value in values[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\ndef to_list(node):\n    \"\"\"Converts a linked list to a list of values.\"\"\"\n    values = []\n    while node:\n        values.append(node.value)\n        node = node.next\n    return values\n\ndef test_reverse_linked_list():\n    # Test with a non-empty list\n    assert to_list(reverse_linked_list(construct_linked_list([1, 2, 3, 4]))) == [4, 3, 2, 1]\n\n    # Test with a single element\n    assert to_list(reverse_linked_list(construct_linked_list([5]))) == [5]\n\n    # Test with an empty list\n    assert to_list(reverse_linked_list(construct_linked_list([]))) == []\n\n    # Test with a negative number\n    assert to_list(reverse_linked_list(construct_linked_list([-5, 6, -7, 8]))) == [8, -7, 6, -5]\n\n    # Test with all negative numbers\n    assert to_list(reverse_linked_list(construct_linked_list([-1, -2, -3, -4]))) == [-4, -3, -2, -1]\n\n    # Test with repeated numbers\n    assert to_list(reverse_linked_list(construct_linked_list([1, 1, 1, 1]))) == [1, 1, 1, 1]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "class ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef reverse_linked_list_with_stack(head):\n    \"\"\"\n    Reverses a linked list by using a stack data structure.\n    \"\"\"\n    if not head:\n        return None\n    \n    stack = []\n    current = head\n    # Push all elements of the linked list onto the stack\n    while current:\n        stack.append(current)\n        current = current.next\n    \n    if not stack:\n        return None\n    \n    # Pop elements from the stack to form the reversed linked list\n    new_head = stack.pop()\n    current = new_head\n    while stack:\n        current.next = stack.pop()\n        current = current.next\n    current.next = None\n    \n    return new_head",
        "test_code": "from solution import ListNode, reverse_linked_list_with_stack\n\ndef create_linked_list(elements):\n    if not elements:\n        return None\n    head = ListNode(elements[0])\n    current = head\n    for element in elements[1:]:\n        current.next = ListNode(element)\n        current = current.next\n    return head\n\ndef linked_list_to_list(head):\n    result = []\n    while head:\n        result.append(head.value)\n        head = head.next\n    return result\n\ndef test_reverse_linked_list_with_stack():\n    # Test with a simple linked list\n    head = create_linked_list([1, 2, 3, 4, 5])\n    reversed_head = reverse_linked_list_with_stack(head)\n    assert linked_list_to_list(reversed_head) == [5, 4, 3, 2, 1]\n    \n    # Test with an empty linked list\n    head = create_linked_list([])\n    assert linked_list_to_list(reverse_linked_list_with_stack(head)) == []\n    \n    # Test with a single element linked list\n    head = create_linked_list([1])\n    assert linked_list_to_list(reverse_linked_list_with_stack(head)) == [1]\n    \n    # Test with a reversed linked list\n    head = create_linked_list([5, 4, 3, 2, 1])\n    assert linked_list_to_list(reverse_linked_list_with_stack(head)) == [1, 2, 3, 4, 5]\n\ntest_reverse_linked_list_with_stack()",
        "test_result": "Pass",
        "test_coverage": 95.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "class ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef reverse_linked_list_with_stack(head):\n    \"\"\"\n    Reverses the given linked list using a stack data structure.\n    \"\"\"\n    if head is None:\n        return None\n    \n    stack = []\n    current = head\n    while current:\n        stack.append(current)\n        current = current.next\n    \n    if not stack:\n        return None\n    \n    new_head = stack.pop()\n    current = new_head\n    while stack:\n        current.next = stack.pop()\n        current = current.next\n    current.next = None\n    \n    return new_head",
        "test_code": "from solution import ListNode, reverse_linked_list_with_stack\nfrom typing import Optional\n\ndef create_linked_list(values):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for value in values[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\ndef to_list(head: Optional[ListNode]) -> list:\n    result = []\n    current = head\n    while current:\n        result.append(current.value)\n        current = current.next\n    return result\n\ndef test_reverse_linked_list_with_stack():\n    # Single element list\n    head = ListNode(1)\n    assert to_list(reverse_linked_list_with_stack(head)) == [1]\n    \n    # Empty list\n    head = None\n    assert reverse_linked_list_with_stack(head) is None\n    \n    # Multiple elements\n    head = create_linked_list([1, 2, 3, 4, 5])\n    assert to_list(reverse_linked_list_with_stack(head)) == [5, 4, 3, 2, 1]\n    \n    # Reversing a linked list with nodes having the same value\n    head = create_linked_list([1, 1, 1])\n    assert to_list(reverse_linked_list_with_stack(head)) == [1, 1, 1]\n    \n    # Reversing a linked list formed in a zigzag pattern\n    head = create_linked_list([1, 3, 2, 4, 5])\n    assert to_list(reverse_linked_list_with_stack(head)) == [5, 4, 2, 3, 1]",
        "test_result": "Pass",
        "test_coverage": 95.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000186",
      "row_id": 186,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to calculate the nth Fibonacci number using recursion.",
    "response": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number using recursion.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
    "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_one():\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == 1\n\ndef test_fibonacci_five():\n    assert fibonacci(5) == 5\n\ndef test_fibonacci_nine():\n    assert fibonacci(9) == 34\n\ndef test_fibonacci_negative():\n    assert fibonacci(-5) == 0",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number using recursion.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_one():\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == 1\n\ndef test_fibonacci_three():\n    assert fibonacci(3) == 2\n\ndef test_fibonacci_five():\n    assert fibonacci(5) == 5\n\ndef test_fibonacci_ten():\n    assert fibonacci(10) == 55",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number.\n    \n    Args:\n    n (int): The position in the Fibonacci sequence.\n    \n    Returns:\n    int: The nth Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) is None\n\ndef test_fibonacci_one():\n    assert fibonacci(1) == 0\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == 1\n\ndef test_fibonacci_three():\n    assert fibonacci(3) == 1\n\ndef test_fibonacci_four():\n    assert fibonacci(4) == 2\n\ndef test_fibonacci_five():\n    assert fibonacci(5) == 3\n\ndef test_fibonacci_six():\n    assert fibonacci(6) == 5\n\ndef test_fibonacci_large_number():\n    assert fibonacci(10) == 34\n\ndef test_fibonacci_invalid_input():\n    try:\n        fibonacci(-1)\n    except ValueError as e:\n        assert str(e) == \"n must be a positive integer\"\n    else:\n        assert False, \"ValueError was expected\"",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number using recursion.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_one():\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == 1\n\ndef test_fibonacci_five():\n    assert fibonacci(5) == 5\n\ndef test_fibonacci_nine():\n    assert fibonacci(9) == 34\n\ndef test_fibonacci_negative():\n    assert fibonacci(-5) == 0",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000188",
      "row_id": 188,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to check if a given number is a Fibonacci number or not.",
    "response": "def is_perfect_square(x):\n    s = int(x ** 0.5)\n    return s * s == x\n\ndef is_fibonacci_number(n):\n    \"\"\"\n    Returns True if n is a Fibonacci number, False otherwise.\n    \"\"\"\n    # A number is Fibonacci if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square\n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)",
    "test_code": "from solution import is_fibonacci_number, is_perfect_square\n\ndef test_is_perfect_square():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(9) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(17) == False\n\ndef test_is_fibonacci_number():\n    assert is_fibonacci_number(0) == True\n    assert is_fibonacci_number(1) == True\n    assert is_fibonacci_number(5) == True\n    assert is_fibonacci_number(8) == True\n    assert is_fibonacci_number(13) == True\n    assert is_fibonacci_number(21) == True\n    assert is_fibonacci_number(34) == True\n    assert is_fibonacci_number(55) == True\n    assert is_fibonacci_number(6) == False\n    assert is_fibonacci_number(-4) == False\n    assert is_fibonacci_number(20) == False",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def is_perfect_square(x):\n    s = int(x ** 0.5)\n    return s * s == x\n\ndef is_fibonacci_number(n):\n    \"\"\"\n    Returns True if n is a Fibonacci number, False otherwise.\n    \"\"\"\n    # A number is Fibonacci if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square\n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)",
        "test_code": "from solution import is_fibonacci_number, is_perfect_square\n\ndef test_is_perfect_square():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(9) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(17) == False\n\ndef test_is_fibonacci_number():\n    assert is_fibonacci_number(0) == True\n    assert is_fibonacci_number(1) == True\n    assert is_fibonacci_number(5) == True\n    assert is_fibonacci_number(8) == True\n    assert is_fibonacci_number(13) == True\n    assert is_fibonacci_number(21) == True\n    assert is_fibonacci_number(34) == True\n    assert is_fibonacci_number(55) == True\n    assert is_fibonacci_number(6) == False\n    assert is_fibonacci_number(-4) == False\n    assert is_fibonacci_number(20) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def is_fibonacci(n):\n    \"\"\"\n    Returns True if n is a Fibonacci number, False otherwise.\n    \"\"\"\n    # A number is a Fibonacci only if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square\n    import math\n    \n    def is_perfect_square(x):\n        s = int(math.sqrt(x))\n        return s * s == x\n    \n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)",
        "test_code": "from solution import is_fibonacci\n\ndef test_is_fibonacci_0():\n    assert is_fibonacci(0) == True\n\ndef test_is_fibonacci_1():\n    assert is_fibonacci(1) == True\n\ndef test_is_fibonacci_8():\n    assert is_fibonacci(8) == True\n\ndef test_is_fibonacci_13():\n    assert is_fibonacci(13) == True\n\ndef test_is_fibonacci_34():\n    assert is_fibonacci(34) == True\n\ndef test_is_fibonacci_9():\n    assert is_fibonacci(9) == False\n\ndef test_is_fibonacci_25():\n    assert is_fibonacci(25) == False\n\ndef test_is_fibonacci_55():\n    assert is_fibonacci(55) == True\n\ndef test_is_fibonacci_89():\n    assert is_fibonacci(89) == True\n\ndef test_is_fibonacci_144():\n    assert is_fibonacci(144) == True\n\ndef test_is_fibonacci_145():\n    assert is_fibonacci(145) == False\n\ndef test_is_fibonacci_negative():\n    assert is_fibonacci(-1) == False",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_fibonacci(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a Fibonacci number.\n    \n    A number is Fibonacci if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square.\n    \"\"\"\n    def is_perfect_square(x: int) -> bool:\n        s = int(x**0.5)\n        return s*s == x\n    \n    return is_perfect_square(5*num**2 + 4) or is_perfect_square(5*num**2 - 4)",
        "test_code": "from solution import is_fibonacci\n\ndef test_is_fibonacci_small_numbers():\n    assert is_fibonacci(0) == True\n    assert is_fibonacci(1) == True\n    assert is_fibonacci(8) == True\n    assert is_fibonacci(13) == True\n\ndef test_is_fibonacci_large_numbers():\n    assert is_fibonacci(144) == True\n    assert is_fibonacci(233) == True\n    assert is_fibonacci(89) == True\n    assert is_fibonacci(377) == True\n\ndef test_is_fibonacci_non_fibonacci_numbers():\n    assert is_fibonacci(2) == False\n    assert is_fibonacci(4) == False\n    assert is_fibonacci(7) == False\n    assert is_fibonacci(10) == False",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000189",
      "row_id": 189,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to determine if a number is a \"perfect square\" number. A \"perfect square\" number is an integer that is the square of an integer. For example, 16 is a perfect square because it is 4 squared.",
    "response": "def is_perfect_square(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect square.\n    \n    Args:\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    root = int(num ** 0.5)\n    return root * root == num",
    "test_code": "from solution import is_perfect_square\n\ndef test_perfect_squares():\n    assert is_perfect_square(1) is True  # 1 = 1^2\n    assert is_perfect_square(4) is True  # 4 = 2^2\n    assert is_perfect_square(9) is True  # 9 = 3^2\n    assert is_perfect_square(16) is True # 16 = 4^2\n    assert is_perfect_square(25) is True # 25 = 5^2\n\ndef test_non_perfect_squares():\n    assert is_perfect_square(2) is False  # No integer square root\n    assert is_perfect_square(3) is False  # No integer square root\n    assert is_perfect_square(5) is False  # No integer square root\n    assert is_perfect_square(7) is False  # No integer square root\n    assert is_perfect_square(8) is False  # No integer square root\n\ndef test_zero_and_negative_numbers():\n    assert is_perfect_square(0) is True  # 0 = 0^2\n    assert is_perfect_square(-4) is False # Negative numbers cannot be perfect squares",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "import math\n\ndef is_perfect_square(n):\n    \"\"\"\n    Returns True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return n == root * root",
        "test_code": "from solution import is_perfect_square\n\ndef test_perfect_squares():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n\ndef test_non_perfect_squares():\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(3) == False\n    assert is_perfect_square(5) == False\n    assert is_perfect_square(17) == False\n\ndef test_zero():\n    assert is_perfect_square(0) == True\n\ndef test_negative_numbers():\n    assert is_perfect_square(-1) == False\n    assert is_perfect_square(-4) == False\n    assert is_perfect_square(-16) == False",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "import math\n\ndef is_perfect_square(n):\n    \"\"\"\n    Checks if a given number n is a perfect square.\n    \n    A perfect square is an integer that is the square of an integer.\n    \"\"\"\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return n == root * root",
        "test_code": "import unittest\n\ndef is_perfect_square(n):\n    \"\"\"Checks if a given number n is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return n == root * root\n\ndef test_is_perfect_square_positive_numbers():\n    assert is_perfect_square(1) == True\n    assert is_perfect_square(4) == True\n    assert is_perfect_square(16) == True\n    assert is_perfect_square(25) == True\n\ndef test_is_perfect_square_zero():\n    assert is_perfect_square(0) == True\n\ndef test_is_perfect_square_negative_numbers():\n    assert is_perfect_square(-1) == False\n    assert is_perfect_square(-16) == False\n\ndef test_is_perfect_square_non_perfect_squares():\n    assert is_perfect_square(2) == False\n    assert is_perfect_square(5) == False\n    assert is_perfect_square(10) == False\n    assert is_perfect_square(15) == False\n\ndef test_is_perfect_square_large_numbers():\n    assert is_perfect_square(1681) == True\n    assert is_perfect_square(676) == True\n    assert is_perfect_square(315186841) == True\n\nif __name__ == \"__main__\":\n    unittest.main()",
        "test_result": "Fail",
        "test_coverage": 33.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def is_perfect_square(num: int) -> bool:\n    \"\"\"\n    Checks if the given number is a perfect square.\n    \n    Args:\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    root = int(num ** 0.5)\n    return root * root == num",
        "test_code": "from solution import is_perfect_square\n\ndef test_perfect_squares():\n    assert is_perfect_square(1) is True  # 1 = 1^2\n    assert is_perfect_square(4) is True  # 4 = 2^2\n    assert is_perfect_square(9) is True  # 9 = 3^2\n    assert is_perfect_square(16) is True # 16 = 4^2\n    assert is_perfect_square(25) is True # 25 = 5^2\n\ndef test_non_perfect_squares():\n    assert is_perfect_square(2) is False  # No integer square root\n    assert is_perfect_square(3) is False  # No integer square root\n    assert is_perfect_square(5) is False  # No integer square root\n    assert is_perfect_square(7) is False  # No integer square root\n    assert is_perfect_square(8) is False  # No integer square root\n\ndef test_zero_and_negative_numbers():\n    assert is_perfect_square(0) is True  # 0 = 0^2\n    assert is_perfect_square(-4) is False # Negative numbers cannot be perfect squares",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000190",
      "row_id": 190,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to reverse a linked list in place.",
    "response": "class ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef reverse_linked_list(head):\n    \"\"\"\n    Reverses a linked list in place.\n    \n    :param head: ListNode, the head of the linked list to be reversed.\n    :return: ListNode, the new head of the reversed linked list.\n    \"\"\"\n    prev = None\n    current = head\n    while current:\n        next_node = current.next  # Store the next node\n        current.next = prev       # Reverse the current node's pointer\n        prev = current            # Move pointers one position forward\n        current = next_node\n    return prev",
    "test_code": "from solution import ListNode, reverse_linked_list\n\ndef create_linked_list(values):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for value in values[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\ndef linked_list_to_list(head):\n    result = []\n    current = head\n    while current:\n        result.append(current.value)\n        current = current.next\n    return result\n\ndef test_reverse_linked_list():\n    assert linked_list_to_list(reverse_linked_list(None)) == []\n    assert linked_list_to_list(reverse_linked_list(create_linked_list([1]))) == [1]\n    assert linked_list_to_list(reverse_linked_list(create_linked_list([1, 2, 3, 4, 5]))) == [5, 4, 3, 2, 1]\n    assert linked_list_to_list(reverse_linked_list(create_linked_list([1, 2]))) == [2, 1]",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "class ListNode:\n    \"\"\"Simple linked list node class.\"\"\"\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef reverse_linked_list(head):\n    \"\"\"\n    Reverses a linked list in place and returns the new head.\n    \n    :param head: ListNode\n        The head node of the linked list to be reversed.\n    :return: ListNode\n        The new head node of the reversed linked list.\n    \"\"\"\n    prev = None\n    current = head\n    while current:\n        next_node = current.next  # Store next node\n        current.next = prev       # Reverse the current node's pointer\n        prev = current            # Move prev and current one step forward\n        current = next_node\n    return prev",
        "test_code": "from solution import ListNode, reverse_linked_list\n\ndef test_reverse_linked_list():\n    # Create a linked list 1 -> 2 -> 3\n    node3 = ListNode(3)\n    node2 = ListNode(2, node3)\n    node1 = ListNode(1, node2)\n    \n    # Reverse it to 3 -> 2 -> 1\n    reversed_head = reverse_linked_list(node1)\n    assert reversed_head.value == 3\n    \n    # Check the next nodes\n    assert reversed_head.next.value == 2\n    assert reversed_head.next.next.value == 1\n    \ndef test_reverse_empty_list():\n    # Reverse an empty list, should return None\n    assert reverse_linked_list(None) is None\n\ndef test_reverse_single_node():\n    # Reverse a single node list, should return the same node\n    node = ListNode(4)\n    assert reverse_linked_list(node).value == 4",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "class ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef reverse_linked_list(head):\n    \"\"\"\n    Reverses a linked list in place.\n    \n    Args:\n    head (ListNode): The head node of the linked list.\n    \n    Returns:\n    ListNode: The new head of the reversed linked list.\n    \"\"\"\n    prev = None\n    current = head\n    while current:\n        next_node = current.next  # Store the next node\n        current.next = prev       # Reverse the link\n        prev = current            # Move prev and current one step forward\n        current = next_node\n    return prev",
        "test_code": "from solution import ListNode, reverse_linked_list\n\ndef create_linked_list(values):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for value in values[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\ndef linked_list_to_list(head):\n    values = []\n    current = head\n    while current:\n        values.append(current.value)\n        current = current.next\n    return values\n\ndef test_reverse_linked_list():\n    assert linked_list_to_list(reverse_linked_list(None)) == []\n    assert linked_list_to_list(reverse_linked_list(create_linked_list([1]))) == [1]\n    assert linked_list_to_list(reverse_linked_list(create_linked_list([1, 2, 3, 4, 5]))) == [5, 4, 3, 2, 1]\n    assert linked_list_to_list(reverse_linked_list(create_linked_list([1, 3, 5, 7, 9]))) == [9, 7, 5, 3, 1]\n\nimport pytest\n@pytest.mark.parametrize(\"values, expected\", [\n    ([], []),\n    ([1], [1]),\n    ([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]),\n    ([1, 3, 5, 7, 9], [9, 7, 5, 3, 1])\n])\ndef test_reverse_linked_list_parametrized(values, expected):\n    head = create_linked_list(values)\n    reversed_head = reverse_linked_list(head)\n    assert linked_list_to_list(reversed_head) == expected",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "class ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef reverse_linked_list(head):\n    \"\"\"\n    Reverses a linked list in place.\n    \n    :param head: ListNode, the head of the linked list to be reversed.\n    :return: ListNode, the new head of the reversed linked list.\n    \"\"\"\n    prev = None\n    current = head\n    while current:\n        next_node = current.next  # Store the next node\n        current.next = prev       # Reverse the current node's pointer\n        prev = current            # Move pointers one position forward\n        current = next_node\n    return prev",
        "test_code": "from solution import ListNode, reverse_linked_list\n\ndef create_linked_list(values):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for value in values[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\ndef linked_list_to_list(head):\n    result = []\n    current = head\n    while current:\n        result.append(current.value)\n        current = current.next\n    return result\n\ndef test_reverse_linked_list():\n    assert linked_list_to_list(reverse_linked_list(None)) == []\n    assert linked_list_to_list(reverse_linked_list(create_linked_list([1]))) == [1]\n    assert linked_list_to_list(reverse_linked_list(create_linked_list([1, 2, 3, 4, 5]))) == [5, 4, 3, 2, 1]\n    assert linked_list_to_list(reverse_linked_list(create_linked_list([1, 2]))) == [2, 1]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000191",
      "row_id": 191,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the first repeating character in a string. If no character is repeating, return -1. For example, in the string \"programming\", the first repeating character is 'r'.",
    "response": "def first_repeating_char(s):\n    \"\"\"\n    Finds and returns the first repeating character in the given string.\n    If no character repeats, returns -1.\n    \"\"\"\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return -1",
    "test_code": "def test_first_repeating_char():\n    assert first_repeating_char(\"programming\") == 'r'\n    assert first_repeating_char(\"abcdef\") == -1\n    assert first_repeating_char(\"aabbccddeeff\") == 'a'\n    assert first_repeating_char(\"abccba\") == 'c'\n    assert first_repeating_char(\"xyz\") == -1\n    assert first_repeating_char(\"\") == -1\n    assert first_repeating_char(\"aa\") == 'a'\n\ndef test_first_repeating_char_with_numbers():\n    assert first_repeating_char(\"12341\") == '1'\n    assert first_repeating_char(\"78907\") == '7'\n    assert first_repeating_char(\"123\") == -1",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def first_repeating_char(s):\n    \"\"\"\n    Finds and returns the first repeating character in the given string.\n    If no character repeats, returns -1.\n    \"\"\"\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return -1",
        "test_code": "def test_first_repeating_char():\n    assert first_repeating_char(\"programming\") == 'r'\n    assert first_repeating_char(\"abcdef\") == -1\n    assert first_repeating_char(\"aabbccddeeff\") == 'a'\n    assert first_repeating_char(\"abccba\") == 'c'\n    assert first_repeating_char(\"xyz\") == -1\n    assert first_repeating_char(\"\") == -1\n    assert first_repeating_char(\"aa\") == 'a'\n\ndef test_first_repeating_char_with_numbers():\n    assert first_repeating_char(\"12341\") == '1'\n    assert first_repeating_char(\"78907\") == '7'\n    assert first_repeating_char(\"123\") == -1",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def first_repeating_char(s: str) -> int:\n    \"\"\"\n    Finds the first repeating character in the string `s` and returns its index.\n    If no character is repeating, returns -1.\n    \"\"\"\n    seen = set()\n    for i, char in enumerate(s):\n        if char in seen:\n            return i\n        seen.add(char)\n    return -1",
        "test_code": "import pytest\n\ndef test_first_repeating_char():\n    assert first_repeating_char(\"programming\") == 2\n    assert first_repeating_char(\"abcdef\") == -1\n    assert first_repeating_char(\"aabbcc\") == 1\n    assert first_repeating_char(\"ababab\") == 1\n    assert first_repeating_char(\"aa\") == 1\n    assert first_repeating_char(\"\") == -1",
        "test_result": "Fail",
        "test_coverage": 86.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def first_repeating_char(s: str) -> int:\n    \"\"\"\n    Finds the first repeating character in the string `s`.\n    If no character is repeating, returns -1.\n    \"\"\"\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return -1",
        "test_code": "from solution import first_repeating_char\n\ndef test_first_repeating_char():\n    assert first_repeating_char(\"programming\") == 'r'\n    assert first_repeating_char(\"python\") == -1\n    assert first_repeating_char(\"abacabad\") == 'a'\n    assert first_repeating_char(\"xyz\") == -1\n    assert first_repeating_char(\"aAAbcCddEe\") == 'a'",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_0",
    "metadata": {
      "prompt_id": "00000192",
      "row_id": 192,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to convert a given string to a list of integers, where each integer is the ASCII value of each character in the string.",
    "response": "def string_to_ascii_list(input_string):\n    \"\"\"\n    Converts a given string to a list of integers, where each integer is the ASCII value of each character in the string.\n    \"\"\"\n    return [ord(char) for char in input_string]",
    "test_code": "def test_string_to_ascii_list():\n    assert string_to_ascii_list(\"AB\") == [65, 66]\n    assert string_to_ascii_list(\"Hello\") == [72, 101, 108, 108, 111]\n    assert string_to_ascii_list(\"\") == []\n    assert string_to_ascii_list(\"123\") == [49, 50, 51]\n\ndef test_empty_string():\n    assert string_to_ascii_list(\"\") == []\n\ndef test_string_with_spaces():\n    assert string_to_ascii_list(\"Hello World!\") == [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]",
    "trials": {
      "trial_qwen2.5_1": {
        "solution_code": "def string_to_ascii_list(input_string):\n    \"\"\"\n    Converts a given string to a list of integers, where each integer is the ASCII value of each character in the string.\n    \"\"\"\n    return [ord(char) for char in input_string]",
        "test_code": "def test_string_to_ascii_list():\n    assert string_to_ascii_list(\"AB\") == [65, 66]\n    assert string_to_ascii_list(\"Hello\") == [72, 101, 108, 108, 111]\n    assert string_to_ascii_list(\"\") == []\n    assert string_to_ascii_list(\"123\") == [49, 50, 51]\n\ndef test_empty_string():\n    assert string_to_ascii_list(\"\") == []\n\ndef test_string_with_spaces():\n    assert string_to_ascii_list(\"Hello World!\") == [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def string_to_ascii_list(input_string):\n    \"\"\"\n    Converts the given string into a list of ASCII values of each character.\n    \n    :param input_string: String to be converted\n    :return: List of ASCII values\n    \"\"\"\n    return [ord(char) for char in input_string]",
        "test_code": "import string_to_ascii_list\n\ndef test_string_to_ascii_list_empty_string():\n    assert string_to_ascii_list.string_to_ascii_list(\"\") == []\n\ndef test_string_to_ascii_list_single_character():\n    assert string_to_ascii_list.string_to_ascii_list(\"a\") == [97]\n\ndef test_string_to_ascii_list_multiple_characters():\n    assert string_to_ascii_list.string_to_ascii_list(\"hello\") == [104, 101, 108, 108, 111]\n\ndef test_string_to_ascii_list_with_spaces():\n    assert string_to_ascii_list.string_to_ascii_list(\"hello world\") == [104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]",
        "test_result": "Fail",
        "test_coverage": 50.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000194",
      "row_id": 194,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to convert a binary tree to its mirror. The function should take a single parameter, which is the root of the binary tree.",
    "response": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef mirror_tree(root):\n    \"\"\"\n    Returns the mirror image of the given binary tree.\n    \"\"\"\n    if root is not None:\n        root.left, root.right = mirror_tree(root.right), mirror_tree(root.left)\n    return root",
    "test_code": "import pytest\nfrom solution import mirror_tree, TreeNode\n\ndef test_mirror_tree_simple():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    mirrored_root = mirror_tree(root)\n    assert mirrored_root.left.val == 3\n    assert mirrored_root.right.val == 2\n\ndef test_mirror_tree_complex():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    mirrored_root = mirror_tree(root)\n    assert mirrored_root.left.val == 3\n    assert mirrored_root.right.val == 2\n    assert mirrored_root.right.left.val == 5\n    assert mirrored_root.right.right.val == 4\n\ndef test_mirror_tree_single_node():\n    root = TreeNode(1)\n    mirrored_root = mirror_tree(root)\n    assert mirrored_root == root\n\ndef test_mirror_tree_empty():\n    mirrored_root = mirror_tree(None)\n    assert mirrored_root is None",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "class TreeNode:\n    \"\"\"Simple Binary Tree Node class.\"\"\"\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef mirror_tree(node):\n    \"\"\"\n    Converts a binary tree into its mirror tree.\n    :param node: TreeNode, the root of the binary tree.\n    :return: TreeNode, the root of the mirror tree.\n    \"\"\"\n    if node is None:\n        return None\n    # Swap the left and right children\n    node.left, node.right = node.right, node.left\n    # Recursively apply to the left and right children\n    mirror_tree(node.left)\n    mirror_tree(node.right)\n    return node",
        "test_code": "from solution import TreeNode, mirror_tree\n\ndef test_mirror_tree():\n    # Construct a simple tree\n    #       1\n    #      / \\\n    #     2   3\n    #    / \\   \\\n    #   4   5   6\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.right = TreeNode(6)\n    \n    # Expected output after mirroring\n    #       1\n    #      / \\\n    #     3   2\n    #        / \\\n    #       6   4\n    #          /\n    #         5\n    mirrored_root = mirror_tree(root)\n    \n    assert mirrored_root.left.value == 3\n    assert mirrored_root.right.left.value == 6\n    assert mirrored_root.right.right.value == 4\n    assert mirrored_root.right.right.right.value == 5",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef mirror_tree(root):\n    \"\"\"\n    Returns the mirror image of the given binary tree.\n    \"\"\"\n    if root is not None:\n        root.left, root.right = mirror_tree(root.right), mirror_tree(root.left)\n    return root",
        "test_code": "import pytest\nfrom solution import mirror_tree, TreeNode\n\ndef test_mirror_tree_simple():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    mirrored_root = mirror_tree(root)\n    assert mirrored_root.left.val == 3\n    assert mirrored_root.right.val == 2\n\ndef test_mirror_tree_complex():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    mirrored_root = mirror_tree(root)\n    assert mirrored_root.left.val == 3\n    assert mirrored_root.right.val == 2\n    assert mirrored_root.right.left.val == 5\n    assert mirrored_root.right.right.val == 4\n\ndef test_mirror_tree_single_node():\n    root = TreeNode(1)\n    mirrored_root = mirror_tree(root)\n    assert mirrored_root == root\n\ndef test_mirror_tree_empty():\n    mirrored_root = mirror_tree(None)\n    assert mirrored_root is None",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.key = key\n\n    def insert(self, key):\n        if self.key:\n            if key < self.key:\n                if self.left is None:\n                    self.left = TreeNode(key)\n                else:\n                    self.left.insert(key)\n            elif key > self.key:\n                if self.right is None:\n                    self.right = TreeNode(key)\n                else:\n                    self.right.insert(key)\n        else:\n            self.key = key\n\n\ndef mirror_tree(root):\n    \"\"\"\n    Returns the mirror image of a binary tree by swapping the left and right children of every node.\n    \"\"\"\n    if root is not None:\n        # Swap the left and right children\n        root.left, root.right = root.right, root.left\n        # Recursively call the function for the left subtree\n        mirror_tree(root.left)\n        # Recursively call the function for the right subtree\n        mirror_tree(root.right)",
        "test_code": "import pytest\nfrom solution import TreeNode, mirror_tree\n\n# Helper function to create a binary tree from pre-order traversal\ndef create_tree(preorder):\n    root = None\n    for value in preorder:\n        if root is None:\n            root = TreeNode(value)\n        else:\n            root.insert(value)\n    return root\n\n# Helper function to get the in-order traversal of a tree\ndef inorder_traversal(root):\n    if root is None:\n        return []\n    return inorder_traversal(root.left) + [root.key] + inorder_traversal(root.right)\n\ndef test_mirror_tree_simple():\n    preorder = [1, 2, 4, 5, 3, 6, 7]\n    root = create_tree(preorder)\n    mirrored_root = mirror_tree(root)\n    expected_inorder = [4, 2, 5, 1, 6, 3, 7]\n    assert inorder_traversal(mirrored_root) == expected_inorder\n\ndef test_mirror_tree_empty_tree():\n    root = None\n    mirrored_root = mirror_tree(root)\n    assert mirrored_root is None\n\ndef test_mirror_tree_single_node():\n    root = TreeNode(1)\n    mirrored_root = mirror_tree(root)\n    assert mirrored_root.key == 1 and mirrored_root.left is None and mirrored_root.right is None\n\ndef test_mirror_tree_complex():\n    preorder = [10, 20, 15, 30, 35, 40]\n    root = create_tree(preorder)\n    mirrored_root = mirror_tree(root)\n    expected_inorder = [15, 30, 35, 20, 40, 10]\n    assert inorder_traversal(mirrored_root) == expected_inorder",
        "test_result": "Fail",
        "test_coverage": 90.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      0
    ],
    "pass_trial_num": 1,
    "chosen_trial": "trial_qwen2.5_1",
    "metadata": {
      "prompt_id": "00000195",
      "row_id": 195,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to calculate the nth Fibonacci number. The function should recursively call itself to find the result.",
    "response": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number using recursion.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
    "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_one():\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == 1\n\ndef test_fibonacci_five():\n    assert fibonacci(5) == 5\n\ndef test_fibonacci_nine():\n    assert fibonacci(9) == 34\n\ndef test_fibonacci_negative():\n    assert fibonacci(-5) == 0",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number using recursion.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_one():\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == 1\n\ndef test_fibonacci_three():\n    assert fibonacci(3) == 2\n\ndef test_fibonacci_five():\n    assert fibonacci(5) == 5\n\ndef test_fibonacci_ten():\n    assert fibonacci(10) == 55",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number.\n    \n    The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it.\n    Starting with 0 and 1, the sequence goes 0, 1, 1, 2, 3, 5, 8, 13, and so forth.\n    \n    Args:\n    n (int): The position in the Fibonacci sequence.\n    \n    Returns:\n    int: The nth Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_one():\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == 1\n\ndef test_fibonacci_five():\n    assert fibonacci(5) == 5\n\ndef test_fibonacci_twelve():\n    assert fibonacci(12) == 144",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def fibonacci(n):\n    \"\"\"\n    Returns the nth Fibonacci number using recursion.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
        "test_code": "from solution import fibonacci\n\ndef test_fibonacci_zero():\n    assert fibonacci(0) == 0\n\ndef test_fibonacci_one():\n    assert fibonacci(1) == 1\n\ndef test_fibonacci_two():\n    assert fibonacci(2) == 1\n\ndef test_fibonacci_five():\n    assert fibonacci(5) == 5\n\ndef test_fibonacci_nine():\n    assert fibonacci(9) == 34\n\ndef test_fibonacci_negative():\n    assert fibonacci(-5) == 0",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      1,
      1,
      1
    ],
    "pass_trial_num": 3,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000197",
      "row_id": 197,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  },
  {
    "instruction": "Write a python function to find the longest substring without repeating characters in a string.",
    "response": "def length_of_longest_substring(s: str) -> int:\n    \"\"\"\n    Finds the length of the longest substring without repeating characters.\n    \"\"\"\n    char_index_map = {}\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        if s[right] in char_index_map:\n            left = max(left, char_index_map[s[right]] + 1)\n        char_index_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length",
    "test_code": "from solution import length_of_longest_substring\n\ndef test_length_of_longest_substring_empty_string():\n    assert length_of_longest_substring(\"\") == 0\n\ndef test_length_of_longest_substring_single_character():\n    assert length_of_longest_substring(\"a\") == 1\n\ndef test_length_of_longest_substring_all_unique_characters():\n    assert length_of_longest_substring(\"abcdefg\") == 7\n\ndef test_length_of_longest_substring_with_repeating_characters():\n    assert length_of_longest_substring(\"abcabcbb\") == 3\n    assert length_of_longest_substring(\"bbbbb\") == 1\n    assert length_of_longest_substring(\"pwwkew\") == 3\n    assert length_of_longest_substring(\"abba\") == 2\n    assert length_of_longest_substring(\"tmmzuxt\") == 5\n\ndef test_length_of_longest_substring_with_similar_characters():\n    assert length_of_longest_substring(\"dvdf\") == 3",
    "trials": {
      "trial_qwen2.5_0": {
        "solution_code": "def longest_substring_without_repeating(s: str) -> str:\n    \"\"\"\n    Finds the longest substring without repeating characters in a given string.\n    \"\"\"\n    if not s:\n        return \"\"\n\n    start = 0\n    max_length = 0\n    max_substring = \"\"\n    used_chars = {}\n\n    for i, char in enumerate(s):\n        if char in used_chars and start <= used_chars[char]:\n            start = used_chars[char] + 1\n        else:\n            if (i - start + 1) > max_length:\n                max_length = i - start + 1\n                max_substring = s[start:i+1]\n\n        used_chars[char] = i\n\n    return max_substring",
        "test_code": "from solution import longest_substring_without_repeating\n\ndef test_longest_substring_with_empty_string():\n    assert longest_substring_without_repeating(\"\") == \"\"\n\ndef test_longest_substring_single_character():\n    assert longest_substring_without_repeating(\"a\") == \"a\"\n\ndef test_longest_substring_no_repeating_characters():\n    assert longest_substring_without_repeating(\"abcd\") == \"abcd\"\n\ndef test_longest_substring_repeating_characters():\n    assert longest_substring_without_repeating(\"abcabcbb\") == \"abc\"\n    assert longest_substring_without_repeating(\"bbbbb\") == \"b\"\n    assert longest_substring_without_repeating(\"pwwkew\") == \"wke\"\n\ndef test_longest_substring_with_spaces():\n    assert longest_substring_without_repeating(\" \") == \" \"\n    assert longest_substring_without_repeating(\"a a\") == \" a\"\n    assert longest_substring_without_repeating(\"a b a\") == \" b\"",
        "test_result": "Fail",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results0.jsonl"
      },
      "trial_qwen2.5_1": {
        "solution_code": "def length_of_longest_substring(s: str) -> int:\n    \"\"\"\n    Returns the length of the longest substring without repeating characters.\n    \"\"\"\n    char_index_map = {}\n    left = 0\n    max_length = 0\n\n    for right in range(len(s)):\n        if s[right] in char_index_map:\n            left = max(left, char_index_map[s[right]] + 1)\n        char_index_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n\n    return max_length",
        "test_code": "from solution import length_of_longest_substring\n\ndef test_length_of_longest_substring_empty_string():\n    assert length_of_longest_substring(\"\") == 0\n\ndef test_length_of_longest_substring_single_character():\n    assert length_of_longest_substring(\"a\") == 1\n\ndef test_length_of_longest_substring_without_repeating_characters():\n    assert length_of_longest_substring(\"abcabcbb\") == 3\n    assert length_of_longest_substring(\"bbbbb\") == 1\n    assert length_of_longest_substring(\"pwwkew\") == 3\n\ndef test_length_of_longest_substring_with_repeating_characters():\n    assert length_of_longest_substring(\"dvdf\") == 3\n    assert length_of_longest_substring(\"abba\") == 2\n    assert length_of_longest_substring(\"tmmzuxt\") == 5",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
      },
      "trial_qwen2.5_2": {
        "solution_code": "def length_of_longest_substring(s: str) -> int:\n    \"\"\"\n    Finds the length of the longest substring without repeating characters.\n    \"\"\"\n    char_index_map = {}\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        if s[right] in char_index_map:\n            left = max(left, char_index_map[s[right]] + 1)\n        char_index_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length",
        "test_code": "from solution import length_of_longest_substring\n\ndef test_length_of_longest_substring_empty_string():\n    assert length_of_longest_substring(\"\") == 0\n\ndef test_length_of_longest_substring_single_character():\n    assert length_of_longest_substring(\"a\") == 1\n\ndef test_length_of_longest_substring_all_unique_characters():\n    assert length_of_longest_substring(\"abcdefg\") == 7\n\ndef test_length_of_longest_substring_with_repeating_characters():\n    assert length_of_longest_substring(\"abcabcbb\") == 3\n    assert length_of_longest_substring(\"bbbbb\") == 1\n    assert length_of_longest_substring(\"pwwkew\") == 3\n    assert length_of_longest_substring(\"abba\") == 2\n    assert length_of_longest_substring(\"tmmzuxt\") == 5\n\ndef test_length_of_longest_substring_with_similar_characters():\n    assert length_of_longest_substring(\"dvdf\") == 3",
        "test_result": "Pass",
        "test_coverage": 100.0,
        "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results2.jsonl"
      }
    },
    "pass_sequence": [
      0,
      1,
      1
    ],
    "pass_trial_num": 2,
    "chosen_trial": "trial_qwen2.5_2",
    "metadata": {
      "prompt_id": "00000199",
      "row_id": 199,
      "seed_ids": [
        0
      ],
      "mode": "prefill"
    }
  }
]