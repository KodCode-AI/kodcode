{
  "metadata": {
    "prompt_id": "00000127",
    "row_id": 127,
    "seed_ids": [
      0
    ],
    "mode": "prefill"
  },
  "instruction": "Write a python function to evaluate the value of the input infix expression. The function should take a single string argument representing the infix expression and return the corresponding value. The expression may contain integers, the operators `+`, `-`, `*`, and `/`, and parentheses `()`.",
  "solution_code": "import operator\nimport re\n\ndef evaluate_infix_expression(expression):\n    \"\"\"\n    Evaluates the given infix expression and returns the result.\n    Supports integers, +, -, *, /, and parentheses.\n    \"\"\"\n    def precedence(op):\n        if op in (\"+\", \"-\"):\n            return 1\n        if op in (\"*\", \"/\"):\n            return 2\n        return 0\n    \n    def apply_operator(operands, operators):\n        op = operators.pop()\n        right = operands.pop()\n        left = operands.pop()\n        operands.append(eval(f\"{left} {op} {right}\"))\n    \n    def evaluate(expression):\n        operands = []\n        operators = []\n        i = 0\n        while i < len(expression):\n            if expression[i].isdigit():\n                start = i\n                while i < len(expression) and expression[i].isdigit():\n                    i += 1\n                operands.append(int(expression[start:i]))\n                i -= 1\n            elif expression[i] in \"+-*/\":\n                while (operators and operators[-1] != \"(\" and\n                       precedence(operators[-1]) >= precedence(expression[i])):\n                    apply_operator(operands, operators)\n                operators.append(expression[i])\n            elif expression[i] == \"(\":\n                operators.append(expression[i])\n            elif expression[i] == \")\":\n                while operators[-1] != \"(\":\n                    apply_operator(operands, operators)\n                operators.pop()  # Remove '(' from operators\n            i += 1\n        \n        while operators:\n            apply_operator(operands, operators)\n        \n        return operands[0]\n    \n    expression = re.sub(r'\\s+', '', expression)\n    return evaluate(expression)\n\n# Predefined operations\nops = {\n    '+': operator.add,\n    '-': operator.sub,\n    '*': operator.mul,\n    '/': operator.truediv\n}\nfor op in ops:\n    setattr(evaluate_infix_expression, op, ops[op])",
  "test_code": "from solution import evaluate_infix_expression\n\ndef test_simple_addition():\n    assert evaluate_infix_expression(\"2 + 3\") == 5\n\ndef test_simple_subtraction():\n    assert evaluate_infix_expression(\"5 - 3\") == 2\n\ndef test_simple_multiplication():\n    assert evaluate_infix_expression(\"4 * 5\") == 20\n\ndef test_simple_division():\n    assert evaluate_infix_expression(\"8 / 2\") == 4\n\ndef test_precedence_addition_subtraction():\n    assert evaluate_infix_expression(\"2 + 3 - 1\") == 4\n\ndef test_precedence_multiplication_division():\n    assert evaluate_infix_expression(\"2 * 3 / 2\") == 3\n\ndef test_precedence_mixed_operations():\n    assert evaluate_infix_expression(\"2 + 3 * 4 - 6 / 3\") == 10\n\ndef test_parentheses_evaluation():\n    assert evaluate_infix_expression(\"(2 + 3) * 4\") == 20\n\ndef test_negative_numbers():\n    assert evaluate_infix_expression(\"-2 + 3 * 4\") == 10\n\ndef test_complex_expression():\n    assert evaluate_infix_expression(\"10 + 2 * (3 + 4) - 5 / (2 + 1)\") == 20",
  "file_source": "KodCode_prefill_200_1741214325_sanitized_prepared_results1.jsonl"
}