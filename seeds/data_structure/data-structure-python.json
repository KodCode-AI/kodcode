[
  {
    "id": 0,
    "category": "queues",
    "file_name": "moving_average",
    "codes": "from __future__ import division\nfrom collections import deque\n\n\nclass MovingAverage(object):\n    def __init__(self, size):\n        \"\"\"\n        Initialize your data structure here.\n        :type size: int\n        \"\"\"\n        self.queue = deque(maxlen=size)\n\n    def next(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: float\n        \"\"\"\n        self.queue.append(val)\n        return sum(self.queue) / len(self.queue)\n\n\n# Given a stream of integers and a window size,\n# calculate the moving average of all integers in the sliding window.\nif __name__ == '__main__':\n    m = MovingAverage(3)\n    assert m.next(1) == 1\n    assert m.next(10) == (1 + 10) / 2\n    assert m.next(3) == (1 + 10 + 3) / 3\n    assert m.next(5) == (10 + 3 + 5) / 3\n"
  },
  {
    "id": 1,
    "category": "queues",
    "file_name": "reconstruct_queue",
    "codes": "# Suppose you have a random list of people standing in a queue.\n# Each person is described by a pair of integers (h, k),\n# where h is the height of the person and k is the number of people\n# in front of this person who have a height greater than or equal to h.\n# Write an algorithm to reconstruct the queue.\n\n# Note:\n# The number of people is less than 1,100.\n\n# Example\n\n# Input:\n# [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\n\n# Output:\n# [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\n\ndef reconstruct_queue(people):\n    \"\"\"\n    :type people: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n    for h, k in people:\n        queue.insert(k, [h, k])\n    return queue\n"
  },
  {
    "id": 2,
    "category": "queues",
    "file_name": "queue",
    "codes": "\"\"\"\nQueue Abstract Data Type (ADT)\n* Queue() creates a new queue that is empty.\n  It needs no parameters and returns an empty queue.\n* enqueue(item) adds a new item to the rear of the queue.\n  It needs the item and returns nothing.\n* dequeue() removes the front item from the queue.\n  It needs no parameters and returns the item. The queue is modified.\n* isEmpty() tests to see whether the queue is empty.\n  It needs no parameters and returns a boolean value.\n* size() returns the number of items in the queue.\n  It needs no parameters and returns an integer.\n* peek() returns the front element of the queue.\n\"\"\"\nfrom abc import ABCMeta, abstractmethod\n\n\nclass AbstractQueue(metaclass=ABCMeta):\n\n    def __init__(self):\n        self._size = 0\n\n    def __len__(self):\n        return self._size\n\n    def is_empty(self):\n        return self._size == 0\n\n    @abstractmethod\n    def enqueue(self, value):\n        pass\n\n    @abstractmethod\n    def dequeue(self):\n        pass\n\n    @abstractmethod\n    def peek(self):\n        pass\n\n    @abstractmethod\n    def __iter__(self):\n        pass\n\n\nclass ArrayQueue(AbstractQueue):\n\n    def __init__(self, capacity=10):\n        \"\"\"\n        Initialize python List with capacity of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        super().__init__()\n        self._array = [None] * capacity\n        self._front = 0\n        self._rear = 0\n\n    def __iter__(self):\n        probe = self._front\n        while True:\n            if probe == self._rear:\n                return\n            yield self._array[probe]\n            probe += 1\n\n    def enqueue(self, value):\n        if self._rear == len(self._array):\n            self._expand()\n        self._array[self._rear] = value\n        self._rear += 1\n        self._size += 1\n\n    def dequeue(self):\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        value = self._array[self._front]\n        self._array[self._front] = None\n        self._front += 1\n        self._size -= 1\n        return value\n\n    def peek(self):\n        \"\"\"returns the front element of queue.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        return self._array[self._front]\n\n    def _expand(self):\n        \"\"\"expands size of the array.\n         Time Complexity: O(n)\n        \"\"\"\n        self._array += [None] * len(self._array)\n\n\nclass QueueNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\nclass LinkedListQueue(AbstractQueue):\n\n    def __init__(self):\n        super().__init__()\n        self._front = None\n        self._rear = None\n\n    def __iter__(self):\n        probe = self._front\n        while True:\n            if probe is None:\n                return\n            yield probe.value\n            probe = probe.next\n\n    def enqueue(self, value):\n        node = QueueNode(value)\n        if self._front is None:\n            self._front = node\n            self._rear = node\n        else:\n            self._rear.next = node\n            self._rear = node\n        self._size += 1\n\n    def dequeue(self):\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        value = self._front.value\n        if self._front is self._rear:\n            self._front = None\n            self._rear = None\n        else:\n            self._front = self._front.next\n        self._size -= 1\n        return value\n\n    def peek(self):\n        \"\"\"returns the front element of queue.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        return self._front.value\n"
  },
  {
    "id": 3,
    "category": "queues",
    "file_name": "max_sliding_window",
    "codes": "\"\"\"\nGiven an array and a number k\nFind the max elements of each of its sub-arrays of length k.\n\nKeep indexes of good candidates in deque d.\nThe indexes in d are from the current window, they're increasing,\nand their corresponding nums are decreasing.\nThen the first deque element is the index of the largest window value.\n\nFor each index i:\n\n1. Pop (from the end) indexes of smaller elements (they'll be useless).\n2. Append the current index.\n3. Pop (from the front) the index i - k, if it's still in the deque\n   (it falls out of the window).\n4. If our window has reached size k,\n   append the current window maximum to the output.\n\"\"\"\n\nimport collections\n\n\ndef max_sliding_window(arr, k):\n    qi = collections.deque()  # queue storing indexes of elements\n    result = []\n    for i, n in enumerate(arr):\n        while qi and arr[qi[-1]] < n:\n            qi.pop()\n        qi.append(i)\n        if qi[0] == i - k:\n            qi.popleft()\n        if i >= k - 1:\n            result.append(arr[qi[0]])\n    return result\n"
  },
  {
    "id": 4,
    "category": "queues",
    "file_name": "zigzagiterator",
    "codes": "class ZigZagIterator:\n    def __init__(self, v1, v2):\n        \"\"\"\n        Initialize your data structure here.\n        :type v1: List[int]\n        :type v2: List[int]\n        \"\"\"\n        self.queue = [_ for _ in (v1, v2) if _]\n        print(self.queue)\n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        v = self.queue.pop(0)\n        ret = v.pop(0)\n        if v:\n            self.queue.append(v)\n        return ret\n\n    def has_next(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if self.queue:\n            return True\n        return False\n\n\nl1 = [1, 2]\nl2 = [3, 4, 5, 6]\nit = ZigZagIterator(l1, l2)\nwhile it.has_next():\n    print(it.next())\n"
  },
  {
    "id": 5,
    "category": "queues",
    "file_name": "priority_queue",
    "codes": "\"\"\"\nImplementation of priority queue using linear array.\nInsertion - O(n)\nExtract min/max Node - O(1)\n\"\"\"\nimport itertools\n\n\nclass PriorityQueueNode:\n    def __init__(self, data, priority):\n        self.data = data\n        self.priority = priority\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.data, self.priority)\n\n\nclass PriorityQueue:\n    def __init__(self, items=None, priorities=None):\n        \"\"\"Create a priority queue with items (list or iterable).\n        If items is not passed, create empty priority queue.\"\"\"\n        self.priority_queue_list = []\n        if items is None:\n            return\n        if priorities is None:\n            priorities = itertools.repeat(None)\n        for item, priority in zip(items, priorities):\n            self.push(item, priority=priority)\n\n    def __repr__(self):\n        return \"PriorityQueue({!r})\".format(self.priority_queue_list)\n\n    def size(self):\n        \"\"\"Return size of the priority queue.\n        \"\"\"\n        return len(self.priority_queue_list)\n\n    def push(self, item, priority=None):\n        \"\"\"Push the item in the priority queue.\n        if priority is not given, priority is set to the value of item.\n        \"\"\"\n        priority = item if priority is None else priority\n        node = PriorityQueueNode(item, priority)\n        for index, current in enumerate(self.priority_queue_list):\n            if current.priority < node.priority:\n                self.priority_queue_list.insert(index, node)\n                return\n        # when traversed complete queue\n        self.priority_queue_list.append(node)\n\n    def pop(self):\n        \"\"\"Remove and return the item with the lowest priority.\n        \"\"\"\n        # remove and return the first node from the queue\n        return self.priority_queue_list.pop().data\n"
  },
  {
    "id": 6,
    "category": "sort",
    "file_name": "bubble_sort",
    "codes": "\"\"\"\n\nhttps://en.wikipedia.org/wiki/Bubble_sort\n\nWorst-case performance: O(N^2)\n\nIf you call bubble_sort(arr,True), you can see the process of the sort\nDefault is simulation = False\n\n\"\"\"\n\n\ndef bubble_sort(arr, simulation=False):\n    def swap(i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n\n    n = len(arr)\n    swapped = True\n    \n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n    x = -1\n    while swapped:\n        swapped = False\n        x = x + 1\n        for i in range(1, n-x):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n                if simulation:\n                    iteration = iteration + 1\n                    print(\"iteration\",iteration,\":\",*arr)\n                    \n    return arr\n"
  },
  {
    "id": 7,
    "category": "sort",
    "file_name": "insertion_sort",
    "codes": "def insertion_sort(arr, simulation=False):\n    \"\"\" Insertion Sort\n        Complexity: O(n^2)\n    \"\"\"\n    \n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n        \n    for i in range(len(arr)):\n        cursor = arr[i]\n        pos = i\n        \n        while pos > 0 and arr[pos - 1] > cursor:\n            # Swap the number down the list\n            arr[pos] = arr[pos - 1]\n            pos = pos - 1\n        # Break and do the final swap\n        arr[pos] = cursor\n        \n        if simulation:\n                iteration = iteration + 1\n                print(\"iteration\",iteration,\":\",*arr)\n\n    return arr\n"
  },
  {
    "id": 8,
    "category": "sort",
    "file_name": "heap_sort",
    "codes": "def max_heap_sort(arr, simulation=False):\n    \"\"\" Heap Sort that uses a max heap to sort an array in ascending order\n        Complexity: O(n log(n))\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n        \n    for i in range(len(arr) - 1, 0, -1):\n        iteration = max_heapify(arr, i, simulation, iteration)\n\n    if simulation:\n                iteration = iteration + 1\n                print(\"iteration\",iteration,\":\",*arr)\n    return arr\n\n\ndef max_heapify(arr, end, simulation, iteration):\n    \"\"\" Max heapify helper for max_heap_sort\n    \"\"\"\n    last_parent = (end - 1) // 2\n\n    # Iterate from last parent to first\n    for parent in range(last_parent, -1, -1):\n        current_parent = parent\n\n        # Iterate from current_parent to last_parent\n        while current_parent <= last_parent:\n            # Find greatest child of current_parent\n            child = 2 * current_parent + 1\n            if child + 1 <= end and arr[child] < arr[child + 1]:\n                child = child + 1\n\n            # Swap if child is greater than parent\n            if arr[child] > arr[current_parent]:\n                arr[current_parent], arr[child] = arr[child], arr[current_parent]\n                current_parent = child\n                if simulation:\n                    iteration = iteration + 1\n                    print(\"iteration\",iteration,\":\",*arr)\n            # If no swap occurred, no need to keep iterating\n            else:\n                break\n    arr[0], arr[end] = arr[end], arr[0]\n    return iteration\n\ndef min_heap_sort(arr, simulation=False):\n    \"\"\" Heap Sort that uses a min heap to sort an array in ascending order\n        Complexity: O(n log(n))\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n        \n    for i in range(0, len(arr) - 1):\n        iteration = min_heapify(arr, i, simulation, iteration)\n\n    return arr\n\n\ndef min_heapify(arr, start, simulation, iteration):\n    \"\"\" Min heapify helper for min_heap_sort\n    \"\"\"\n    # Offset last_parent by the start (last_parent calculated as if start index was 0)\n    # All array accesses need to be offset by start\n    end = len(arr) - 1\n    last_parent = (end - start - 1) // 2\n\n    # Iterate from last parent to first\n    for parent in range(last_parent, -1, -1):\n        current_parent = parent\n\n        # Iterate from current_parent to last_parent\n        while current_parent <= last_parent:\n            # Find lesser child of current_parent\n            child = 2 * current_parent + 1\n            if child + 1 <= end - start and arr[child + start] > arr[\n                child + 1 + start]:\n                child = child + 1\n            \n            # Swap if child is less than parent\n            if arr[child + start] < arr[current_parent + start]:\n                arr[current_parent + start], arr[child + start] = \\\n                    arr[child + start], arr[current_parent + start]\n                current_parent = child\n                if simulation:\n                    iteration = iteration + 1\n                    print(\"iteration\",iteration,\":\",*arr)\n            # If no swap occurred, no need to keep iterating\n            else:\n                break\n    return iteration\n"
  },
  {
    "id": 9,
    "category": "sort",
    "file_name": "pancake_sort",
    "codes": "def pancake_sort(arr):\n    \"\"\"\n    Pancake_sort\n    Sorting a given array\n    mutation of selection sort\n\n    reference: https://www.geeksforgeeks.org/pancake-sorting/\n    \n    Overall time complexity : O(N^2)\n    \"\"\"\n\n    len_arr = len(arr)\n    if len_arr <= 1:\n        return arr\n    for cur in range(len(arr), 1, -1):\n        #Finding index of maximum number in arr\n        index_max = arr.index(max(arr[0:cur]))\n        if index_max+1 != cur:\n            #Needs moving\n            if index_max != 0:\n                #reverse from 0 to index_max\n                arr[:index_max+1] = reversed(arr[:index_max+1])\n            # Reverse list\n            arr[:cur] = reversed(arr[:cur])\n    return arr\n"
  },
  {
    "id": 10,
    "category": "sort",
    "file_name": "stooge_sort",
    "codes": "'''\n\nStooge Sort\nTime Complexity : O(n2.709)\nReference: https://www.geeksforgeeks.org/stooge-sort/\n\n'''\n\n\n\ndef stoogesort(arr, l, h): \n    if l >= h: \n        return\n   \n    # If first element is smaller \n    # than last, swap them \n    if arr[l]>arr[h]: \n        t = arr[l] \n        arr[l] = arr[h] \n        arr[h] = t \n   \n    # If there are more than 2 elements in \n    # the array \n    if h-l + 1 > 2: \n        t = (int)((h-l + 1)/3) \n   \n        # Recursively sort first 2 / 3 elements \n        stoogesort(arr, l, (h-t)) \n   \n        # Recursively sort last 2 / 3 elements \n        stoogesort(arr, l + t, (h)) \n   \n        # Recursively sort first 2 / 3 elements \n        # again to confirm \n        stoogesort(arr, l, (h-t)) \n        \n\nif __name__ == \"__main__\":\n    array = [1,3,64,5,7,8]\n    n = len(array) \n    stoogesort(array, 0, n-1) \n    for i in range(0, n): \n        print(array[i], end = ' ') \n"
  },
  {
    "id": 11,
    "category": "sort",
    "file_name": "counting_sort",
    "codes": "def counting_sort(arr):\n    \"\"\"\n    Counting_sort\n    Sorting a array which has no element greater than k\n    Creating a new temp_arr,where temp_arr[i] contain the number of\n    element less than or equal to i in the arr\n    Then placing the number i into a correct position in the result_arr\n    return the result_arr\n    Complexity: 0(n)\n    \"\"\"\n\n    m = min(arr)\n    # in case there are negative elements, change the array to all positive element\n    different = 0\n    if m < 0:\n        # save the change, so that we can convert the array back to all positive number\n        different = -m\n        for i in range(len(arr)):\n            arr[i] += -m\n    k = max(arr)\n    temp_arr = [0] * (k + 1)\n    for i in range(0, len(arr)):\n        temp_arr[arr[i]] = temp_arr[arr[i]] + 1\n    # temp_array[i] contain the times the number i appear in arr\n\n    for i in range(1, k + 1):\n        temp_arr[i] = temp_arr[i] + temp_arr[i - 1]\n    # temp_array[i] contain the number of element less than or equal i in arr\n\n    result_arr = arr.copy()\n    # creating a result_arr an put the element in a correct positon\n    for i in range(len(arr) - 1, -1, -1):\n        result_arr[temp_arr[arr[i]] - 1] = arr[i] - different\n        temp_arr[arr[i]] = temp_arr[arr[i]] - 1\n\n    return result_arr\n"
  },
  {
    "id": 12,
    "category": "sort",
    "file_name": "merge_sort",
    "codes": "def merge_sort(arr):\n    \"\"\" Merge Sort\n        Complexity: O(n log(n))\n    \"\"\"\n    # Our recursive base case\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    # Perform merge_sort recursively on both halves\n    left, right = merge_sort(arr[:mid]), merge_sort(arr[mid:])\n\n    # Merge each side together\n    # return merge(left, right, arr.copy()) # changed, no need to copy, mutate inplace.\n    merge(left,right,arr)\n    return arr\n\n\ndef merge(left, right, merged):\n    \"\"\" Merge helper\n        Complexity: O(n)\n    \"\"\"\n\n    left_cursor, right_cursor = 0, 0\n    while left_cursor < len(left) and right_cursor < len(right):\n        # Sort each one and place into the result\n        if left[left_cursor] <= right[right_cursor]:\n            merged[left_cursor+right_cursor]=left[left_cursor]\n            left_cursor += 1\n        else:\n            merged[left_cursor + right_cursor] = right[right_cursor]\n            right_cursor += 1\n    # Add the left overs if there's any left to the result\n    for left_cursor in range(left_cursor, len(left)):\n        merged[left_cursor + right_cursor] = left[left_cursor]\n    # Add the left overs if there's any left to the result\n    for right_cursor in range(right_cursor, len(right)):\n        merged[left_cursor + right_cursor] = right[right_cursor]\n\n    # Return result\n    # return merged # do not return anything, as it is replacing inplace.\n"
  },
  {
    "id": 13,
    "category": "sort",
    "file_name": "gnome_sort",
    "codes": "\"\"\"\n\nGnome Sort\nBest case performance is O(n)\nWorst case performance is O(n^2)\n\n\"\"\"\n\n\ndef gnome_sort(arr):\n    n = len(arr)\n    index = 0\n    while index < n:\n        if index == 0 or arr[index] >= arr[index-1]:\n            index = index + 1\n        else:\n            arr[index], arr[index-1] = arr[index-1], arr[index]\n            index = index - 1\n    return arr\n"
  },
  {
    "id": 14,
    "category": "sort",
    "file_name": "wiggle_sort",
    "codes": "\"\"\"\nGiven an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\"\"\"\ndef wiggle_sort(nums):\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i-1] > nums[i]):\n            nums[i-1], nums[i] = nums[i], nums[i-1]\n\nif __name__ == \"__main__\":\n    array = [3, 5, 2, 1, 6, 4]\n\n    print(array)\n    wiggle_sort(array)\n    print(array)\n\n\n"
  },
  {
    "id": 15,
    "category": "sort",
    "file_name": "radix_sort",
    "codes": "\"\"\"\nradix sort\ncomplexity: O(nk + n) . n is the size of input list and k is the digit length of the number\n\"\"\"\ndef radix_sort(arr, simulation=False):\n    position = 1\n    max_number = max(arr)\n\n    iteration = 0\n    if simulation:\n        print(\"iteration\", iteration, \":\", *arr)\n\n    while position <= max_number:\n        queue_list = [list() for _ in range(10)]\n\n        for num in arr:\n            digit_number = num // position % 10\n            queue_list[digit_number].append(num)\n\n        index = 0\n        for numbers in queue_list:\n            for num in numbers:\n                arr[index] = num\n                index += 1\n\n        if simulation:\n            iteration = iteration + 1\n            print(\"iteration\", iteration, \":\", *arr)\n\n        position *= 10\n    return arr\n    "
  },
  {
    "id": 16,
    "category": "sort",
    "file_name": "bogo_sort",
    "codes": "import random\n\ndef bogo_sort(arr, simulation=False):\n    \"\"\"Bogo Sort\n        Best Case Complexity: O(n)\n        Worst Case Complexity: O(\u221e)\n        Average Case Complexity: O(n(n-1)!)\n    \"\"\"\n    \n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n    \n    def is_sorted(arr):\n        #check the array is inorder\n        i = 0\n        arr_len = len(arr)\n        while i+1 < arr_len:\n            if arr[i] > arr[i+1]:\n                return False\n            i += 1\n            \n\n        return True\n    while not is_sorted(arr):\n        random.shuffle(arr)\n        \n        if simulation:\n            iteration = iteration + 1\n            print(\"iteration\",iteration,\":\",*arr)\n            \n    return arr\n"
  },
  {
    "id": 17,
    "category": "sort",
    "file_name": "bitonic_sort",
    "codes": "def bitonic_sort(arr, reverse=False):\n    \"\"\"\n    bitonic sort is sorting algorithm to use multiple process, but this code not containing parallel process\n    It can sort only array that sizes power of 2\n    It can sort array in both increasing order and decreasing order by giving argument true(increasing) and false(decreasing)\n    \n    Worst-case in parallel: O(log(n)^2)\n    Worst-case in non-parallel: O(nlog(n)^2)\n    \n    reference: https://en.wikipedia.org/wiki/Bitonic_sorter\n    \"\"\"\n    def compare(arr, reverse):\n        n = len(arr)//2\n        for i in range(n):\n            if reverse != (arr[i] > arr[i+n]):\n                arr[i], arr[i+n] = arr[i+n], arr[i]\n        return arr\n\n    def bitonic_merge(arr, reverse):\n        n = len(arr)\n        \n        if n <= 1:\n            return arr\n        \n        arr = compare(arr, reverse)\n        left = bitonic_merge(arr[:n // 2], reverse)\n        right = bitonic_merge(arr[n // 2:], reverse)\n        return left + right\n    \n    #end of function(compare and bitionic_merge) definition\n    n = len(arr)\n    if n <= 1:\n        return arr\n    # checks if n is power of two\n    if not (n and (not(n & (n - 1))) ):\n        raise ValueError(\"the size of input should be power of two\")\n    \n    left = bitonic_sort(arr[:n // 2], True)\n    right = bitonic_sort(arr[n // 2:], False)\n\n    arr = bitonic_merge(left + right, reverse)\n        \n    return arr\n"
  },
  {
    "id": 18,
    "category": "sort",
    "file_name": "selection_sort",
    "codes": "def selection_sort(arr, simulation=False):\n    \"\"\" Selection Sort\n        Complexity: O(n^2)\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n        \n    for i in range(len(arr)):\n        minimum = i\n        \n        for j in range(i + 1, len(arr)):\n            # \"Select\" the correct value\n            if arr[j] < arr[minimum]:\n                minimum = j\n\n        arr[minimum], arr[i] = arr[i], arr[minimum]\n        \n        if simulation:\n                iteration = iteration + 1\n                print(\"iteration\",iteration,\":\",*arr)\n            \n    return arr\n"
  },
  {
    "id": 19,
    "category": "sort",
    "file_name": "top_sort",
    "codes": "GRAY, BLACK = 0, 1\n\ndef top_sort_recursive(graph):\n    \"\"\" Time complexity is the same as DFS, which is O(V + E)\n        Space complexity: O(V)\n    \"\"\"\n    order, enter, state = [], set(graph), {}\n    \n    def dfs(node):\n        state[node] = GRAY\n        #print(node)\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError(\"cycle\")\n            if sk == BLACK:\n                continue\n            enter.discard(k)\n            dfs(k)\n        order.append(node)\n        state[node] = BLACK\n        \n    while enter: dfs(enter.pop())\n    return order\n\ndef top_sort(graph):\n    \"\"\" Time complexity is the same as DFS, which is O(V + E)\n        Space complexity: O(V)\n    \"\"\"\n    order, enter, state = [], set(graph), {}\n    \n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:\n            sk = state.get(k, None)\n            if sk == GRAY: \n                raise ValueError(\"cycle\")\n            if sk != BLACK:\n                return False\n        return True\n        \n    while enter:\n        node = enter.pop()\n        stack = []\n        while True:\n            state[node] = GRAY\n            stack.append(node)\n            for k in graph.get(node, ()):\n                sk = state.get(k, None)\n                if sk == GRAY: \n                    raise ValueError(\"cycle\")\n                if sk == BLACK: \n                    continue\n                enter.discard(k)\n                stack.append(k)\n            while stack and is_ready(stack[-1]):\n                node = stack.pop()\n                order.append(node)\n                state[node] = BLACK\n            if len(stack) == 0:\n                break\n            node = stack.pop()\n        \n    return order\n"
  },
  {
    "id": 20,
    "category": "sort",
    "file_name": "meeting_rooms",
    "codes": "\"\"\"\nGiven an array of meeting time intervals consisting of\nstart and end times [[s1,e1],[s2,e2],...] (si < ei),\ndetermine if a person could attend all meetings.\n\nFor example,\nGiven [[0, 30],[5, 10],[15, 20]],\nreturn false.\n\"\"\"\n\n\ndef can_attend_meetings(intervals):\n    \"\"\"\n    :type intervals: List[Interval]\n    :rtype: bool\n    \"\"\"\n    intervals = sorted(intervals, key=lambda x: x.start)\n    for i in range(1, len(intervals)):\n        if intervals[i].start < intervals[i - 1].end:\n            return False\n    return True\n"
  },
  {
    "id": 21,
    "category": "sort",
    "file_name": "comb_sort",
    "codes": "\"\"\"\n\nhttps://en.wikipedia.org/wiki/Comb_sort\n\nWorst-case performance: O(N^2)\n\n\"\"\"\n\n\ndef comb_sort(arr):\n    def swap(i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap > 1:\n            sorted = False\n        else:\n            gap = 1\n            sorted = True\n\n        i = 0\n        while i + gap < n:\n            if arr[i] > arr[i + gap]:\n                swap(i, i + gap)\n                sorted = False\n            i = i + 1\n    return arr\n"
  },
  {
    "id": 22,
    "category": "sort",
    "file_name": "shell_sort",
    "codes": "def shell_sort(arr):\n    ''' Shell Sort\n        Complexity: O(n^2)\n    '''\n    n = len(arr)\n    # Initialize size of the gap\n    gap = n//2\n    \n    while gap > 0:\n        y_index = gap\n        while y_index < len(arr):\n            y = arr[y_index]\n            x_index = y_index - gap\n            while x_index >= 0 and y < arr[x_index]:\n                arr[x_index + gap] = arr[x_index]\n                x_index = x_index - gap\n            arr[x_index + gap] = y\n            y_index = y_index + 1\n        gap = gap//2\n        \n    return arr\n"
  },
  {
    "id": 23,
    "category": "sort",
    "file_name": "pigeonhole_sort",
    "codes": "\"\"\"\n\nhttps://en.wikipedia.org/wiki/Pigeonhole_sort\n\nTime complexity: O(n + Range) where n = number of elements and Range = possible values in the array\n\nSuitable for lists where the number of elements and key values are mostly the same.\n\n\"\"\"\n\n\ndef pigeonhole_sort(arr):\n    Max = max(arr)\n    Min = min(arr)\n    size = Max - Min + 1\n\n    holes = [0]*size\n\n    for i in arr:\n        holes[i-Min] += 1\n\n    i = 0\n    for count in range(size):\n        while holes[count] > 0:\n            holes[count] -= 1\n            arr[i] = count + Min\n            i += 1\n    return arr\n"
  },
  {
    "id": 24,
    "category": "sort",
    "file_name": "cocktail_shaker_sort",
    "codes": "def cocktail_shaker_sort(arr):\n    \"\"\"\n    Cocktail_shaker_sort\n    Sorting a given array\n    mutation of bubble sort\n\n    reference: https://en.wikipedia.org/wiki/Cocktail_shaker_sort\n    \n    Worst-case performance: O(N^2)\n    \"\"\"\n\n    def swap(i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n\n    n = len(arr)\n    swapped = True\n    while swapped:\n        swapped = False\n        for i in range(1, n):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n        if swapped == False:\n            return arr\n        swapped = False\n        for i in range(n-1,0,-1):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n    return arr\n"
  },
  {
    "id": 25,
    "category": "sort",
    "file_name": "quick_sort",
    "codes": "def quick_sort(arr, simulation=False):\n    \"\"\" Quick sort\n        Complexity: best O(n log(n)) avg O(n log(n)), worst O(N^2)\n    \"\"\"\n    \n    iteration = 0\n    if simulation:\n        print(\"iteration\",iteration,\":\",*arr)\n    arr, _ = quick_sort_recur(arr, 0, len(arr) - 1, iteration, simulation)\n    return arr\n\ndef quick_sort_recur(arr, first, last, iteration, simulation):\n    if first < last:\n        pos = partition(arr, first, last)\n        # Start our two recursive calls\n        if simulation:\n            iteration = iteration + 1\n            print(\"iteration\",iteration,\":\",*arr)\n            \n        _, iteration = quick_sort_recur(arr, first, pos - 1, iteration, simulation)\n        _, iteration = quick_sort_recur(arr, pos + 1, last, iteration, simulation)\n\n    return arr, iteration\n\ndef partition(arr, first, last):\n    wall = first\n    for pos in range(first, last):\n        if arr[pos] < arr[last]:  # last is the pivot\n            arr[pos], arr[wall] = arr[wall], arr[pos]\n            wall += 1\n    arr[wall], arr[last] = arr[last], arr[wall]\n    return wall\n"
  },
  {
    "id": 26,
    "category": "sort",
    "file_name": "bucket_sort",
    "codes": "def bucket_sort(arr):\n    ''' Bucket Sort\n        Complexity: O(n^2)\n        The complexity is dominated by nextSort\n    '''\n    # The number of buckets and make buckets\n    num_buckets = len(arr)\n    buckets = [[] for bucket in range(num_buckets)]\n    # Assign values into bucket_sort\n    for value in arr:\n        index = value * num_buckets // (max(arr) + 1)\n        buckets[index].append(value)\n    # Sort\n    sorted_list = []\n    for i in range(num_buckets):\n        sorted_list.extend(next_sort(buckets[i]))\n    return sorted_list\n\ndef next_sort(arr):\n    # We will use insertion sort here.\n    for i in range(1, len(arr)):\n        j = i - 1\n        key = arr[i]\n        while arr[j] > key and j >= 0:\n            arr[j+1] = arr[j]\n            j = j - 1\n        arr[j + 1] = key\n    return arr\n"
  },
  {
    "id": 27,
    "category": "sort",
    "file_name": "sort_colors",
    "codes": "\"\"\"\nGiven an array with n objects colored red,\nwhite or blue, sort them so that objects of the same color\nare adjacent, with the colors in the order red, white and blue.\n\nHere, we will use the integers 0, 1, and 2 to represent\nthe color red, white, and blue respectively.\n\nNote:\nYou are not suppose to use the library's sort function for this problem.\n\"\"\"\n\n\ndef sort_colors(nums):\n    i = j = 0\n    for k in range(len(nums)):\n        v = nums[k]\n        nums[k] = 2\n        if v < 2:\n            nums[j] = 1\n            j += 1\n        if v == 0:\n            nums[i] = 0\n            i += 1\n\n\nif __name__ == \"__main__\":\n    nums = [0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 2, 2]\n    sort_colors(nums)\n    print(nums)\n"
  },
  {
    "id": 28,
    "category": "sort",
    "file_name": "exchange_sort",
    "codes": "def exchange_sort(arr):\n    \"\"\"\n    Reference : https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    Complexity : O(n^2)\n    \"\"\"\n    arr_len = len(arr)\n    for i in range(arr_len-1):\n        for j in range(i+1, arr_len):\n            if(arr[i] > arr[j]):\n                arr[i], arr[j] = arr[j], arr[i]\n    return arr\n"
  },
  {
    "id": 29,
    "category": "sort",
    "file_name": "cycle_sort",
    "codes": "def cycle_sort(arr):\n    \"\"\"\n    cycle_sort\n    This is based on the idea that the permutations to be sorted\n    can be decomposed into cycles,\n    and the results can be individually sorted by cycling.\n    \n    reference: https://en.wikipedia.org/wiki/Cycle_sort\n    \n    Average time complexity : O(N^2)\n    Worst case time complexity : O(N^2)\n    \"\"\"\n    len_arr = len(arr)\n    # Finding cycle to rotate.\n    for cur in range(len_arr - 1):\n        item = arr[cur]\n\n        # Finding an indx to put items in.\n        index = cur\n        for i in range(cur + 1, len_arr):\n            if arr[i] < item:\n                index += 1\n\n        # Case of there is not a cycle\n        if index == cur:\n            continue\n\n        # Putting the item immediately right after the duplicate item or on the right.\n        while item == arr[index]:\n            index += 1\n        arr[index], item = item, arr[index]\n\n        # Rotating the remaining cycle.\n        while index != cur:\n\n            # Finding where to put the item.\n            index = cur\n            for i in range(cur + 1, len_arr):\n                if arr[i] < item:\n                    index += 1\n\n            # After item is duplicated, put it in place or put it there.\n            while item == arr[index]:\n                index += 1\n            arr[index], item = item, arr[index]\n    return arr\n"
  },
  {
    "id": 30,
    "category": "dp",
    "file_name": "knapsack",
    "codes": "\"\"\"\nGiven the capacity of the knapsack and items specified by weights and values,\nreturn the maximum summarized value of the items that can be fit in the\nknapsack.\n\nExample:\ncapacity = 5, items(value, weight) = [(60, 5), (50, 3), (70, 4), (30, 2)]\nresult = 80 (items valued 50 and 30 can both be fit in the knapsack)\n\nThe time complexity is O(n * m) and the space complexity is O(m), where n is\nthe total number of items and m is the knapsack's capacity.\n\"\"\"\n\n\nclass Item:\n\n    def __init__(self, value, weight):\n        self.value = value\n        self.weight = weight\n\n\ndef get_maximum_value(items, capacity):\n    dp = [0] * (capacity + 1)\n    for item in items:\n        for cur_weight in reversed(range(item.weight, capacity+1)):\n            dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight])\n    return dp[capacity]\n\n"
  },
  {
    "id": 31,
    "category": "dp",
    "file_name": "edit_distance",
    "codes": "\"\"\"The edit distance between two words is the minimum number\nof letter insertions, letter deletions, and letter substitutions\nrequired to transform one word into another.\n\nFor example, the edit distance between FOOD and MONEY is at\nmost four:\n\nFOOD -> MOOD -> MOND -> MONED -> MONEY\n\nGiven two words A and B, find the minimum number of operations\nrequired to transform one string into the other.\nIn other words, find the edit distance between A and B.\n\nThought process:\n\nLet edit(i, j) denote the edit distance between\nthe prefixes A[1..i] and B[1..j].\n\nThen, the function satifies the following recurrence:\n\nedit(i, j) = i if j = 0\n             j if i = 0\n             min(edit(i-1, j) + 1,\n                 edit(i, j-1), + 1,\n                 edit(i-1, j-1) + cost) otherwise\n\nThere are two base cases, both of which occur when one string is empty\nand the other is not.\n1. To convert an empty string A into a string B of length n,\nperform n insertions.\n2. To convert a string A of length m into an empty string B,\nperform m deletions.\n\nHere, the cost is 1 if a substitution is required,\nor 0 if both chars in words A and B are the same at\nindexes i and j, respectively.\n\nTo find the edit distance between two words A and B,\nwe need to find edit(length_a, length_b).\n\nTime: O(length_a*length_b)\nSpace: O(length_a*length_b)\n\"\"\"\n\n\ndef edit_distance(word_a, word_b):\n    \"\"\"Finds edit distance between word_a and word_b\n\n    Kwyword arguments:\n    word_a -- string\n    word_b -- string\n    \"\"\"\n\n    length_a, length_b = len(word_a) + 1, len(word_b) + 1\n\n    edit = [[0 for _ in range(length_b)] for _ in range(length_a)]\n\n    for i in range(1, length_a):\n        edit[i][0] = i\n\n    for j in range(1, length_b):\n        edit[0][j] = j\n\n    for i in range(1, length_a):\n        for j in range(1, length_b):\n            cost = 0 if word_a[i - 1] == word_b[j - 1] else 1\n            edit[i][j] = min(edit[i - 1][j] + 1, edit[i][j - 1] + 1, edit[i - 1][j - 1] + cost)\n\n    return edit[-1][-1]  # this is the same as edit[length_a][length_b]\n"
  },
  {
    "id": 32,
    "category": "dp",
    "file_name": "longest_increasing",
    "codes": "\"\"\"\nGiven an unsorted array of integers, find the length of\nlongest increasing subsequence.\n\nExample:\n\nInput: [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the\nlength is 4.\n\nTime complexity:\nFirst algorithm is O(n^2).\nSecond algorithm is O(nlogx) where x is the max element in the list\nThird algorithm is O(nlogn)\n\nSpace complexity:\nFirst algorithm is O(n)\nSecond algorithm is O(x) where x is the max element in the list\nThird algorithm is O(n)\n\"\"\"\n\n\ndef longest_increasing_subsequence(sequence):\n    \"\"\"\n    Dynamic Programming Algorithm for\n    counting the length of longest increasing subsequence\n    type sequence: list[int]\n    rtype: int\n    \"\"\"\n    length = len(sequence)\n    counts = [1 for _ in range(length)]\n    for i in range(1, length):\n        for j in range(0, i):\n            if sequence[i] > sequence[j]:\n                counts[i] = max(counts[i], counts[j] + 1)\n                print(counts)\n    return max(counts)\n\n\ndef longest_increasing_subsequence_optimized(sequence):\n    \"\"\"\n    Optimized dynamic programming algorithm for\n    couting the length of the longest increasing subsequence\n    using segment tree data structure to achieve better complexity\n    if max element is larger than 10^5 then use\n    longest_increasing_subsequence_optimied2() instead\n    type sequence: list[int]\n    rtype: int\n    \"\"\"\n    max_seq = max(sequence)\n    tree = [0] * (max_seq<<2)\n\n    def update(pos, left, right, target, vertex):\n        if left == right:\n            tree[pos] = vertex\n            return\n        mid = (left+right)>>1\n        if target <= mid:\n            update(pos<<1, left, mid, target, vertex)\n        else:\n            update((pos<<1)|1, mid+1, right, target, vertex)\n        tree[pos] = max_seq(tree[pos<<1], tree[(pos<<1)|1])\n\n    def get_max(pos, left, right, start, end):\n        if left > end or right < start:\n            return 0\n        if left >= start and right <= end:\n            return tree[pos]\n        mid = (left+right)>>1\n        return max_seq(get_max(pos<<1, left, mid, start, end),\n            get_max((pos<<1)|1, mid+1, right, start, end))\n    ans = 0\n    for element in sequence:\n        cur = get_max(1, 0, max_seq, 0, element-1)+1\n        ans = max_seq(ans, cur)\n        update(1, 0, max_seq, element, cur)\n    return ans\n\n\ndef longest_increasing_subsequence_optimized2(sequence):\n    \"\"\"\n    Optimized dynamic programming algorithm for\n    counting the length of the longest increasing subsequence\n    using segment tree data structure to achieve better complexity\n    type sequence: list[int]\n    rtype: int\n    \"\"\"\n    length = len(sequence)\n    tree = [0] * (length<<2)\n    sorted_seq = sorted((x, -i) for i, x in enumerate(sequence))\n    def update(pos, left, right, target, vertex):\n        if left == right:\n            tree[pos] = vertex\n            return\n        mid = (left+right)>>1\n        if target <= mid:\n            vertex(pos<<1, left, mid, target, vertex)\n        else:\n            vertex((pos<<1)|1, mid+1, right, target, vertex)\n        tree[pos] = max(tree[pos<<1], tree[(pos<<1)|1])\n\n    def get_max(pos, left, right, start, end):\n        if left > end or right < start:\n            return 0\n        if left >= start and right <= end:\n            return tree[pos]\n        mid = (left+right)>>1\n        return max(get_max(pos<<1, left, mid, start, end),\n            get_max((pos<<1)|1, mid+1, right, start, end))\n    ans = 0\n    for tup in sorted_seq:\n        i = -tup[1]\n        cur = get_max(1, 0, length-1, 0, i-1)+1\n        ans = max(ans, cur)\n        update(1, 0, length-1, i, cur)\n    return ans\n"
  },
  {
    "id": 33,
    "category": "dp",
    "file_name": "house_robber",
    "codes": "\"\"\"\nYou are a professional robber planning to rob houses along a street.\nEach house has a certain amount of money stashed,\nthe only constraint stopping you from robbing each of them\nis that adjacent houses have security system connected and\nit will automatically contact the police if two adjacent houses\nwere broken into on the same night.\n\nGiven a list of non-negative integers representing the amount of money\nof each house, determine the maximum amount of money you\ncan rob tonight without alerting the police.\n\"\"\"\n\n\ndef house_robber(houses):\n    last, now = 0, 0\n    for house in houses:\n        last, now = now, max(last + house, now)\n    return now\n"
  },
  {
    "id": 34,
    "category": "dp",
    "file_name": "regex_matching",
    "codes": "\"\"\"\nImplement regular expression matching with support for '.' and '*'.\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\nThe function prototype should be:\nbool is_match(const char *s, const char *p)\n\nSome examples:\nis_match(\"aa\",\"a\") \u2192 false\nis_match(\"aa\",\"aa\") \u2192 true\nis_match(\"aaa\",\"aa\") \u2192 false\nis_match(\"aa\", \"a*\") \u2192 true\nis_match(\"aa\", \".*\") \u2192 true\nis_match(\"ab\", \".*\") \u2192 true\nis_match(\"aab\", \"c*a*b\") \u2192 true\n\"\"\"\n\ndef is_match(str_a, str_b):\n    \"\"\"Finds if `str_a` matches `str_b`\n\n    Keyword arguments:\n    str_a -- string\n    str_b -- string\n    \"\"\"\n    len_a, len_b = len(str_a) + 1, len(str_b) + 1\n    matches = [[False] * len_b  for _ in range(len_a)]\n\n    # Match empty string with empty pattern\n    matches[0][0] = True\n\n    # Match empty string with .*\n    for i, element in enumerate(str_b[1:], 2):\n        matches[0][i] = matches[0][i - 2] and element == '*'\n\n    for i, char_a in enumerate(str_a, 1):\n        for j, char_b in enumerate(str_b, 1):\n            if char_b != '*':\n                # The previous character has matched and the current one\n                # has to be matched. Two possible matches: the same or .\n                matches[i][j] = matches[i - 1][j - 1] and \\\n                                char_b in (char_a, '.')\n            else:\n                # Horizontal look up [j - 2].\n                # Not use the character before *.\n                matches[i][j] |= matches[i][j - 2]\n\n                # Vertical look up [i - 1].\n                # Use at least one character before *.\n                #   p a b *\n                # s 1 0 0 0\n                # a 0 1 0 1\n                # b 0 0 1 1\n                # b 0 0 0 ?\n                if char_a == str_b[j - 2] or str_b[j - 2] == '.':\n                    matches[i][j] |= matches[i - 1][j]\n\n    return matches[-1][-1]\n"
  },
  {
    "id": 35,
    "category": "dp",
    "file_name": "coin_change",
    "codes": "\"\"\"\nProblem\nGiven a value `value`, if we want to make change for `value` cents, and we have infinite\nsupply of each of coins = {S1, S2, .. , Sm} valued `coins`, how many ways can we make the change?\nThe order of `coins` doesn't matter.\nFor example, for `value` = 4 and `coins` = [1, 2, 3], there are four solutions:\n[1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3].\nSo output should be 4.\n\nFor `value` = 10 and `coins` = [2, 5, 3, 6], there are five solutions:\n\n[2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5] and [5, 5].\nSo the output should be 5.\n\nTime complexity: O(n * m) where n is the `value` and m is the number of `coins`\nSpace complexity: O(n)\n\"\"\"\n\ndef count(coins, value):\n    \"\"\" Find number of combination of `coins` that adds upp to `value`\n\n    Keyword arguments:\n    coins -- int[]\n    value -- int\n    \"\"\"\n    # initialize dp array and set base case as 1\n    dp_array = [1] + [0] * value\n\n    # fill dp in a bottom up manner\n    for coin in coins:\n        for i in range(coin, value+1):\n            dp_array[i] += dp_array[i-coin]\n\n    return dp_array[value]\n"
  },
  {
    "id": 36,
    "category": "dp",
    "file_name": "planting_trees",
    "codes": "\"\"\"\nAn even number of trees are left along one side of a country road. You've been\nassigned the job to plant these trees at an even interval on both sides of the\nroad. The length and width of the road are variable, and a pair of trees must\nbe planted at the beginning (at 0) and at the end (at length) of the road. Only\none tree can be moved at a time. The goal is to calculate the lowest amount of\ndistance that the trees have to be moved before they are all in a valid\nposition.\n\"\"\"\n\nfrom math import sqrt\n\ndef planting_trees(trees, length, width):\n    \"\"\"\n    Returns the minimum distance that trees have to be moved before they\n    are all in a valid state.\n\n        Parameters:\n            tree (list<int>): A sorted list of integers with all trees'\n                              position along the road.\n            length (int): An integer with the length of the road.\n            width (int): An integer with the width of the road.\n\n        Returns:\n            A float number with the total distance trees have been moved.\n    \"\"\"\n    trees = [0] + trees\n\n    n_pairs = int(len(trees)/2)\n\n    space_between_pairs = length/(n_pairs-1)\n\n    target_locations = [location*space_between_pairs for location in range(n_pairs)]\n\n    cmatrix = [[0 for _ in range(n_pairs+1)] for _ in range(n_pairs+1)]\n    for r_i in range(1, n_pairs+1):\n        cmatrix[r_i][0] = cmatrix[r_i-1][0] + sqrt(\n                width + abs(trees[r_i]-target_locations[r_i-1])**2)\n    for l_i in range(1, n_pairs+1):\n        cmatrix[0][l_i] = cmatrix[0][l_i-1] + abs(trees[l_i]-target_locations[l_i-1])\n\n    for r_i in range(1, n_pairs+1):\n        for l_i in range(1, n_pairs+1):\n            cmatrix[r_i][l_i] = min(\n                cmatrix[r_i-1][l_i] + sqrt(width + (trees[l_i + r_i]-target_locations[r_i-1])**2),\n                cmatrix[r_i][l_i-1] + abs(trees[l_i + r_i]-target_locations[l_i-1])\n            )\n\n    return cmatrix[n_pairs][n_pairs]\n"
  },
  {
    "id": 37,
    "category": "dp",
    "file_name": "fib",
    "codes": "'''\nIn mathematics, the Fibonacci numbers, commonly denoted Fn,\nform a sequence, called the Fibonacci sequence,\nsuch that each number is the sum of the two preceding ones,\nstarting from 0 and 1.\nThat is,\n    F0=0 , F1=1\nand\n    Fn= F(n-1) + F(n-2)\nThe Fibonacci numbers are the numbers in the following integer sequence.\n    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u2026\u2026.\n\nIn mathematical terms, the sequence Fn of Fibonacci numbers is\ndefined by the recurrence relation\n\nHere, given a number n, print n-th Fibonacci Number.\n'''\n\n\ndef fib_recursive(n):\n    \"\"\"[summary]\n    Computes the n-th fibonacci number recursive.\n    Problem: This implementation is very slow.\n    approximate O(2^n)\n\n    Arguments:\n        n {[int]} -- [description]\n\n    Returns:\n        [int] -- [description]\n    \"\"\"\n\n    # precondition\n    assert n >= 0, 'n must be a positive integer'\n\n    if n <= 1:\n        return n\n    return fib_recursive(n-1) + fib_recursive(n-2)\n\n# print(fib_recursive(35)) # => 9227465 (slow)\n\n\ndef fib_list(n):\n    \"\"\"[summary]\n    This algorithm computes the n-th fibbonacci number\n    very quick. approximate O(n)\n    The algorithm use dynamic programming.\n\n    Arguments:\n        n {[int]} -- [description]\n\n    Returns:\n        [int] -- [description]\n    \"\"\"\n\n    # precondition\n    assert n >= 0, 'n must be a positive integer'\n\n    list_results = [0, 1]\n    for i in range(2, n+1):\n        list_results.append(list_results[i-1] + list_results[i-2])\n    return list_results[n]\n\n# print(fib_list(100)) # => 354224848179261915075\n\n\ndef fib_iter(n):\n    \"\"\"[summary]\n    Works iterative approximate O(n)\n\n    Arguments:\n        n {[int]} -- [description]\n\n    Returns:\n        [int] -- [description]\n    \"\"\"\n\n    # precondition\n    assert n >= 0, 'n must be positive integer'\n\n    fib_1 = 0\n    fib_2 = 1\n    res = 0\n    if n <= 1:\n        return n\n    for _ in range(n-1):\n        res = fib_1 + fib_2\n        fib_1 = fib_2\n        fib_2 = res\n    return res\n\n# print(fib_iter(100)) # => 354224848179261915075\n"
  },
  {
    "id": 38,
    "category": "dp",
    "file_name": "buy_sell_stock",
    "codes": "\"\"\"\nSay you have an array for which the ith element\nis the price of a given stock on day i.\n\nIf you were only permitted to complete at most one transaction\n(ie, buy one and sell one share of the stock),\ndesign an algorithm to find the maximum profit.\n\nExample 1:\nInput: [7, 1, 5, 3, 6, 4]\nOutput: 5\n\nmax. difference = 6-1 = 5\n(not 7-1 = 6, as selling price needs to be larger than buying price)\nExample 2:\nInput: [7, 6, 4, 3, 1]\nOutput: 0\n\nIn this case, no transaction is done, i.e. max profit = 0.\n\"\"\"\n\n\n# O(n^2) time\ndef max_profit_naive(prices):\n    \"\"\"\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    max_so_far = 0\n    for i in range(0, len(prices) - 1):\n        for j in range(i + 1, len(prices)):\n            max_so_far = max(max_so_far, prices[j] - prices[i])\n    return max_so_far\n\n\n# O(n) time\ndef max_profit_optimized(prices):\n    \"\"\"\n    input: [7, 1, 5, 3, 6, 4]\n    diff : [X, -6, 4, -2, 3, -2]\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    cur_max, max_so_far = 0, 0\n    for i in range(1, len(prices)):\n        cur_max = max(0, cur_max + prices[i] - prices[i-1])\n        max_so_far = max(max_so_far, cur_max)\n    return max_so_far\n"
  },
  {
    "id": 39,
    "category": "dp",
    "file_name": "egg_drop",
    "codes": "\"\"\"\nYou are given K eggs, and you have access to a building with N floors\nfrom 1 to N. Each egg is identical in function, and if an egg breaks,\nyou cannot drop it again. You know that there exists a floor F with\n0 <= F <= N such that any egg dropped at a floor higher than F will\nbreak, and any egg dropped at or below floor F will not break.\nEach move, you may take an egg (if you have an unbroken one) and drop\nit from any floor X (with 1 <= X <= N). Your goal is to know with\ncertainty what the value of F is. What is the minimum number of moves\nthat you need to know with certainty what F is, regardless of the\ninitial value of F?\n\nExample:\nInput: K = 1, N = 2\nOutput: 2\nExplanation:\nDrop the egg from floor 1.  If it breaks, we know with certainty that F = 0.\nOtherwise, drop the egg from floor 2.  If it breaks, we know with\ncertainty that F = 1.\nIf it didn't break, then we know with certainty F = 2.\nHence, we needed 2 moves in the worst case to know what F is with certainty.\n\"\"\"\n\n# A Dynamic Programming based Python Program for the Egg Dropping Puzzle\nINT_MAX = 32767\n\n\ndef egg_drop(n, k):\n    \"\"\"\n    Keyword arguments:\n    n -- number of floors\n    k -- number of eggs\n    \"\"\"\n    # A 2D table where entery eggFloor[i][j] will represent minimum\n    # number of trials needed for i eggs and j floors.\n    egg_floor = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n\n    # We need one trial for one floor and 0 trials for 0 floors\n    for i in range(1, n+1):\n        egg_floor[i][1] = 1\n        egg_floor[i][0] = 0\n\n    # We always need j trials for one egg and j floors.\n    for j in range(1, k+1):\n        egg_floor[1][j] = j\n\n    # Fill rest of the entries in table using optimal substructure\n    # property\n    for i in range(2, n+1):\n        for j in range(2, k+1):\n            egg_floor[i][j] = INT_MAX\n            for x in range(1, j+1):\n                res = 1 + max(egg_floor[i-1][x-1], egg_floor[i][j-x])\n                if res < egg_floor[i][j]:\n                    egg_floor[i][j] = res\n\n    # eggFloor[n][k] holds the result\n    return egg_floor[n][k]\n"
  },
  {
    "id": 40,
    "category": "dp",
    "file_name": "num_decodings",
    "codes": "\"\"\"\nA message containing letters from A-Z is being\nencoded to numbers using the following mapping:\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\nGiven an encoded message containing digits,\ndetermine the total number of ways to decode it.\n\nFor example,\nGiven encoded message \"12\",\nit could be decoded as \"AB\" (1 2) or \"L\" (12).\n\nThe number of ways decoding \"12\" is 2.\n\"\"\"\n\n\ndef num_decodings(enc_mes):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if not enc_mes or enc_mes[0] == \"0\":\n        return 0\n    last_char, last_two_chars = 1, 1\n    for i in range(1, len(enc_mes)):\n        last = last_char if enc_mes[i] != \"0\" else 0\n        last_two = last_two_chars if int(enc_mes[i-1:i+1]) < 27 and enc_mes[i-1] != \"0\" else 0\n        last_two_chars = last_char\n        last_char = last+last_two\n    return last_char\n\n\ndef num_decodings2(enc_mes):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if not enc_mes or enc_mes.startswith('0'):\n        return 0\n    stack = [1, 1]\n    for i in range(1, len(enc_mes)):\n        if enc_mes[i] == '0':\n            if enc_mes[i-1] == '0' or enc_mes[i-1] > '2':\n                # only '10', '20' is valid\n                return 0\n            stack.append(stack[-2])\n        elif 9 < int(enc_mes[i-1:i+1]) < 27:\n            # '01 - 09' is not allowed\n            stack.append(stack[-2]+stack[-1])\n        else:\n            # other case '01, 09, 27'\n            stack.append(stack[-1])\n    return stack[-1]\n"
  },
  {
    "id": 41,
    "category": "dp",
    "file_name": "min_cost_path",
    "codes": "\"\"\"\nauthor @goswami-rahul\n\nTo find minimum cost path\nfrom station 0 to station N-1,\nwhere cost of moving from ith station to jth station is given as:\n\nMatrix of size (N x N)\nwhere Matrix[i][j] denotes the cost of moving from\nstation i --> station j   for i < j\n\nNOTE that values where Matrix[i][j] and i > j does not\nmean anything, and hence represented by -1 or INF\n\nFor the input below (cost matrix),\nMinimum cost is obtained as from  { 0 --> 1 --> 3}\n                                  = cost[0][1] + cost[1][3] = 65\nthe Output will be:\n\nThe Minimum cost to reach station 4 is 65\n\nTime Complexity: O(n^2)\nSpace Complexity: O(n)\n\"\"\"\n\nINF = float(\"inf\")\n\n\ndef min_cost(cost):\n    \"\"\"Find minimum cost.\n\n    Keyword arguments:\n    cost -- matrix containing costs\n    \"\"\"\n    length = len(cost)\n    # dist[i] stores minimum cost from 0 --> i.\n    dist = [INF] * length\n\n    dist[0] = 0   # cost from 0 --> 0 is zero.\n\n    for i in range(length):\n        for j in range(i+1,length):\n            dist[j] = min(dist[j], dist[i] + cost[i][j])\n\n    return dist[length-1]\n\n\nif __name__ == '__main__':\n    costs = [ [ 0, 15, 80, 90],         # cost[i][j] is the cost of\n             [-1,  0, 40, 50],         # going from i --> j\n             [-1, -1,  0, 70],\n             [-1, -1, -1,  0] ]        # cost[i][j] = -1 for i > j\n    TOTAL_LEN = len(costs)\n\n    mcost = min_cost(costs)\n    assert mcost == 65\n\n    print(f\"The minimum cost to reach station {TOTAL_LEN} is {mcost}\")\n"
  },
  {
    "id": 42,
    "category": "dp",
    "file_name": "rod_cut",
    "codes": "\"\"\"A Dynamic Programming solution for Rod cutting problem\n\"\"\"\n\nINT_MIN = -32767\n\ndef cut_rod(price):\n    \"\"\"\n    Returns the best obtainable price for a rod of length n and\n    price[] as prices of different pieces\n    \"\"\"\n    n = len(price)\n    val = [0]*(n+1)\n\n    # Build the table val[] in bottom up manner and return\n    # the last entry from the table\n    for i in range(1, n+1):\n        max_val = INT_MIN\n        for j in range(i):\n            max_val = max(max_val, price[j] + val[i-j-1])\n        val[i] = max_val\n\n    return val[n]\n\n# Driver program to test above functions\narr = [1, 5, 8, 9, 10, 17, 17, 20]\nprint(\"Maximum Obtainable Value is \" + str(cut_rod(arr)))\n\n# This code is contributed by Bhavya Jain\n"
  },
  {
    "id": 43,
    "category": "dp",
    "file_name": "job_scheduling",
    "codes": "\"\"\"\nPython program for weighted job scheduling using Dynamic\nProgramming and Binary Search\n\"\"\"\n\nclass Job:\n    \"\"\"\n    Class to represent a job\n    \"\"\"\n    def __init__(self, start, finish, profit):\n        self.start = start\n        self.finish = finish\n        self.profit  = profit\n\ndef binary_search(job, start_index):\n    \"\"\"\n    A Binary Search based function to find the latest job\n    (before current job) that doesn't conflict with current\n    job.  \"index\" is index of the current job.  This function\n    returns -1 if all jobs before index conflict with it.\n    The array jobs[] is sorted in increasing order of finish\n    time.\n    \"\"\"\n\n    left = 0\n    right = start_index - 1\n\n    # Perform binary Search iteratively\n    while left <= right:\n        mid = (left + right) // 2\n        if job[mid].finish <= job[start_index].start:\n            if job[mid + 1].finish <= job[start_index].start:\n                left = mid + 1\n            else:\n                return mid\n        else:\n            right = mid - 1\n    return -1\n\ndef schedule(job):\n    \"\"\"\n    The main function that returns the maximum possible\n    profit from given array of jobs\n    \"\"\"\n\n    # Sort jobs according to finish time\n    job = sorted(job, key = lambda j: j.finish)\n\n    # Create an array to store solutions of subproblems.  table[i]\n    # stores the profit for jobs till arr[i] (including arr[i])\n    length = len(job)\n    table = [0 for _ in range(length)]\n\n    table[0] = job[0].profit\n\n    # Fill entries in table[] using recursive property\n    for i in range(1, length):\n\n        # Find profit including the current job\n        incl_prof = job[i].profit\n        pos = binary_search(job, i)\n        if pos != -1:\n            incl_prof += table[pos]\n\n        # Store maximum of including and excluding\n        table[i] = max(incl_prof, table[i - 1])\n\n    return table[length-1]\n"
  },
  {
    "id": 44,
    "category": "dp",
    "file_name": "longest_common_subsequence",
    "codes": "\"\"\"\nA subsequence is a sequence that can be derived from another\nsequence by deleting some or no elements without changing the\norder of the remaining elements.\n\nFor example, 'abd' is a subsequence of 'abcd' whereas 'adc' is not\n\nGiven 2 strings containing lowercase english alphabets, find the length\nof the Longest Common Subsequence (L.C.S.).\n\nExample:\n    Input:  'abcdgh'\n            'aedfhr'\n    Output: 3\n\n    Explanation: The longest subsequence common to both the string is \"adh\"\n\nTime Complexity : O(M*N)\nSpace Complexity : O(M*N), where M and N are the lengths of the 1st and 2nd string\nrespectively.\n\n\"\"\"\n\n\ndef longest_common_subsequence(s_1, s_2):\n    \"\"\"\n    :param s1: string\n    :param s2: string\n    :return: int\n    \"\"\"\n    m = len(s_1)\n    n = len(s_2)\n\n    mat = [[0] * (n + 1) for i in range(m + 1)]\n    # mat[i][j] : contains length of LCS of s_1[0..i-1] and s_2[0..j-1]\n\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                mat[i][j] = 0\n            elif s_1[i - 1] == s_2[j - 1]:\n                mat[i][j] = mat[i - 1][j - 1] + 1\n            else:\n                mat[i][j] = max(mat[i - 1][j], mat[i][j - 1])\n\n    return mat[m][n]\n"
  },
  {
    "id": 45,
    "category": "dp",
    "file_name": "matrix_chain_order",
    "codes": "'''\nDynamic Programming\nImplementation of matrix Chain Multiplication\nTime Complexity: O(n^3)\nSpace Complexity: O(n^2)\n'''\nINF = float(\"inf\")\n\n\ndef matrix_chain_order(array):\n    \"\"\"Finds optimal order to multiply matrices\n\n    array -- int[]\n    \"\"\"\n    n = len(array)\n    matrix = [[0 for x in range(n)] for x in range(n)]\n    sol = [[0 for x in range(n)] for x in range(n)]\n    for chain_length in range(2, n):\n        for a in range(1, n-chain_length+1):\n            b = a+chain_length-1\n\n            matrix[a][b] = INF\n            for c in range(a, b):\n                cost = matrix[a][c] + matrix[c+1][b] + array[a-1]*array[c]*array[b]\n                if cost < matrix[a][b]:\n                    matrix[a][b] = cost\n                    sol[a][b] = c\n    return matrix, sol\n# Print order of matrix with Ai as matrix\n\ndef print_optimal_solution(optimal_solution,i,j):\n    \"\"\"Print the solution\n\n    optimal_solution -- int[][]\n    i -- int[]\n    j -- int[]\n    \"\"\"\n    if i==j:\n        print(\"A\" + str(i),end = \" \")\n    else:\n        print(\"(\", end=\" \")\n        print_optimal_solution(optimal_solution, i, optimal_solution[i][j])\n        print_optimal_solution(optimal_solution, optimal_solution[i][j]+1, j)\n        print(\")\", end=\" \")\n\n\ndef main():\n    \"\"\"\n    Testing for matrix_chain_ordering\n    \"\"\"\n    array=[30,35,15,5,10,20,25]\n    length=len(array)\n    #Size of matrix created from above array will be\n    # 30*35 35*15 15*5 5*10 10*20 20*25\n    matrix, optimal_solution = matrix_chain_order(array)\n\n    print(\"No. of Operation required: \"+str((matrix[1][length-1])))\n    print_optimal_solution(optimal_solution,1,length-1)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "id": 46,
    "category": "dp",
    "file_name": "climbing_stairs",
    "codes": "\"\"\"\nYou are climbing a stair case.\nIt takes `steps` number of steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps.\nIn how many distinct ways can you climb to the top?\n\nNote: Given argument `steps` will be a positive integer.\n\"\"\"\n\n\n# O(n) space\n\ndef climb_stairs(steps):\n    \"\"\"\n    :type steps: int\n    :rtype: int\n    \"\"\"\n    arr = [1, 1]\n    for _ in range(1, steps):\n        arr.append(arr[-1] + arr[-2])\n    return arr[-1]\n\n\n# the above function can be optimized as:\n# O(1) space\n\ndef climb_stairs_optimized(steps):\n    \"\"\"\n    :type steps: int\n    :rtype: int\n    \"\"\"\n    a_steps = b_steps = 1\n    for _ in range(steps):\n        a_steps, b_steps = b_steps, a_steps + b_steps\n    return a_steps\n"
  },
  {
    "id": 47,
    "category": "dp",
    "file_name": "k_factor",
    "codes": "'''\nThe K factor of a string is defined as the number of times 'abba' appears as a\nsubstring. Given two numbers `length` and `k_factor`, find the number of\nstrings of length `length` with 'K factor' = `k_factor`.\n\nThe algorithms is as follows:\n\ndp[length][k_factor] will be a 4 element array, wherein each element can be the\nnumber of strings of length `length` and 'K factor' = `k_factor` which belong\nto the criteria represented by that index:\n\n    - dp[length][k_factor][0] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'a'\n\n    - dp[length][k_factor][1] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'ab'\n\n    - dp[length][k_factor][2] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'abb'\n\n    - dp[length][k_factor][3] can be the number of strings of `length` and\n      K-factor = `k_factor` which end with anything other than the above\n      substrings (anything other than 'a' 'ab' 'abb')\n\nExample inputs\n\nlength=4 k_factor=1  no of strings = 1\nlength=7 k_factor=1 no of strings = 70302\nlength=10 k_factor=2 no of strings = 74357\n\n'''\n\ndef find_k_factor(length, k_factor):\n    \"\"\"Find the number of strings of length `length` with K factor = `k_factor`.\n\n    Keyword arguments:\n    length -- integer\n    k_factor -- integer\n    \"\"\"\n    mat=[[[0 for i in range(4)]for j in range((length-1)//3+2)]for k in range(length+1)]\n    if 3*k_factor+1>length:\n        return 0\n    #base cases\n    mat[1][0][0]=1\n    mat[1][0][1]=0\n    mat[1][0][2]=0\n    mat[1][0][3]=25\n\n    for i in range(2,length+1):\n        for j in range((length-1)//3+2):\n            if j==0:\n                #adding a at the end\n                mat[i][j][0]=mat[i-1][j][0]+mat[i-1][j][1]+mat[i-1][j][3]\n\n                #adding b at the end\n                mat[i][j][1]=mat[i-1][j][0]\n                mat[i][j][2]=mat[i-1][j][1]\n\n                #adding any other lowercase character\n                mat[i][j][3]=mat[i-1][j][0]*24+mat[i-1][j][1]*24+mat[i-1][j][2]*25+mat[i-1][j][3]*25\n\n            elif 3*j+1<i:\n                #adding a at the end\n                mat[i][j][0]=mat[i-1][j][0]+mat[i-1][j][1]+mat[i-1][j][3]+mat[i-1][j-1][2]\n\n                #adding b at the end\n                mat[i][j][1]=mat[i-1][j][0]\n                mat[i][j][2]=mat[i-1][j][1]\n\n                #adding any other lowercase character\n                mat[i][j][3]=mat[i-1][j][0]*24+mat[i-1][j][1]*24+mat[i-1][j][2]*25+mat[i-1][j][3]*25\n\n            elif 3*j+1==i:\n                mat[i][j][0]=1\n                mat[i][j][1]=0\n                mat[i][j][2]=0\n                mat[i][j][3]=0\n\n            else:\n                mat[i][j][0]=0\n                mat[i][j][1]=0\n                mat[i][j][2]=0\n                mat[i][j][3]=0\n\n    return sum(mat[length][k_factor])\n"
  },
  {
    "id": 48,
    "category": "dp",
    "file_name": "word_break",
    "codes": "\"\"\"\nGiven a non-empty string s and a dictionary wordDict\ncontaining a list of non-empty words,\ndetermine if word can be segmented into a space-separated\nsequence of one or more dictionary words.\nYou may assume the dictionary does not contain duplicate words.\n\nFor example, given\nword = \"leetcode\",\ndict = [\"leet\", \"code\"].\n\nReturn true because \"leetcode\" can be segmented as \"leet code\".\n\nword = abc word_dict = [\"a\",\"bc\"]\nTrue False False False\n\n\"\"\"\n\n\n# TC: O(N^2)  SC: O(N)\ndef word_break(word, word_dict):\n    \"\"\"\n    :type word: str\n    :type word_dict: Set[str]\n    :rtype: bool\n    \"\"\"\n    dp_array = [False] * (len(word)+1)\n    dp_array[0] = True\n    for i in range(1, len(word)+1):\n        for j in range(0, i):\n            if dp_array[j] and word[j:i] in word_dict:\n                dp_array[i] = True\n                break\n    return dp_array[-1]\n\n\nif __name__ == \"__main__\":\n    STR = \"keonkim\"\n    dic = [\"keon\", \"kim\"]\n\n    print(word_break(str, dic))\n"
  },
  {
    "id": 49,
    "category": "dp",
    "file_name": "int_divide",
    "codes": "\"\"\"\nGiven positive integer decompose, find an algorithm to find the number of\nnon-negative number division, or decomposition.\n\nThe complexity is O(n^2).\n\nExample 1:\nInput: 4\nOutput: 5\nExplaination:\n4=4\n4=3+1\n4=2+2\n4=2+1+1\n4=1+1+1+1\n\nExample :\nInput: 7\nOutput: 15\nExplaination:\n7=7\n7=6+1\n7=5+2\n7=5+1+1\n7=4+3\n7=4+2+1\n7=4+1+1+1\n7=3+3+1\n7=3+2+2\n7=3+2+1+1\n7=3+1+1+1+1\n7=2+2+2+1\n7=2+2+1+1+1\n7=2+1+1+1+1+1\n7=1+1+1+1+1+1+1\n\n\"\"\"\n\n\ndef int_divide(decompose):\n    \"\"\"Find number of decompositions from `decompose`\n\n    decompose -- integer\n    \"\"\"\n    arr = [[0 for i in range(decompose + 1)] for j in range(decompose + 1)]\n    arr[1][1] = 1\n    for i in range(1, decompose + 1):\n        for j in range(1, decompose + 1):\n            if i < j:\n                arr[i][j] = arr[i][i]\n            elif i == j:\n                arr[i][j] = 1 + arr[i][j - 1]\n            else:\n                arr[i][j] = arr[i][j - 1] + arr[i - j][j]\n    return arr[decompose][decompose]\n"
  },
  {
    "id": 50,
    "category": "dp",
    "file_name": "hosoya_triangle",
    "codes": "\"\"\"\nHosoya triangle (originally Fibonacci triangle) is a triangular arrangement\nof numbers, where if you take any number it is the sum of 2 numbers above.\nFirst line is always 1, and second line is always {1     1}.\n\nThis printHosoya function takes argument n which is the height of the triangle\n(number of lines).\n\nFor example:\nprintHosoya( 6 ) would return:\n1\n1 1\n2 1 2\n3 2 2 3\n5 3 4 3 5\n8 5 6 6 5 8\n\nThe complexity is O(n^3).\n\n\"\"\"\n\ndef hosoya(height, width):\n    \"\"\" Calculates the hosoya triangle\n\n    height -- height of the triangle\n    \"\"\"\n    if (width == 0) and (height in (0,1)):\n        return 1\n    if (width == 1) and (height in (1,2)):\n        return 1\n    if height > width:\n        return hosoya(height - 1, width) + hosoya(height - 2, width)\n    if width == height:\n        return hosoya(height - 1, width - 1) + hosoya(height - 2, width - 2)\n    return 0\n\ndef print_hosoya(height):\n    \"\"\"Prints the hosoya triangle\n\n    height -- height of the triangle\n    \"\"\"\n    for i in range(height):\n        for j in range(i + 1):\n            print(hosoya(i, j) , end = \" \")\n        print (\"\\n\", end = \"\")\n\ndef hosoya_testing(height):\n    \"\"\"Test hosoya function\n\n    height -- height of the triangle\n    \"\"\"\n    res = []\n    for i in range(height):\n        for j in range(i + 1):\n            res.append(hosoya(i, j))\n    return res\n"
  },
  {
    "id": 51,
    "category": "dp",
    "file_name": "max_subarray",
    "codes": "\ndef max_subarray(array):\n    max_so_far = max_now = array[0]\n    for i in range(1, len(array)):\n        max_now = max(array[i], max_now + array[i])\n        max_so_far = max(max_so_far, max_now)\n    return max_so_far\n\na = [1, 2, -3, 4, 5, -7, 23]\nprint(a)\nprint(max_subarray(a))\n"
  },
  {
    "id": 52,
    "category": "dp",
    "file_name": "combination_sum",
    "codes": "\"\"\"\nGiven an integer array with all positive numbers and no duplicates,\nfind the number of possible combinations that\nadd up to a positive integer target.\n\nExample:\n\nnums = [1, 2, 3]\ntarget = 4\n\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\nNote that different sequences are counted as different combinations.\n\nTherefore the output is 7.\nFollow up:\nWhat if negative numbers are allowed in the given array?\nHow does it change the problem?\nWhat limitation we need to add to the question to allow negative numbers?\n\n\"\"\"\n\nDP = None\n\ndef helper_topdown(nums, target):\n    \"\"\"Generates DP and finds result.\n\n    Keyword arguments:\n    nums -- positive integer array without duplicates\n    target -- integer describing what a valid combination should add to\n    \"\"\"\n    if DP[target] != -1:\n        return DP[target]\n    res = 0\n    for num in nums:\n        if target >= num:\n            res += helper_topdown(nums, target - num)\n    DP[target] = res\n    return res\n\n\ndef combination_sum_topdown(nums, target):\n    \"\"\"Find number of possible combinations in nums that add up to target, in top-down manner.\n\n    Keyword arguments:\n    nums -- positive integer array without duplicates\n    target -- integer describing what a valid combination should add to\n    \"\"\"\n    global DP\n    DP = [-1] * (target + 1)\n    DP[0] = 1\n    return helper_topdown(nums, target)\n\ndef combination_sum_bottom_up(nums, target):\n    \"\"\"Find number of possible combinations in nums that add up to target, in bottom-up manner.\n\n    Keyword arguments:\n    nums -- positive integer array without duplicates\n    target -- integer describing what a valid combination should add to\n    \"\"\"\n    combs = [0] * (target + 1)\n    combs[0] = 1\n    for i in range(0, len(combs)):\n        for num in nums:\n            if i - num >= 0:\n                combs[i] += combs[i - num]\n    return combs[target]\n"
  },
  {
    "id": 53,
    "category": "dp",
    "file_name": "max_product_subarray",
    "codes": "\"\"\"\nFind the contiguous subarray within an array\n(containing at least one number) which has the largest product.\n\nFor example, given the array [2,3,-2,4],\nthe contiguous subarray [2,3] has the largest product = 6.\n\"\"\"\nfrom functools import reduce\n\n\ndef max_product(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    lmin = lmax = gmax = nums[0]\n    for num in nums:\n        t_1 = num * lmax\n        t_2 = num * lmin\n        lmax = max(max(t_1, t_2), num)\n        lmin = min(min(t_1, t_2), num)\n        gmax = max(gmax, lmax)\n\n\n\"\"\"\nAnother approach that would print max product and the subarray\n\nExamples:\nsubarray_with_max_product([2,3,6,-1,-1,9,5])\n    #=> max_product_so_far: 45, [-1, -1, 9, 5]\nsubarray_with_max_product([-2,-3,6,0,-7,-5])\n    #=> max_product_so_far: 36, [-2, -3, 6]\nsubarray_with_max_product([-4,-3,-2,-1])\n    #=> max_product_so_far: 24, [-4, -3, -2, -1]\nsubarray_with_max_product([-3,0,1])\n    #=> max_product_so_far: 1, [1]\n\"\"\"\n\n\ndef subarray_with_max_product(arr):\n    ''' arr is list of positive/negative numbers '''\n    length = len(arr)\n    product_so_far = max_product_end = 1\n    max_start_i = 0\n    so_far_start_i = so_far_end_i = 0\n    all_negative_flag = True\n\n    for i in range(length):\n        max_product_end *= arr[i]\n        if arr[i] > 0:\n            all_negative_flag = False\n\n        if max_product_end <= 0:\n            max_product_end = arr[i]\n            max_start_i = i\n\n        if product_so_far <= max_product_end:\n            product_so_far = max_product_end\n            so_far_end_i = i\n            so_far_start_i = max_start_i\n\n    if all_negative_flag:\n        print(f\"max_product_so_far: {reduce(lambda x, y: x * y, arr)}, {arr}\")\n\n    else:\n        print(f\"max_product_so_far: {product_so_far},{arr[so_far_start_i:so_far_end_i + 1]}\")\n"
  },
  {
    "id": 54,
    "category": "automata",
    "file_name": "dfa",
    "codes": "def DFA(transitions, start, final, string):\n\n    num = len(string)\n    num_final = len(final)\n    cur = start\n\n    for i in range(num):\n\n        if transitions[cur][string[i]] is None:\n            return False\n        else:\n            cur = transitions[cur][string[i]]\n\n    for i in range(num_final):\n        if cur == final[i]:\n            return True\n    return False\n"
  },
  {
    "id": 55,
    "category": "path",
    "file_name": "full_path",
    "codes": "\"\"\"\nGet a full absolute path a file\n\"\"\"\nimport os\ndef full_path(file):\n    return os.path.abspath(os.path.expanduser(file))\n"
  },
  {
    "id": 56,
    "category": "path",
    "file_name": "simplify_path",
    "codes": "\"\"\"\nGiven an absolute path for a file (Unix-style), simplify it.\n\nFor example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n\nCorner Cases:\n\nDid you consider the case where path = \"/../\"?\nIn this case, you should return \"/\".\nAnother corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\nIn this case, you should ignore redundant slashes and return \"/home/foo\".\n\nReference: https://leetcode.com/problems/simplify-path/description/\n\"\"\"\n\nimport os\ndef simplify_path_v1(path):\n    return os.path.abspath(path)\n\ndef simplify_path_v2(path):\n    stack, tokens = [], path.split(\"/\")\n    for token in tokens:\n        if token == \"..\" and stack:\n            stack.pop()\n        elif token != \"..\" and token != \".\" and token:\n            stack.append(token)\n    return \"/\" + \"/\".join(stack)\n"
  },
  {
    "id": 57,
    "category": "path",
    "file_name": "join_with_slash",
    "codes": "\"\"\"\nBoth URL and file path joins use slashes as dividers between their parts.\nFor example:\n\npath/to/dir + file --> path/to/dir/file\npath/to/dir/ + file --> path/to/dir/file\nhttp://algorithms.com/ + part --> http://algorithms.com/part\nhttp://algorithms.com + part --> http://algorithms/part\n\"\"\"\nimport os\n\ndef join_with_slash(base, suffix):\n    # Remove / trailing\n    base = base.rstrip('/')\n    # Remove / leading\n    suffix = suffix.lstrip('/').rstrip()\n    full_path = \"{}/{}\".format(base, suffix)\n    return full_path\n"
  },
  {
    "id": 58,
    "category": "path",
    "file_name": "split",
    "codes": "\"\"\"\nSplitting a path into 2 parts\nExample:\nInput: https://algorithms/unix/test.py   (for url)\nOutput:\n    part[0]: https://algorithms/unix\n    part[1]: test.py\n\nInput: algorithms/unix/test.py          (for file path)\nOutput:\n    part[0]: algorithms/unix\n    part[1]: test.py\n\"\"\"\nimport os\n\ndef split(path):\n    parts = []\n    split_part = path.rpartition('/')\n    # Takt the origin path without the last part\n    parts.append(split_part[0])\n    # Take the last element of list\n    parts.append(split_part[2])\n    return parts\n"
  },
  {
    "id": 59,
    "category": "strings",
    "file_name": "longest_palindromic_substring",
    "codes": "'''\nGiven string s, find the longest palindromic substring.\n\nExample1:\n\n* input: \"dasdasdasdasdasdadsa\"\n* output: \"asdadsa\"\n\nExample2:\n\n* input: \"acdbbdaa\"\n* output: \"dbbd\"\n\nManacher's algorithm\n\n'''\n\ndef longest_palindrome(s):\n    if len(s) < 2:\n        return s\n\n    n_str = '#' + '#'.join(s) + '#'\n    p = [0] * len(n_str)\n    mx, loc = 0, 0\n    index, maxlen = 0, 0\n    for i in range(len(n_str)):\n        if i < mx and 2 * loc - i < len(n_str):\n            p[i] = min(mx - i, p[2 * loc - i])\n        else:\n            p[i] = 1\n\n        while p[i] + i < len(n_str) and i - p[i] >= 0 and n_str[\n                i - p[i]] == n_str[i + p[i]]:\n            p[i] += 1\n\n        if i + p[i] > mx:\n            mx = i + p[i]\n            loc = i\n\n        if p[i] > maxlen:\n            index = i\n            maxlen = p[i]\n    s = n_str[index - p[index] + 1:index + p[index]]\n    return s.replace('#', '')\n"
  },
  {
    "id": 60,
    "category": "strings",
    "file_name": "encode_decode",
    "codes": "\"\"\" Design an algorithm to encode a list of strings to a string.\n The encoded mystring is then sent over the network and is decoded\n back to the original list of strings.\n\"\"\"\n\n# Implement the encode and decode methods.\n\ndef encode(strs):\n    \"\"\"Encodes a list of strings to a single string.\n    :type strs: List[str]\n    :rtype: str\n    \"\"\"\n    res = ''\n    for string in strs.split():\n        res += str(len(string)) + \":\" + string\n    return res\n\ndef decode(s):\n    \"\"\"Decodes a single string to a list of strings.\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    strs = []\n    i = 0\n    while i < len(s):\n        index = s.find(\":\", i)\n        size = int(s[i:index])\n        strs.append(s[index+1: index+1+size])\n        i = index+1+size\n    return strs"
  },
  {
    "id": 61,
    "category": "strings",
    "file_name": "reverse_string",
    "codes": "def recursive(s):\n    l = len(s)\n    if l < 2:\n        return s\n    return recursive(s[l//2:]) + recursive(s[:l//2])\n\ndef iterative(s):\n    r = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        r[i], r[j] = r[j], r[i]\n        i += 1\n        j -= 1\n    return \"\".join(r)\n\ndef pythonic(s):\n    r = list(reversed(s))\n    return \"\".join(r)\n\ndef ultra_pythonic(s):\n    return s[::-1]\n"
  },
  {
    "id": 62,
    "category": "strings",
    "file_name": "count_binary_substring",
    "codes": "\"\"\"\nGive a string s, count the number of non-empty (contiguous) substrings that have\n the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur.\nExample 1:\nInput: \"00110011\"\nOutput: 6\nExplanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\n\nNotice that some of these substrings repeat and are counted the number of times they occur.\n\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\nExample 2:\nInput: \"10101\"\nOutput: 4\nExplanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\nReference: https://leetcode.com/problems/count-binary-substrings/description/\n\"\"\"\ndef count_binary_substring(s):\n    cur = 1\n    pre = 0\n    count = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i - 1]:\n            count = count + min(pre, cur)\n            pre = cur\n            cur = 1\n        else:\n            cur = cur + 1\n    count = count + min(pre, cur)\n    return count\n"
  },
  {
    "id": 63,
    "category": "strings",
    "file_name": "int_to_roman",
    "codes": "\"\"\"\nGiven an integer, convert it to a roman numeral.\nInput is guaranteed to be within the range from 1 to 3999.\n\"\"\"\n\ndef int_to_roman(num):\n    \"\"\"\n    :type num: int\n    :rtype: str\n    \"\"\"\n    m = [\"\", \"M\", \"MM\", \"MMM\"];\n    c = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\n    x = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\n    i = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\n    return m[num//1000] + c[(num%1000)//100] + x[(num%100)//10] + i[num%10];\n"
  },
  {
    "id": 64,
    "category": "strings",
    "file_name": "panagram",
    "codes": "\"\"\"\nGiven a string, check whether it is a panagram or not.\n\nA panagram is a sentence that uses every letter at least once.\n\nThe most famous example is: \"he quick brown fox jumps over the lazy dog.\n\nNote:\nA panagram in one language isn't necessarily a panagram in another. This\nmodule assumes the english language. Hence, the Finnish panagram\n'T\u00f6rkylempij\u00e4vongahdus' won't pass for a panagram despite being considered\na perfect panagram in its language. However, the Swedish panagram\n'Yxm\u00f6rdaren Julia Blomqvist p\u00e5 f\u00e4ktning i Schweiz' will pass despite\nincluding letters not used in the english alphabet. This is because the\nSwedish alphabet only extends the Latin one.\n\"\"\"\n\nfrom string import ascii_lowercase\n\ndef panagram(string):\n    \"\"\"\n    Returns whether the input string is an English panagram or not.\n\n        Parameters:\n            string (str): A sentence in the form of a string.\n\n        Returns:\n            A boolean with the result.\n    \"\"\"\n    letters = set(ascii_lowercase)\n    for c in string:\n        try:\n            letters.remove(c.lower())\n        except:\n            pass\n    return len(letters) == 0"
  },
  {
    "id": 65,
    "category": "strings",
    "file_name": "judge_circle",
    "codes": "\"\"\"\nInitially, there is a Robot at position (0, 0). Given a sequence of its moves,\njudge if this robot makes a circle, which means it moves back to the original place.\n\nThe move sequence is represented by a string. And each move is represent by a\ncharacter. The valid robot moves are R (Right), L (Left), U (Up) and D (down).\nThe output should be true or false representing whether the robot makes a circle.\n\nExample 1:\nInput: \"UD\"\nOutput: true\nExample 2:\nInput: \"LL\"\nOutput: false\n\"\"\"\ndef judge_circle(moves):\n    dict_moves = {\n        'U' : 0,\n        'D' : 0,\n        'R' : 0,\n        'L' : 0\n    }\n    for char in moves:\n        dict_moves[char] = dict_moves[char] + 1\n    return dict_moves['L'] == dict_moves['R'] and dict_moves['U'] == dict_moves['D']\n"
  },
  {
    "id": 66,
    "category": "strings",
    "file_name": "unique_morse",
    "codes": "\"\"\"\nInternational Morse Code defines a standard encoding where each letter is mapped to\na series of dots and dashes, as follows: \"a\" maps to \".-\", \"b\" maps to \"-...\", \"c\"\nmaps to \"-.-.\", and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n        'a':\".-\",\n        'b':\"-...\",\n        'c':\"-.-.\",\n        'd': \"-..\",\n        'e':\".\",\n        'f':\"..-.\",\n        'g':\"--.\",\n        'h':\"....\",\n        'i':\"..\",\n        'j':\".---\",\n        'k':\"-.-\",\n        'l':\".-..\",\n        'm':\"--\",\n        'n':\"-.\",\n        'o':\"---\",\n        'p':\".--.\",\n        'q':\"--.-\",\n        'r':\".-.\",\n        's':\"...\",\n        't':\"-\",\n        'u':\"..-\",\n        'v':\"...-\",\n        'w':\".--\",\n        'x':\"-..-\",\n        'y':\"-.--\",\n        'z':\"--..\"\n\nNow, given a list of words, each word can be written as a concatenation of the\nMorse code of each letter. For example, \"cab\" can be written as \"-.-.-....-\",\n(which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a\nconcatenation, the transformation of a word.\n\nReturn the number of different transformations among all words we have.\nExample:\nInput: words = [\"gin\", \"zen\", \"gig\", \"msg\"]\nOutput: 2\nExplanation:\nThe transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\n\nThere are 2 different transformations, \"--...-.\" and \"--...--.\".\n\"\"\"\n\nmorse_code = {\n    'a':\".-\",\n    'b':\"-...\",\n    'c':\"-.-.\",\n    'd': \"-..\",\n    'e':\".\",\n    'f':\"..-.\",\n    'g':\"--.\",\n    'h':\"....\",\n    'i':\"..\",\n    'j':\".---\",\n    'k':\"-.-\",\n    'l':\".-..\",\n    'm':\"--\",\n    'n':\"-.\",\n    'o':\"---\",\n    'p':\".--.\",\n    'q':\"--.-\",\n    'r':\".-.\",\n    's':\"...\",\n    't':\"-\",\n    'u':\"..-\",\n    'v':\"...-\",\n    'w':\".--\",\n    'x':\"-..-\",\n    'y':\"-.--\",\n    'z':\"--..\"\n}\ndef convert_morse_word(word):\n    morse_word = \"\"\n    word = word.lower()\n    for char in word:\n        morse_word = morse_word + morse_code[char]\n    return morse_word\n\ndef unique_morse(words):\n    unique_morse_word = []\n    for word in words:\n        morse_word = convert_morse_word(word)\n        if morse_word not in unique_morse_word:\n            unique_morse_word.append(morse_word)\n    return len(unique_morse_word)\n"
  },
  {
    "id": 67,
    "category": "strings",
    "file_name": "longest_common_prefix",
    "codes": "\"\"\"\nWrite a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\nExample 1:\nInput: [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nExample 2:\nInput: [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\nReference: https://leetcode.com/problems/longest-common-prefix/description/\n\"\"\"\n\n\"\"\"\nFirst solution: Horizontal scanning\n\"\"\"\ndef common_prefix(s1, s2):\n    \"Return prefix common of 2 strings\"\n    if not s1 or not s2:\n        return \"\"\n    k = 0\n    while s1[k] == s2[k]:\n        k = k + 1\n        if k >= len(s1) or k >= len(s2):\n            return s1[0:k]\n    return s1[0:k]\n\ndef longest_common_prefix_v1(strs):\n    if not strs:\n        return \"\"\n    result = strs[0]\n    for i in range(len(strs)):\n        result = common_prefix(result, strs[i])\n    return result\n\n\"\"\"\nSecond solution: Vertical scanning\n\"\"\"\ndef longest_common_prefix_v2(strs):\n    if not strs:\n        return \"\"\n    for i in range(len(strs[0])):\n        for string in strs[1:]:\n            if i == len(string) or string[i] != strs[0][i]:\n                return strs[0][0:i]\n    return strs[0]\n\n\"\"\"\nThird solution: Divide and Conquer\n\"\"\"\ndef longest_common_prefix_v3(strs):\n    if not strs:\n        return \"\"\n    return longest_common(strs, 0, len(strs) -1)\n\ndef longest_common(strs, left, right):\n    if left == right:\n        return strs[left]\n    mid = (left + right) // 2\n    lcp_left = longest_common(strs, left, mid)\n    lcp_right = longest_common(strs, mid + 1, right)\n    return common_prefix(lcp_left, lcp_right)\n"
  },
  {
    "id": 68,
    "category": "strings",
    "file_name": "one_edit_distance",
    "codes": "\"\"\"\nGiven two strings S and T, determine if they are both one edit distance apart.\n\"\"\"\n\n\ndef is_one_edit(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    if len(s) > len(t):\n        return is_one_edit(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            return s[i+1:] == t[i+1:] or s[i:] == t[i+1:]\n    return True\n\n\ndef is_one_edit2(s, t):\n    l1, l2 = len(s), len(t)\n    if l1 > l2:\n        return is_one_edit2(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if l1 == l2:\n                s = s[:i]+t[i]+s[i+1:]  # modify\n            else:\n                s = s[:i]+t[i]+s[i:]  # insertion\n            break\n    return s == t or s == t[:-1]\n"
  },
  {
    "id": 69,
    "category": "strings",
    "file_name": "reverse_words",
    "codes": "\ndef reverse(array, i, j):\n    while i < j:\n        array[i], array[j] = array[j], array[i]\n        i += 1\n        j -= 1\n\n\ndef reverse_words(string):\n    arr = string.strip().split()  # arr is list of words\n    n = len(arr)\n    reverse(arr, 0, n-1)\n\n    return \" \".join(arr)\n\n\nif __name__ == \"__main__\":\n    test = \"I am keon kim and I like pizza\"\n    print(test)\n    print(reverse_words(test))\n"
  },
  {
    "id": 70,
    "category": "strings",
    "file_name": "is_palindrome",
    "codes": "\"\"\"\nGiven a string, determine if it is a palindrome,\nconsidering only alphanumeric characters and ignoring cases.\nFor example,\n\"A man, a plan, a canal: Panama\" is a palindrome.\n\"race a car\" is not a palindrome.\nNote:\nHave you consider that the string might be empty?\nThis is a good question to ask during an interview.\nFor the purpose of this problem,\nwe define empty string as valid palindrome.\n\"\"\"\nfrom string import ascii_letters\nfrom collections import deque\n\n\ndef is_palindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    i = 0\n    j = len(s)-1\n    while i < j:\n        while not s[i].isalnum():\n            i += 1\n        while not s[j].isalnum():\n            j -= 1\n        if s[i].lower() != s[j].lower():\n            return False\n        i, j = i+1, j-1\n    return True\n\n\"\"\"\nHere is a bunch of other variations of is_palindrome function.\n\nVariation 1:\nFind the reverse of the string and compare it with the original string\n\nVariation 2:\nLoop from the start to length/2 and check the first character and last character\nand so on... for instance s[0] compared with s[n-1], s[1] == s[n-2]...\n\nVariation 3:\nUsing stack idea. \n\nNote: We are assuming that we are just checking a one word string. To check if a complete sentence \n\"\"\"  \ndef remove_punctuation(s):\n    \"\"\"\n    Remove punctuation, case sensitivity and spaces\n    \"\"\"\n    return \"\".join(i.lower() for i in s if i in ascii_letters)\n\n# Variation 1\ndef string_reverse(s):\n\treturn s[::-1]\n\ndef is_palindrome_reverse(s):\n\ts = remove_punctuation(s)\n\t\n\t# can also get rid of the string_reverse function and just do this return s == s[::-1] in one line.\n\tif (s == string_reverse(s)): \n\t\treturn True\n\treturn False\t\n\n\n# Variation 2\ndef is_palindrome_two_pointer(s):\n    s = remove_punctuation(s)\n\t\n    for i in range(0, len(s)//2):\n        if (s[i] != s[len(s) - i - 1]):\n            return False\n    return True\n\t\n\n# Variation 3\ndef is_palindrome_stack(s):\n    stack = []\n    s = remove_punctuation(s)\n\t\n    for i in range(len(s)//2, len(s)):\n        stack.append(s[i])\n    for i in range(0, len(s)//2):\n        if s[i] != stack.pop():\n            return False\n    return True\t\n\n# Variation 4 (using deque)\ndef is_palindrome_deque(s):\n    s = remove_punctuation(s)\n    deq = deque()\n    for char in s:\n        deq.appendleft(char)\n\n    equal = True\n\n    while len(deq) > 1 and equal:\n        first = deq.pop()\n        last = deq.popleft()\n        if first != last :\n            equal = False\n\n    return equal\n"
  },
  {
    "id": 71,
    "category": "strings",
    "file_name": "atbash_cipher",
    "codes": "\"\"\"\nAtbash cipher is mapping the alphabet to it's reverse.\nSo if we take \"a\" as it is the first letter, we change it to the last - z.\n\nExample:\nAttack at dawn --> Zggzxp zg wzdm\n\nComplexity: O(n)\n\"\"\"\n\ndef atbash(s):\n    translated = \"\"\n    for i in range(len(s)):\n        n = ord(s[i])\n        \n        if s[i].isalpha():\n            \n            if s[i].isupper():\n                x = n - ord('A')\n                translated += chr(ord('Z') - x)\n            \n            if s[i].islower():\n                x = n - ord('a')\n                translated += chr(ord('z') - x)\n        else:\n            translated += s[i]\n    return translated"
  },
  {
    "id": 72,
    "category": "strings",
    "file_name": "rabin_karp",
    "codes": "# Following program is the python implementation of\n# Rabin Karp Algorithm\n\nclass RollingHash:\n    def __init__(self, text, size_word):\n        self.text = text\n        self.hash = 0\n        self.size_word = size_word\n\n        for i in range(0, size_word):\n            #ord maps the character to a number\n            #subtract out the ASCII value of \"a\" to start the indexing at zero\n            self.hash += (ord(self.text[i]) - ord(\"a\")+1)*(26**(size_word - i -1))\n\n        #start index of current window\n        self.window_start = 0\n        #end of index window\n        self.window_end = size_word\n\n    def move_window(self):\n        if self.window_end <= len(self.text) - 1:\n            #remove left letter from hash value\n            self.hash -= (ord(self.text[self.window_start]) - ord(\"a\")+1)*26**(self.size_word-1)\n            self.hash *= 26\n            self.hash += ord(self.text[self.window_end])- ord(\"a\")+1\n            self.window_start += 1\n            self.window_end += 1\n\n    def window_text(self):\n        return self.text[self.window_start:self.window_end]\n\ndef rabin_karp(word, text):\n    if word == \"\" or text == \"\":\n        return None\n    if len(word) > len(text):\n        return None\n\n    rolling_hash = RollingHash(text, len(word))\n    word_hash = RollingHash(word, len(word))\n    #word_hash.move_window()\n\n    for i in range(len(text) - len(word) + 1):\n        if rolling_hash.hash == word_hash.hash:\n            if rolling_hash.window_text() == word:\n                return i\n        rolling_hash.move_window()\n    return None\n\n"
  },
  {
    "id": 73,
    "category": "strings",
    "file_name": "breaking_bad",
    "codes": "\"\"\"\nGiven an api which returns an array of words and an array of symbols, display\nthe word with their matched symbol surrounded by square brackets.\n\nIf the word string matches more than one symbol, then choose the one with\nlongest length. (ex. 'Microsoft' matches 'i' and 'cro'):\n\nExample:\nWords array: ['Amazon', 'Microsoft', 'Google']\nSymbols: ['i', 'Am', 'cro', 'Na', 'le', 'abc']\n\nOutput:\n[Am]azon, Mi[cro]soft, Goog[le]\n\nMy solution(Wrong):\n(I sorted the symbols array in descending order of length and ran loop over\nwords array to find a symbol match(using indexOf in javascript) which\nworked. But I didn't make it through the interview, I am guessing my solution\nwas O(n^2) and they expected an efficient algorithm.\n\noutput:\n['[Am]azon', 'Mi[cro]soft', 'Goog[le]', 'Amaz[o]n', 'Micr[o]s[o]ft', 'G[o][o]gle']\n\"\"\"\n\nfrom functools import reduce\n\n\ndef match_symbol(words, symbols):\n    import re\n    combined = []\n    for s in symbols:\n        for c in words:\n            r = re.search(s, c)\n            if r:\n                combined.append(re.sub(s, \"[{}]\".format(s), c))\n    return combined\n\ndef match_symbol_1(words, symbols):\n    res = []\n    # reversely sort the symbols according to their lengths.\n    symbols = sorted(symbols, key=lambda _: len(_), reverse=True)\n    for word in words:\n        for symbol in symbols:\n            word_replaced = ''\n            # once match, append the `word_replaced` to res, process next word\n            if word.find(symbol) != -1:\n                word_replaced = word.replace(symbol, '[' + symbol + ']')\n                res.append(word_replaced)\n                break\n        # if this word matches no symbol, append it.\n        if word_replaced == '':\n            res.append(word)\n    return res\n\n\"\"\"\nAnother approach is to use a Tree for the dictionary (the symbols), and then\nmatch brute force. The complexity will depend on the dictionary;\nif all are suffixes of the other, it will be n*m\n(where m is the size of the dictionary). For example, in Python:\n\"\"\"\n\n\nclass TreeNode:\n    def __init__(self):\n        self.c = dict()\n        self.sym = None\n\n\ndef bracket(words, symbols):\n    root = TreeNode()\n    for s in symbols:\n        t = root\n        for char in s:\n            if char not in t.c:\n                t.c[char] = TreeNode()\n            t = t.c[char]\n        t.sym = s\n    result = dict()\n    for word in words:\n        i = 0\n        symlist = list()\n        while i < len(word):\n            j, t = i, root\n            while j < len(word) and word[j] in t.c:\n                t = t.c[word[j]]\n                if t.sym is not None:\n                    symlist.append((j + 1 - len(t.sym), j + 1, t.sym))\n                j += 1\n            i += 1\n        if len(symlist) > 0:\n            sym = reduce(lambda x, y: x if x[1] - x[0] >= y[1] - y[0] else y,\n                         symlist)\n            result[word] = \"{}[{}]{}\".format(word[:sym[0]], sym[2],\n                                             word[sym[1]:])\n    return tuple(word if word not in result else result[word] for word in words)\n"
  },
  {
    "id": 74,
    "category": "strings",
    "file_name": "min_distance",
    "codes": "\"\"\"\nGiven two words word1 and word2, find the minimum number of steps required to\nmake word1 and word2 the same, where in each step you can delete one character\nin either string.\n\nFor example:\nInput: \"sea\", \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".\n\nReference: https://leetcode.com/problems/delete-operation-for-two-strings/description/\n\"\"\"\n\ndef min_distance(word1, word2):\n    \"\"\"\n    Finds minimum distance by getting longest common subsequence\n\n    :type word1: str\n    :type word2: str\n    :rtype: int\n    \"\"\"\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))\n\ndef lcs(word1, word2, i, j):\n    \"\"\"\n    The length of longest common subsequence among the two given strings word1 and word2\n    \"\"\"\n    if i == 0 or j == 0:\n        return 0\n    if word1[i - 1] == word2[j - 1]:\n        return 1 + lcs(word1, word2, i - 1, j - 1)\n    return max(lcs(word1, word2, i - 1, j), lcs(word1, word2, i, j - 1))\n\ndef min_distance_dp(word1, word2):\n    \"\"\"\n    Finds minimum distance in a dynamic programming manner\n    TC: O(length1*length2), SC: O(length1*length2)\n\n    :type word1: str\n    :type word2: str\n    :rtype: int\n    \"\"\"\n    length1, length2 = len(word1)+1, len(word2)+1\n    res = [[0 for _ in range(length2)] for _ in range(length1)]\n\n    if length1 == length2:\n        for i in range(1, length1):\n            res[i][0], res[0][i] = i, i\n    else:\n        for i in range(length1):\n            res[i][0] = i\n        for i in range(length2):\n            res[0][i] = i\n\n    for i in range(1, length1):\n        for j in range(1, length2):\n            if word1[i-1] == word2[j-1]:\n                res[i][j] = res[i-1][j-1]\n            else:\n                res[i][j] = min(res[i-1][j], res[i][j-1]) + 1\n\n    return res[len(word1)][len(word2)]\n"
  },
  {
    "id": 75,
    "category": "strings",
    "file_name": "first_unique_char",
    "codes": "\"\"\"\nGiven a string, find the first non-repeating character in it and return it's\nindex. If it doesn't exist, return -1.\n\nFor example:\ns = \"leetcode\"\nreturn 0.\n\ns = \"loveleetcode\",\nreturn 2.\n\nReference: https://leetcode.com/problems/first-unique-character-in-a-string/description/\n\"\"\"\ndef first_unique_char(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if (len(s) == 1):\n        return 0\n    ban = []\n    for i in range(len(s)):\n        if all(s[i] != s[k] for k in range(i + 1, len(s))) == True and s[i] not in ban:\n            return i\n        else:\n            ban.append(s[i])\n    return -1   \n"
  },
  {
    "id": 76,
    "category": "strings",
    "file_name": "multiply_strings",
    "codes": "\"\"\"\nGiven two non-negative integers num1 and num2 represented as strings,\nreturn the product of num1 and num2.\n\nNote:\n\nThe length of both num1 and num2 is < 110.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert\nthe inputs to integer directly.\n\"\"\"\n\n\ndef multiply(num1: \"str\", num2: \"str\") -> \"str\":\n    interm = []\n    zero = ord('0')\n    i_pos = 1\n    for i in reversed(num1):\n        j_pos = 1\n        add = 0\n        for j in reversed(num2):\n            mult = (ord(i)-zero) * (ord(j)-zero) * j_pos * i_pos\n            j_pos *= 10\n            add += mult\n        i_pos *= 10\n        interm.append(add)\n    return str(sum(interm))\n\n\nif __name__ == \"__main__\":\n    print(multiply(\"1\", \"23\"))\n    print(multiply(\"23\", \"23\"))\n    print(multiply(\"100\", \"23\"))\n    print(multiply(\"100\", \"10000\"))\n"
  },
  {
    "id": 77,
    "category": "strings",
    "file_name": "decode_string",
    "codes": "# Given an encoded string, return it's decoded string.\n\n# The encoding rule is: k[encoded_string], where the encoded_string\n# inside the square brackets is being repeated exactly k times.\n# Note that k is guaranteed to be a positive integer.\n\n# You may assume that the input string is always valid; No extra white spaces,\n# square brackets are well-formed, etc.\n\n# Furthermore, you may assume that the original data does not contain any\n# digits and that digits are only for those repeat numbers, k.\n# For example, there won't be input like 3a or 2[4].\n\n# Examples:\n\n# s = \"3[a]2[bc]\", return \"aaabcbc\".\n# s = \"3[a2[c]]\", return \"accaccacc\".\n# s = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\n\ndef decode_string(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    stack = []; cur_num = 0; cur_string = ''\n    for c in s:\n        if c == '[':\n            stack.append((cur_string, cur_num))\n            cur_string = ''\n            cur_num = 0\n        elif c == ']':\n            prev_string, num = stack.pop()\n            cur_string = prev_string + num * cur_string\n        elif c.isdigit():\n            cur_num = cur_num*10 + int(c)\n        else:\n            cur_string += c\n    return cur_string\n"
  },
  {
    "id": 78,
    "category": "strings",
    "file_name": "caesar_cipher",
    "codes": "\n\"\"\"\nJulius Caesar protected his confidential information by encrypting it using a cipher.\nCaesar's cipher shifts each letter by a number of letters. If the shift takes you\npast the end of the alphabet, just rotate back to the front of the alphabet.\nIn the case of a rotation by 3, w, x, y and z would map to z, a, b and c.\nOriginal alphabet:      abcdefghijklmnopqrstuvwxyz\nAlphabet rotated +3:    defghijklmnopqrstuvwxyzabc\n\"\"\"\ndef caesar_cipher(s, k):\n    result = \"\"\n    for char in s:\n        n = ord(char)\n        if 64 < n < 91:\n            n = ((n - 65 + k) % 26) + 65\n        if 96 < n < 123:\n            n = ((n - 97 + k) % 26) + 97\n        result = result + chr(n)\n    return result\n"
  },
  {
    "id": 79,
    "category": "strings",
    "file_name": "strong_password",
    "codes": "\"\"\"\nThe signup page required her to input a name and a password. However, the password\nmust be strong. The website considers a password to be strong if it satisfies the following criteria:\n\n1) Its length is at least 6.\n2) It contains at least one digit.\n3) It contains at least one lowercase English character.\n4) It contains at least one uppercase English character.\n5) It contains at least one special character. The special characters are: !@#$%^&*()-+\nShe typed a random string of length  in the password field but wasn't sure if it was strong.\nGiven the string she typed, can you find the minimum number of characters she must add to make her password strong?\n\nNote: Here's the set of types of characters in a form you can paste in your solution:\nnumbers = \"0123456789\"\nlower_case = \"abcdefghijklmnopqrstuvwxyz\"\nupper_case = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nspecial_characters = \"!@#$%^&*()-+\"\n\nInput Format\nThe first line contains an integer  denoting the length of the string.\nThe second line contains a string consisting of  characters, the password\ntyped by Louise. Each character is either a lowercase/uppercase English alphabet, a digit, or a special character.\n\nSample Input 1: strong_password(3,\"Ab1\")\nOutput: 3 (Because She can make the password strong by adding  characters,for example, $hk, turning the password into Ab1$hk which is strong.\n2 characters aren't enough since the length must be at least 6.)\n\nSample Output 2: strong_password(11,\"#Algorithms\")\nOutput: 1 (Because the password isn't strong, but she can make it strong by adding a single digit.)\n\n\"\"\"\ndef strong_password(n, password):\n    count_error = 0\n    # Return the minimum number of characters to make the password strong\n    if any(i.isdigit() for i in password) == False:\n        count_error = count_error + 1\n    if any(i.islower() for i in password) == False:\n        count_error = count_error + 1\n    if any(i.isupper() for i in password) == False:\n        count_error = count_error + 1\n    if any(i in '!@#$%^&*()-+' for i in password) == False:\n        count_error = count_error + 1\n    return max(count_error, 6 - n)\n"
  },
  {
    "id": 80,
    "category": "strings",
    "file_name": "make_sentence",
    "codes": "\"\"\"\nFor a given string and dictionary, how many sentences can you make from the\nstring, such that all the words are contained in the dictionary.\n\neg: for given string -> \"appletablet\"\n\"apple\", \"tablet\"\n\"applet\", \"able\", \"t\"\n\"apple\", \"table\", \"t\"\n\"app\", \"let\", \"able\", \"t\"\n\n\"applet\", {app, let, apple, t, applet} => 3\n\"thing\", {\"thing\"} -> 1\n\"\"\"\n\ncount = 0\n\n\ndef make_sentence(str_piece, dictionaries):\n    global count\n    if len(str_piece) == 0:\n        return True\n    for i in range(0, len(str_piece)):\n        prefix, suffix = str_piece[0:i], str_piece[i:]\n        if prefix in dictionaries:\n            if suffix in dictionaries or make_sentence(suffix, dictionaries):\n                count += 1\n    return True\n"
  },
  {
    "id": 81,
    "category": "strings",
    "file_name": "validate_coordinates",
    "codes": "\"\"\"\"\nCreate a function that will validate if given parameters are valid geographical coordinates.\nValid coordinates look like the following: \"23.32353342, -32.543534534\". The return value should be either true or false.\nLatitude (which is first float) can be between 0 and 90, positive or negative. Longitude (which is second float) can be between 0 and 180, positive or negative.\nCoordinates can only contain digits, or one of the following symbols (including space after comma) -, .\nThere should be no space between the minus \"-\" sign and the digit after it.\n\nHere are some valid coordinates:\n-23, 25\n43.91343345, 143\n4, -3\n\nAnd some invalid ones:\n23.234, - 23.4234\nN23.43345, E32.6457\n6.325624, 43.34345.345\n0, 1,2\n\n\"\"\"\n# I'll be adding my attempt as well as my friend's solution (took us ~ 1 hour)\n\n# my attempt\nimport re\ndef is_valid_coordinates_0(coordinates):\n    for char in coordinates:\n        if not (char.isdigit() or char in ['-', '.', ',', ' ']):\n            return False\n    l = coordinates.split(\", \")\n    if len(l) != 2:\n        return False\n    try:\n        latitude = float(l[0])\n        longitude = float(l[1])\n    except:\n        return False\n    return -90 <= latitude <= 90 and -180 <= longitude <= 180\n\n# friends solutions\ndef is_valid_coordinates_1(coordinates):\n    try:\n        lat, lng = [abs(float(c)) for c in coordinates.split(',') if 'e' not in c]\n    except ValueError:\n        return False\n\n    return lat <= 90 and lng <= 180\n\n# using regular expression\ndef is_valid_coordinates_regular_expression(coordinates):\n    return bool(re.match(\"-?(\\d|[1-8]\\d|90)\\.?\\d*, -?(\\d|[1-9]\\d|1[0-7]\\d|180)\\.?\\d*$\", coordinates))  \n"
  },
  {
    "id": 82,
    "category": "strings",
    "file_name": "roman_to_int",
    "codes": "\"\"\"\nGiven a roman numeral, convert it to an integer.\nInput is guaranteed to be within the range from 1 to 3999.\n\"\"\"\n\n\ndef roman_to_int(s:\"str\")->\"int\":\n    number = 0\n    roman = {'M':1000, 'D':500, 'C': 100, 'L':50, 'X':10, 'V':5, 'I':1}\n    for i in range(len(s)-1):\n        if roman[s[i]] < roman[s[i+1]]:\n            number -= roman[s[i]]\n        else:\n            number += roman[s[i]]\n    return number + roman[s[-1]]\n\n\nif __name__ == \"__main__\":\n    roman = \"DCXXI\"\n    print(roman_to_int(roman))\n"
  },
  {
    "id": 83,
    "category": "strings",
    "file_name": "reverse_vowel",
    "codes": "\ndef reverse_vowel(s):\n    vowels = \"AEIOUaeiou\"\n    i, j = 0, len(s)-1\n    s = list(s)\n    while i < j:\n        while i < j and s[i] not in vowels:\n            i += 1\n        while i < j and s[j] not in vowels:\n            j -= 1\n        s[i], s[j] = s[j], s[i]\n        i, j = i + 1, j - 1\n    return \"\".join(s)\n"
  },
  {
    "id": 84,
    "category": "strings",
    "file_name": "check_pangram",
    "codes": "\"\"\"\nAlgorithm that checks if a given string is a pangram or not\n\"\"\"\n\ndef check_pangram(input_string):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    for ch in alphabet:\n        if ch not in input_string.lower():\n            return False\n    return True "
  },
  {
    "id": 85,
    "category": "strings",
    "file_name": "group_anagrams",
    "codes": "\"\"\"\nGiven an array of strings, group anagrams together.\n\nFor example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\nReturn:\n\n[\n  [\"ate\", \"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n\"\"\"\n\n\ndef group_anagrams(strs):\n    d = {}\n    ans = []\n    k = 0\n    for str in strs:\n        sstr = ''.join(sorted(str))\n        if sstr not in d:\n            d[sstr] = k\n            k += 1\n            ans.append([])\n            ans[-1].append(str)\n        else:\n            ans[d[sstr]].append(str)\n    return ans\n"
  },
  {
    "id": 86,
    "category": "strings",
    "file_name": "contain_string",
    "codes": "\"\"\"\nImplement strStr().\n\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\nExample 1:\nInput: haystack = \"hello\", needle = \"ll\"\nOutput: 2\n\nExample 2:\nInput: haystack = \"aaaaa\", needle = \"bba\"\nOutput: -1\nReference: https://leetcode.com/problems/implement-strstr/description/\n\"\"\"\ndef contain_string(haystack, needle):\n    if len(needle) == 0:\n        return 0\n    if len(needle) > len(haystack):\n        return -1\n    for i in range(len(haystack)):\n        if len(haystack) - i < len(needle):\n            return -1\n        if haystack[i:i+len(needle)] == needle:\n            return i\n    return -1\n"
  },
  {
    "id": 87,
    "category": "strings",
    "file_name": "word_squares",
    "codes": "# Given a set of words (without duplicates),\n# find all word squares you can build from them.\n\n# A sequence of words forms a valid word square\n# if the kth row and column read the exact same string,\n# where 0 \u2264 k < max(numRows, numColumns).\n\n# For example, the word sequence [\"ball\",\"area\",\"lead\",\"lady\"] forms\n# a word square because each word reads the same both horizontally\n# and vertically.\n\n# b a l l\n# a r e a\n# l e a d\n# l a d y\n# Note:\n# There are at least 1 and at most 1000 words.\n# All words will have the exact same length.\n# Word length is at least 1 and at most 5.\n# Each word contains only lowercase English alphabet a-z.\n\n# Example 1:\n\n# Input:\n# [\"area\",\"lead\",\"wall\",\"lady\",\"ball\"]\n\n# Output:\n# [\n  # [ \"wall\",\n    # \"area\",\n    # \"lead\",\n    # \"lady\"\n  # ],\n  # [ \"ball\",\n    # \"area\",\n    # \"lead\",\n    # \"lady\"\n  # ]\n# ]\n\n# Explanation:\n# The output consists of two word squares. The order of output does not matter\n# (just the order of words in each word square matters).\n\nimport collections\n\ndef word_squares(words):\n    n = len(words[0])\n    fulls = collections.defaultdict(list)\n    for word in words:\n        for i in range(n):\n            fulls[word[:i]].append(word)\n\n    def build(square):\n        if len(square) == n:\n            squares.append(square)\n            return\n        prefix = \"\"\n        for k in range(len(square)):\n            prefix += square[k][len(square)]\n        for word in fulls[prefix]:\n            build(square + [word])\n    squares = []\n    for word in words:\n        build([word])\n    return squares\n\n"
  },
  {
    "id": 88,
    "category": "strings",
    "file_name": "is_rotated",
    "codes": "\"\"\"\nGiven two strings s1 and s2, determine if s2 is a rotated version of s1.\nFor example,\nis_rotated(\"hello\", \"llohe\") returns True\nis_rotated(\"hello\", \"helol\") returns False\n\naccepts two strings\nreturns bool\nReference: https://leetcode.com/problems/rotate-string/description/\n\"\"\"\n\ndef is_rotated(s1, s2):\n    if len(s1) == len(s2):\n        return s2 in s1 + s1\n    else:\n        return False\n\n\"\"\"\nAnother solution: brutal force\nComplexity: O(N^2)\n\"\"\"\ndef is_rotated_v1(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    if len(s1) == 0:\n        return True\n\n    for c in range(len(s1)):\n        if all(s1[(c + i) % len(s1)] == s2[i] for i in range(len(s1))):\n            return True\n    return False\n"
  },
  {
    "id": 89,
    "category": "strings",
    "file_name": "add_binary",
    "codes": "\"\"\"\nGiven two binary strings,\nreturn their sum (also a binary string).\n\nFor example,\na = \"11\"\nb = \"1\"\nReturn \"100\".\n\"\"\"\n\n\ndef add_binary(a, b):\n    s = \"\"\n    c, i, j = 0, len(a)-1, len(b)-1\n    zero = ord('0')\n    while (i >= 0 or j >= 0 or c == 1):\n        if (i >= 0):\n            c += ord(a[i]) - zero\n            i -= 1\n        if (j >= 0):\n            c += ord(b[j]) - zero\n            j -= 1\n        s = chr(c % 2 + zero) + s\n        c //= 2 \n        \n    return s\n"
  },
  {
    "id": 90,
    "category": "strings",
    "file_name": "text_justification",
    "codes": "\"\"\"\nGiven an array of words and a width maxWidth, format the text such that each line\nhas exactly maxWidth characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as\nyou can in each line. Pad extra spaces ' ' when necessary so that each line has\nexactly maxWidth characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the\nnumber of spaces on a line do not divide evenly between words, the empty slots\non the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left justified and no extra space is\ninserted between words.\n\nNote:\nA word is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\nThe input array words contains at least one word.\n\nExample:\nInput:\nwords = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\nmaxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\n\"\"\"\n\n\ndef text_justification(words, max_width):\n    '''\n    :type words: list\n    :type max_width: int\n    :rtype: list\n    '''\n    ret = []  # return value\n    row_len = 0  # current length of strs in a row\n    row_words = []  # current words in a row\n    index = 0  # the index of current word in words\n    is_first_word = True  # is current word the first in a row\n    while index < len(words):\n        while row_len <= max_width and index < len(words):\n            if len(words[index]) > max_width:\n                raise ValueError(\"there exists word whose length is larger than max_width\")\n            tmp = row_len\n            row_words.append(words[index])\n            tmp += len(words[index])\n            if not is_first_word:\n                tmp += 1  # except for the first word, each word should have at least a ' ' before it.\n            if tmp > max_width:\n                row_words.pop()\n                break\n            row_len = tmp\n            index += 1\n            is_first_word = False\n        # here we have already got a row of str , then we should supplement enough ' ' to make sure the length is max_width.\n        row = \"\"\n        # if the row is the last\n        if index == len(words):\n            for word in row_words:\n                row += (word + ' ')\n            row = row[:-1]\n            row += ' ' * (max_width - len(row))\n        # not the last row and more than one word\n        elif len(row_words) != 1:\n            space_num = max_width - row_len\n            space_num_of_each_interval = space_num // (len(row_words) - 1)\n            space_num_rest = space_num - space_num_of_each_interval * (len(row_words) - 1)\n            for j in range(len(row_words)):\n                row += row_words[j]\n                if j != len(row_words) - 1:\n                    row += ' ' * (1 + space_num_of_each_interval)\n                if space_num_rest > 0:\n                    row += ' '\n                    space_num_rest -= 1\n        # row with only one word\n        else:\n            row += row_words[0]\n            row += ' ' * (max_width - len(row))\n        ret.append(row)\n        # after a row , reset those value\n        row_len = 0\n        row_words = []\n        is_first_word = True\n    return ret\n"
  },
  {
    "id": 91,
    "category": "strings",
    "file_name": "repeat_substring",
    "codes": "\"\"\"\nGiven a non-empty string check if it can be constructed by taking\na substring of it and appending multiple copies of the substring together.\n\nFor example:\nInput: \"abab\"\nOutput: True\nExplanation: It's the substring \"ab\" twice.\n\nInput: \"aba\"\nOutput: False\n\nInput: \"abcabcabcabc\"\nOutput: True\nExplanation: It's the substring \"abc\" four times.\n\nReference: https://leetcode.com/problems/repeated-substring-pattern/description/\n\"\"\"\ndef repeat_substring(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    str = (s + s)[1:-1]\n    return s in str\n"
  },
  {
    "id": 92,
    "category": "strings",
    "file_name": "merge_string_checker",
    "codes": "\"\"\"\nAt a job interview, you are challenged to write an algorithm to check if a \ngiven string, s, can be formed from two other strings, part1 and part2.\nThe restriction is that the characters in part1 and part2 are in the same \norder as in s. The interviewer gives you the following example and tells \nyou to figure out the rest from the given test cases.\n'codewars' is a merge from 'cdw' and 'oears':\ns:  c o d e w a r s   = codewars\npart1:  c   d   w         = cdw\npart2:    o   e   a r s   = oears\n\"\"\"\n\n\n# Recursive Solution\ndef is_merge_recursive(s, part1, part2):\n    if not part1:\n        return s == part2\n    if not part2:\n        return s == part1\n    if not s:\n        return part1 + part2 == ''\n    if s[0] == part1[0] and is_merge_recursive(s[1:], part1[1:], part2):\n        return True\n    if s[0] == part2[0] and is_merge_recursive(s[1:], part1, part2[1:]):\n        return True\n    return False\n\n\n# An iterative approach\ndef is_merge_iterative(s, part1, part2):\n    tuple_list = [(s, part1, part2)]\n    while tuple_list:\n        string, p1, p2 = tuple_list.pop()            \n        if string:\n            if p1 and string[0] == p1[0]:\n                tuple_list.append((string[1:], p1[1:], p2))\n            if p2 and string[0] == p2[0]:\n                tuple_list.append((string[1:], p1, p2[1:]))\n        else:\n            if not p1 and not p2:\n                return True\n    return False\n"
  },
  {
    "id": 93,
    "category": "strings",
    "file_name": "knuth_morris_pratt",
    "codes": "from typing import Sequence, List\n\ndef knuth_morris_pratt(text : Sequence, pattern : Sequence) -> List[int]:\n    \"\"\"\n    Given two strings text and pattern, return the list of start indexes in text that matches with the pattern\n    using knuth_morris_pratt algorithm.\n\n    Args:\n        text: Text to search\n        pattern: Pattern to search in the text\n    Returns:\n        List of indices of patterns found\n\n    Example:\n        >>> knuth_morris_pratt('hello there hero!', 'he')\n        [0, 7, 12]\n\n    If idx is in the list, text[idx : idx + M] matches with pattern.\n    Time complexity of the algorithm is O(N+M), with N and M the length of text and pattern, respectively.\n    \"\"\"\n    n = len(text)\n    m = len(pattern)\n    pi = [0 for i in range(m)]\n    i = 0\n    j = 0\n    # making pi table\n    for i in range(1, m):\n        while j and pattern[i] != pattern[j]:\n            j = pi[j - 1]\n        if pattern[i] == pattern[j]:\n            j += 1\n            pi[i] = j\n    # finding pattern\n    j = 0\n    ret = []\n    for i in range(n):\n        while j and text[i] != pattern[j]:\n            j = pi[j - 1]\n        if text[i] == pattern[j]:\n            j += 1\n            if j == m:\n                ret.append(i - m + 1)\n                j = pi[j - 1]\n    return ret\n"
  },
  {
    "id": 94,
    "category": "strings",
    "file_name": "domain_extractor",
    "codes": "\"\"\"\nWrite a function that when given a URL as a string, parses out just the domain name and returns it as a string. \n\nExamples:\ndomain_name(\"http://github.com/SaadBenn\") == \"github\" \ndomain_name(\"http://www.zombie-bites.com\") == \"zombie-bites\"\ndomain_name(\"https://www.cnet.com\") == \"cnet\"\n\nNote: The idea is not to use any built-in libraries such as re (regular expression) or urlparse except .split() built-in function\n\"\"\"\n\n# Non pythonic way\ndef domain_name_1(url):\n\t#grab only the non http(s) part\n    full_domain_name = url.split('//')[-1] \n    #grab the actual one depending on the len of the list  \n    actual_domain = full_domain_name.split('.')  \n    \n    # case when www is in the url\n    if (len(actual_domain) > 2):\n        return actual_domain[1]    \n    # case when www is not in the url\n    return actual_domain[0]\n\n\n# pythonic one liner\ndef domain_name_2(url):\n    return url.split(\"//\")[-1].split(\"www.\")[-1].split(\".\")[0]\n\n"
  },
  {
    "id": 95,
    "category": "strings",
    "file_name": "delete_reoccurring",
    "codes": "\"\"\"\nQUESTION: Given a string as your input, delete any reoccurring \ncharacter, and return the new string.\n\nThis is a Google warmup interview question that was asked duirng phone screening\nat my university. \n\"\"\"\n\n# time complexity O(n)\ndef delete_reoccurring_characters(string):\n    seen_characters = set()\n    output_string = ''\n    for char in string:\n        if char not in seen_characters:\n            seen_characters.add(char)\n            output_string += char\n    return output_string\n\n    "
  },
  {
    "id": 96,
    "category": "strings",
    "file_name": "rotate",
    "codes": "\"\"\"\nGiven a strings s and int k, return a string that rotates k times\n\nk can be any positive integer.\n\nFor example,\nrotate(\"hello\", 2) return \"llohe\"\nrotate(\"hello\", 5) return \"hello\"\nrotate(\"hello\", 6) return \"elloh\"\nrotate(\"hello\", 7) return \"llohe\"\nrotate(\"hello\", 102) return \"lohel\"\n\n\"\"\"\ndef rotate(s, k):\n    long_string = s * (k // len(s) + 2)\n    if k <= len(s):\n        return long_string[k:k + len(s)]\n    else:\n        return long_string[k-len(s):k]\n    \ndef rotate_alt(string, k):\n    k = k % len(string)\n    return string[k:] + string[:k]\n"
  },
  {
    "id": 97,
    "category": "strings",
    "file_name": "repeat_string",
    "codes": "\"\"\"\nGiven two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.\n\nFor example, with A = \"abcd\" and B = \"cdabcdab\".\n\nReturn 3, because by repeating A three times (\u201cabcdabcdabcd\u201d), B is a substring of it; and B is not a substring of A repeated two times (\"abcdabcd\").\n\nNote:\nThe length of A and B will be between 1 and 10000.\n\nReference: https://leetcode.com/problems/repeated-string-match/description/\n\"\"\"\ndef repeat_string(A, B):\n    count = 1\n    tmp = A\n    max_count = (len(B) / len(A)) + 1\n    while not(B in tmp):\n        tmp = tmp + A\n        if (count > max_count):\n            count = -1\n            break\n        count = count + 1\n\n    return count\n"
  },
  {
    "id": 98,
    "category": "strings",
    "file_name": "license_number",
    "codes": "\ndef license_number(key, k):\n    res, alnum = [], []\n    for char in key:\n        if char != \"-\":\n            alnum.append(char)\n    for i, char in enumerate(reversed(alnum)):\n        res.append(char)\n        if (i+1) % k == 0 and i != len(alnum)-1:\n            res.append(\"-\")\n    return \"\".join(res[::-1])\n"
  },
  {
    "id": 99,
    "category": "strings",
    "file_name": "strip_url_params",
    "codes": "\"\"\"\nWrite a function that does the following:\nRemoves any duplicate query string parameters from the url\nRemoves any query string parameters specified within the 2nd argument (optional array)\n\nAn example:\nwww.saadbenn.com?a=1&b=2&a=2') // returns 'www.saadbenn.com?a=1&b=2'\n\"\"\"\nfrom collections import defaultdict\nimport urllib\nimport urllib.parse\n\n# Here is a very non-pythonic grotesque solution\ndef strip_url_params1(url, params_to_strip=None):\n    \n    if not params_to_strip:\n        params_to_strip = []\n    if url:\n        result = '' # final result to be returned\n        tokens = url.split('?')\n        domain = tokens[0]\n        query_string = tokens[-1]\n        result += domain\n        # add the '?' to our result if it is in the url\n        if len(tokens) > 1:\n            result += '?'\n        if not query_string:\n            return url\n        else:\n            # logic for removing duplicate query strings\n            # build up the list by splitting the query_string using digits\n            key_value_string = []\n            string = ''\n            for char in query_string:\n                if char.isdigit():\n                    key_value_string.append(string + char)\n                    string = ''\n                else:\n                    string += char\n            dict = defaultdict(int)\n            # logic for checking whether we should add the string to our result\n            for i in key_value_string:\n                _token = i.split('=')\n                if _token[0]:\n                    length = len(_token[0])\n                    if length == 1:\n                        if _token and (not(_token[0] in dict)):\n                            if params_to_strip:\n                                if _token[0] != params_to_strip[0]:\n                                    dict[_token[0]] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n                            else:\n                                if not _token[0] in dict:\n                                    dict[_token[0]] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n                    else:\n                        check = _token[0]\n                        letter = check[1]\n                        if _token and (not(letter in dict)):\n                            if params_to_strip:\n                                if letter != params_to_strip[0]:\n                                    dict[letter] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n                            else:\n                                if not letter in dict:\n                                    dict[letter] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n    return result\n\n# A very friendly pythonic solution (easy to follow)\ndef strip_url_params2(url, param_to_strip=[]):\n    if '?' not in url:\n        return url\n\n    queries = (url.split('?')[1]).split('&')\n    queries_obj = [query[0] for query in queries]\n    for i in range(len(queries_obj) - 1, 0, -1):\n        if queries_obj[i] in param_to_strip or queries_obj[i] in queries_obj[0:i]:\n            queries.pop(i)\n\n    return url.split('?')[0] + '?' + '&'.join(queries)\n\n\n# Here is my friend's solution using python's builtin libraries\ndef strip_url_params3(url, strip=None):\n    if not strip: strip = []\n    \n    parse = urllib.parse.urlparse(url)\n    query = urllib.parse.parse_qs(parse.query)\n    \n    query = {k: v[0] for k, v in query.items() if k not in strip}\n    query = urllib.parse.urlencode(query)\n    new = parse._replace(query=query)\n    \n    return new.geturl()"
  },
  {
    "id": 100,
    "category": "strings",
    "file_name": "fizzbuzz",
    "codes": "\"\"\"\nWrite a function that returns an array containing the numbers from 1 to N, \nwhere N is the parametered value. N will never be less than 1.\n\nReplace certain values however if any of the following conditions are met:\n\nIf the value is a multiple of 3: use the value 'Fizz' instead\nIf the value is a multiple of 5: use the value 'Buzz' instead\nIf the value is a multiple of 3 & 5: use the value 'FizzBuzz' instead\n\"\"\"\n\n\"\"\"\nThere is no fancy algorithm to solve fizz buzz.\n\nIterate from 1 through n\nUse the mod operator to determine if the current iteration is divisible by:\n3 and 5 -> 'FizzBuzz'\n3 -> 'Fizz'\n5 -> 'Buzz'\nelse -> string of current iteration\nreturn the results\nComplexity:\n\nTime: O(n)\nSpace: O(n)\n\"\"\"\n\ndef fizzbuzz(n):\n    \n    # Validate the input\n    if n < 1:\n        raise ValueError('n cannot be less than one')\n    if n is None:\n        raise TypeError('n cannot be None')\n    \n    result = []\n    \n    for i in range(1, n+1):\n        if i%3 == 0 and i%5 == 0:\n            result.append('FizzBuzz')\n        elif i%3 == 0:\n            result.append('Fizz')\n        elif i%5 == 0:\n            result.append('Buzz')\n        else:\n            result.append(i)\n    return result\n\n# Alternative solution\ndef fizzbuzz_with_helper_func(n):\n    return [fb(m) for m in range(1,n+1)]\n    \ndef fb(m):\n    r = (m % 3 == 0) * \"Fizz\" + (m % 5 == 0) * \"Buzz\"\n    return r if r != \"\" else m\n"
  },
  {
    "id": 101,
    "category": "backtrack",
    "file_name": "anagram",
    "codes": "\"\"\"\nGiven two strings, determine if they are equal after reordering.\n\nExamples:\n\"apple\", \"pleap\"  -> True\n\"apple\", \"cherry\" -> False\n\"\"\"\n\n\ndef anagram(s1, s2):\n    c1 = [0] * 26\n    c2 = [0] * 26\n\n    for c in s1:\n        pos = ord(c)-ord('a')\n        c1[pos] = c1[pos] + 1\n\n    for c in s2:\n        pos = ord(c)-ord('a')\n        c2[pos] = c2[pos] + 1\n\n    return c1 == c2\n"
  },
  {
    "id": 102,
    "category": "backtrack",
    "file_name": "permute",
    "codes": "\"\"\"\nGiven a collection of distinct numbers, return all possible permutations.\n\nFor example,\n[1,2,3] have the following permutations:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\"\"\"\n\n\ndef permute(elements):\n    \"\"\"\n        returns a list with the permuations.\n    \"\"\"\n    if len(elements) <= 1:\n        return [elements]\n    else:\n        tmp = []\n        for perm in permute(elements[1:]):\n            for i in range(len(elements)):\n                tmp.append(perm[:i] + elements[0:1] + perm[i:])\n        return tmp\n\n\ndef permute_iter(elements):\n    \"\"\"\n        iterator: returns a perumation by each call.\n    \"\"\"\n    if len(elements) <= 1:\n        yield elements\n    else:\n        for perm in permute_iter(elements[1:]):\n            for i in range(len(elements)):\n                yield perm[:i] + elements[0:1] + perm[i:]\n\n\n# DFS Version\ndef permute_recursive(nums):\n    def dfs(res, nums, path):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            print(nums[:i]+nums[i+1:])\n            dfs(res, nums[:i]+nums[i+1:], path+[nums[i]])\n\n    res = []\n    dfs(res, nums, [])\n    return res\n"
  },
  {
    "id": 103,
    "category": "backtrack",
    "file_name": "subsets",
    "codes": "\"\"\"\nGiven a set of distinct integers, nums, return all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,3], a solution is:\n\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n\"\"\"\n\n\ndef subsets(nums):\n    \"\"\"\n    O(2**n)\n    \"\"\"\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.append(list(stack))\n        else:\n            # take nums[pos]\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos+1)\n            stack.pop()\n            # dont take nums[pos]\n            backtrack(res, nums, stack, pos+1)\n\n    res = []\n    backtrack(res, nums, [], 0)\n    return res\n\n\n\"\"\"\nsimplified backtrack\n\ndef backtrack(res, nums, cur, pos):\n    if pos >= len(nums):\n        res.append(cur)\n    else:\n        backtrack(res, nums, cur+[nums[pos]], pos+1)\n        backtrack(res, nums, cur, pos+1)\n\"\"\"\n\n\n# Iteratively\ndef subsets_v2(nums):\n    res = [[]]\n    for num in sorted(nums):\n        res += [item+[num] for item in res]\n    return res\n"
  },
  {
    "id": 104,
    "category": "backtrack",
    "file_name": "array_sum_combinations",
    "codes": "\"\"\"\nWAP to take one element from each of the array add it to the target sum.\nPrint all those three-element combinations.\n\n/*\nA = [1, 2, 3, 3]\nB = [2, 3, 3, 4]\nC = [2, 3, 3, 4]\ntarget = 7\n*/\n\nResult:\n[[1, 2, 4], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 4, 2],\n [2, 2, 3], [2, 2, 3], [2, 3, 2], [2, 3, 2], [3, 2, 2], [3, 2, 2]]\n\"\"\"\nimport itertools\nfrom functools import partial\n\n\ndef array_sum_combinations(A, B, C, target):\n\n    def over(constructed_sofar):\n        sum = 0\n        to_stop, reached_target = False, False\n        for elem in constructed_sofar:\n            sum += elem\n        if sum >= target or len(constructed_sofar) >= 3:\n            to_stop = True\n            if sum == target and 3 == len(constructed_sofar):\n                reached_target = True\n        return to_stop, reached_target\n\n    def construct_candidates(constructed_sofar):\n        array = A\n        if 1 == len(constructed_sofar):\n            array = B\n        elif 2 == len(constructed_sofar):\n            array = C\n        return array\n\n    def backtrack(constructed_sofar=[], res=[]):\n        to_stop, reached_target = over(constructed_sofar)\n        if to_stop:\n            if reached_target:\n                res.append(constructed_sofar)\n            return\n        candidates = construct_candidates(constructed_sofar)\n\n        for candidate in candidates:\n            constructed_sofar.append(candidate)\n            backtrack(constructed_sofar[:], res)\n            constructed_sofar.pop()\n\n    res = []\n    backtrack([], res)\n    return res\n\n\ndef unique_array_sum_combinations(A, B, C, target):\n    \"\"\"\n    1. Sort all the arrays - a,b,c. - This improves average time complexity.\n    2. If c[i] < Sum, then look for Sum - c[i] in array a and b.\n       When pair found, insert c[i], a[j] & b[k] into the result list.\n       This can be done in O(n).\n    3. Keep on doing the above procedure while going through complete c array.\n\n    Complexity: O(n(m+p))\n    \"\"\"\n    def check_sum(n, *nums):\n        if sum(x for x in nums) == n:\n            return (True, nums)\n        else:\n            return (False, nums)\n\n    pro = itertools.product(A, B, C)\n    func = partial(check_sum, target)\n    sums = list(itertools.starmap(func, pro))\n\n    res = set()\n    for s in sums:\n        if s[0] is True and s[1] not in res:\n            res.add(s[1])\n\n    return list(res)\n"
  },
  {
    "id": 105,
    "category": "backtrack",
    "file_name": "add_operators",
    "codes": "\"\"\"\nGiven a string that contains only digits 0-9 and a target value,\nreturn all possibilities to add binary operators (not unary) +, -, or *\nbetween the digits so they prevuate to the target value.\n\nExamples:\n\"123\", 6 -> [\"1+2+3\", \"1*2*3\"]\n\"232\", 8 -> [\"2*3+2\", \"2+3*2\"]\n\"105\", 5 -> [\"1*0+5\",\"10-5\"]\n\"00\", 0 -> [\"0+0\", \"0-0\", \"0*0\"]\n\"3456237490\", 9191 -> []\n\"\"\"\n\n\ndef add_operators(num, target):\n    \"\"\"\n    :type num: str\n    :type target: int\n    :rtype: List[str]\n    \"\"\"\n\n    def dfs(res, path, num, target, pos, prev, multed):\n        if pos == len(num):\n            if target == prev:\n                res.append(path)\n            return\n        for i in range(pos, len(num)):\n            if i != pos and num[pos] == '0':  # all digits have to be used\n                break\n            cur = int(num[pos:i+1])\n            if pos == 0:\n                dfs(res, path + str(cur), num, target, i+1, cur, cur)\n            else:\n                dfs(res, path + \"+\" + str(cur), num, target,\n                    i+1, prev + cur, cur)\n                dfs(res, path + \"-\" + str(cur), num, target,\n                    i+1, prev - cur, -cur)\n                dfs(res, path + \"*\" + str(cur), num, target,\n                    i+1, prev - multed + multed * cur, multed * cur)\n\n    res = []\n    if not num:\n        return res\n    dfs(res, \"\", num, target, 0, 0, 0)\n    return res\n"
  },
  {
    "id": 106,
    "category": "backtrack",
    "file_name": "pattern_match",
    "codes": "\"\"\"\nGiven a pattern and a string str,\nfind if str follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between\na letter in pattern and a non-empty substring in str.\n\nExamples:\npattern = \"abab\", str = \"redblueredblue\" should return true.\npattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\nNotes:\nYou may assume both pattern and str contains only lowercase letters.\n\"\"\"\n\n\ndef pattern_match(pattern, string):\n    \"\"\"\n    :type pattern: str\n    :type string: str\n    :rtype: bool\n    \"\"\"\n    def backtrack(pattern, string, dic):\n\n        if len(pattern) == 0 and len(string) > 0:\n            return False\n\n        if len(pattern) == len(string) == 0:\n            return True\n\n        for end in range(1, len(string)-len(pattern)+2):\n            if pattern[0] not in dic and string[:end] not in dic.values():\n                dic[pattern[0]] = string[:end]\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n                del dic[pattern[0]]\n            elif pattern[0] in dic and dic[pattern[0]] == string[:end]:\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n        return False\n\n    return backtrack(pattern, string, {})\n"
  },
  {
    "id": 107,
    "category": "backtrack",
    "file_name": "factor_combinations",
    "codes": "\"\"\"\nNumbers can be regarded as product of its factors. For example,\n\n8 = 2 x 2 x 2;\n  = 2 x 4.\nWrite a function that takes an integer n\nand return all possible combinations of its factors.\n\nNote:\nYou may assume that n is always positive.\nFactors should be greater than 1 and less than n.\nExamples:\ninput: 1\noutput:\n[]\ninput: 37\noutput:\n[]\ninput: 12\noutput:\n[\n  [2, 6],\n  [2, 2, 3],\n  [3, 4]\n]\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n  [2, 4, 4],\n  [4, 8]\n]\n\"\"\"\n\n\n# Iterative:\ndef get_factors(n):\n    todo, combis = [(n, 2, [])], []\n    while todo:\n        n, i, combi = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                combis.append(combi + [i, n//i])\n                todo.append((n//i, i, combi+[i]))\n            i += 1\n    return combis\n\n\n# Recursive:\ndef recursive_get_factors(n):\n\n    def factor(n, i, combi, combis):\n        while i * i <= n:\n            if n % i == 0:\n                combis.append(combi + [i, n//i]),\n                factor(n//i, i, combi+[i], combis)\n            i += 1\n        return combis\n\n    return factor(n, 2, [], [])\n"
  },
  {
    "id": 108,
    "category": "backtrack",
    "file_name": "letter_combination",
    "codes": "\"\"\"\nGiven a digit string, return all possible letter\ncombinations that the number could represent.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below:\n2: \"abc\"\n3: \"def\"\n4: \"ghi\"\n5: \"jkl\"\n6: \"mno\"\n7: \"pqrs\"\n8: \"tuv\"\n9: \"wxyz\"\n\nInput:Digit string \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n\"\"\"\n\n\ndef letter_combinations(digits):\n    if digits == \"\":\n        return []\n    kmaps = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\"\n    }\n    ans = [\"\"]\n    for num in digits:\n        tmp = []\n        for an in ans:\n            for char in kmaps[num]:\n                tmp.append(an + char)\n        ans = tmp\n    return ans\n"
  },
  {
    "id": 109,
    "category": "backtrack",
    "file_name": "subsets_unique",
    "codes": "\"\"\"\nGiven a collection of integers that might contain duplicates, nums,\nreturn all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,2], a solution is:\n\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n\"\"\"\n\n\ndef subsets_unique(nums):\n\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.add(tuple(stack))\n        else:\n            # take\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos+1)\n            stack.pop()\n\n            # don't take\n            backtrack(res, nums, stack, pos+1)\n\n    res = set()\n    backtrack(res, nums, [], 0)\n    return list(res)\n"
  },
  {
    "id": 110,
    "category": "backtrack",
    "file_name": "permute_unique",
    "codes": "\"\"\"\nGiven a collection of numbers that might contain duplicates,\nreturn all possible unique permutations.\n\nFor example,\n[1,1,2] have the following unique permutations:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n\"\"\"\n\n\ndef permute_unique(nums):\n    perms = [[]]\n    for n in nums:\n        new_perms = []\n        for l in perms:\n            for i in range(len(l)+1):\n                new_perms.append(l[:i]+[n]+l[i:])\n                if i < len(l) and l[i] == n:\n                    break  # handles duplication\n        perms = new_perms\n    return perms\n"
  },
  {
    "id": 111,
    "category": "backtrack",
    "file_name": "generate_parenthesis",
    "codes": "\"\"\"\nGiven n pairs of parentheses, write a function to generate\nall combinations of well-formed parentheses.\n\nFor example, given n = 3, a solution set is:\n\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n\"\"\"\n\n\ndef generate_parenthesis_v1(n):\n    def add_pair(res, s, left, right):\n        if left == 0 and right == 0:\n            res.append(s)\n            return\n        if right > 0:\n            add_pair(res, s + \")\", left, right - 1)\n        if left > 0:\n            add_pair(res, s + \"(\", left - 1, right + 1)\n\n    res = []\n    add_pair(res, \"\", n, 0)\n    return res\n\n\ndef generate_parenthesis_v2(n):\n    def add_pair(res, s, left, right):\n        if left == 0 and right == 0:\n            res.append(s)\n        if left > 0:\n            add_pair(res, s + \"(\", left - 1, right)\n        if right > 0 and left < right:\n            add_pair(res, s + \")\", left, right - 1)\n\n    res = []\n    add_pair(res, \"\", n, n)\n    return res\n"
  },
  {
    "id": 112,
    "category": "backtrack",
    "file_name": "generate_abbreviations",
    "codes": "\"\"\"\ngiven input word, return the list of abbreviations.\nex)\nword => ['word', 'wor1', 'wo1d', 'wo2', 'w1rd', 'w1r1', 'w2d', 'w3', '1ord', '1or1', '1o1d', '1o2', '2rd', '2r1', '3d', '4']\n\"\"\"\n\n\ndef generate_abbreviations(word):\n\n    def backtrack(result, word, pos, count, cur):\n        if pos == len(word):\n            if count > 0:\n                cur += str(count)\n            result.append(cur)\n            return\n\n        if count > 0:  # add the current word\n            backtrack(result, word, pos+1, 0, cur+str(count)+word[pos])\n        else:\n            backtrack(result, word, pos+1, 0, cur+word[pos])\n        # skip the current word\n        backtrack(result, word, pos+1, count+1, cur)\n\n    result = []\n    backtrack(result, word, 0, 0, \"\")\n    return result\n"
  },
  {
    "id": 113,
    "category": "backtrack",
    "file_name": "palindrome_partitioning",
    "codes": "\"\"\" It looks like you need to be looking not for all palindromic substrings,\nbut rather for all the ways you can divide the input string\nup into palindromic substrings.\n(There's always at least one way,\nsince one-character substrings are always palindromes.)\n\nex)\n'abcbab' => [['abcba', 'b'], ['a', 'bcb', 'a', 'b'], ['a', 'b', 'c', 'bab'], ['a', 'b', 'c', 'b', 'a', 'b']]\n\"\"\"\n\n\ndef palindromic_substrings(s):\n    if not s:\n        return [[]]\n    results = []\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if sub == sub[::-1]:\n            for rest in palindromic_substrings(s[i:]):\n                results.append([sub] + rest)\n    return results\n\n\n\"\"\"\nThere's two loops.\nThe outer loop checks each length of initial substring\n(in descending length order) to see if it is a palindrome.\nIf so, it recurses on the rest of the string and loops over the returned\nvalues, adding the initial substring to\neach item before adding it to the results.\n\"\"\"\n\n\ndef palindromic_substrings_iter(s):\n    \"\"\"\n    A slightly more Pythonic approach with a recursive generator\n    \"\"\"\n    if not s:\n        yield []\n        return\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if sub == sub[::-1]:\n            for rest in palindromic_substrings_iter(s[i:]):\n                yield [sub] + rest\n"
  },
  {
    "id": 114,
    "category": "backtrack",
    "file_name": "combination_sum",
    "codes": "\"\"\"\nGiven a set of candidate numbers (C) (without duplicates) and a target number\n(T), find all unique combinations in C where the candidate numbers sums to T.\n\nThe same repeated number may be chosen from C unlimited number of times.\n\nNote:\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\nFor example, given candidate set [2, 3, 6, 7] and target 7,\nA solution set is:\n[\n  [7],\n  [2, 2, 3]\n]\n\"\"\"\n\n\ndef combination_sum(candidates, target):\n\n    def dfs(nums, target, index, path, res):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(index, len(nums)):\n            dfs(nums, target-nums[i], i, path+[nums[i]], res)\n\n    res = []\n    candidates.sort()\n    dfs(candidates, target, 0, [], res)\n    return res\n"
  },
  {
    "id": 115,
    "category": "backtrack",
    "file_name": "find_words",
    "codes": "'''\nGiven a matrix of words and a list of words to search,\nreturn a list of words that exists in the board\nThis is Word Search II on LeetCode\n\nboard = [\n         ['o','a','a','n'],\n         ['e','t','a','e'],\n         ['i','h','k','r'],\n         ['i','f','l','v']\n         ]\n\nwords = [\"oath\",\"pea\",\"eat\",\"rain\"]\n'''\n\n\ndef find_words(board, words):\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        '''\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        '''\n\n        if '#' in trie:\n            result.add(pre)\n\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n            return\n\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i+1, j, trie[board[i][j]],\n                      pre+board[i][j], used, result)\n            backtrack(board, i, j+1, trie[board[i][j]],\n                      pre+board[i][j], used, result)\n            backtrack(board, i-1, j, trie[board[i][j]],\n                      pre+board[i][j], used, result)\n            backtrack(board, i, j-1, trie[board[i][j]],\n                      pre+board[i][j], used, result)\n            used[i][j] = False\n\n    # make a trie structure that is essentially dictionaries of dictionaries\n    # that map each character to a potential next character\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n\n    # result is a set of found words since we do not want repeats\n    result = set()\n    used = [[False]*len(board[0]) for _ in range(len(board))]\n\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)\n"
  },
  {
    "id": 116,
    "category": "map",
    "file_name": "valid_sudoku",
    "codes": "\"\"\"\nDetermine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.\n\nThe Sudoku board could be partially filled, where empty cells are filled with\nthe character '.'.\n\"\"\"\n\ndef is_valid_sudoku(self, board):\n    seen = []\n    for i, row in enumerate(board):\n        for j, c in enumerate(row):\n            if c != '.':\n                seen += [(c,j),(i,c),(i/3,j/3,c)]\n    return len(seen) == len(set(seen))\n"
  },
  {
    "id": 117,
    "category": "map",
    "file_name": "is_anagram",
    "codes": "\"\"\"\nGiven two strings s and t , write a function to determine if t is an anagram of s.\n\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nNote:\nYou may assume the string contains only lowercase alphabets.\n\nReference: https://leetcode.com/problems/valid-anagram/description/\n\"\"\"\ndef is_anagram(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    maps = {}\n    mapt = {}\n    for i in s:\n        maps[i] = maps.get(i, 0) + 1\n    for i in t:\n        mapt[i] = mapt.get(i, 0) + 1\n    return maps == mapt\n"
  },
  {
    "id": 118,
    "category": "map",
    "file_name": "is_isomorphic",
    "codes": "\"\"\"\nGiven two strings s and t, determine if they are isomorphic.\nTwo strings are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while\npreserving the order of characters. No two characters may map to the same\ncharacter but a character may map to itself.\n\nExample 1:\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\nExample 2:\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExample 3:\nInput: s = \"paper\", t = \"title\"\nOutput: true\nReference: https://leetcode.com/problems/isomorphic-strings/description/\n\"\"\"\ndef is_isomorphic(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    dict = {}\n    set_value = set()\n    for i in range(len(s)):\n        if s[i] not in dict:\n            if t[i] in set_value:\n                return False\n            dict[s[i]] = t[i]\n            set_value.add(t[i])\n        else:\n            if dict[s[i]] != t[i]:\n                return False\n    return True\n"
  },
  {
    "id": 119,
    "category": "map",
    "file_name": "separate_chaining_hashtable",
    "codes": "import unittest\n\n\nclass Node(object):\n    def __init__(self, key=None, value=None, next=None):\n        self.key = key\n        self.value = value\n        self.next = next\n\n\nclass SeparateChainingHashTable(object):\n    \"\"\"\n    HashTable Data Type:\n    By having each bucket contain a linked list of elements that are hashed to that bucket.\n\n    Usage:\n    >>> table = SeparateChainingHashTable() # Create a new, empty map.\n    >>> table.put('hello', 'world') # Add a new key-value pair.\n    >>> len(table) # Return the number of key-value pairs stored in the map.\n    1\n    >>> table.get('hello') # Get value by key.\n    'world'\n    >>> del table['hello'] # Equivalent to `table.del_('hello')`, deleting key-value pair.\n    >>> table.get('hello') is None # Return `None` if a key doesn't exist.\n    True\n    \"\"\"\n    _empty = None\n\n    def __init__(self, size=11):\n        self.size = size\n        self._len = 0\n        self._table = [self._empty] * size\n\n    def put(self, key, value):\n        hash_ = self.hash(key)\n        node_ = self._table[hash_]\n        if node_ is self._empty:\n            self._table[hash_] = Node(key, value)\n        else:\n            while node_.next is not None:\n                if node_.key == key:\n                    node_.value = value\n                    return\n                node_ = node_.next\n            node_.next = Node(key, value)\n        self._len += 1\n\n    def get(self, key):\n        hash_ = self.hash(key)\n        node_ = self._table[hash_]\n        while node_ is not self._empty:\n            if node_.key == key:\n                return node_.value\n            node_ = node_.next\n        return None\n\n    def del_(self, key):\n        hash_ = self.hash(key)\n        node_ = self._table[hash_]\n        pre_node = None\n        while node_ is not None:\n            if node_.key == key:\n                if pre_node is None:\n                    self._table[hash_] = node_.next\n                else:\n                    pre_node.next = node_.next\n                self._len -= 1\n            pre_node = node_\n            node_ = node_.next\n\n    def hash(self, key):\n        return hash(key) % self.size\n\n    def __len__(self):\n        return self._len\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __delitem__(self, key):\n        return self.del_(key)\n\n    def __setitem__(self, key, value):\n        self.put(key, value)\n"
  },
  {
    "id": 120,
    "category": "map",
    "file_name": "randomized_set",
    "codes": "\"\"\"\nDesign a data structure that supports all following operations\nin average O(1) time.\n\ninsert(val): Inserts an item val to the set if not already present.\nremove(val): Removes an item val from the set if present.\ngetRandom: Returns a random element from current set of elements.\nEach element must have the same probability of being returned.\n\"\"\"\n\n\nimport random\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.nums = []\n        self.idxs = {}\n\n    def insert(self, val):\n        if val not in self.idxs:\n            self.nums.append(val)\n            self.idxs[val] = len(self.nums)-1\n            return True\n        return False\n\n    def remove(self, val):\n        if val in self.idxs:\n            idx, last = self.idxs[val], self.nums[-1]\n            self.nums[idx], self.idxs[last] = last, idx\n            self.nums.pop()\n            self.idxs.pop(val, 0)\n            return True\n        return False\n\n    def get_random(self):\n        idx = random.randint(0, len(self.nums)-1)\n        return self.nums[idx]\n\n\nif __name__ == \"__main__\":\n    rs = RandomizedSet()\n    print(\"insert 1: \", rs.insert(1))\n    print(\"insert 2: \", rs.insert(2))\n    print(\"insert 3: \", rs.insert(3))\n    print(\"insert 4: \", rs.insert(4))\n    print(\"remove 3: \", rs.remove(3))\n    print(\"remove 3: \", rs.remove(3))\n    print(\"remove 1: \", rs.remove(1))\n    print(\"random: \", rs.get_random())\n    print(\"random: \", rs.get_random())\n    print(\"random: \", rs.get_random())\n    print(\"random: \", rs.get_random())\n"
  },
  {
    "id": 121,
    "category": "map",
    "file_name": "longest_common_subsequence",
    "codes": "\"\"\"\nGiven string a and b, with b containing all distinct characters,\nfind the longest common sub sequence's length.\n\nExpected complexity O(n logn).\n\"\"\"\n\n\ndef max_common_sub_string(s1, s2):\n    # Assuming s2 has all unique chars\n    s2dic = {s2[i]: i for i in range(len(s2))}\n    maxr = 0\n    subs = ''\n    i = 0\n    while i < len(s1):\n        if s1[i] in s2dic:\n            j = s2dic[s1[i]]\n            k = i\n            while j < len(s2) and k < len(s1) and s1[k] == s2[j]:\n                k += 1\n                j += 1\n            if k - i > maxr:\n                maxr = k-i\n                subs = s1[i:k]\n            i = k\n        else:\n            i += 1\n    return subs\n"
  },
  {
    "id": 122,
    "category": "map",
    "file_name": "hashtable",
    "codes": "class HashTable(object):\n    \"\"\"\n    HashMap Data Type\n    HashMap() Create a new, empty map. It returns an empty map collection.\n    put(key, val) Add a new key-value pair to the map. If the key is already in the map then replace\n                    the old value with the new value.\n    get(key) Given a key, return the value stored in the map or None otherwise.\n    del_(key) or del map[key] Delete the key-value pair from the map using a statement of the form del map[key].\n    len() Return the number of key-value pairs stored in the map.\n    in Return True for a statement of the form key in map, if the given key is in the map, False otherwise.\n    \"\"\"\n\n    _empty = object()\n    _deleted = object()\n\n    def __init__(self, size=11):\n        self.size = size\n        self._len = 0\n        self._keys = [self._empty] * size  # keys\n        self._values = [self._empty] * size  # values\n\n    def put(self, key, value):\n        initial_hash = hash_ = self.hash(key)\n\n        while True:\n            if self._keys[hash_] is self._empty or self._keys[hash_] is self._deleted:\n                # can assign to hash_ index\n                self._keys[hash_] = key\n                self._values[hash_] = value\n                self._len += 1\n                return\n            elif self._keys[hash_] == key:\n                # key already exists here, assign over\n                self._keys[hash_] = key\n                self._values[hash_] = value\n                return\n\n            hash_ = self._rehash(hash_)\n\n            if initial_hash == hash_:\n                # table is full\n                raise ValueError(\"Table is full\")\n\n    def get(self, key):\n        initial_hash = hash_ = self.hash(key)\n        while True:\n            if self._keys[hash_] is self._empty:\n                # That key was never assigned\n                return None\n            elif self._keys[hash_] == key:\n                # key found\n                return self._values[hash_]\n\n            hash_ = self._rehash(hash_)\n            if initial_hash == hash_:\n                # table is full and wrapped around\n                return None\n\n    def del_(self, key):\n        initial_hash = hash_ = self.hash(key)\n        while True:\n            if self._keys[hash_] is self._empty:\n                # That key was never assigned\n                return None\n            elif self._keys[hash_] == key:\n                # key found, assign with deleted sentinel\n                self._keys[hash_] = self._deleted\n                self._values[hash_] = self._deleted\n                self._len -= 1\n                return\n\n            hash_ = self._rehash(hash_)\n            if initial_hash == hash_:\n                # table is full and wrapped around\n                return None\n\n    def hash(self, key):\n        return key % self.size\n\n    def _rehash(self, old_hash):\n        \"\"\"\n        linear probing\n        \"\"\"\n        return (old_hash + 1) % self.size\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __delitem__(self, key):\n        return self.del_(key)\n\n    def __setitem__(self, key, value):\n        self.put(key, value)\n\n    def __len__(self):\n        return self._len\n\n\nclass ResizableHashTable(HashTable):\n    MIN_SIZE = 8\n\n    def __init__(self):\n        super().__init__(self.MIN_SIZE)\n\n    def put(self, key, value):\n        rv = super().put(key, value)\n        # increase size of dict * 2 if filled >= 2/3 size (like python dict)\n        if len(self) >= (self.size * 2) / 3:\n            self.__resize()\n\n    def __resize(self):\n        keys, values = self._keys, self._values\n        self.size *= 2  # this will be the new size\n        self._len = 0\n        self._keys = [self._empty] * self.size\n        self._values = [self._empty] * self.size\n        for key, value in zip(keys, values):\n            if key is not self._empty and key is not self._deleted:\n                self.put(key, value)\n"
  },
  {
    "id": 123,
    "category": "map",
    "file_name": "longest_palindromic_subsequence",
    "codes": "def longest_palindromic_subsequence(s):\n\n    k = len(s)\n    olist = [0] * k    # \u7533\u8bf7\u957f\u5ea6\u4e3an\u7684\u5217\u8868\uff0c\u5e76\u521d\u59cb\u5316\n    nList = [0] * k    # \u540c\u4e0a\n    logestSubStr = \"\"\n    logestLen = 0\n\n    for j in range(0, k):\n        for i in range(0, j + 1):\n            if j - i <= 1:\n                if s[i] == s[j]:\n                    nList[i] = 1                 # \u5f53 j \u65f6\uff0c\u7b2c i \u4e2a\u5b50\u4e32\u4e3a\u56de\u6587\u5b50\u4e32\n                    len_t = j - i + 1\n                    if logestLen < len_t:        # \u5224\u65ad\u957f\u5ea6\n                        logestSubStr = s[i:j + 1]\n                        logestLen = len_t\n            else:\n                if s[i] == s[j] and olist[i+1]:   # \u5f53j-i>1\u65f6\uff0c\u5224\u65ads[i]\u662f\u5426\u7b49\u4e8es[j]\uff0c\u5e76\u5224\u65ad\u5f53j-1\u65f6\uff0c\u7b2ci+1\u4e2a\u5b50\u4e32\u662f\u5426\u4e3a\u56de\u6587\u5b50\u4e32\n                    nList[i] = 1                  # \u5f53 j \u65f6\uff0c\u7b2c i \u4e2a\u5b50\u4e32\u4e3a\u56de\u6587\u5b50\u4e32\n                    len_t = j - i + 1\n                    if logestLen < len_t:\n                        logestSubStr = s[i:j + 1]\n                        logestLen = len_t\n        olist = nList                            # \u8986\u76d6\u65e7\u7684\u5217\u8868\n        nList = [0] * k                          # \u65b0\u7684\u5217\u8868\u6e05\u7a7a\n    # ~ from icecream import ic\n    # ~ ic(s, logestSubStr)\n    return logestLen#, logestSubStr\n"
  },
  {
    "id": 124,
    "category": "map",
    "file_name": "word_pattern",
    "codes": "\"\"\"\nGiven a pattern and a string str, find if str follows the same pattern.\nHere follow means a full match, such that there is a bijection between a\nletter in pattern and a non-empty word in str.\n\nExample 1:\nInput: pattern = \"abba\", str = \"dog cat cat dog\"\nOutput: true\n\nExample 2:\nInput:pattern = \"abba\", str = \"dog cat cat fish\"\nOutput: false\n\nExample 3:\nInput: pattern = \"aaaa\", str = \"dog cat cat dog\"\nOutput: false\n\nExample 4:\nInput: pattern = \"abba\", str = \"dog dog dog dog\"\nOutput: false\nNotes:\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.\nReference: https://leetcode.com/problems/word-pattern/description/\n\"\"\"\ndef word_pattern(pattern, str):\n    dict = {}\n    set_value = set()\n    list_str = str.split()\n    if len(list_str) != len(pattern):\n        return False\n    for i in range(len(pattern)):\n        if pattern[i] not in dict:\n            if list_str[i] in set_value:\n                return False\n            dict[pattern[i]] = list_str[i]\n            set_value.add(list_str[i])\n        else:\n            if dict[pattern[i]] != list_str[i]:\n                return False\n    return True\n"
  },
  {
    "id": 125,
    "category": "unionfind",
    "file_name": "count_islands",
    "codes": "\"\"\"\nDefines the Union-Find (or Disjoint Set) data structure.\n\nA disjoint set is made up of a number of elements contained within another\nnumber of sets. Initially, elements are put in their own set, but sets may be\nmerged using the `unite` operation. We can check if two elements are in the\nsame seet by comparing their `root`s. If they are identical, the two elements\nare in the same set. All operations can be completed in O(a(n)) where `n` is\nthe number of elements, and `a` the inverse ackermann function. a(n) grows so\nslowly that it might as well be constant for any conceivable `n`.\n\"\"\"\n\nclass Union:\n    \"\"\"\n    A Union-Find data structure.\n\n    Consider the following sequence of events:\n    Starting with the elements 1, 2, 3, and 4:\n\n        {1} {2} {3} {4}\n\n    Initally they all live in their own sets, which means that `root(1) !=\n    root(3)`, however, if we call `unite(1, 3)` we would then have the following:\n\n        {1,3} {2} {4}\n\n    Now we have `root(1) == root(3)`, but it is still the case that `root(1) != root(2)`.\n\n    We may call `unite(2, 4)` and end up with:\n\n        {1,3} {2,4}\n\n    Again we have `root(1) != root(2)`. But after `unite(3, 4)` we end up with:\n\n        {1,2,3,4}\n\n    which results in `root(1) == root(2)`.\n    \"\"\"\n\n    def __init__(self):\n        self.parents = {}\n        self.size = {}\n        self.count = 0\n\n    def add(self, element):\n        \"\"\"\n        Add a new set containing the single element\n        \"\"\"\n\n        self.parents[element] = element\n        self.size[element] = 1\n        self.count += 1\n\n    def root(self, element):\n        \"\"\"\n        Find the root element which represents the set of a given element.\n        That is, all elements that are in the same set will return the same\n        root element.\n        \"\"\"\n\n        while element != self.parents[element]:\n            self.parents[element] = self.parents[self.parents[element]]\n            element = self.parents[element]\n        return element\n\n    def unite(self, element1, element2):\n        \"\"\"\n        Finds the sets which contains the two elements and merges them into a\n        single set.\n        \"\"\"\n\n        root1, root2 = self.root(element1), self.root(element2)\n        if root1 == root2:\n            return\n        if self.size[root1] > self.size[root2]:\n            root1, root2 = root2, root1\n        self.parents[root1] = root2\n        self.size[root2] += self.size[root1]\n        self.count -= 1\n\ndef num_islands(positions):\n    \"\"\"\n    Given a list of positions to operate, count the number of islands\n    after each addLand operation. An island is surrounded by water and is\n    formed by connecting adjacent lands horizontally or vertically. You may\n    assume all four edges of the grid are all surrounded by water.\n\n    Given a 3x3 grid, positions = [[0,0], [0,1], [1,2], [2,1]].\n    Initially, the 2d grid grid is filled with water.\n    (Assume 0 represents water and 1 represents land).\n\n    0 0 0\n    0 0 0\n    0 0 0\n    Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land.\n\n    1 0 0\n    0 0 0   Number of islands = 1\n    0 0 0\n    Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land.\n\n    1 1 0\n    0 0 0   Number of islands = 1\n    0 0 0\n    Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land.\n\n    1 1 0\n    0 0 1   Number of islands = 2\n    0 0 0\n    Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land.\n\n    1 1 0\n    0 0 1   Number of islands = 3\n    0 1 0\n    \"\"\"\n\n    ans = []\n    islands = Union()\n    for position in map(tuple, positions):\n        islands.add(position)\n        for delta in (0, 1), (0, -1), (1, 0), (-1, 0):\n            adjacent = (position[0] + delta[0], position[1] + delta[1])\n            if adjacent in islands.parents:\n                islands.unite(position, adjacent)\n        ans += [islands.count]\n    return ans\n"
  },
  {
    "id": 126,
    "category": "streaming",
    "file_name": "one_sparse_recovery",
    "codes": "\"\"\"\nNon-negative 1-sparse recovery problem.\nThis algorithm assumes we have a non negative dynamic stream.\n\nGiven a stream of tuples, where each tuple contains a number and a sign (+/-), it check if the\nstream is 1-sparse, meaning if the elements in the stream cancel eacheother out in such\na way that ther is only a unique number at the end.\n\nExamples:\n#1\nInput:  [(4,'+'), (2,'+'),(2,'-'),(4,'+'),(3,'+'),(3,'-')],\nOutput: 4\nComment: Since 2 and 3 gets removed.\n#2\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+')]\nOutput: 2\nComment: No other numbers present\n#3\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(1,'+')]\nOutput: None\nComment: Not 1-sparse\n\"\"\"\n\ndef one_sparse(array):\n    \"\"\"1-sparse algorithm\n\n    Keyword arguments:\n    array -- stream of tuples\n    \"\"\"\n    sum_signs = 0\n    bitsum = [0]*32\n    sum_values = 0\n    for val,sign in array:\n        if sign == \"+\":\n            sum_signs += 1\n            sum_values += val\n        else:\n            sum_signs -= 1\n            sum_values -= val\n\n        _get_bit_sum(bitsum,val,sign)\n\n    if sum_signs > 0 and _check_every_number_in_bitsum(bitsum,sum_signs):\n        return int(sum_values/sum_signs)\n    else:\n        return None\n\n#Helper function to check that every entry in the list is either 0 or  the same as the\n#sum of signs\ndef _check_every_number_in_bitsum(bitsum,sum_signs):\n    for val in bitsum:\n        if val != 0 and val != sum_signs :\n            return False\n    return True\n\n# Adds bit representation value to bitsum array\ndef _get_bit_sum(bitsum,val,sign):\n    i = 0\n    if sign == \"+\":\n        while val:\n            bitsum[i] += val & 1\n            i +=1\n            val >>=1\n    else :\n        while val:\n            bitsum[i] -= val & 1\n            i +=1\n            val >>=1\n"
  },
  {
    "id": 127,
    "category": "streaming",
    "file_name": "misra_gries",
    "codes": "\n\"\"\"\nImplementation of the Misra-Gries algorithm.\nGiven a list of items and a value k, it returns the every item in the list\nthat appears at least n/k times, where n is the length of the array\n\nBy default, k is set to 2, solving the majority problem.\n\nFor the majority problem, this algorithm only guarantees that if there is\nan element that appears more than n/2 times, it will be outputed. If there\nis no such element, any arbitrary element is returned by the algorithm.\nTherefore, we need to iterate through again at the end. But since we have filtred\nout the suspects, the memory complexity is significantly lower than\nit would be to create counter for every element in the list.\n\nFor example:\nInput misras_gries([1,4,4,4,5,4,4])\nOutput {'4':5}\nInput misras_gries([0,0,0,1,1,1,1])\nOutput {'1':4}\nInput misras_gries([0,0,0,0,1,1,1,2,2],3)\nOutput {'0':4,'1':3}\nInput misras_gries([0,0,0,1,1,1]\nOutput None\n\"\"\"\n\ndef misras_gries(array,k=2):\n    \"\"\"Misra-Gries algorithm\n\n    Keyword arguments:\n    array -- list of integers\n    k -- value of k (default 2)\n    \"\"\"\n    keys = {}\n    for i in array:\n        val = str(i)\n        if val in keys:\n            keys[val] = keys[val] + 1\n\n        elif len(keys) < k - 1:\n            keys[val] = 1\n\n        else:\n            for key in list(keys):\n                keys[key] = keys[key] - 1\n                if keys[key] == 0:\n                    del keys[key]\n\n    suspects =  keys.keys()\n    frequencies = {}\n    for suspect in suspects:\n        freq = _count_frequency(array,int(suspect))\n        if freq >= len(array) / k:\n            frequencies[suspect] = freq\n\n    return frequencies if len(frequencies) > 0 else None\n\n\ndef _count_frequency(array,element):\n    return array.count(element)\n"
  },
  {
    "id": 128,
    "category": "greedy",
    "file_name": "max_contiguous_subsequence_sum",
    "codes": "'''\nAlgorithm used => Kadane's Algorithm\n\nkadane's algorithm is used for finding the maximum sum of contiguous subsequence in a sequence.\nIt is considered a greedy/dp algorithm but I think they more greedy than dp\nhere are some of the examples to understand the use case more clearly\nExample1 => [-2, 3, 8, -1, 4]\nresult =>  {3, 8, -1, 4} => 14\nExample2 => [-1, 1, 0]\nresult => {1} => 1\nExample3 => [-1, -3, -4]\nresult => -1\nExample1 => [-2, 3, 8, -12, 8, 4]\nresult =>  {8, 4} => 12\nBasic Algorithm Idea\n    If the sum of the current contiguous subsequence after adding the value at the current position is less than the value\n    at the current position then we know that it will be better if we start the current contiguous subsequence from this position.\n    Else we add the value at the current position to the current contiguous subsequence.\nNote\n    In the implementation, the contiguous subsequence has at least one element.\n    If it can have 0 elements then the result will be max(max_till_now, 0)\n'''\n\n\ndef max_contiguous_subsequence_sum(arr) -> int:\n    arr_size = len(arr)\n\n    if arr_size == 0:\n        return 0\n\n    max_till_now = arr[0]\n    curr_sub_sum = 0\n\n    for i in range(0, arr_size):\n        if curr_sub_sum + arr[i] < arr[i]:\n            curr_sub_sum = arr[i]\n        else:\n            curr_sub_sum += arr[i]\n\n        max_till_now = max(max_till_now, curr_sub_sum)\n\n    return max_till_now\n"
  },
  {
    "id": 129,
    "category": "set",
    "file_name": "find_keyboard_row",
    "codes": "\"\"\"\nGiven a List of words, return the words that can be typed using letters of\nalphabet on only one row's of American keyboard.\n\nFor example:\nInput: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\nOutput: [\"Alaska\", \"Dad\"]\n\nReference: https://leetcode.com/problems/keyboard-row/description/\n\"\"\"\n\ndef find_keyboard_row(words):\n    \"\"\"\n    :type words: List[str]\n    :rtype: List[str]\n    \"\"\"\n    keyboard = [\n        set('qwertyuiop'),\n        set('asdfghjkl'),\n        set('zxcvbnm'),\n    ]\n    result = []\n    for word in words:\n        for key in keyboard:\n            if set(word.lower()).issubset(key):\n                result.append(word)\n    return result\n"
  },
  {
    "id": 130,
    "category": "set",
    "file_name": "set_covering",
    "codes": "from itertools import chain, combinations\n\n\"\"\"\nUniverse *U* of n elements\nCollection of subsets of U:\n    S = S1,S2...,Sm\n    Where every substet Si has an associated cost.\n\nFind a minimum cost subcollection of S that covers all elements of U\n\nExample:\n    U = {1,2,3,4,5}\n    S = {S1,S2,S3}\n\n    S1 = {4,1,3},    Cost(S1) = 5\n    S2 = {2,5},      Cost(S2) = 10\n    S3 = {1,4,3,2},  Cost(S3) = 3\n\n    Output:\n        Set cover = {S2, S3}\n        Min Cost = 13\n\"\"\"\n\n\ndef powerset(iterable):\n    \"\"\"Calculate the powerset of any iterable.\n\n    For a range of integers up to the length of the given list,\n    make all possible combinations and chain them together as one object.\n    From https://docs.python.org/3/library/itertools.html#itertools-recipes\n    \"\"\"\n    \"list(powerset([1,2,3])) --> [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n\n\ndef optimal_set_cover(universe, subsets, costs):\n    \"\"\" Optimal algorithm - DONT USE ON BIG INPUTS - O(2^n) complexity!\n    Finds the minimum cost subcollection os S that covers all elements of U\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    pset = powerset(subsets.keys())\n    best_set = None\n    best_cost = float(\"inf\")\n    for subset in pset:\n        covered = set()\n        cost = 0\n        for s in subset:\n            covered.update(subsets[s])\n            cost += costs[s]\n        if len(covered) == len(universe) and cost < best_cost:\n            best_set = subset\n            best_cost = cost\n    return best_set\n\n\ndef greedy_set_cover(universe, subsets, costs):\n    \"\"\"Approximate greedy algorithm for set-covering. Can be used on large\n    inputs - though not an optimal solution.\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    elements = set(e for s in subsets.keys() for e in subsets[s])\n    # elements don't cover universe -> invalid input for set cover\n    if elements != universe:\n        return None\n\n    # track elements of universe covered\n    covered = set()\n    cover_sets = []\n\n    while covered != universe:\n        min_cost_elem_ratio = float(\"inf\")\n        min_set = None\n        # find set with minimum cost:elements_added ratio\n        for s, elements in subsets.items():\n            new_elements = len(elements - covered)\n            # set may have same elements as already covered -> new_elements = 0\n            # check to avoid division by 0 error\n            if new_elements != 0:\n                cost_elem_ratio = costs[s] / new_elements\n                if cost_elem_ratio < min_cost_elem_ratio:\n                    min_cost_elem_ratio = cost_elem_ratio\n                    min_set = s\n        cover_sets.append(min_set)\n        # union\n        covered |= subsets[min_set]\n    return cover_sets\n\n\nif __name__ == '__main__':\n    universe = {1, 2, 3, 4, 5}\n    subsets = {'S1': {4, 1, 3}, 'S2': {2, 5}, 'S3': {1, 4, 3, 2}}\n    costs = {'S1': 5, 'S2': 10, 'S3': 3}\n\n    optimal_cover = optimal_set_cover(universe, subsets, costs)\n    optimal_cost = sum(costs[s] for s in optimal_cover)\n\n    greedy_cover = greedy_set_cover(universe, subsets, costs)\n    greedy_cost = sum(costs[s] for s in greedy_cover)\n\n    print('Optimal Set Cover:')\n    print(optimal_cover)\n    print('Cost = %s' % optimal_cost)\n\n    print('Greedy Set Cover:')\n    print(greedy_cover)\n    print('Cost = %s' % greedy_cost)\n"
  },
  {
    "id": 131,
    "category": "set",
    "file_name": "randomized_set",
    "codes": "#! /usr/bin/env python3\n\n\"\"\"\nDesign a data structure that supports all following operations\nin average O(1) time.\n\ninsert(val): Inserts an item val to the set if not already present.\nremove(val): Removes an item val from the set if present.\nrandom_element: Returns a random element from current set of elements.\n           Each element must have the same probability of being returned.\n\"\"\"\n\nimport random\n\n\nclass RandomizedSet():\n    \"\"\"\n    idea: shoot\n    \"\"\"\n\n    def __init__(self):\n        self.elements = []\n        self.index_map = {}  # element -> index\n\n    def insert(self, new_one):\n        if new_one in self.index_map:\n            return\n        self.index_map[new_one] = len(self.elements)\n        self.elements.append(new_one)\n\n    def remove(self, old_one):\n        if not old_one in self.index_map:\n            return\n        index = self.index_map[old_one]\n        last = self.elements.pop()\n        self.index_map.pop(old_one)\n        if index == len(self.elements):\n            return\n        self.elements[index] = last\n        self.index_map[last] = index\n\n    def random_element(self):\n        return random.choice(self.elements)\n\n\ndef __test():\n    rset = RandomizedSet()\n    ground_truth = set()\n    n = 64\n\n    for i in range(n):\n        rset.insert(i)\n        ground_truth.add(i)\n\n    # Remove a half\n    for i in random.sample(range(n), n // 2):\n        rset.remove(i)\n        ground_truth.remove(i)\n\n    print(len(ground_truth), len(rset.elements), len(rset.index_map))\n    for i in ground_truth:\n        assert(i == rset.elements[rset.index_map[i]])\n\n    for i in range(n):\n        print(rset.random_element(), end=' ')\n    print()\n\n\nif __name__ == \"__main__\":\n    __test()\n"
  },
  {
    "id": 132,
    "category": "maths",
    "file_name": "magic_number",
    "codes": "\"\"\"\nMagic Number\nA number is said to be a magic number,\nif summing the digits of the number and then recursively repeating this process for the given sum\nuntill the number becomes a single digit number equal to 1.\n\nExample:\n    Number = 50113 => 5+0+1+1+3=10 => 1+0=1 [This is a Magic Number]\n    Number = 1234 => 1+2+3+4=10 => 1+0=1 [This is a Magic Number]\n    Number = 199 => 1+9+9=19 => 1+9=10 => 1+0=1 [This is a Magic Number]\n    Number = 111 => 1+1+1=3 [This is NOT a Magic Number]\n\nThe following function checks for Magic numbers and returns a Boolean accordingly.\n\"\"\"\n\ndef magic_number(n):\n    \"\"\" Checks if n is a magic number \"\"\"\n    total_sum = 0\n\n    # will end when n becomes 0\n    # AND\n    # sum becomes single digit.\n    while n > 0 or total_sum > 9:\n        # when n becomes 0 but we have a total_sum,\n        # we update the value of n with the value of the sum digits\n        if n == 0:\n            n = total_sum  # only when sum of digits isn't single digit\n            total_sum = 0\n        total_sum += n % 10\n        n //= 10\n\n    # Return true if sum becomes 1\n    return total_sum == 1\n"
  },
  {
    "id": 133,
    "category": "maths",
    "file_name": "primes_sieve_of_eratosthenes",
    "codes": "\"\"\"\nReturn list of all primes less than n,\nUsing sieve of Eratosthenes.\n\nModification:\nWe don't need to check all even numbers, we can make the sieve excluding even\nnumbers and adding 2 to the primes list by default.\n\nWe are going to make an array of: x / 2 - 1 if number is even, else x / 2\n(The -1 with even number it's to exclude the number itself)\nBecause we just need numbers [from 3..x if x is odd]\n\n# We can get value represented at index i with (i*2 + 3)\n\nFor example, for x = 10, we start with an array of x / 2 - 1 = 4\n[1, 1, 1, 1]\n 3  5  7  9\n\nFor x = 11:\n[1, 1, 1, 1, 1]\n 3  5  7  9  11  # 11 is odd, it's included in the list\n\nWith this, we have reduced the array size to a half,\nand complexity it's also a half now.\n\"\"\"\n\ndef get_primes(n):\n    \"\"\"Return list of all primes less than n,\n    Using sieve of Eratosthenes.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    # If x is even, exclude x from list (-1):\n    sieve_size = (n // 2 - 1) if n % 2 == 0 else (n // 2)\n    sieve = [True for _ in range(sieve_size)]   # Sieve\n    primes = []      # List of Primes\n    if n >= 2:\n        primes.append(2)      # 2 is prime by default\n    for i in range(sieve_size):\n        if sieve[i]:\n            value_at_i = i*2 + 3\n            primes.append(value_at_i)\n            for j in range(i, sieve_size, value_at_i):\n                sieve[j] = False\n    return primes\n"
  },
  {
    "id": 134,
    "category": "maths",
    "file_name": "pythagoras",
    "codes": "\"\"\"\nGiven the lengths of two of the three sides of a right angled triangle, this function returns the\nlength of the third side.\n\"\"\"\n\ndef pythagoras(opposite, adjacent, hypotenuse):\n    \"\"\"\n    Returns length of a third side of a right angled triangle.\n    Passing \"?\" will indicate the unknown side.\n    \"\"\"\n    try:\n        if opposite == str(\"?\"):\n            return (\"Opposite = \" + str(((hypotenuse**2) - (adjacent**2))**0.5))\n        if adjacent == str(\"?\"):\n            return (\"Adjacent = \" + str(((hypotenuse**2) - (opposite**2))**0.5))\n        if hypotenuse == str(\"?\"):\n            return (\"Hypotenuse = \" + str(((opposite**2) + (adjacent**2))**0.5))\n        return \"You already know the answer!\"\n    except:\n        raise ValueError(\"invalid argument(s) were given.\")\n"
  },
  {
    "id": 135,
    "category": "maths",
    "file_name": "summing_digits",
    "codes": "\"\"\"\nRecently, I encountered an interview question whose description was as below:\n\nThe number 89 is the first integer with more than one digit whose digits when raised up to\nconsecutive powers give the same number. For example, 89 = 8**1 + 9**2 gives the number 89.\n\nThe next number after 89 with this property is 135 = 1**1 + 3**2 + 5**3 = 135.\n\nWrite a function that returns a list of numbers with the above property. The function will\nreceive range as parameter.\n\"\"\"\n\ndef sum_dig_pow(low, high):\n    result = []\n\n    for number in range(low, high + 1):\n        exponent = 1  # set to 1\n        summation = 0    # set to 1\n        number_as_string = str(number)\n\n        tokens = list(map(int, number_as_string))  # parse the string into individual digits\n\n        for k in tokens:\n            summation = summation + (k ** exponent)\n            exponent += 1\n\n        if summation == number:\n            result.append(number)\n    return result\n\n\n# Some test cases:\nassert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89]\n"
  },
  {
    "id": 136,
    "category": "maths",
    "file_name": "rabin_miller",
    "codes": "\"\"\"\nRabin-Miller primality test\nreturning False implies that n is guaranteed composite\nreturning True means that n is probably prime\nwith a 4 ** -k chance of being wrong\n\"\"\"\nimport random\n\n\ndef is_prime(n, k):\n\n    def pow2_factor(num):\n        \"\"\"factor n into a power of 2 times an odd number\"\"\"\n        power = 0\n        while num % 2 == 0:\n            num /= 2\n            power += 1\n        return power, num\n\n    def valid_witness(a):\n        \"\"\"\n        returns true if a is a valid 'witness' for n\n        a valid witness increases chances of n being prime\n        an invalid witness guarantees n is composite\n        \"\"\"\n        x = pow(int(a), int(d), int(n))\n\n        if x == 1 or x == n - 1:\n            return False\n\n        for _ in range(r - 1):\n            x = pow(int(x), int(2), int(n))\n\n            if x == 1:\n                return True\n            if x == n - 1:\n                return False\n\n        return True\n\n    # precondition n >= 5\n    if n < 5:\n        return n == 2 or n == 3  # True for prime\n\n    r, d = pow2_factor(n - 1)\n\n    for _ in range(k):\n        if valid_witness(random.randrange(2, n - 2)):\n            return False\n\n    return True\n"
  },
  {
    "id": 137,
    "category": "maths",
    "file_name": "combination",
    "codes": "\"\"\"\nFunctions to calculate nCr (ie how many ways to choose r items from n items)\n\"\"\"\ndef combination(n, r):\n    \"\"\"This function calculates nCr.\"\"\"\n    if n == r or r == 0:\n        return 1\n    return combination(n-1, r-1) + combination(n-1, r)\n\ndef combination_memo(n, r):\n    \"\"\"This function calculates nCr using memoization method.\"\"\"\n    memo = {}\n    def recur(n, r):\n        if n == r or r == 0:\n            return 1\n        if (n, r) not in memo:\n            memo[(n, r)] = recur(n - 1, r - 1) + recur(n - 1, r)\n        return memo[(n, r)]\n    return recur(n, r)\n"
  },
  {
    "id": 138,
    "category": "maths",
    "file_name": "sqrt_precision_factor",
    "codes": "\"\"\"\nGiven a positive integer N and a precision factor P,\nit produces an output\nwith a maximum error P from the actual square root of N.\n\nExample:\nGiven N = 5 and P = 0.001, can produce output x such that\n2.235 < x < 2.237. Actual square root of 5 being 2.236.\n\"\"\"\n\n\ndef square_root(n, epsilon=0.001):\n    \"\"\"Return square root of n, with maximum absolute error epsilon\"\"\"\n    guess = n / 2\n\n    while abs(guess * guess - n) > epsilon:\n        guess = (guess + (n / guess)) / 2\n\n    return guess\n"
  },
  {
    "id": 139,
    "category": "maths",
    "file_name": "factorial",
    "codes": "\"\"\"\nCalculates the factorial with the added functionality of calculating it modulo mod.\n\"\"\"\ndef factorial(n, mod=None):\n    \"\"\"Calculates factorial iteratively.\n    If mod is not None, then return (n! % mod)\n    Time Complexity - O(n)\"\"\"\n    if not (isinstance(n, int) and n >= 0):\n        raise ValueError(\"'n' must be a non-negative integer.\")\n    if mod is not None and not (isinstance(mod, int) and mod > 0):\n        raise ValueError(\"'mod' must be a positive integer\")\n    result = 1\n    if n == 0:\n        return 1\n    for i in range(2, n+1):\n        result *= i\n        if mod:\n            result %= mod\n    return result\n\n\ndef factorial_recur(n, mod=None):\n    \"\"\"Calculates factorial recursively.\n    If mod is not None, then return (n! % mod)\n    Time Complexity - O(n)\"\"\"\n    if not (isinstance(n, int) and n >= 0):\n        raise ValueError(\"'n' must be a non-negative integer.\")\n    if mod is not None and not (isinstance(mod, int) and mod > 0):\n        raise ValueError(\"'mod' must be a positive integer\")\n    if n == 0:\n        return 1\n    result = n * factorial(n - 1, mod)\n    if mod:\n        result %= mod\n    return result\n"
  },
  {
    "id": 140,
    "category": "maths",
    "file_name": "generate_strobogrammtic",
    "codes": "\"\"\"\nA strobogrammatic number is a number that looks\nthe same when rotated 180 degrees (looked at upside down).\n\nFind all strobogrammatic numbers that are of length = n.\n\nFor example,\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\n\"\"\"\n\ndef gen_strobogrammatic(n):\n    \"\"\"\n    Given n, generate all strobogrammatic numbers of length n.\n    :type n: int\n    :rtype: List[str]\n    \"\"\"\n    return helper(n, n)\n\ndef helper(n, length):\n    if n == 0:\n        return [\"\"]\n    if n == 1:\n        return [\"1\", \"0\", \"8\"]\n    middles = helper(n-2, length)\n    result = []\n    for middle in middles:\n        if n != length:\n            result.append(\"0\" + middle + \"0\")\n        result.append(\"8\" + middle + \"8\")\n        result.append(\"1\" + middle + \"1\")\n        result.append(\"9\" + middle + \"6\")\n        result.append(\"6\" + middle + \"9\")\n    return result\n\ndef strobogrammatic_in_range(low, high):\n    \"\"\"\n    :type low: str\n    :type high: str\n    :rtype: int\n    \"\"\"\n    res = []\n    count = 0\n    low_len = len(low)\n    high_len = len(high)\n    for i in range(low_len, high_len + 1):\n        res.extend(helper2(i, i))\n    for perm in res:\n        if len(perm) == low_len and int(perm) < int(low):\n            continue\n        if len(perm) == high_len and int(perm) > int(high):\n            continue\n        count += 1\n    return count\n\ndef helper2(n, length):\n    if n == 0:\n        return [\"\"]\n    if n == 1:\n        return [\"0\", \"8\", \"1\"]\n    mids = helper(n-2, length)\n    res = []\n    for mid in mids:\n        if n != length:\n            res.append(\"0\"+mid+\"0\")\n        res.append(\"1\"+mid+\"1\")\n        res.append(\"6\"+mid+\"9\")\n        res.append(\"9\"+mid+\"6\")\n        res.append(\"8\"+mid+\"8\")\n    return res\n"
  },
  {
    "id": 141,
    "category": "maths",
    "file_name": "euler_totient",
    "codes": "\"\"\"\nEuler's totient function, also known as phi-function \u03d5(n),\ncounts the number of integers between 1 and n inclusive,\nwhich are coprime to n.\n(Two numbers are coprime if their greatest common divisor (GCD) equals 1).\n\"\"\"\ndef euler_totient(n):\n    \"\"\"Euler's totient function or Phi function.\n    Time Complexity: O(sqrt(n)).\"\"\"\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result\n"
  },
  {
    "id": 142,
    "category": "maths",
    "file_name": "krishnamurthy_number",
    "codes": "\"\"\"\nA Krishnamurthy number is a number whose sum total of the factorials of each digit is equal to the\nnumber itself.\n\nThe following are some examples of Krishnamurthy numbers:\n\n\"145\" is a Krishnamurthy Number because,\n1! + 4! + 5! = 1 + 24 + 120 = 145\n\n\"40585\" is also a Krishnamurthy Number.\n4! + 0! + 5! + 8! + 5! = 40585\n\n\"357\" or \"25965\" is NOT a Krishnamurthy Number\n3! + 5! + 7! = 6 + 120 + 5040 != 357\n\nThe following function will check if a number is a Krishnamurthy Number or not and return a\nboolean value.\n\"\"\"\n\n\ndef find_factorial(n):\n    \"\"\" Calculates the factorial of a given number n \"\"\"\n    fact = 1\n    while n != 0:\n        fact *= n\n        n -= 1\n    return fact\n\n\ndef krishnamurthy_number(n):\n    if n == 0:\n        return False\n    sum_of_digits = 0   # will hold sum of FACTORIAL of digits\n    temp = n\n\n    while temp != 0:\n\n        # get the factorial of of the last digit of n and add it to sum_of_digits\n        sum_of_digits += find_factorial(temp % 10)\n\n        # replace value of temp by temp/10\n        # i.e. will remove the last digit from temp\n        temp //= 10\n\n    # returns True if number is krishnamurthy\n    return sum_of_digits == n\n"
  },
  {
    "id": 143,
    "category": "maths",
    "file_name": "prime_check",
    "codes": "def prime_check(n):\n    \"\"\"Return True if n is a prime number\n    Else return False.\n    \"\"\"\n\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    j = 5\n    while j * j <= n:\n        if n % j == 0 or n % (j + 2) == 0:\n            return False\n        j += 6\n    return True\n"
  },
  {
    "id": 144,
    "category": "maths",
    "file_name": "num_digits",
    "codes": "\"\"\"\nnum_digits() method will return the number of digits of a number in O(1) time using\nmath.log10() method.\n\"\"\"\n\nimport math\n\ndef num_digits(n):\n    n=abs(n)\n    if n==0:\n        return 1\n    return int(math.log10(n))+1\n"
  },
  {
    "id": 145,
    "category": "maths",
    "file_name": "next_perfect_square",
    "codes": "\"\"\"\nThis program will look for the next perfect square.\nCheck the argument to see if it is a perfect square itself, if it is not then return -1 otherwise\nlook for the next perfect square.\nfor instance if you pass 121 then the script should return the next perfect square which is 144.\n\"\"\"\n\ndef find_next_square(sq):\n    root = sq ** 0.5\n    if root.is_integer():\n        return (root + 1)**2\n    return -1\n\ndef find_next_square2(sq):\n    \"\"\" Alternative method, works by evaluating anything non-zero as True (0.000001 --> True) \"\"\"\n    root = sq**0.5\n    return -1 if root % 1 else (root+1)**2\n"
  },
  {
    "id": 146,
    "category": "maths",
    "file_name": "diffie_hellman_key_exchange",
    "codes": "\"\"\"\nAlgorithms for performing diffie-hellman key exchange.\n\"\"\"\nimport math\nfrom random import randint\n\n\n\"\"\"\nCode from /algorithms/maths/prime_check.py,\nwritten by 'goswami-rahul' and 'Hai Honag Dang'\n\"\"\"\ndef prime_check(num):\n    \"\"\"Return True if num is a prime number\n    Else return False.\n    \"\"\"\n\n    if num <= 1:\n        return False\n    if num == 2 or num == 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    j = 5\n    while j * j <= num:\n        if num % j == 0 or num % (j + 2) == 0:\n            return False\n        j += 6\n    return True\n\n\n\"\"\"\nFor positive integer n and given integer a that satisfies gcd(a, n) = 1,\nthe order of a modulo n is the smallest positive integer k that satisfies\npow (a, k) % n = 1. In other words, (a^k) \u2261 1 (mod n).\nOrder of certain number may or may not exist. If not, return -1.\n\"\"\"\ndef find_order(a, n):\n    if (a == 1) & (n == 1):\n        # Exception Handeling : 1 is the order of of 1\n        return 1\n    if math.gcd(a, n) != 1:\n        print (\"a and n should be relative prime!\")\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1\n\n\n\"\"\"\nEuler's totient function, also known as phi-function \u03d5(n),\ncounts the number of integers between 1 and n inclusive,\nwhich are coprime to n.\n(Two numbers are coprime if their greatest common divisor (GCD) equals 1).\nCode from /algorithms/maths/euler_totient.py, written by 'goswami-rahul'\n\"\"\"\ndef euler_totient(n):\n    \"\"\"Euler's totient function or Phi function.\n    Time Complexity: O(sqrt(n)).\"\"\"\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result\n\n\"\"\"\nFor positive integer n and given integer a that satisfies gcd(a, n) = 1,\na is the primitive root of n, if a's order k for n satisfies k = \u03d5(n).\nPrimitive roots of certain number may or may not be exist.\nIf so, return empty list.\n\"\"\"\n\ndef find_primitive_root(n):\n    \"\"\" Returns all primitive roots of n. \"\"\"\n    if n == 1:\n        # Exception Handeling : 0 is the only primitive root of 1\n        return [0]\n    phi = euler_totient(n)\n    p_root_list = []\n    for i in range (1, n):\n        if math.gcd(i, n) != 1:\n            # To have order, a and n must be relative prime with each other.\n            continue\n        order = find_order(i, n)\n        if order == phi:\n            p_root_list.append(i)\n    return p_root_list\n\n\n\"\"\"\nDiffie-Hellman key exchange is the method that enables\ntwo entities (in here, Alice and Bob), not knowing each other,\nto share common secret key through not-encrypted communication network.\nThis method use the property of one-way function (discrete logarithm)\nFor example, given a, b and n, it is easy to calculate x\nthat satisfies (a^b) \u2261 x (mod n).\nHowever, it is very hard to calculate x that satisfies (a^x) \u2261 b (mod n).\nFor using this method, large prime number p and its primitive root a\nmust be given.\n\"\"\"\n\ndef alice_private_key(p):\n    \"\"\"Alice determine her private key\n    in the range of 1 ~ p-1.\n    This must be kept in secret\"\"\"\n    return randint(1, p-1)\n\n\ndef alice_public_key(a_pr_k, a, p):\n    \"\"\"Alice calculate her public key\n    with her private key.\n    This is open to public\"\"\"\n    return pow(a, a_pr_k) % p\n\n\ndef bob_private_key(p):\n    \"\"\"Bob determine his private key\n    in the range of 1 ~ p-1.\n    This must be kept in secret\"\"\"\n    return randint(1, p-1)\n\n\ndef bob_public_key(b_pr_k, a, p):\n    \"\"\"Bob calculate his public key\n    with his private key.\n    This is open to public\"\"\"\n    return pow(a, b_pr_k) % p\n\n\ndef alice_shared_key(b_pu_k, a_pr_k, p):\n    \"\"\" Alice calculate secret key shared with Bob,\n    with her private key and Bob's public key.\n    This must be kept in secret\"\"\"\n    return pow(b_pu_k, a_pr_k) % p\n\n\ndef bob_shared_key(a_pu_k, b_pr_k, p):\n    \"\"\" Bob calculate secret key shared with Alice,\n    with his private key and Alice's public key.\n    This must be kept in secret\"\"\"\n    return pow(a_pu_k, b_pr_k) % p\n\n\ndef diffie_hellman_key_exchange(a, p, option = None):\n    \"\"\" Perform diffie-helmman key exchange. \"\"\"\n    if option is not None:\n        # Print explanation of process when option parameter is given\n        option = 1\n    if prime_check(p) is False:\n        print(f\"{p} is not a prime number\")\n        # p must be large prime number\n        return False\n    try:\n        p_root_list = find_primitive_root(p)\n        p_root_list.index(a)\n    except ValueError:\n        print(f\"{a} is not a primitive root of {p}\")\n        # a must be primitive root of p\n        return False\n\n    a_pr_k = alice_private_key(p)\n    a_pu_k = alice_public_key(a_pr_k, a, p)\n\n    b_pr_k = bob_private_key(p)\n    b_pu_k = bob_public_key(b_pr_k, a, p)\n\n    if option == 1:\n        print(f\"Alice's private key: {a_pr_k}\")\n        print(f\"Alice's public key: {a_pu_k}\")\n        print(f\"Bob's private key: {b_pr_k}\")\n        print(f\"Bob's public key: {b_pu_k}\")\n\n    # In here, Alice send her public key to Bob, and Bob also send his public key to Alice.\n\n    a_sh_k = alice_shared_key(b_pu_k, a_pr_k, p)\n    b_sh_k = bob_shared_key(a_pu_k, b_pr_k, p)\n    print (f\"Shared key calculated by Alice = {a_sh_k}\")\n    print (f\"Shared key calculated by Bob = {b_sh_k}\")\n\n    return a_sh_k == b_sh_k\n"
  },
  {
    "id": 147,
    "category": "maths",
    "file_name": "modular_exponential",
    "codes": "def modular_exponential(base, exponent, mod):\n    \"\"\"Computes (base ^ exponent) % mod.\n    Time complexity - O(log n)\n    Use similar to Python in-built function pow.\"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be positive.\")\n    base %= mod\n    result = 1\n\n    while exponent > 0:\n        # If the last bit is 1, add 2^k.\n        if exponent & 1:\n            result = (result * base) % mod\n        exponent = exponent >> 1\n        # Utilize modular multiplication properties to combine the computed mod C values.\n        base = (base * base) % mod\n\n    return result\n"
  },
  {
    "id": 148,
    "category": "maths",
    "file_name": "num_perfect_squares",
    "codes": "\"\"\"\nGiven an integer num_perfect_squares will return the minimum amount of perfect squares are required\nto sum to the specified number. Lagrange's four-square theorem gives us that the answer will always\nbe between 1 and 4 (https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem).\n\nSome examples:\nNumber | Perfect Squares representation | Answer\n-------|--------------------------------|--------\n9      | 3^2                            | 1\n10     | 3^2 + 1^2                      | 2\n12     | 2^2 + 2^2 + 2^2                | 3\n31     | 5^2 + 2^2 + 1^2 + 1^2          | 4\n\"\"\"\n\nimport math\n\ndef num_perfect_squares(number):\n    \"\"\"\n    Returns the smallest number of perfect squares that sum to the specified number.\n    :return: int between 1 - 4\n    \"\"\"\n    # If the number is a perfect square then we only need 1 number.\n    if int(math.sqrt(number))**2 == number:\n        return 1\n\n    # We check if https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem holds and divide\n    # the number accordingly. Ie. if the number can be written as a sum of 3 squares (where the\n    # 0^2 is allowed), which is possible for all numbers except those of the form: 4^a(8b + 7).\n    while number > 0 and number % 4 == 0:\n        number /= 4\n\n    # If the number is of the form: 4^a(8b + 7) it can't be expressed as a sum of three (or less\n    # excluding the 0^2) perfect squares. If the number was of that form, the previous while loop\n    # divided away the 4^a, so by now it would be of the form: 8b + 7. So check if this is the case\n    # and return 4 since it neccessarily must be a sum of 4 perfect squares, in accordance \n    # with https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem.\n    if number % 8 == 7:\n        return 4\n\n    # By now we know that the number wasn't of the form 4^a(8b + 7) so it can be expressed as a sum\n    # of 3 or less perfect squares. Try first to express it as a sum of 2 perfect squares, and if\n    # that fails, we know finally that it can be expressed as a sum of 3 perfect squares.\n    for i in range(1, int(math.sqrt(number)) + 1):\n        if int(math.sqrt(number - i**2))**2 == number - i**2:\n            return 2\n\n    return 3\n"
  },
  {
    "id": 149,
    "category": "maths",
    "file_name": "cosine_similarity",
    "codes": "\"\"\"\nCalculate cosine similarity between given two 1d list.\nTwo list must have the same length.\n\nExample:\ncosine_similarity([1, 1, 1], [1, 2, -1])  # output : 0.47140452079103173\n\"\"\"\nimport math\n\n\ndef _l2_distance(vec):\n    \"\"\"\n    Calculate l2 distance from two given vectors.\n    \"\"\"\n    norm = 0.\n    for element in vec:\n        norm += element * element\n    norm = math.sqrt(norm)\n    return norm\n\n\ndef cosine_similarity(vec1, vec2):\n    \"\"\"\n    Calculate cosine similarity between given two vectors\n    :type vec1: list\n    :type vec2: list\n    \"\"\"\n    if len(vec1) != len(vec2):\n        raise ValueError(\"The two vectors must be the same length. Got shape \" + str(len(vec1))\n                        + \" and \" + str(len(vec2)))\n\n    norm_a = _l2_distance(vec1)\n    norm_b = _l2_distance(vec2)\n\n    similarity = 0.\n\n    # Calculate the dot product of two vectors\n    for vec1_element, vec2_element in zip(vec1, vec2):\n        similarity += vec1_element * vec2_element\n\n    similarity /= (norm_a * norm_b)\n\n    return similarity\n"
  },
  {
    "id": 150,
    "category": "maths",
    "file_name": "find_order_simple",
    "codes": "\"\"\"\nFor positive integer n and given integer a that satisfies gcd(a, n) = 1,\nthe order of a modulo n is the smallest positive integer k that satisfies\npow (a, k) % n = 1. In other words, (a^k) \u2261 1 (mod n).\nOrder of a certain number may or may not be exist. If not, return -1.\n\nTotal time complexity O(nlog(n)):\nO(n) for iteration loop, \nO(log(n)) for built-in power function\n\"\"\"\n\nimport math\n\ndef find_order(a, n):\n    \"\"\"\n    Find order for positive integer n and given integer a that satisfies gcd(a, n) = 1.\n    \"\"\"\n    if (a == 1) & (n == 1):\n        # Exception Handeling : 1 is the order of of 1\n        return 1\n    if math.gcd(a, n) != 1:\n        print (\"a and n should be relative prime!\")\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1\n"
  },
  {
    "id": 151,
    "category": "maths",
    "file_name": "power",
    "codes": "\"\"\"\nPerforms exponentiation, similarly to the built-in pow() or ** functions.\nAllows also for calculating the exponentiation modulo.\n\"\"\"\ndef power(a: int, n: int, mod: int = None):\n    \"\"\"\n    Iterative version of binary exponentiation\n\n    Calculate a ^ n\n    if mod is specified, return the result modulo mod\n\n    Time Complexity :  O(log(n))\n    Space Complexity : O(1)\n    \"\"\"\n    ans = 1\n    while n:\n        if n & 1:\n            ans = ans * a\n        a = a * a\n        if mod:\n            ans %= mod\n            a %= mod\n        n >>= 1\n    return ans\n\n\ndef power_recur(a: int, n: int, mod: int = None):\n    \"\"\"\n    Recursive version of binary exponentiation\n\n    Calculate a ^ n\n    if mod is specified, return the result modulo mod\n\n    Time Complexity :  O(log(n))\n    Space Complexity : O(log(n))\n    \"\"\"\n    if n == 0:\n        ans = 1\n    elif n == 1:\n        ans = a\n    else:\n        ans = power_recur(a, n // 2, mod)\n        ans = ans * ans\n        if n % 2:\n            ans = ans * a\n    if mod:\n        ans %= mod\n    return ans\n"
  },
  {
    "id": 152,
    "category": "maths",
    "file_name": "decimal_to_binary_ip",
    "codes": "\"\"\"\nGiven an ip address in dotted-decimal representation, determine the\nbinary representation. For example,\ndecimal_to_binary(255.0.0.5) returns 11111111.00000000.00000000.00000101\naccepts string\nreturns string\n\"\"\"\n\ndef decimal_to_binary_util(val):\n    \"\"\"\n    Convert 8-bit decimal number to binary representation\n    :type val: str\n    :rtype: str\n    \"\"\"\n    bits = [128, 64, 32, 16, 8, 4, 2, 1]\n    val = int(val)\n    binary_rep = ''\n    for bit in bits:\n        if val >= bit:\n            binary_rep += str(1)\n            val -= bit\n        else:\n            binary_rep += str(0)\n\n    return binary_rep\n\ndef decimal_to_binary_ip(ip):\n    \"\"\"\n    Convert dotted-decimal ip address to binary representation with help of decimal_to_binary_util\n    \"\"\"\n    values = ip.split('.')\n    binary_list = []\n    for val in values:\n        binary_list.append(decimal_to_binary_util(val))\n    return '.'.join(binary_list)\n"
  },
  {
    "id": 153,
    "category": "maths",
    "file_name": "recursive_binomial_coefficient",
    "codes": "def recursive_binomial_coefficient(n,k):\n    \"\"\"Calculates the binomial coefficient, C(n,k), with n>=k using recursion\n    Time complexity is O(k), so can calculate fairly quickly for large values of k.\n\n    >>> recursive_binomial_coefficient(5,0)\n    1\n\n    >>> recursive_binomial_coefficient(8,2)\n    28\n\n    >>> recursive_binomial_coefficient(500,300)\n    5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640\n\n    \"\"\"\n\n    if k>n:\n        raise ValueError('Invalid Inputs, ensure that n >= k')\n        #function is only defined for n>=k\n    if k == 0 or n == k:\n        #C(n,0) = C(n,n) = 1, so this is our base case.\n        return 1\n    if k > n/2:\n        #C(n,k) = C(n,n-k), so if n/2 is sufficiently small, we can reduce the problem size.\n        return recursive_binomial_coefficient(n,n-k)\n    #else, we know C(n,k) = (n/k)C(n-1,k-1), so we can use this to reduce our problem size.\n    return int((n/k)*recursive_binomial_coefficient(n-1,k-1))\n"
  },
  {
    "id": 154,
    "category": "maths",
    "file_name": "rsa",
    "codes": "\"\"\"\nRSA encryption algorithm\na method for encrypting a number that uses seperate encryption and decryption keys\nthis file only implements the key generation algorithm\n\nthere are three important numbers in RSA called n, e, and d\ne is called the encryption exponent\nd is called the decryption exponent\nn is called the modulus\n\nthese three numbers satisfy\n((x ** e) ** d) % n == x % n\n\nto use this system for encryption, n and e are made publicly available, and d is kept secret\na number x can be encrypted by computing (x ** e) % n\nthe original number can then be recovered by computing (E ** d) % n, where E is\nthe encrypted number\n\nfortunately, python provides a three argument version of pow() that can compute powers modulo\na number very quickly:\n(a ** b) % c == pow(a,b,c)\n\"\"\"\n\n# sample usage:\n# n,e,d = generate_key(16)\n# data = 20\n# encrypted = pow(data,e,n)\n# decrypted = pow(encrypted,d,n)\n# assert decrypted == data\n\nimport random\n\n\ndef generate_key(k, seed=None):\n    \"\"\"\n    the RSA key generating algorithm\n    k is the number of bits in n\n    \"\"\"\n\n    def modinv(a, m):\n        \"\"\"calculate the inverse of a mod m\n        that is, find b such that (a * b) % m == 1\"\"\"\n        b = 1\n        while not (a * b) % m == 1:\n            b += 1\n        return b\n\n    def gen_prime(k, seed=None):\n        \"\"\"generate a prime with k bits\"\"\"\n\n        def is_prime(num):\n            if num == 2:\n                return True\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n\n        random.seed(seed)\n        while True:\n            key = random.randrange(int(2 ** (k - 1)), int(2 ** k))\n            if is_prime(key):\n                return key\n\n    # size in bits of p and q need to add up to the size of n\n    p_size = k / 2\n    q_size = k - p_size\n\n    e = gen_prime(k, seed)  # in many cases, e is also chosen to be a small constant\n\n    while True:\n        p = gen_prime(p_size, seed)\n        if p % e != 1:\n            break\n\n    while True:\n        q = gen_prime(q_size, seed)\n        if q % e != 1:\n            break\n\n    n = p * q\n    l = (p - 1) * (q - 1)  # calculate totient function\n    d = modinv(e, l)\n\n    return int(n), int(e), int(d)\n\n\ndef encrypt(data, e, n):\n    return pow(int(data), int(e), int(n))\n\n\ndef decrypt(data, d, n):\n    return pow(int(data), int(d), int(n))\n"
  },
  {
    "id": 155,
    "category": "maths",
    "file_name": "nth_digit",
    "codes": "def find_nth_digit(n):\n    \"\"\"find the nth digit of given number.\n    1. find the length of the number where the nth digit is from.\n    2. find the actual number where the nth digit is from\n    3. find the nth digit and return\n    \"\"\"\n    length = 1\n    count = 9\n    start = 1\n    while n > length * count:\n        n -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    start += (n-1) / length\n    s = str(start)\n    return int(s[(n-1) % length])\n"
  },
  {
    "id": 156,
    "category": "maths",
    "file_name": "extended_gcd",
    "codes": "\"\"\"\nProvides extended GCD functionality for finding co-prime numbers s and t such that:\nnum1 * s + num2 * t = GCD(num1, num2).\nIe the coefficients of B\u00e9zout's identity.\n\"\"\"\ndef extended_gcd(num1, num2):\n    \"\"\"Extended GCD algorithm.\n    Return s, t, g\n    such that num1 * s + num2 * t = GCD(num1, num2)\n    and s and t are co-prime.\n    \"\"\"\n\n    old_s, s = 1, 0\n    old_t, t = 0, 1\n    old_r, r = num1, num2\n\n    while r != 0:\n        quotient = old_r / r\n\n        old_r, r = r, old_r - quotient * r\n        old_s, s = s, old_s - quotient * s\n        old_t, t = t, old_t - quotient * t\n\n    return old_s, old_t, old_r\n"
  },
  {
    "id": 157,
    "category": "maths",
    "file_name": "polynomial",
    "codes": "# from __future__ import annotations\n\nfrom fractions import Fraction\nfrom typing import Dict, Union, Set, Iterable\nfrom numbers import Rational\nfrom functools import reduce\n\n\nclass Monomial:\n    \"\"\"\n    A simple Monomial class to\n    record the details of all variables\n    that a typical monomial is composed of.\n    \"\"\"\n    def __init__(self, variables: Dict[int, int], coeff: Union[int, float, Fraction, None]= None) -> None:\n        '''\n        Create a monomial in the given variables:\n        Examples:\n\n            Monomial({1:1}) = (a_1)^1\n\n            Monomial({\n                1:3,\n                2:2,\n                4:1,\n                5:0\n            }, 12) = 12(a_1)^3(a_2)^2(a_4)\n\n            Monomial({}) = 0\n\n            Monomial({2:3, 3:-1}, 1.5) = (3/2)(a_2)^3(a_3)^(-1)\n\n        '''\n        self.variables = dict()\n\n        if coeff is None:\n            if len(variables) == 0:\n                coeff = Fraction(0, 1)\n            else:\n                coeff = Fraction(1, 1)\n        elif coeff == 0:\n            self.coeff = Fraction(0, 1)\n            return\n\n        if len(variables) == 0:\n            self.coeff = Monomial._rationalize_if_possible(coeff)\n            return\n\n        for i in variables:\n            if variables[i] != 0:\n                self.variables[i] = variables[i]\n        self.coeff = Monomial._rationalize_if_possible(coeff)\n\n    @staticmethod\n    def _rationalize_if_possible(num):\n        '''\n        A helper for converting numbers\n        to Fraction only when possible.\n        '''\n        if isinstance(num, Rational):\n            res = Fraction(num, 1)\n            return Fraction(res.numerator, res.denominator)\n        else:\n            return num\n\n    # def equal_upto_scalar(self, other: Monomial) -> bool:\n    def equal_upto_scalar(self, other) -> bool:\n        \"\"\"\n        Return True if other is a monomial\n        and is equivalent to self up to a scalar\n        multiple.\n        \"\"\"\n        if not isinstance(other, Monomial):\n            raise ValueError('Can only compare monomials.')\n        return other.variables == self.variables\n\n    # def __add__(self, other: Union[int, float, Fraction, Monomial]):\n    def __add__(self, other: Union[int, float, Fraction]):\n        \"\"\"\n        Define the addition of two\n        monomials or the addition of\n        a monomial with an int, float, or a Fraction.\n        \"\"\"\n        if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n            return self.__add__(Monomial({}, Monomial._rationalize_if_possible(other)))\n\n        if not isinstance(other, Monomial):\n            raise ValueError('Can only add monomials, ints, floats, or Fractions.')\n\n        if self.variables == other.variables:\n            mono = {i: self.variables[i] for i in self.variables}\n            return Monomial(mono, Monomial._rationalize_if_possible(self.coeff + other.coeff)).clean()\n        \n        # If they don't share same variables then by the definition,\n        # if they are added, the result becomes a polynomial and not a monomial.\n        # Thus, raise ValueError in that case.\n\n        raise ValueError(f'Cannot add {str(other)} to {self.__str__()} because they don\\'t have same variables.')\n\n    # def __eq__(self, other: Monomial) -> bool:\n    def __eq__(self, other) -> bool:\n        \"\"\"\n        Return True if two monomials\n        are equal upto a scalar multiple.\n        \"\"\"\n        return self.equal_upto_scalar(other) and self.coeff == other.coeff\n\n    # def __mul__(self, other: Union[int, float, Fraction, Monomial]) -> Monomial:\n    def __mul__(self, other: Union[int, float, Fraction]):\n        \"\"\"\n        Multiply two monomials and merge the variables\n        in both of them.\n\n        Examples:\n\n            Monomial({1:1}) * Monomial({1: -3, 2: 1}) = (a_1)^(-2)(a_2)\n            Monomial({3:2}) * 2.5 = (5/2)(a_3)^2\n\n        \"\"\"\n        if isinstance(other, float) or isinstance(other, int) or isinstance(other, Fraction):\n            mono = {i: self.variables[i] for i in self.variables}\n            return Monomial(mono, Monomial._rationalize_if_possible(self.coeff * other)).clean()\n\n        if not isinstance(other, Monomial):\n            raise ValueError('Can only multiply monomials, ints, floats, or Fractions.')\n        else:\n            mono = {i: self.variables[i] for i in self.variables}\n            for i in other.variables:\n                if i in mono:\n                    mono[i] += other.variables[i]\n                else:\n                    mono[i] = other.variables[i]\n\n            temp = dict()\n            for k in mono:\n                if mono[k] != 0:\n                    temp[k] = mono[k]\n\n            return Monomial(temp, Monomial._rationalize_if_possible(self.coeff * other.coeff)).clean()\n\n    # def inverse(self) -> Monomial:\n    def inverse(self):\n        \"\"\"\n        Compute the inverse of a monomial.\n\n        Examples:\n\n            Monomial({1:1, 2:-1, 3:2}, 2.5).inverse() = Monomial({1:-1, 2:1, 3:-2} ,2/5)\n\n\n        \"\"\"\n        mono = {i: self.variables[i] for i in self.variables if self.variables[i] != 0}\n        for i in mono:\n            mono[i] *= -1\n        if self.coeff == 0:\n            raise ValueError(\"Coefficient must not be 0.\")\n        return Monomial(mono, Monomial._rationalize_if_possible(1/self.coeff)).clean()\n\n    # def __truediv__(self, other: Union[int, float, Fraction, Monomial]) -> Monomial:\n    def __truediv__(self, other: Union[int, float, Fraction]):\n        \"\"\"\n        Compute the division between two monomials\n        or a monomial and some other datatype\n        like int/float/Fraction.\n        \"\"\"\n        if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n            mono = {i: self.variables[i] for i in self.variables}\n            if other == 0:\n                raise ValueError('Cannot divide by 0.')\n            return Monomial(mono, Monomial._rationalize_if_possible(self.coeff / other)).clean()\n\n        o = other.inverse()\n        return self.__mul__(o)\n\n    # def __floordiv__(self, other: Union[int, float, Fraction, Monomial]) -> Monomial:\n    def __floordiv__(self, other: Union[int, float, Fraction]):\n        \"\"\"\n        For monomials,\n        floor div is the same as true div.\n        \"\"\"\n        return self.__truediv__(other)\n\n    # def clone(self) -> Monomial:\n    def clone(self):\n        \"\"\"\n        Clone the monomial.\n        \"\"\"\n        temp_variables = {i: self.variables[i] for i in self.variables}\n        return Monomial(temp_variables, Monomial._rationalize_if_possible(self.coeff)).clean()\n\n    # def clean(self) -> Monomial:\n    def clean(self):\n        \"\"\"\n        Clean the monomial by dropping any variables that have power 0.\n        \"\"\"\n        temp_variables = {i: self.variables[i] for i in self.variables if self.variables[i] != 0}\n        return Monomial(temp_variables, Monomial._rationalize_if_possible(self.coeff))\n\n    # def __sub__(self, other: Union[int, float, Fraction, Monomial]) -> Monomial:\n    def __sub__(self, other: Union[int, float, Fraction]):\n        \"\"\"\n        Compute the subtraction\n        of a monomial and a datatype\n        such as int, float, Fraction, or Monomial.\n        \"\"\"\n        if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n            mono = {i: self.variables[i] for i in self.variables if self.variables[i] != 0}\n            if len(mono) != 0:\n                raise ValueError('Can only subtract like monomials.')\n            other_term = Monomial(mono, Monomial._rationalize_if_possible(other))\n            return self.__sub__(other_term)\n        if not isinstance(other, Monomial):\n            raise ValueError('Can only subtract monomials')\n        return self.__add__(other.__mul__(Fraction(-1, 1)))\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Define the hash of a monomial\n        by the underlying variables.\n\n        If hashing is implemented in O(v*log(v))\n        where v represents the number of\n        variables in the monomial,\n        then search queries for the\n        purposes of simplification of a\n        polynomial can be performed in\n        O(v*log(v)) as well; much better than\n        the length of the polynomial.\n        \"\"\"\n        arr = []\n        for i in sorted(self.variables):\n            if self.variables[i] > 0:\n                for _ in range(self.variables[i]):\n                    arr.append(i)\n        return hash(tuple(arr))\n\n    def all_variables(self) -> Set:\n        \"\"\"\n        Get the set of all variables\n        present in the monomial.\n        \"\"\"\n        return set(sorted(self.variables.keys()))\n\n    def substitute(self, substitutions: Union[int, float, Fraction, Dict[int, Union[int, float, Fraction]]]) -> Fraction:\n        \"\"\"\n        Substitute the variables in the\n        monomial for values defined by\n        the substitutions dictionary.\n        \"\"\"\n        if isinstance(substitutions, int) or isinstance(substitutions, float) or isinstance(substitutions, Fraction):\n            substitutions = {v: Monomial._rationalize_if_possible(substitutions) for v in self.all_variables()}\n        else:\n            if not self.all_variables().issubset(set(substitutions.keys())):\n                raise ValueError('Some variables didn\\'t receive their values.')\n        if self.coeff == 0:\n            return Fraction(0, 1)\n        ans = Monomial._rationalize_if_possible(self.coeff)\n        for k in self.variables:\n            ans *= Monomial._rationalize_if_possible(substitutions[k]**self.variables[k])\n        return Monomial._rationalize_if_possible(ans)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Get a string representation of\n        the monomial.\n        \"\"\"\n        if len(self.variables) == 0:\n            return str(self.coeff)\n\n        result = str(self.coeff)\n        result += '('\n        for i in self.variables:\n            temp = 'a_{}'.format(str(i))\n            if self.variables[i] > 1:\n                temp = '(' + temp + ')**{}'.format(self.variables[i])\n            elif self.variables[i] < 0:\n                temp = '(' + temp + ')**(-{})'.format(-self.variables[i])\n            elif self.variables[i] == 0:\n                continue\n            else:\n                temp = '(' + temp + ')'\n            result += temp\n        return result + ')'\n\n\nclass Polynomial:\n    \"\"\"\n    A simple implementation\n    of a polynomial class that\n    records the details about two polynomials\n    that are potentially comprised of multiple\n    variables.\n    \"\"\"\n    def __init__(self, monomials: Iterable[Union[int, float, Fraction, Monomial]]) -> None:\n        '''\n        Create a polynomial in the given variables:\n        Examples:\n\n            Polynomial([\n                Monomial({1:1}, 2),\n                Monomial({2:3, 1:-1}, -1),\n                math.pi,\n                Fraction(-1, 2)\n            ]) = (a_1)^2 + (-1)(a_2)^3(a_1)^(-1) + 2.6415926536\n\n            Polynomial([]) = 0\n\n        '''\n        self.monomials = set()\n        for m in monomials:\n            if any(map(lambda x: isinstance(m, x), [int, float, Fraction])):\n                self.monomials |= {Monomial({}, m)}\n            elif isinstance(m, Monomial):\n                self.monomials |= {m}\n            else:\n                raise ValueError('Iterable should have monomials, int, float, or Fraction.')\n        self.monomials -= {Monomial({}, 0)}\n\n    @staticmethod\n    def _rationalize_if_possible(num):\n        '''\n        A helper for converting numbers\n        to Fraction only when possible.\n        '''\n        if isinstance(num, Rational):\n            res = Fraction(num, 1)\n            return Fraction(res.numerator, res.denominator)\n        else:\n            return num\n\n\n    # def __add__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial:\n    def __add__(self, other: Union[int, float, Fraction, Monomial]):\n        \"\"\"\n        Add a given poylnomial to a copy of self.\n\n        \"\"\"\n        if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n            return self.__add__(Monomial({}, Polynomial._rationalize_if_possible(other)))\n        elif isinstance(other, Monomial):\n            monos = {m.clone() for m in self.monomials}\n\n            for _own_monos in monos:\n                if _own_monos.equal_upto_scalar(other):\n                    scalar = _own_monos.coeff\n                    monos -= {_own_monos}\n                    temp_variables = {i: other.variables[i] for i in other.variables}\n                    monos |= {Monomial(temp_variables, Polynomial._rationalize_if_possible(scalar + other.coeff))}\n                    return Polynomial([z for z in monos])\n\n            monos |= {other.clone()}\n            return Polynomial([z for z in monos])\n        elif isinstance(other, Polynomial):\n            temp = list(z for z in {m.clone() for m in self.all_monomials()})\n\n            p = Polynomial(temp)\n            for o in other.all_monomials():\n                p = p.__add__(o.clone())\n            return p\n        else:\n            raise ValueError('Can only add int, float, Fraction, Monomials, or Polynomials to Polynomials.')\n\n    # def __sub__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial:\n    def __sub__(self, other: Union[int, float, Fraction, Monomial]):\n        \"\"\"\n        Subtract the given polynomial\n        from a copy of self.\n\n        \"\"\"\n        if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n            return self.__sub__(Monomial({}, Polynomial._rationalize_if_possible(other)))\n        elif isinstance(other, Monomial):\n            monos = {m.clone() for m in self.all_monomials()}\n            for _own_monos in monos:\n                if _own_monos.equal_upto_scalar(other):\n                    scalar = _own_monos.coeff\n                    monos -= {_own_monos}\n                    temp_variables = {i: other.variables[i] for i in other.variables}\n                    monos |= {Monomial(temp_variables, Polynomial._rationalize_if_possible(scalar - other.coeff))}\n                    return Polynomial([z for z in monos])\n\n            to_insert = other.clone()\n            to_insert.coeff *= -1\n\n            monos |= {to_insert}\n            return Polynomial([z for z in monos])\n\n        elif isinstance(other, Polynomial):\n            p = Polynomial(list(z for z in {m.clone() for m in self.all_monomials()}))\n            for o in other.all_monomials():\n                p = p.__sub__(o.clone())\n            return p\n\n        else:\n            raise ValueError('Can only subtract int, float, Fraction, Monomials, or Polynomials from Polynomials.')\n            return\n\n    # def __mul__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial:\n    def __mul__(self, other: Union[int, float, Fraction, Monomial]):\n        \"\"\"\n        Multiply a given polynomial\n        to a copy of self.\n        \"\"\"\n        if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n            result = Polynomial([])\n            monos = {m.clone() for m in self.all_monomials()}\n            for m in monos:\n                result = result.__add__(m.clone()*other)\n            return result\n        elif isinstance(other, Monomial):\n            result = Polynomial([])\n            monos = {m.clone() for m in self.all_monomials()}\n            for m in monos:\n                result = result.__add__(m.clone() * other)\n            return result\n        elif isinstance(other, Polynomial):\n            temp_self = {m.clone() for m in self.all_monomials()}\n            temp_other = {m.clone() for m in other.all_monomials()}\n\n            result = Polynomial([])\n\n            for i in temp_self:\n                for j in temp_other:\n                    result = result.__add__(i * j)\n\n            return result\n        else:\n            raise ValueError('Can only multiple int, float, Fraction, Monomials, or Polynomials with Polynomials.')\n\n    # def __floordiv__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial:\n    def __floordiv__(self, other: Union[int, float, Fraction, Monomial]):\n        \"\"\"\n        For Polynomials, floordiv is the same\n        as truediv.\n        \"\"\"\n        return self.__truediv__(other)\n\n    # def __truediv__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial:\n    def __truediv__(self, other: Union[int, float, Fraction, Monomial]):\n        \"\"\"\n        For Polynomials, only division by a monomial\n        is defined.\n\n        TODO: Implement polynomial / polynomial.\n        \"\"\"\n        if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n            return self.__truediv__( Monomial({}, other) )\n        elif isinstance(other, Monomial):\n            poly_temp = reduce(lambda acc, val: acc + val, map(lambda x: x / other, [z for z in self.all_monomials()]), Polynomial([Monomial({}, 0)]))\n            return poly_temp\n        elif isinstance(other, Polynomial):\n            if Monomial({}, 0) in other.all_monomials():\n                if len(other.all_monomials()) == 2:\n                    temp_set = {x for x in other.all_monomials() if x != Monomial({}, 0)}\n                    only = temp_set.pop()\n                    return self.__truediv__(only)\n            elif len(other.all_monomials()) == 1:\n                temp_set = {x for x in other.all_monomials()}\n                only = temp_set.pop()\n                return self.__truediv__(only)\n\n        raise ValueError('Can only divide a polynomial by an int, float, Fraction, or a Monomial.')\n\n        return\n\n    # def clone(self) -> Polynomial:\n    def clone(self):\n        \"\"\"\n        Clone the polynomial.\n        \"\"\"\n        return Polynomial(list({m.clone() for m in self.all_monomials()}))\n\n    def variables(self) -> Set:\n        \"\"\"\n        Get all the variables present\n        in this polynomials.\n        \"\"\"\n        res = set()\n        for i in self.all_monomials():\n            res |= {j for j in i.variables}\n        res = list(res)\n        # res.sort()\n        return set(res)\n\n    def all_monomials(self) -> Iterable[Monomial]:\n        \"\"\"\n        Get the monomials of this polynomial.\n        \"\"\"\n        return {m for m in self.monomials if m != Monomial({}, 0)}\n\n\n    def __eq__(self, other) -> bool:\n        \"\"\"\n        Return True if the other polynomial is the same as\n        this.\n        \"\"\"\n        if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n            other_poly = Polynomial([Monomial({}, other)])\n            return self.__eq__(other_poly)\n        elif isinstance(other, Monomial):\n            return self.__eq__(Polynomial([other]))\n        elif isinstance(other, Polynomial):\n            return self.all_monomials() == other.all_monomials()\n        else:\n            raise ValueError('Can only compare a polynomial with an int, float, Fraction, Monomial, or another Polynomial.')\n\n\n    def subs(self, substitutions: Union[int, float, Fraction, Dict[int, Union[int, float, Fraction]]]) -> Union[int, float, Fraction]:\n        \"\"\"\n        Get the value after substituting\n        certain values for the variables\n        defined in substitutions.\n        \"\"\"\n        if isinstance(substitutions, int) or isinstance(substitutions, float) or isinstance(substitutions, Fraction):\n            substitutions = {i: Polynomial._rationalize_if_possible(substitutions) for i in set(self.variables())}\n            return self.subs(substitutions)\n        elif not isinstance(substitutions, dict):\n            raise ValueError('The substitutions should be a dictionary.')\n        if not self.variables().issubset(set(substitutions.keys())):\n            raise ValueError('Some variables didn\\'t receive their values.')\n\n        ans = 0\n        for m in self.all_monomials():\n            ans += Polynomial._rationalize_if_possible(m.substitute(substitutions))\n        return Polynomial._rationalize_if_possible(ans)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Get a string representation of\n        the polynomial.\n        \"\"\"\n        return ' + '.join(str(m) for m in self.all_monomials() if m.coeff != Fraction(0, 1))\n"
  },
  {
    "id": 158,
    "category": "maths",
    "file_name": "chinese_remainder_theorem",
    "codes": "\"\"\"\nSolves system of equations using the chinese remainder theorem if possible.\n\"\"\"\nfrom typing import List\nfrom algorithms.maths.gcd import gcd\n\ndef solve_chinese_remainder(nums : List[int], rems : List[int]):\n    \"\"\"\n    Computes the smallest x that satisfies the chinese remainder theorem\n    for a system of equations.\n    The system of equations has the form:\n    x % nums[0] = rems[0]\n    x % nums[1] = rems[1]\n    ...\n    x % nums[k - 1] = rems[k - 1]\n    Where k is the number of elements in nums and rems, k > 0.\n    All numbers in nums needs to be pariwise coprime otherwise an exception is raised\n    returns x: the smallest value for x that satisfies the system of equations\n    \"\"\"\n    if not len(nums) == len(rems):\n        raise Exception(\"nums and rems should have equal length\")\n    if not len(nums) > 0:\n        raise Exception(\"Lists nums and rems need to contain at least one element\")\n    for num in nums:\n        if not num > 1:\n            raise Exception(\"All numbers in nums needs to be > 1\")\n    if not _check_coprime(nums):\n        raise Exception(\"All pairs of numbers in nums are not coprime\")\n    k = len(nums)\n    x = 1\n    while True:\n        i = 0\n        while i < k:\n            if x % nums[i] != rems[i]:\n                break\n            i += 1\n        if i == k:\n            return x\n        x += 1\n\ndef _check_coprime(list_to_check : List[int]):\n    for ind, num in enumerate(list_to_check):\n        for num2 in list_to_check[ind + 1:]:\n            if gcd(num, num2) != 1:\n                return False\n    return True\n"
  },
  {
    "id": 159,
    "category": "maths",
    "file_name": "is_strobogrammatic",
    "codes": "\"\"\"\nA strobogrammatic number is a number that looks\nthe same when rotated 180 degrees (looked at upside down).\n\nWrite a function to determine if a number is strobogrammatic.\nThe number is represented as a string.\n\nFor example, the numbers \"69\", \"88\", and \"818\" are all strobogrammatic.\n\"\"\"\n\n\ndef is_strobogrammatic(num):\n    \"\"\"\n    :type num: str\n    :rtype: bool\n    \"\"\"\n    comb = \"00 11 88 69 96\"\n    i = 0\n    j = len(num) - 1\n    while i <= j:\n        if comb.find(num[i]+num[j]) == -1:\n            return False\n        i += 1\n        j -= 1\n    return True\n\n\ndef is_strobogrammatic2(num: str):\n    \"\"\"Another implementation.\"\"\"\n    return num == num[::-1].replace('6', '#').replace('9', '6').replace('#', '9')\n"
  },
  {
    "id": 160,
    "category": "maths",
    "file_name": "find_primitive_root_simple",
    "codes": "\"\"\"\nFunction to find the primitive root of a number.\n\"\"\"\nimport math\n\n\"\"\"\nFor positive integer n and given integer a that satisfies gcd(a, n) = 1,\nthe order of a modulo n is the smallest positive integer k that satisfies\npow (a, k) % n = 1. In other words, (a^k) \u2261 1 (mod n).\nOrder of certain number may or may not be exist. If so, return -1.\n\"\"\"\ndef find_order(a, n):\n    \"\"\"\n    Find order for positive integer n and given integer a that satisfies gcd(a, n) = 1.\n    Time complexity O(nlog(n))\n    \"\"\"\n    if (a == 1) & (n == 1):\n        # Exception Handeling : 1 is the order of of 1\n        return 1\n    if math.gcd(a, n) != 1:\n        print (\"a and n should be relative prime!\")\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1\n\n\"\"\"\nEuler's totient function, also known as phi-function \u03d5(n),\ncounts the number of integers between 1 and n inclusive,\nwhich are coprime to n.\n(Two numbers are coprime if their greatest common divisor (GCD) equals 1).\nCode from /algorithms/maths/euler_totient.py, written by 'goswami-rahul'\n\"\"\"\ndef euler_totient(n):\n    \"\"\"Euler's totient function or Phi function.\n    Time Complexity: O(sqrt(n)).\"\"\"\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result\n\n\"\"\"\nFor positive integer n and given integer a that satisfies gcd(a, n) = 1,\na is the primitive root of n, if a's order k for n satisfies k = \u03d5(n).\nPrimitive roots of certain number may or may not exist.\nIf so, return empty list.\n\"\"\"\ndef find_primitive_root(n):\n    if n == 1:\n        # Exception Handeling : 0 is the only primitive root of 1\n        return [0]\n    phi = euler_totient(n)\n    p_root_list = []\n    \"\"\" It will return every primitive roots of n. \"\"\"\n    for i in range (1, n):\n        #To have order, a and n must be relative prime with each other.\n        if math.gcd(i, n) == 1:\n            order = find_order(i, n)\n            if order == phi:\n                p_root_list.append(i)\n    return p_root_list\n"
  },
  {
    "id": 161,
    "category": "maths",
    "file_name": "modular_inverse",
    "codes": "# extended_gcd(a, b) modified from\n# https://github.com/keon/algorithms/blob/master/algorithms/maths/extended_gcd.py\n\ndef extended_gcd(a: int, b: int) -> [int, int, int]:\n    \"\"\"Extended GCD algorithm.\n    Return s, t, g\n    such that a * s + b * t = GCD(a, b)\n    and s and t are co-prime.\n    \"\"\"\n\n    old_s, s = 1, 0\n    old_t, t = 0, 1\n    old_r, r = a, b\n\n    while r != 0:\n        quotient = old_r // r\n\n        old_r, r = r, old_r - quotient * r\n        old_s, s = s, old_s - quotient * s\n        old_t, t = t, old_t - quotient * t\n\n    return old_s, old_t, old_r\n\n\ndef modular_inverse(a: int, m: int) -> int:\n    \"\"\"\n    Returns x such that a * x = 1 (mod m)\n    a and m must be coprime\n    \"\"\"\n\n    s, _, g = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError(\"a and m must be coprime\")\n    return s % m\n"
  },
  {
    "id": 162,
    "category": "maths",
    "file_name": "symmetry_group_cycle_index",
    "codes": "\"\"\"\nThe significance of the cycle index (polynomial) of symmetry group\nis deeply rooted in counting the number of configurations\nof an object excluding those that are symmetric (in terms of permutations).\n\nFor example, the following problem can be solved as a direct\napplication of the cycle index polynomial of the symmetry\ngroup.\n\nNote: I came across this problem as a Google's foo.bar challenge at Level 5\nand solved it using a purely Group Theoretic approach. :)\n-----\n\nProblem:\n\nGiven positive integers\nw, h, and s,\ncompute the number of distinct 2D\ngrids of dimensions w x h that contain\nentries from {0, 1, ..., s-1}.\nNote that two grids are defined\nto be equivalent if one can be\nobtained from the other by\nswitching rows and columns\nsome number of times.\n\n-----\n\nApproach:\n\nCompute the cycle index (polynomials)\nof S_w, and S_h, i.e. the Symmetry\ngroup on w and h symbols respectively.\n\nCompute the product of the two\ncycle indices while combining two\nmonomials in such a way that\nfor any pair of cycles c1, and c2\nin the elements of S_w X S_h,\nthe resultant monomial contains\nterms of the form:\n$$ x_{lcm(|c1|, |c2|)}^{gcd(|c1|, |c2|)} $$\n\nReturn the specialization of\nthe product of cycle indices\nat x_i = s (for all the valid i).\n\n-----\n\nCode:\n\ndef solve(w, h, s):\n    s1 = get_cycle_index_sym(w)\n    s2 = get_cycle_index_sym(h)\n\n    result = cycle_product_for_two_polynomials(s1, s2, s)\n\n    return str(result)\n\"\"\"\n\nfrom fractions import Fraction\nfrom typing import Dict, Union\nfrom polynomial import ( Monomial, Polynomial )\nfrom gcd import lcm\n\n\ndef cycle_product(m1: Monomial, m2: Monomial) -> Monomial:\n    \"\"\"\n    Given two monomials (from the\n    cycle index of a symmetry group),\n    compute the resultant monomial\n    in the cartesian product\n    corresponding to their merging.\n    \"\"\"\n    assert isinstance(m1, Monomial) and isinstance(m2, Monomial)\n    A = m1.variables\n    B = m2.variables\n    result_variables = dict()\n    for i in A:\n        for j in B:\n            k = lcm(i, j)\n            g = (i * j) // k\n            if k in result_variables:\n                result_variables[k] += A[i] * B[j] * g\n            else:\n                result_variables[k] = A[i] * B[j] * g\n\n    return Monomial(result_variables, Fraction(m1.coeff * m2.coeff, 1))\n\n\ndef cycle_product_for_two_polynomials(p1: Polynomial, p2: Polynomial, q: Union[float, int, Fraction]) -> Union[float, int, Fraction]:\n    \"\"\"\n    Compute the product of\n    given cycle indices p1,\n    and p2 and evaluate it at q.\n    \"\"\"\n    ans = Fraction(0, 1)\n    for m1 in p1.monomials:\n        for m2 in p2.monomials:\n            ans += cycle_product(m1, m2).substitute(q)\n\n    return ans\n\n\ndef cycle_index_sym_helper(n: int, memo: Dict[int, Polynomial]) -> Polynomial:\n    \"\"\"\n    A helper for the dp-style evaluation\n    of the cycle index.\n\n    The recurrence is given in:\n    https://en.wikipedia.org/wiki/Cycle_index#Symmetric_group_Sn\n\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    ans = Polynomial([Monomial({}, Fraction(0, 1))])\n    for t in range(1, n+1):\n        ans = ans.__add__(Polynomial([Monomial({t: 1}, Fraction(1, 1))]) * cycle_index_sym_helper(n-t, memo))\n    ans *= Fraction(1, n)\n    memo[n] = ans\n    return memo[n]\n\n\ndef get_cycle_index_sym(n: int) -> Polynomial:\n    \"\"\"\n    Compute the cycle index\n    of S_n, i.e. the symmetry\n    group of n symbols.\n\n    \"\"\"\n    if n < 0:\n        raise ValueError('n should be a non-negative integer.')\n\n    memo = {\n        0: Polynomial([\n            Monomial({}, Fraction(1, 1))\n        ]),\n        1: Polynomial([\n            Monomial({1: 1}, Fraction(1, 1))\n        ]),\n        2: Polynomial([\n            Monomial({1: 2}, Fraction(1, 2)),\n            Monomial({2: 1}, Fraction(1, 2))\n        ]),\n        3: Polynomial([\n            Monomial({1: 3}, Fraction(1, 6)),\n            Monomial({1: 1, 2: 1}, Fraction(1, 2)),\n            Monomial({3: 1}, Fraction(1, 3))\n        ]),\n        4: Polynomial([\n            Monomial({1: 4}, Fraction(1, 24)),\n            Monomial({2: 1, 1: 2}, Fraction(1, 4)),\n            Monomial({3: 1, 1: 1}, Fraction(1, 3)),\n            Monomial({2: 2}, Fraction(1, 8)),\n            Monomial({4: 1}, Fraction(1, 4)),\n        ])\n    }\n    result = cycle_index_sym_helper(n, memo)\n    return result\n"
  },
  {
    "id": 163,
    "category": "maths",
    "file_name": "next_bigger",
    "codes": "\"\"\"\nI just bombed an interview and made pretty much zero\nprogress on my interview question.\n\nGiven a number, find the next higher number which has the\nexact same set of digits as the original number.\nFor example: given 38276 return 38627.\n             given 99999 return -1. (no such number exists)\n\nCondensed mathematical description:\n\nFind largest index i such that array[i \u2212 1] < array[i].\n(If no such i exists, then this is already the last permutation.)\n\nFind largest index j such that j \u2265 i and array[j] > array[i \u2212 1].\n\nSwap array[j] and array[i \u2212 1].\n\nReverse the suffix starting at array[i].\n\n\"\"\"\nimport unittest\n\n\ndef next_bigger(num):\n\n    digits = [int(i) for i in str(num)]\n    idx = len(digits) - 1\n\n    while idx >= 1 and digits[idx-1] >= digits[idx]:\n        idx -= 1\n\n    if idx == 0:\n        return -1  # no such number exists\n\n    pivot = digits[idx-1]\n    swap_idx = len(digits) - 1\n\n    while pivot >= digits[swap_idx]:\n        swap_idx -= 1\n\n    digits[swap_idx], digits[idx-1] = digits[idx-1], digits[swap_idx]\n    digits[idx:] = digits[:idx-1:-1]   # prefer slicing instead of reversed(digits[idx:])\n\n    return int(''.join(str(x) for x in digits))\n\n\nclass TestSuite(unittest.TestCase):\n\n    def test_next_bigger(self):\n\n        self.assertEqual(next_bigger(38276), 38627)\n        self.assertEqual(next_bigger(12345), 12354)\n        self.assertEqual(next_bigger(1528452), 1528524)\n        self.assertEqual(next_bigger(138654), 143568)\n\n        self.assertEqual(next_bigger(54321), -1)\n        self.assertEqual(next_bigger(999), -1)\n        self.assertEqual(next_bigger(5), -1)\n\n\nif __name__ == '__main__':\n\n    unittest.main()\n"
  },
  {
    "id": 164,
    "category": "maths",
    "file_name": "base_conversion",
    "codes": "\"\"\"\nInteger base conversion algorithm\n\nint_to_base(5, 2) return '101'.\nbase_to_int('F', 16) return 15.\n\n\"\"\"\n\nimport string\n\ndef int_to_base(num, base):\n    \"\"\"\n        :type num: int\n        :type base: int\n        :rtype: str\n    \"\"\"\n    is_negative = False\n    if num == 0:\n        return '0'\n    if num < 0:\n        is_negative = True\n        num *= -1\n    digit = string.digits + string.ascii_uppercase\n    res = ''\n    while num > 0:\n        res += digit[num % base]\n        num //= base\n    if is_negative:\n        return '-' + res[::-1]\n    return res[::-1]\n\n\ndef base_to_int(str_to_convert, base):\n    \"\"\"\n        Note : You can use int() built-in function instead of this.\n        :type str_to_convert: str\n        :type base: int\n        :rtype: int\n    \"\"\"\n\n    digit = {}\n    for ind, char in enumerate(string.digits + string.ascii_uppercase):\n        digit[char] = ind\n    multiplier = 1\n    res = 0\n    for char in str_to_convert[::-1]:\n        res += digit[char] * multiplier\n        multiplier *= base\n    return res\n"
  },
  {
    "id": 165,
    "category": "maths",
    "file_name": "fft",
    "codes": "\"\"\"\nImplementation of the Cooley-Tukey, which is the most common FFT algorithm.\n\nInput: an array of complex values which has a size of N, where N is an integer power of 2\nOutput: an array of complex values which is the discrete fourier transform of the input\n\nExample 1\nInput: [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j]\nOutput: [8+8j, 2j, 2-2j, -2+0j]\n\n\nPseudocode: https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n\"\"\"\nfrom cmath import exp, pi\n\ndef fft(x):\n    \"\"\" Recursive implementation of the Cooley-Tukey\"\"\"\n    N = len(x)\n    if N == 1:\n        return x\n\n    # get the elements at even/odd indices\n    even = fft(x[0::2])\n    odd = fft(x[1::2])\n\n    y = [0 for i in range(N)]\n    for k in range(N//2):\n        q = exp(-2j*pi*k/N)*odd[k]\n        y[k] = even[k] + q\n        y[k + N//2] = even[k] - q\n\n    return y\n"
  },
  {
    "id": 166,
    "category": "maths",
    "file_name": "gcd",
    "codes": "\"\"\"\nFunctions for calculating the greatest common divisor of two integers or\ntheir least common multiple.\n\"\"\"\n\ndef gcd(a, b):\n    \"\"\"Computes the greatest common divisor of integers a and b using\n    Euclid's Algorithm.\n    gcd{\ud835\udc4e,\ud835\udc4f}=gcd{\u2212\ud835\udc4e,\ud835\udc4f}=gcd{\ud835\udc4e,\u2212\ud835\udc4f}=gcd{\u2212\ud835\udc4e,\u2212\ud835\udc4f}\n    See proof: https://proofwiki.org/wiki/GCD_for_Negative_Integers\n    \"\"\"\n    a_int = isinstance(a, int)\n    b_int = isinstance(b, int)\n    a = abs(a)\n    b = abs(b)\n    if not(a_int or b_int):\n        raise ValueError(\"Input arguments are not integers\")\n\n    if (a == 0) or (b == 0) :\n        raise ValueError(\"One or more input arguments equals zero\")\n\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    \"\"\"Computes the lowest common multiple of integers a and b.\"\"\"\n    return abs(a) * abs(b) / gcd(a, b)\n\n\"\"\"\nGiven a positive integer x, computes the number of trailing zero of x.\nExample\nInput : 34(100010)\n           ~~~~~^\nOutput : 1\n\nInput : 40(101000)\n           ~~~^^^\nOutput : 3\n\"\"\"\ndef trailing_zero(x):\n    count = 0\n    while x and not x & 1:\n        count += 1\n        x >>= 1\n    return count\n\n\"\"\"\nGiven two non-negative integer a and b,\ncomputes the greatest common divisor of a and b using bitwise operator.\n\"\"\"\ndef gcd_bit(a, b):\n    \"\"\" Similar to gcd but uses bitwise operators and less error handling.\"\"\"\n    tza = trailing_zero(a)\n    tzb = trailing_zero(b)\n    a >>= tza\n    b >>= tzb\n    while b:\n        if a < b:\n            a, b = b, a\n        a -= b\n        a >>= trailing_zero(a)\n    return a << min(tza, tzb)\n"
  },
  {
    "id": 167,
    "category": "maths",
    "file_name": "hailstone",
    "codes": "\"\"\"\nImplementation of hailstone function which generates a sequence for some n by following these rules:\n* n == 1    : done\n* n is even : the next n = n/2\n* n is odd  : the next n = 3n + 1\n\"\"\"\n\ndef hailstone(n):\n    \"\"\"\n    Return the 'hailstone sequence' from n to 1\n    n: The starting point of the hailstone sequence\n    \"\"\"\n\n    sequence = [n]\n    while n > 1:\n        if n%2 != 0:\n            n = 3*n + 1\n        else:\n            n = int(n/2)\n        sequence.append(n)\n    return sequence\n"
  },
  {
    "id": 168,
    "category": "stack",
    "file_name": "is_consecutive",
    "codes": "\"\"\"\nGiven a stack, a function is_consecutive takes a stack as a parameter and that\nreturns whether or not the stack contains a sequence of consecutive integers\nstarting from the bottom of the stack (returning true if it does, returning\nfalse if it does not).\n\nFor example:\nbottom [3, 4, 5, 6, 7] top\nThen the call of is_consecutive(s) should return true.\nbottom [3, 4, 6, 7] top\nThen the call of is_consecutive(s) should return false.\nbottom [3, 2, 1] top\nThe function should return false due to reverse order.\n\nNote: There are 2 solutions:\nfirst_is_consecutive: it uses a single stack as auxiliary storage\nsecond_is_consecutive: it uses a single queue as auxiliary storage\n\"\"\"\nimport collections\n\n\ndef first_is_consecutive(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:  # Case odd number of values in stack\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:  # Not consecutive\n            return False\n        stack.append(second_value)          # Backup second value\n        storage_stack.append(first_value)\n\n    # Back up stack from storage stack\n    for i in range(len(storage_stack)):\n        stack.append(storage_stack.pop())\n    return True\n\n\ndef second_is_consecutive(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:  # Case odd number of values in stack\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:  # Not consecutive\n            return False\n        stack.append(second_value)          # Backup second value\n        q.append(first_value)\n\n    # Back up stack from queue\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n\n    return True\n"
  },
  {
    "id": 169,
    "category": "stack",
    "file_name": "stutter",
    "codes": "\"\"\"\nGiven a stack, stutter takes a stack as a parameter and  replaces every value\nin the stack with two occurrences of that value.\n\nFor example, suppose the stack stores these values:\nbottom [3, 7, 1, 14, 9] top\nThen the stack should store these values after the method terminates:\nbottom [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] top\n\nNote: There are 2 solutions:\nfirst_stutter: it uses a single stack as auxiliary storage\nsecond_stutter: it uses a single queue as auxiliary storage\n\"\"\"\nimport collections\n\n\ndef first_stutter(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        val = storage_stack.pop()\n        stack.append(val)\n        stack.append(val)\n\n    return stack\n\n\ndef second_stutter(stack):\n    q = collections.deque()\n    # Put all values into queue from stack\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    # Put values back into stack from queue\n    for i in range(len(q)):\n        stack.append(q.pop())\n    # Now, stack is reverse, put all values into queue from stack\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    # Put 2 times value into stack from queue\n    for i in range(len(q)):\n        val = q.pop()\n        stack.append(val)\n        stack.append(val)\n\n    return stack\n"
  },
  {
    "id": 170,
    "category": "stack",
    "file_name": "ordered_stack",
    "codes": "# The stack remains always ordered such that the highest value\n# is at the top and the lowest at the bottom\n\n\nclass OrderedStack:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return self.items == []\n\n    def push_t(self, item):\n        self.items.append(item)\n\n    # push method to maintain order when pushing new elements\n    def push(self, item):\n        temp_stack = OrderedStack()\n        if self.is_empty() or item > self.peek():\n            self.push_t(item)\n        else:\n            while item < self.peek() and not self.is_empty():\n                temp_stack.push_t(self.pop())\n            self.push_t(item)\n            while not temp_stack.is_empty():\n                self.push_t(temp_stack.pop())\n\n    def pop(self):\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        return self.items.pop()\n\n    def peek(self):\n        return self.items[len(self.items) - 1]\n\n    def size(self):\n        return len(self.items)\n"
  },
  {
    "id": 171,
    "category": "stack",
    "file_name": "is_sorted",
    "codes": "\"\"\"\nGiven a stack, a function is_sorted accepts a stack as a parameter and returns\ntrue if the elements in the stack occur in ascending increasing order from\nbottom, and false otherwise. That is, the smallest element should be at bottom\n\nFor example:\nbottom [6, 3, 5, 1, 2, 4] top\nThe function should return false\nbottom [1, 2, 3, 4, 5, 6] top\nThe function should return true\n\"\"\"\n\n\ndef is_sorted(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        if len(stack) == 0:\n            break\n        first_val = stack.pop()\n        if len(stack) == 0:\n            break\n        second_val = stack.pop()\n        if first_val < second_val:\n            return False\n        storage_stack.append(first_val)\n        stack.append(second_val)\n\n    # Backup stack\n    for i in range(len(storage_stack)):\n        stack.append(storage_stack.pop())\n\n    return True\n"
  },
  {
    "id": 172,
    "category": "stack",
    "file_name": "remove_min",
    "codes": "\"\"\"\nGiven a stack, a function remove_min accepts a stack as a parameter\nand removes the smallest value from the stack.\n\nFor example:\nbottom [2, 8, 3, -6, 7, 3] top\nAfter remove_min(stack):\nbottom [2, 8, 3, 7, 3] top\n\n\"\"\"\n\n\ndef remove_min(stack):\n    storage_stack = []\n    if len(stack) == 0:  # Stack is empty\n        return stack\n    # Find the smallest value\n    min = stack.pop()\n    stack.append(min)\n    for i in range(len(stack)):\n        val = stack.pop()\n        if val <= min:\n            min = val\n        storage_stack.append(val)\n    # Back up stack and remove min value\n    for i in range(len(storage_stack)):\n        val = storage_stack.pop()\n        if val != min:\n            stack.append(val)\n    return stack\n"
  },
  {
    "id": 173,
    "category": "stack",
    "file_name": "stack",
    "codes": "\"\"\"\nStack Abstract Data Type (ADT)\nStack() creates a new stack that is empty.\n   It needs no parameters and returns an empty stack.\npush(item) adds a new item to the top of the stack.\n   It needs the item and returns nothing.\npop() removes the top item from the stack.\n   It needs no parameters and returns the item. The stack is modified.\npeek() returns the top item from the stack but does not remove it.\n   It needs no parameters. The stack is not modified.\nis_empty() tests to see whether the stack is empty.\n   It needs no parameters and returns a boolean value.\n\"\"\"\nfrom abc import ABCMeta, abstractmethod\n\n\nclass AbstractStack(metaclass=ABCMeta):\n    \"\"\"Abstract Class for Stacks.\"\"\"\n    def __init__(self):\n        self._top = -1\n\n    def __len__(self):\n        return self._top + 1\n\n    def __str__(self):\n        result = \" \".join(map(str, self))\n        return 'Top-> ' + result\n\n    def is_empty(self):\n        return self._top == -1\n\n    @abstractmethod\n    def __iter__(self):\n        pass\n\n    @abstractmethod\n    def push(self, value):\n        pass\n\n    @abstractmethod\n    def pop(self):\n        pass\n\n    @abstractmethod\n    def peek(self):\n        pass\n\n\nclass ArrayStack(AbstractStack):\n    def __init__(self, size=10):\n        \"\"\"\n        Initialize python List with size of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        super().__init__()\n        self._array = [None] * size\n\n    def __iter__(self):\n        probe = self._top\n        while True:\n            if probe == -1:\n                return\n            yield self._array[probe]\n            probe -= 1\n\n    def push(self, value):\n        self._top += 1\n        if self._top == len(self._array):\n            self._expand()\n        self._array[self._top] = value\n\n    def pop(self):\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        value = self._array[self._top]\n        self._top -= 1\n        return value\n\n    def peek(self):\n        \"\"\"returns the current top element of the stack.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        return self._array[self._top]\n\n    def _expand(self):\n        \"\"\"\n         expands size of the array.\n         Time Complexity: O(n)\n        \"\"\"\n        self._array += [None] * len(self._array)  # double the size of the array\n\n\nclass StackNode:\n    \"\"\"Represents a single stack node.\"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\nclass LinkedListStack(AbstractStack):\n\n    def __init__(self):\n        super().__init__()\n        self.head = None\n\n    def __iter__(self):\n        probe = self.head\n        while True:\n            if probe is None:\n                return\n            yield probe.value\n            probe = probe.next\n\n    def push(self, value):\n        node = StackNode(value)\n        node.next = self.head\n        self.head = node\n        self._top += 1\n\n    def pop(self):\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        value = self.head.value\n        self.head = self.head.next\n        self._top -= 1\n        return value\n\n    def peek(self):\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        return self.head.value\n"
  },
  {
    "id": 174,
    "category": "stack",
    "file_name": "simplify_path",
    "codes": "\"\"\"\nGiven an absolute path for a file (Unix-style), simplify it.\n\nFor example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n\n* Did you consider the case where path = \"/../\"?\n    In this case, you should return \"/\".\n* Another corner case is the path might contain multiple slashes '/' together,\n    such as \"/home//foo/\". In this case, you should ignore redundant\n    slashes and return \"/home/foo\".\n\"\"\"\ndef simplify_path(path):\n    \"\"\"\n    :type path: str\n    :rtype: str\n    \"\"\"\n    skip = {'..', '.', ''}\n    stack = []\n    paths = path.split('/')\n    for tok in paths:\n        if tok == '..':\n            if stack:\n                stack.pop()\n        elif tok not in skip:\n            stack.append(tok)\n    return '/' + '/'.join(stack)\n"
  },
  {
    "id": 175,
    "category": "stack",
    "file_name": "longest_abs_path",
    "codes": "# def lengthLongestPath(input):\n#     maxlen = 0\n#     pathlen = {0: 0}\n#     for line in input.splitlines():\n#         print(\"---------------\")\n#         print(\"line:\", line)\n#         name = line.strip('\\t')\n#         print(\"name:\", name)\n#         depth = len(line) - len(name)\n#         print(\"depth:\", depth)\n#         if '.' in name:\n#             maxlen = max(maxlen, pathlen[depth] + len(name))\n#         else:\n#             pathlen[depth + 1] = pathlen[depth] + len(name) + 1\n#         print(\"maxlen:\", maxlen)\n#     return maxlen\n\n# def lengthLongestPath(input):\n#     paths = input.split(\"\\n\")\n#     level = [0] * 10\n#     maxLength = 0\n#     for path in paths:\n#         print(\"-------------\")\n#         levelIdx = path.rfind(\"\\t\")\n#         print(\"Path: \", path)\n#         print(\"path.rfind(\\\\t)\", path.rfind(\"\\t\"))\n#         print(\"levelIdx: \", levelIdx)\n#         print(\"level: \", level)\n#         level[levelIdx + 1] = level[levelIdx] + len(path) - levelIdx + 1\n#         print(\"level: \", level)\n#         if \".\" in path:\n#             maxLength = max(maxLength, level[levelIdx+1] - 1)\n#             print(\"maxlen: \", maxLength)\n#     return maxLength\n\ndef length_longest_path(input):\n    \"\"\"\n    :type input: str\n    :rtype: int\n    \"\"\"\n    curr_len, max_len = 0, 0    # running length and max length\n    stack = []    # keep track of the name length\n    for s in input.split('\\n'):\n        print(\"---------\")\n        print(\"<path>:\", s)\n        depth = s.count('\\t')    # the depth of current dir or file\n        print(\"depth: \", depth)\n        print(\"stack: \", stack)\n        print(\"curlen: \", curr_len)\n        while len(stack) > depth:    # go back to the correct depth\n            curr_len -= stack.pop()\n        stack.append(len(s.strip('\\t'))+1)   # 1 is the length of '/'\n        curr_len += stack[-1]    # increase current length\n        print(\"stack: \", stack)\n        print(\"curlen: \", curr_len)\n        if '.' in s:    # update maxlen only when it is a file\n            max_len = max(max_len, curr_len-1)    # -1 is to minus one '/'\n    return max_len\n\n\nst = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdirectory1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"\nst2 = \"a\\n\\tb1\\n\\t\\tf1.txt\\n\\taaaaa\\n\\t\\tf2.txt\"\nprint(\"path:\", st2)\n\nprint(\"answer:\", length_longest_path(st2))\n"
  },
  {
    "id": 176,
    "category": "stack",
    "file_name": "switch_pairs",
    "codes": "\"\"\"\nGiven a stack, switch_pairs function takes a stack as a parameter and that\nswitches successive pairs of numbers starting at the bottom of the stack.\n\nFor example, if the stack initially stores these values:\nbottom [3, 8, 17, 9, 1, 10] top\nYour function should switch the first pair (3, 8),\nthe second pair (17, 9), ...:\nbottom [8, 3, 9, 17, 10, 1] top\n\nif there are an odd number of values in the stack, the value at the top of the\nstack is not moved: For example:\nbottom [3, 8, 17, 9, 1] top\nIt would again switch pairs of values, but the value at the\ntop of the stack (1)\nwould not be moved\nbottom [8, 3, 9, 17, 1] top\n\nNote: There are 2 solutions:\nfirst_switch_pairs: it uses a single stack as auxiliary storage\nsecond_switch_pairs: it uses a single queue as auxiliary storage\n\"\"\"\nimport collections\n\n\ndef first_switch_pairs(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        if len(storage_stack) == 0:\n            break\n        first = storage_stack.pop()\n        if len(storage_stack) == 0:    # case: odd number of values in stack\n            stack.append(first)\n            break\n        second = storage_stack.pop()\n        stack.append(second)\n        stack.append(first)\n    return stack\n\n\ndef second_switch_pairs(stack):\n    q = collections.deque()\n    # Put all values into queue from stack\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    # Put values back into stack from queue\n    for i in range(len(q)):\n        stack.append(q.pop())\n    # Now, stack is reverse, put all values into queue from stack\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    # Swap pairs by appending the 2nd value before appending 1st value\n    for i in range(len(q)):\n        if len(q) == 0:\n            break\n        first = q.pop()\n        if len(q) == 0:                 # case: odd number of values in stack\n            stack.append(first)\n            break\n        second = q.pop()\n        stack.append(second)\n        stack.append(first)\n\n    return stack\n"
  },
  {
    "id": 177,
    "category": "stack",
    "file_name": "valid_parenthesis",
    "codes": "\"\"\"\nGiven a string containing just the characters\n'(', ')', '{', '}', '[' and ']',\ndetermine if the input string is valid.\n\nThe brackets must close in the correct order,\n\"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\n\"\"\"\n\n\ndef is_valid(s: str) -> bool:\n    stack = []\n    dic = {\")\": \"(\",\n           \"}\": \"{\",\n           \"]\": \"[\"}\n    for char in s:\n        if char in dic.values():\n            stack.append(char)\n        elif char in dic:\n            if not stack or dic[char] != stack.pop():\n                return False\n    return not stack\n"
  },
  {
    "id": 178,
    "category": "dfs",
    "file_name": "maze_search",
    "codes": "'''\nFind shortest path from top left column to the right lowest column using DFS.\nonly step on the columns whose value is 1\nif there is no path, it returns -1\n(The first column(top left column) is not included in the answer.)\n\nEx 1)\nIf maze is\n[[1,0,1,1,1,1],\n [1,0,1,0,1,0],\n [1,0,1,0,1,1],\n [1,1,1,0,1,1]],\nthe answer is: 14\n\nEx 2)\nIf maze is\n[[1,0,0],\n [0,1,1],\n [0,1,1]],\nthe answer is: -1\n'''\n\n\ndef find_path(maze):\n    cnt = dfs(maze, 0, 0, 0, -1)\n    return cnt\n\n\ndef dfs(maze, i, j, depth, cnt):\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n    row = len(maze)\n    col = len(maze[0])\n\n    if i == row - 1 and j == col - 1:\n        if cnt == -1:\n            cnt = depth\n        else:\n            if cnt > depth:\n                cnt = depth\n        return cnt\n\n    maze[i][j] = 0\n\n    for k in range(len(directions)):\n        nx_i = i + directions[k][0]\n        nx_j = j + directions[k][1]\n\n        if nx_i >= 0 and nx_i < row and nx_j >= 0 and nx_j < col:\n            if maze[nx_i][nx_j] == 1:\n                cnt = dfs(maze, nx_i, nx_j, depth + 1, cnt)\n\n    maze[i][j] = 1\n\n    return cnt\n"
  },
  {
    "id": 179,
    "category": "dfs",
    "file_name": "sudoku_solver",
    "codes": "\"\"\"\nIt's similar to how human solve Sudoku.\n\ncreate a hash table (dictionary) val to store possible values in every location.\nEach time, start from the location with fewest possible values, choose one value\nfrom it and then update the board and possible values at other locations.\nIf this update is valid, keep solving (DFS). If this update is invalid (leaving\nzero possible values at some locations) or this value doesn't lead to the\nsolution, undo the updates and then choose the next value.\nSince we calculated val at the beginning and start filling the board from the\nlocation with fewest possible values, the amount of calculation and thus the\nruntime can be significantly reduced:\n\n\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest\npython solutions here.\n\n\nThe PossibleVals function may be further simplified/optimized, but it works just\nfine for now. (it would look less lengthy if we are allowed to use numpy array\nfor the board lol).\n\"\"\"\nclass Sudoku: \n    def __init__ (self, board, row, col):\n        self.board = board\n        self.row = row\n        self.col = col\n        self.val = self.possible_values()\n\n    def possible_values(self):\n        a = \"123456789\"\n        d, val = {}, {}\n        for i in range(self.row):\n            for j in range(self.col):\n                ele = self.board[i][j]\n                if ele != \".\":\n                    d[(\"r\", i)] = d.get((\"r\", i), []) + [ele]\n                    d[(\"c\", j)] = d.get((\"c\", j), []) + [ele]\n                    d[(i//3, j//3)] = d.get((i//3, j//3), []) + [ele]\n                else:\n                    val[(i,j)] = []\n        for (i,j) in val.keys():\n            inval = d.get((\"r\",i),[])+d.get((\"c\",j),[])+d.get((i/3,j/3),[])\n            val[(i,j)] = [n for n in a if n not in inval ]\n        return val\n\n    def solve(self):\n        if len(self.val)==0:\n            return True\n        kee = min(self.val.keys(), key=lambda x: len(self.val[x]))\n        nums = self.val[kee]\n        for n in nums:\n            update = {kee:self.val[kee]}\n            if self.valid_one(n, kee, update): # valid choice\n                if self.solve(): # keep solving\n                    return True\n            self.undo(kee, update) # invalid choice or didn't solve it => undo\n        return False\n\n    def valid_one(self, n, kee, update):\n        self.board[kee[0]][kee[1]] = n\n        del self.val[kee]\n        i, j = kee\n        for ind in self.val.keys():\n            if n in self.val[ind]:\n                if ind[0]==i or ind[1]==j or (ind[0]/3,ind[1]/3)==(i/3,j/3):\n                    update[ind] = n\n                    self.val[ind].remove(n)\n                    if len(self.val[ind])==0:\n                        return False\n        return True\n\n    def undo(self, kee, update):\n        self.board[kee[0]][kee[1]]=\".\"\n        for k in update:\n            if k not in self.val:\n                self.val[k]= update[k]\n            else:\n                self.val[k].append(update[k])\n        return None\n\n    def __str__(self):\n        \"\"\"[summary]\n        Generates a board representation as string.\n\n        Returns:\n            [str] -- [board representation]\n        \"\"\"\n\n        resp = \"\"\n        for i in range(self.row):\n            for j in range(self.col):\n                resp += \" {0} \".format(self.board[i][j])\n            resp += \"\\n\"\n        return resp\n"
  },
  {
    "id": 180,
    "category": "dfs",
    "file_name": "count_islands",
    "codes": "\"\"\"\nGiven a 2d grid map of '1's (land) and '0's (water),\ncount the number of islands.\nAn island is surrounded by water and is formed by\nconnecting adjacent lands horizontally or vertically.\nYou may assume all four edges of the grid are all surrounded by water.\n\nExample 1:\n\n11110\n11010\n11000\n00000\nAnswer: 1\n\nExample 2:\n\n11000\n11000\n00100\n00011\nAnswer: 3\n\"\"\"\n\ndef num_islands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j, col in enumerate(grid[i]):\n            if col == 1:\n                dfs(grid, i, j)\n                count += 1\n    return count\n\n\ndef dfs(grid, i, j):\n    if (i < 0 or i >= len(grid)) or (j < 0 or j >= len(grid[0])):\n        return\n    if grid[i][j] != 1:\n        return\n    grid[i][j] = 0\n    dfs(grid, i+1, j)\n    dfs(grid, i-1, j)\n    dfs(grid, i, j+1)\n    dfs(grid, i, j-1)\n"
  },
  {
    "id": 181,
    "category": "dfs",
    "file_name": "walls_and_gates",
    "codes": "\"\"\"\nYou are given a m x n 2D grid initialized with these three possible values:\n    -1: A wall or an obstacle.\n    0: A gate.\n    INF: Infinity means an empty room. We use the value 2^31 - 1 = 2147483647 to represent INF \n         as you may assume that the distance to a gate is less than 2147483647.\nFill the empty room with distance to its nearest gate.\nIf it is impossible to reach a gate, it should be filled with INF.\n\nFor example, given the 2D grid:\n    INF -1  0   INF\n    INF INF INF -1\n    INF -1  INF -1\n    0   -1  INF INF\nAfter running your function, the 2D grid should be:\n    3   -1  0   1\n    2   2   1   -1\n    1   -1  2   -1\n    0   -1  3   4\n\"\"\"\n\ndef walls_and_gates(rooms):\n    for i in range(len(rooms)):\n        for j in range(len(rooms[0])):\n            if rooms[i][j] == 0:\n                dfs(rooms, i, j, 0)\n\n\ndef dfs(rooms, i, j, depth):\n    if (i < 0 or i >= len(rooms)) or (j < 0 or j >= len(rooms[0])):\n        return  # out of bounds\n    if rooms[i][j] < depth:\n        return  # crossed\n    rooms[i][j] = depth\n    dfs(rooms, i+1, j, depth+1)\n    dfs(rooms, i-1, j, depth+1)\n    dfs(rooms, i, j+1, depth+1)\n    dfs(rooms, i, j-1, depth+1)\n"
  },
  {
    "id": 182,
    "category": "dfs",
    "file_name": "all_factors",
    "codes": "\"\"\"\nNumbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\n\nWrite a function that takes an integer n and return all possible combinations\nof its factors.Numbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\nExamples:\ninput: 1\noutput:\n[]\n\n\ninput: 37\noutput:\n[]\n\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n\"\"\"\ndef get_factors(n):\n    \"\"\"[summary]\n    \n    Arguments:\n        n {[int]} -- [to analysed number]\n    \n    Returns:\n        [list of lists] -- [all factors of the number n]\n    \"\"\"\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n\n        while i * i <= n:\n            if n % i == 0:\n                res += combi + [i, int(n/i)],\n                factor(n/i, i, combi+[i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])\n\n\ndef get_factors_iterative1(n):\n    \"\"\"[summary]\n    Computes all factors of n.\n    Translated the function get_factors(...) in\n    a call-stack modell.\n\n    Arguments:\n        n {[int]} -- [to analysed number]\n    \n    Returns:\n        [list of lists] -- [all factors]\n    \"\"\"\n\n    todo, res = [(n, 2, [])], []\n    while todo:\n        n, i, combi = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += combi + [i, n//i],\n                todo.append((n//i, i, combi+[i])),\n            i += 1\n    return res\n\n\ndef get_factors_iterative2(n):\n    \"\"\"[summary]\n    analog as above\n\n    Arguments:\n        n {[int]} -- [description]\n    \n    Returns:\n        [list of lists] -- [all factors of n]\n    \"\"\"\n\n    ans, stack, x = [], [], 2\n    while True:\n        if x > n // x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n //= x\n        else:\n            x += 1\n"
  },
  {
    "id": 183,
    "category": "dfs",
    "file_name": "pacific_atlantic",
    "codes": "# Given an m x n matrix of non-negative integers representing\n# the height of each unit cell in a continent,\n# the \"Pacific ocean\" touches the left and top edges of the matrix\n# and the \"Atlantic ocean\" touches the right and bottom edges.\n\n# Water can only flow in four directions (up, down, left, or right)\n# from a cell to another one with height equal or lower.\n\n# Find the list of grid coordinates where water can flow to both the\n# Pacific and Atlantic ocean.\n\n# Note:\n# The order of returned grid coordinates does not matter.\n# Both m and n are less than 150.\n# Example:\n\n# Given the following 5x5 matrix:\n\n  # Pacific ~   ~   ~   ~   ~\n       # ~  1   2   2   3  (5) *\n       # ~  3   2   3  (4) (4) *\n       # ~  2   4  (5)  3   1  *\n       # ~ (6) (7)  1   4   5  *\n       # ~ (5)  1   1   2   4  *\n          # *   *   *   *   * Atlantic\n\n# Return:\n\n# [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]\n# (positions with parentheses in above matrix).\n\ndef pacific_atlantic(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    n = len(matrix)\n    if not n: return []\n    m = len(matrix[0])\n    if not m: return []\n    res = []\n    atlantic = [[False for _ in range (n)] for _ in range(m)]\n    pacific =  [[False for _ in range (n)] for _ in range(m)]\n    for i in range(n):\n        dfs(pacific, matrix, float(\"-inf\"), i, 0)\n        dfs(atlantic, matrix, float(\"-inf\"), i, m-1)\n    for i in range(m):\n        dfs(pacific, matrix, float(\"-inf\"), 0, i)\n        dfs(atlantic, matrix, float(\"-inf\"), n-1, i)\n    for i in range(n):\n        for j in range(m):\n            if pacific[i][j] and atlantic[i][j]:\n                res.append([i, j])\n    return res\n\ndef dfs(grid, matrix, height, i, j):\n    if i < 0 or i >= len(matrix) or j < 0 or  j >= len(matrix[0]):\n        return\n    if grid[i][j] or matrix[i][j] < height:\n        return\n    grid[i][j] = True\n    dfs(grid, matrix, matrix[i][j], i-1, j)\n    dfs(grid, matrix, matrix[i][j], i+1, j)\n    dfs(grid, matrix, matrix[i][j], i, j-1)\n    dfs(grid, matrix, matrix[i][j], i, j+1)\n"
  },
  {
    "id": 184,
    "category": "bfs",
    "file_name": "maze_search",
    "codes": "from collections import deque\n\n'''\nBFS time complexity : O(|E| + |V|)\nBFS space complexity : O(|E| + |V|)\n\ndo BFS from (0,0) of the grid and get the minimum number of steps needed to get to the lower right column\n\nonly step on the columns whose value is 1\n\nif there is no path, it returns -1\n\nEx 1)\nIf grid is\n[[1,0,1,1,1,1],\n [1,0,1,0,1,0],\n [1,0,1,0,1,1],\n [1,1,1,0,1,1]], \nthe answer is: 14\n\nEx 2)\nIf grid is\n[[1,0,0],\n [0,1,1],\n [0,1,1]], \nthe answer is: -1\n'''\n\ndef maze_search(maze):\n    BLOCKED, ALLOWED = 0, 1\n    UNVISITED, VISITED = 0, 1\n\n    initial_x, initial_y = 0, 0\n\n    if maze[initial_x][initial_y] == BLOCKED:\n        return -1\n    \n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n    height, width = len(maze), len(maze[0])\n\n    target_x, target_y = height - 1, width - 1\n\n    queue = deque([(initial_x, initial_y, 0)])\n\n    is_visited = [[UNVISITED for w in range(width)] for h in range(height)]\n    is_visited[initial_x][initial_y] = VISITED\n\n    while queue:\n        x, y, steps = queue.popleft()\n\n        if x == target_x and y == target_y:\n            return steps\n\n        for dx, dy in directions:\n            new_x = x + dx\n            new_y = y + dy\n\n            if not (0 <= new_x < height and 0 <= new_y < width):\n                continue\n\n            if maze[new_x][new_y] == ALLOWED and is_visited[new_x][new_y] == UNVISITED:\n                queue.append((new_x, new_y, steps + 1))\n                is_visited[new_x][new_y] = VISITED\n\n    return -1 \n\n"
  },
  {
    "id": 185,
    "category": "bfs",
    "file_name": "shortest_distance_from_all_buildings",
    "codes": "import collections\n\n\"\"\"\ndo BFS from each building, and decrement all empty place for every building visit\nwhen grid[i][j] == -b_nums, it means that grid[i][j] are already visited from all b_nums\nand use dist to record distances from b_nums\n\"\"\"\n\ndef shortest_distance(grid):\n    if not grid or not grid[0]:\n        return -1\n\n    matrix = [[[0,0] for i in range(len(grid[0]))] for j in range(len(grid))]\n\n    count = 0    # count how many building we have visited\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                bfs(grid, matrix, i, j, count)\n                count += 1\n\n    res = float('inf')\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j][1]==count:\n                res = min(res, matrix[i][j][0])\n\n    return res if res!=float('inf') else -1\n\ndef bfs(grid, matrix, i, j, count):\n    q = [(i, j, 0)]\n    while q:\n        i, j, step = q.pop(0)\n        for k, l in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:\n            # only the position be visited by count times will append to queue\n            if 0<=k<len(grid) and 0<=l<len(grid[0]) and \\\n                    matrix[k][l][1]==count and grid[k][l]==0:\n                matrix[k][l][0] += step+1\n                matrix[k][l][1] = count+1\n                q.append((k, l, step+1))\n"
  },
  {
    "id": 186,
    "category": "bfs",
    "file_name": "count_islands",
    "codes": "\"\"\"\nThis is a bfs-version of counting-islands problem in dfs section.\nGiven a 2d grid map of '1's (land) and '0's (water),\ncount the number of islands.\nAn island is surrounded by water and is formed by\nconnecting adjacent lands horizontally or vertically.\nYou may assume all four edges of the grid are all surrounded by water.\n\nExample 1:\n11110\n11010\n11000\n00000\nAnswer: 1\n\nExample 2:\n11000\n11000\n00100\n00011\nAnswer: 3\n\nExample 3:\n111000\n110000\n100001\n001101\n001100\nAnswer: 3\n\nExample 4:\n110011\n001100\n000001\n111100\nAnswer: 5\n\"\"\"\n\n\ndef count_islands(grid):\n    row = len(grid)\n    col = len(grid[0])\n\n    num_islands = 0\n    visited = [[0] * col for i in range(row)]\n    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    queue = []\n\n    for i in range(row):\n        for j, num in enumerate(grid[i]):\n            if num == 1 and visited[i][j] != 1:\n                visited[i][j] = 1\n                queue.append((i, j))\n                while queue:\n                    x, y = queue.pop(0)\n                    for k in range(len(directions)):\n                        nx_x = x + directions[k][0]\n                        nx_y = y + directions[k][1]\n                        if nx_x >= 0 and nx_y >= 0 and nx_x < row and nx_y < col:\n                            if visited[nx_x][nx_y] != 1 and grid[nx_x][nx_y] == 1:\n                                queue.append((nx_x, nx_y))\n                                visited[nx_x][nx_y] = 1\n                num_islands += 1\n\n    return num_islands\n"
  },
  {
    "id": 187,
    "category": "bfs",
    "file_name": "word_ladder",
    "codes": "\"\"\"\nGiven two words (begin_word and end_word), and a dictionary's word list,\nfind the length of shortest transformation sequence\nfrom beginWord to endWord, such that:\n\nOnly one letter can be changed at a time\nEach intermediate word must exist in the word list\nFor example,\n\nGiven:\nbegin_word = \"hit\"\nend_word = \"cog\"\nword_list = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\n\nNote:\nReturn -1 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\n\"\"\"\n\n\ndef ladder_length(begin_word, end_word, word_list):\n    \"\"\"\n    Bidirectional BFS!!!\n    :type begin_word: str\n    :type end_word: str\n    :type word_list: Set[str]\n    :rtype: int\n    \"\"\"\n    if len(begin_word) != len(end_word):\n        return -1   # not possible\n\n    if begin_word == end_word:\n        return 0\n\n    # when only differ by 1 character\n    if sum(c1 != c2 for c1, c2 in zip(begin_word, end_word)) == 1:\n        return 1\n\n    begin_set = set()\n    end_set = set()\n    begin_set.add(begin_word)\n    end_set.add(end_word)\n    result = 2\n    while begin_set and end_set:\n\n        if len(begin_set) > len(end_set):\n            begin_set, end_set = end_set, begin_set\n\n        next_begin_set = set()\n        for word in begin_set:\n            for ladder_word in word_range(word):\n                if ladder_word in end_set:\n                    return result\n                if ladder_word in word_list:\n                    next_begin_set.add(ladder_word)\n                    word_list.remove(ladder_word)\n        begin_set = next_begin_set\n        result += 1\n        # print(begin_set)\n        # print(result)\n    return -1\n\n\ndef word_range(word):\n    for ind in range(len(word)):\n        temp = word[ind]\n        for c in [chr(x) for x in range(ord('a'), ord('z') + 1)]:\n            if c != temp:\n                yield word[:ind] + c + word[ind + 1:]\n"
  },
  {
    "id": 188,
    "category": "search",
    "file_name": "linear_search",
    "codes": "\"\"\"\nLinear search works in any array.\nT(n): O(n)\n\"\"\"\n\ndef linear_search(array, query):\n    \"\"\"\n    Find the index of the given element in the array.\n    There are no restrictions on the order of the elements in the array.\n    If the element couldn't be found, returns -1.\n    \"\"\"\n    for i, value in enumerate(array):\n        if value == query:\n            return i\n    return -1\n"
  },
  {
    "id": 189,
    "category": "search",
    "file_name": "search_rotate",
    "codes": "\"\"\"\nSearch in Rotated Sorted Array\nSuppose an array sorted in ascending order is rotated at some pivot unknown\nto you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\n\nYou are given a target value to search. If found in the array return its index,\notherwise return -1.\n\nYour algorithm's runtime complexity must be in the order of O(log n).\n---------------------------------------------------------------------------------\nExplanation algorithm:\n\nIn classic binary search, we compare val with the midpoint to figure out if\nval belongs on the low or the high side. The complication here is that the\narray is rotated and may have an inflection point. Consider, for example:\n\nArray1: [10, 15, 20, 0, 5]\nArray2: [50, 5, 20, 30, 40]\n\nNote that both arrays have a midpoint of 20, but 5 appears on the left side of\none and on the right side of the other. Therefore, comparing val with the\nmidpoint is insufficient.\n\nHowever, if we look a bit deeper, we can see that one half of the array must be\nordered normally(increasing order). We can therefore look at the normally ordered\nhalf to determine whether we should search the low or hight side.\n\nFor example, if we are searching for 5 in Array1, we can look at the left element (10)\nand middle element (20). Since 10 < 20, the left half must be ordered normally. And, since 5\nis not between those, we know that we must search the right half\n\nIn array2, we can see that since 50 > 20, the right half must be ordered normally. We turn to\nthe middle 20, and right 40 element to check if 5 would fall between them. The value 5 would not\nTherefore, we search the left half.\n\nThere are 2 possible solution: iterative and recursion.\nRecursion helps you understand better the above algorithm explanation\n\"\"\"\ndef search_rotate(array, val):\n    \"\"\"\n    Finds the index of the given value in an array that has been sorted in\n    ascending order and then rotated at some unknown pivot.\n    \"\"\"\n    low, high = 0, len(array) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if val == array[mid]:\n            return mid\n\n        if array[low] <= array[mid]:\n            if array[low] <= val <= array[mid]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        else:\n            if array[mid] <= val <= array[high]:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n    return -1\n\n# Recursion technique\ndef search_rotate_recur(array, low, high, val):\n    \"\"\"\n    Finds the index of the given value in an array that has been sorted in\n    ascending order and then rotated at some unknown pivot.\n    \"\"\"\n    if low >= high:\n        return -1\n    mid = (low + high) // 2\n    if val == array[mid]:       # found element\n        return mid\n    if array[low] <= array[mid]:\n        if array[low] <= val <= array[mid]:\n            return search_rotate_recur(array, low, mid - 1, val)    # Search left\n        return search_rotate_recur(array, mid + 1, high, val)   # Search right\n    if array[mid] <= val <= array[high]:\n        return search_rotate_recur(array, mid + 1, high, val)   # Search right\n    return search_rotate_recur(array, low, mid - 1, val)    # Search left\n"
  },
  {
    "id": 190,
    "category": "search",
    "file_name": "first_occurrence",
    "codes": "\"\"\"\nFind first occurance of a number in a sorted array (increasing order)\nApproach- Binary Search\nT(n)- O(log n)\n\"\"\"\ndef first_occurrence(array, query):\n    \"\"\"\n    Returns the index of the first occurance of the given element in an array.\n    The array has to be sorted in increasing order.\n    \"\"\"\n\n    low, high = 0, len(array) - 1\n    while low <= high:\n        mid = low + (high-low)//2 #Now mid will be ininteger range\n        #print(\"lo: \", lo, \" hi: \", hi, \" mid: \", mid)\n        if low == high:\n            break\n        if array[mid] < query:\n            low = mid + 1\n        else:\n            high = mid\n    if array[low] == query:\n        return low\n"
  },
  {
    "id": 191,
    "category": "search",
    "file_name": "last_occurrence",
    "codes": "\"\"\"\nFind last occurance of a number in a sorted array (increasing order)\nApproach- Binary Search\nT(n)- O(log n)\n\"\"\"\ndef last_occurrence(array, query):\n    \"\"\"\n    Returns the index of the last occurance of the given element in an array.\n    The array has to be sorted in increasing order.\n    \"\"\"\n    low, high = 0, len(array) - 1\n    while low <= high:\n        mid = (high + low) // 2\n        if (array[mid] == query and mid == len(array)-1) or \\\n           (array[mid] == query and array[mid+1] > query):\n            return mid\n        if array[mid] <= query:\n            low = mid + 1\n        else:\n            high = mid - 1\n"
  },
  {
    "id": 192,
    "category": "search",
    "file_name": "interpolation_search",
    "codes": "\"\"\"\nPython implementation of the Interpolation Search algorithm.\nGiven a sorted array in increasing order, interpolation search calculates\nthe starting point of its search according to the search key.\n\nFORMULA: start_pos = low + [ (x - arr[low])*(high - low) / (arr[high] - arr[low]) ]\n\nDoc: https://en.wikipedia.org/wiki/Interpolation_search\n\nTime Complexity: O(log2(log2 n)) for average cases, O(n) for the worst case.\nThe algorithm performs best with uniformly distributed arrays.\n\"\"\"\n\nfrom typing import List\n\n\ndef interpolation_search(array: List[int], search_key: int) -> int:\n    \"\"\"\n    :param array: The array to be searched.\n    :param search_key: The key to be searched in the array.\n\n    :returns: Index of search_key in array if found, else -1.\n\n    Examples:\n\n    >>> interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)\n    2\n    >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)\n    -1\n    >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)\n    -1\n\n    \"\"\"\n\n    # highest and lowest index in array\n    high = len(array) - 1\n    low = 0\n\n    while (low <= high) and (array[low] <= search_key <= array[high]):\n        # calculate the search position\n        pos = low + int(((search_key - array[low]) *\n                         (high - low) / (array[high] - array[low])))\n\n        # search_key is found\n        if array[pos] == search_key:\n            return pos\n\n        # if search_key is larger, search_key is in upper part\n        if array[pos] < search_key:\n            low = pos + 1\n\n        # if search_key is smaller, search_key is in lower part\n        else:\n            high = pos - 1\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n"
  },
  {
    "id": 193,
    "category": "search",
    "file_name": "ternary_search",
    "codes": "\"\"\"\nTernary search is a divide and conquer algorithm that can be used to find an element in an array.\nIt is similar to binary search where we divide the array into two parts but in this algorithm,\nwe divide the given array into three parts and determine which has the key (searched element).\nWe can divide the array into three parts by taking mid1 and mid2.\nInitially, l and r will be equal to 0 and n-1 respectively, where n is the length of the array.\nmid1 = l + (r-l)/3\nmid2 = r \u2013 (r-l)/3\n\nNote: Array needs to be sorted to perform ternary search on it.\nT(N) = O(log3(N))\nlog3 = log base 3\n\"\"\"\ndef ternary_search(left, right, key, arr):\n    \"\"\"\n    Find the given value (key) in an array sorted in ascending order.\n    Returns the index of the value if found, and -1 otherwise.\n    If the index is not in the range left..right (ie. left <= index < right) returns -1.\n    \"\"\"\n\n    while right >= left:\n        mid1 = left + (right-left) // 3\n        mid2 = right - (right-left) // 3\n\n        if key == arr[mid1]:\n            return mid1\n        if key == mid2:\n            return mid2\n\n        if key < arr[mid1]:\n            # key lies between l and mid1\n            right = mid1 - 1\n        elif key > arr[mid2]:\n            # key lies between mid2 and r\n            left = mid2 + 1\n        else:\n            # key lies between mid1 and mid2\n            left = mid1 + 1\n            right = mid2 - 1\n\n    # key not found\n    return -1\n"
  },
  {
    "id": 194,
    "category": "search",
    "file_name": "search_range",
    "codes": "\"\"\"\nGiven an array of integers nums sorted in ascending order, find the starting\nand ending position of a given target value. If the target is not found in the\narray, return [-1, -1].\n\nFor example:\nInput: nums = [5,7,7,8,8,8,10], target = 8\nOutput: [3,5]\nInput: nums = [5,7,7,8,8,8,10], target = 11\nOutput: [-1,-1]\n\"\"\"\ndef search_range(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    # breaks at low == high\n    # both pointing to first occurence of target\n    while low < high:\n        mid = low + (high - low) // 2\n        if target <= nums[mid]:\n            high = mid\n        else:\n            low = mid + 1\n\n    for j in range(len(nums) - 1, -1, -1):\n        if nums[j] == target:\n            return [low, j]\n\n    return [-1, -1]\n"
  },
  {
    "id": 195,
    "category": "search",
    "file_name": "two_sum",
    "codes": "\"\"\"\nGiven an array of integers that is already sorted in ascending order, find two\nnumbers such that they add up to a specific target number. The function two_sum\nshould return indices of the two numbers such that they add up to the target,\nwhere index1 must be less than index2. Please note that your returned answers\n(both index1 and index2) are not zero-based.\nYou may assume that each input would have exactly one solution and you\nmay not use the same element twice.\n\nInput: numbers = [2, 7, 11, 15], target=9\nOutput: index1 = 1, index2 = 2\n\nSolution:\ntwo_sum: using binary search\ntwo_sum1: using dictionary as a hash table\ntwo_sum2: using two pointers\n\"\"\"\n\ndef two_sum(numbers, target):\n    \"\"\"\n    Given a list of numbers sorted in ascending order, find the indices of two\n    numbers such that their sum is the given target.\n\n    Using binary search.\n    \"\"\"\n    for i, number in enumerate(numbers):\n        second_val = target - number\n        low, high = i+1, len(numbers)-1\n        while low <= high:\n            mid = low + (high - low) // 2\n            if second_val == numbers[mid]:\n                return [i + 1, mid + 1]\n\n            if second_val > numbers[mid]:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return None\n\ndef two_sum1(numbers, target):\n    \"\"\"\n    Given a list of numbers, find the indices of two numbers such that their\n    sum is the given target.\n\n    Using a hash table.\n    \"\"\"\n    dic = {}\n    for i, num in enumerate(numbers):\n        if target - num in dic:\n            return [dic[target - num] + 1, i + 1]\n        dic[num] = i\n    return None\n\ndef two_sum2(numbers, target):\n    \"\"\"\n    Given a list of numbers sorted in ascending order, find the indices of two\n    numbers such that their sum is the given target.\n\n    Using a bidirectional linear search.\n    \"\"\"\n    left = 0                      # pointer 1 holds from left of array numbers\n    right = len(numbers) - 1       # pointer 2 holds from right of array numbers\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n\n        if current_sum > target:\n            right = right - 1\n        else:\n            left = left + 1\n"
  },
  {
    "id": 196,
    "category": "search",
    "file_name": "jump_search",
    "codes": "\"\"\"\nJump Search\n\nFind an element in a sorted array.\n\"\"\"\n\nimport math\n\ndef jump_search(arr,target):\n    \"\"\"\n    Worst-case Complexity: O(\u221an) (root(n))\n    All items in list must be sorted like binary search\n\n    Find block that contains target value and search it linearly in that block\n    It returns a first target value in array\n\n    reference: https://en.wikipedia.org/wiki/Jump_search\n    \"\"\"\n\n    length = len(arr)\n    block_size = int(math.sqrt(length))\n    block_prev = 0\n    block= block_size\n\n    # return -1 means that array doesn't contain target value\n    # find block that contains target value\n\n    if arr[length - 1] < target:\n        return -1\n    while block <= length and arr[block - 1] < target:\n        block_prev = block\n        block += block_size\n\n    # find target value in block\n\n    while arr[block_prev] < target :\n        block_prev += 1\n        if block_prev == min(block, length) :\n            return -1\n\n    # if there is target value in array, return it\n\n    if arr[block_prev] == target :\n        return block_prev\n    return -1\n"
  },
  {
    "id": 197,
    "category": "search",
    "file_name": "next_greatest_letter",
    "codes": "'''\nGiven a list of sorted characters letters containing only lowercase letters,\nand given a target letter target, find the smallest element in the list that\nis larger than the given target.\n\nLetters also wrap around. For example, if the target is target = 'z' and\nletters = ['a', 'b'], the answer is 'a'.\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nOutput: \"c\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\nOutput: \"f\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\nOutput: \"f\"\n\nReference: https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/\n'''\n\nimport bisect\n\ndef next_greatest_letter(letters, target):\n    \"\"\"\n    Using bisect libarary\n    \"\"\"\n    index = bisect.bisect(letters, target)\n    return letters[index % len(letters)]\n\ndef next_greatest_letter_v1(letters, target):\n    \"\"\"\n    Using binary search: complexity O(logN)\n    \"\"\"\n    if letters[0] > target:\n        return letters[0]\n    if letters[len(letters) - 1] <= target:\n        return letters[0]\n    left, right = 0, len(letters) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if  letters[mid] > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return letters[left]\n\ndef next_greatest_letter_v2(letters, target):\n    \"\"\"\n    Brute force: complexity O(N)\n    \"\"\"\n    for index in letters:\n        if index > target:\n            return index\n    return letters[0]\n"
  },
  {
    "id": 198,
    "category": "search",
    "file_name": "find_min_rotate",
    "codes": "\"\"\"\nSuppose an array sorted in ascending order is rotated at some pivot unknown\nto you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n\nFind the minimum element. The complexity must be O(logN)\n\nYou may assume no duplicate exists in the array.\n\"\"\"\ndef find_min_rotate(array):\n    \"\"\"\n    Finds the minimum element in a sorted array that has been rotated.\n    \"\"\"\n    low = 0\n    high = len(array) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if array[mid] > array[high]:\n            low = mid + 1\n        else:\n            high = mid\n\n    return array[low]\n\ndef find_min_rotate_recur(array, low, high):\n    \"\"\"\n    Finds the minimum element in a sorted array that has been rotated.\n    \"\"\"\n    mid = (low + high) // 2\n    if mid == low:\n        return array[low]\n    if array[mid] > array[high]:\n        return find_min_rotate_recur(array, mid + 1, high)\n    return find_min_rotate_recur(array, low, mid)\n"
  },
  {
    "id": 199,
    "category": "search",
    "file_name": "search_insert",
    "codes": "\"\"\"\nHelper methods for implementing insertion sort.\n\"\"\"\n\ndef search_insert(array, val):\n    \"\"\"\n    Given a sorted array and a target value, return the index if the target is\n    found. If not, return the index where it would be if it were inserted in order.\n\n    For example:\n    [1,3,5,6], 5 -> 2\n    [1,3,5,6], 2 -> 1\n    [1,3,5,6], 7 -> 4\n    [1,3,5,6], 0 -> 0\n    \"\"\"\n    low = 0\n    high = len(array) - 1\n    while low <=  high:\n        mid = low + (high - low) // 2\n        if val > array[mid]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n"
  },
  {
    "id": 200,
    "category": "search",
    "file_name": "binary_search",
    "codes": "\"\"\"\nBinary Search\n\nFind an element in a sorted array (in ascending order).\n\"\"\"\n\n# For Binary Search, T(N) = T(N/2) + O(1) // the recurrence relation\n# Apply Masters Theorem for computing Run time complexity of recurrence relations:\n#       T(N) = aT(N/b) + f(N)\n# Here,\n#       a = 1, b = 2 => log (a base b) = 1\n# also, here\n#       f(N) = n^c log^k(n)  // k = 0 & c = log (a base b)\n# So,\n#       T(N) = O(N^c log^(k+1)N) = O(log(N))\n\ndef binary_search(array, query):\n    \"\"\"\n    Worst-case Complexity: O(log(n))\n\n    reference: https://en.wikipedia.org/wiki/Binary_search_algorithm\n    \"\"\"\n\n    low, high = 0, len(array) - 1\n    while low <= high:\n        mid = (high + low) // 2\n        val = array[mid]\n        if val == query:\n            return mid\n\n        if val < query:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return None\n\n#In this below function we are passing array, it's first index , last index and value to be searched\ndef binary_search_recur(array, low, high, val):\n    \"\"\"\n    Worst-case Complexity: O(log(n))\n\n    reference: https://en.wikipedia.org/wiki/Binary_search_algorithm\n    \"\"\"\n#Here in Logic section first we are checking if low is greater than high which means its an error condition because low index should not move ahead of high index\n    if low > high:       \n        return -1\n    mid = low + (high-low)//2   #This mid will not break integer range\n    if val < array[mid]:  \n        return binary_search_recur(array, low, mid - 1, val) #Go search in the left subarray\n    if val > array[mid]:\n        return binary_search_recur(array, mid + 1, high, val) #Go search in the right subarray\n    return mid\n"
  },
  {
    "id": 201,
    "category": "bit",
    "file_name": "flip_bit_longest_sequence",
    "codes": "\"\"\"\nYou have an integer and you can flip exactly one bit from a 0 to 1.\nWrite code to find the length of the longest sequence of 1s you could create.\nFor example:\nInput: 1775 ( or: 11011101111)\nOutput: 8\n\"\"\"\n\n\ndef flip_bit_longest_seq(num):\n\n    curr_len = 0\n    prev_len = 0\n    max_len = 0\n\n    while num:\n        if num & 1 == 1:  # last digit is 1\n            curr_len += 1\n\n        elif num & 1 == 0:  # last digit is 0\n            if num & 2 == 0:  # second last digit is 0\n                prev_len = 0\n            else:\n                prev_len = curr_len\n            curr_len = 0\n\n        max_len = max(max_len, prev_len + curr_len)\n        num = num >> 1  # right shift num\n\n    return max_len + 1\n"
  },
  {
    "id": 202,
    "category": "bit",
    "file_name": "count_flips_to_convert",
    "codes": "\"\"\"\nWrite a function to determine the minimal number of bits you would need to\nflip to convert integer A to integer B.\nFor example:\nInput: 29 (or: 11101), 15 (or: 01111)\nOutput: 2\n\"\"\"\n\n\ndef count_flips_to_convert(a, b):\n\n    diff = a ^ b\n\n    # count number of ones in diff\n    count = 0\n    while diff:\n        diff &= (diff - 1)\n        count += 1\n    return count\n"
  },
  {
    "id": 203,
    "category": "bit",
    "file_name": "find_missing_number",
    "codes": "\"\"\"\n    Returns the missing number from a sequence of unique integers\n    in range [0..n] in O(n) time and space. The difference between\n    consecutive integers cannot be more than 1. If the sequence is\n    already complete, the next integer in the sequence will be returned.\n\n    For example:\n    Input: nums = [4, 1, 3, 0, 6, 5, 2]\n    Output: 7\n\"\"\"\ndef find_missing_number(nums):\n\n    missing = 0\n    for i, num in enumerate(nums):\n        missing ^= num\n        missing ^= i + 1\n\n    return missing\n\n\ndef find_missing_number2(nums):\n\n    num_sum = sum(nums)\n    n = len(nums)\n    total_sum = n*(n+1) // 2\n    missing = total_sum - num_sum\n    return missing\n"
  },
  {
    "id": 204,
    "category": "bit",
    "file_name": "binary_gap",
    "codes": "\"\"\"\nGiven a positive integer N, find and return the longest distance between two\nconsecutive 1' in the binary representation of N.\nIf there are not two consecutive 1's, return 0\n\nFor example:\nInput: 22\nOutput: 2\nExplanation:\n22 in binary is 10110\nIn the binary representation of 22, there are three ones, and two consecutive pairs of 1's.\nThe first consecutive pair of 1's have distance 2.\nThe second consecutive pair of 1's have distance 1.\nThe answer is the largest of these two distances, which is 2\n\"\"\"\n\n\n# \u539f\u65b9\u6cd5\u4e3a binary_gap\uff0c\u4f46\u901a\u8fc7\u5b9e\u9a8c\u53d1\u73b0\u7b97\u6cd5\u6709\u8bef\uff0c\u4e0d\u8bba\u662f\u4ec0\u4e48\u6570\uff0c\u8f93\u51fa\u503c\u6700\u591a\u4e3a2\u3002\n# \u6539\u8fdb\u65b9\u6cd5\u4e3abinary_gap_improved\u3002\n# The original method is binary_gap,\n# but the experimental results show that the algorithm seems to be wrong,\n# regardless of the number, the output value is up to 2.\n# The improved method is binary_gap_improved.\ndef binary_gap(N):\n    last = None\n    ans = 0\n    index = 0\n    while N != 0:\n        if N & 1:\n            if last is not None:\n                ans = max(ans, index - last)\n            last = index\n        index = index + 1\n        N = N >> 1\n    return ans\n\n\ndef binary_gap_improved(N):\n    last = None\n    ans = 0\n    index = 0\n    while N != 0:\n        tes = N & 1\n        if tes:\n            if last is not None:\n                ans = max(ans, index - last + 1)\n            else:\n                last = index\n        else:\n            last = index + 1\n        index = index + 1\n        N = N >> 1\n    return ans\n\n\nprint(binary_gap(111))\nprint(binary_gap_improved(111))"
  },
  {
    "id": 205,
    "category": "bit",
    "file_name": "has_alternative_bit",
    "codes": "\"\"\"\nGiven a positive integer, check whether it has alternating bits: namely,\nif two adjacent bits will always have different values.\n\nFor example:\nInput: 5\nOutput: True because the binary representation of 5 is: 101.\n\nInput: 7\nOutput: False because the binary representation of 7 is: 111.\n\nInput: 11\nOutput: False because the binary representation of 11 is: 1011.\n\nInput: 10\nOutput: True because The binary representation of 10 is: 1010.\n\"\"\"\n\n# Time Complexity - O(number of bits in n)\ndef has_alternative_bit(n):\n    first_bit = 0\n    second_bit = 0\n    while n:\n        first_bit = n & 1\n        if n >> 1:\n            second_bit = (n >> 1) & 1\n            if not first_bit ^ second_bit:\n                return False\n        else:\n            return True\n        n = n >> 1\n    return True    \n\n# Time Complexity - O(1)\ndef has_alternative_bit_fast(n):\n    mask1 = int('aaaaaaaa', 16)  # for bits ending with zero (...1010)\n    mask2 = int('55555555', 16)  # for bits ending with one  (...0101)\n    return mask1 == (n + (n ^ mask1)) or mask2 == (n + (n ^ mask2))\n"
  },
  {
    "id": 206,
    "category": "bit",
    "file_name": "subsets",
    "codes": "\"\"\"\nGiven a set of distinct integers, nums,\nreturn all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,3], a solution is:\n\n{\n    (1, 2),\n    (1, 3),\n    (1,),\n    (2,),\n    (3,),\n    (1, 2, 3),\n    (),\n    (2, 3)\n}\n\"\"\"\ndef subsets(nums):\n    \"\"\"\n    :param nums: List[int]\n    :return: Set[tuple]\n    \"\"\"\n    n = len(nums)\n    total = 1 << n\n    res = set()\n\n    for i in range(total):\n        subset = tuple(num for j, num in enumerate(nums) if i & 1 << j)\n        res.add(subset)\n\n    return res\n\"\"\"\nthis explanation is from leet_nik @ leetcode\nThis is an amazing solution. Learnt a lot.\n\nNumber of subsets for {1 , 2 , 3 } = 2^3 .\nwhy ?\ncase    possible outcomes for the set of subsets\n  1   ->          Take or dont take = 2\n  2   ->          Take or dont take = 2\n  3   ->          Take or dont take = 2\n\ntherefore,\ntotal = 2*2*2 = 2^3 = {{}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}}\n\nLets assign bits to each outcome  ->\nFirst bit to 1 , Second bit to 2 and third bit to 3\nTake = 1\nDont take = 0\n\n0) 0 0 0  -> Dont take 3 , Dont take 2 , Dont take 1 = { }\n1) 0 0 1  -> Dont take 3 , Dont take 2 ,   take 1    = { 1 }\n2) 0 1 0  -> Dont take 3 ,    take 2   , Dont take 1 = { 2 }\n3) 0 1 1  -> Dont take 3 ,    take 2   ,   take 1    = { 1 , 2 }\n4) 1 0 0  ->    take 3   , Dont take 2 , Dont take 1 = { 3 }\n5) 1 0 1  ->    take 3   , Dont take 2 ,   take 1    = { 1 , 3 }\n6) 1 1 0  ->    take 3   ,    take 2   , Dont take 1 = { 2 , 3 }\n7) 1 1 1  ->    take 3   ,    take 2   ,   take 1    = { 1 , 2 , 3 }\n\nIn the above logic ,Insert S[i] only if (j>>i)&1 ==true\n{ j E { 0,1,2,3,4,5,6,7 }   i = ith element in the input array }\n\nelement 1 is inserted only into those places where 1st bit of j is 1\nif( j >> 0 &1 )  ==> for above above eg.\nthis is true for sl.no.( j )= 1 , 3 , 5 , 7\n\nelement 2 is inserted only into those places where 2nd bit of j is 1\nif( j >> 1 &1 )  == for above above eg.\nthis is true for sl.no.( j ) = 2 , 3 , 6 , 7\n\nelement 3 is inserted only into those places where 3rd bit of j is 1\nif( j >> 2 & 1 )  == for above above eg.\nthis is true for sl.no.( j ) = 4 , 5 , 6 , 7\n\nTime complexity : O(n*2^n) , for every input element loop traverses\nthe whole solution set length i.e. 2^n\n\"\"\"\n"
  },
  {
    "id": 207,
    "category": "bit",
    "file_name": "find_difference",
    "codes": "\"\"\"\nGiven two strings s and t which consist of only lowercase letters.\nString t is generated by random shuffling string s and then add one more letter\nat a random position. Find the letter that was added in t.\n\nFor example:\nInput:\ns = \"abcd\"\nt = \"abecd\"\nOutput: 'e'\n\nExplanation:\n'e' is the letter that was added.\n\"\"\"\n\n\"\"\"\nWe use the characteristic equation of XOR.\nA xor B xor C = A xor C xor B\nIf A == C, then A xor C = 0\nand then, B xor 0 =  B\n\"\"\"\ndef find_difference(s, t):\n    ret = 0\n    for ch in s + t:\n        # ord(ch) return an integer representing the Unicode code point of that character\n        ret = ret ^ ord(ch)\n    # chr(i) Return the string representing a character whose Unicode code point is the integer i\n    return chr(ret)\n"
  },
  {
    "id": 208,
    "category": "bit",
    "file_name": "swap_pair",
    "codes": "\"\"\"\nSwap_pair: A function swap odd and even bits in an integer with as few instructions\nas possible (Ex bit and bit 1 are swapped, bit 2 and bit 3 are swapped)\n\nFor example:\n22: 010110  --> 41: 101001\n10: 1010    --> 5 : 0101\n\"\"\"\n\n\"\"\"\nWe can approach this as operating on the odds bit first, and then the even bits.\nWe can mask all odd bits with 10101010 in binary ('AA') then shift them right by 1\nSimilarly, we mask all even bit with 01010101 in binary ('55') then shift them left\nby 1. Finally, we merge these two values by OR operation.\n\"\"\"\ndef swap_pair(num):\n    # odd bit arithmetic right shift 1 bit\n    odd = (num & int('AAAAAAAA', 16)) >> 1\n    # even bit left shift 1 bit\n    even = (num & int('55555555', 16)) << 1\n    return odd | even\n"
  },
  {
    "id": 209,
    "category": "bit",
    "file_name": "add_bitwise_operator",
    "codes": "\"\"\"\nThe following code adds two positive integers without using the '+' operator.\nThe code uses bitwise operations to add two numbers.\n\nInput: 2 3\nOutput: 5\n\"\"\"\ndef add_bitwise_operator(x, y):\n\n    while y:\n        carry = x & y\n        x = x ^ y\n        y = carry << 1\n    return x\n"
  },
  {
    "id": 210,
    "category": "bit",
    "file_name": "remove_bit",
    "codes": "\"\"\"\nRemove_bit(num, i): remove a bit at specific position.\nFor example:\n\nInput: num = 10101 (21)\nremove_bit(num, 2): output = 1001 (9)\nremove_bit(num, 4): output = 101 (5)\nremove_bit(num, 0): output = 1010 (10)\n\"\"\"\n\ndef remove_bit(num, i):\n    mask = num >> (i + 1)\n    mask = mask << i\n    right = ((1 << i) - 1) & num\n    return mask | right\n"
  },
  {
    "id": 211,
    "category": "bit",
    "file_name": "insert_bit",
    "codes": "\"\"\"\nInsertion:\n\ninsert_one_bit(num, bit, i): insert exact one bit at specific position\nFor example:\n\nInput: num = 10101 (21)\ninsert_one_bit(num, 1, 2): 101101 (45)\ninsert_one_bit(num, 0, 2): 101001 (41)\ninsert_one_bit(num, 1, 5): 110101 (53)\ninsert_one_bit(num, 1, 0): 101011 (43)\n\ninsert_mult_bits(num, bits, len, i): insert multiple bits with len at specific position\nFor example:\n\nInput: num = 101 (5)\ninsert_mult_bits(num, 7, 3, 1): 101111 (47)\ninsert_mult_bits(num, 7, 3, 0): 101111 (47)\ninsert_mult_bits(num, 7, 3, 3): 111101 (61)\n\"\"\"\n\n\"\"\"\nInsert exact one bit at specific position\n\nAlgorithm:\n1. Create a mask having bit from i to the most significant bit, and append the new bit at 0 position\n2. Keep the bit from 0 position to i position ( like 000...001111)\n3. Merge mask and num\n\"\"\"\ndef insert_one_bit(num, bit, i):\n    # Create mask\n    mask = num >> i\n    mask = (mask << 1) | bit\n    mask = mask << i\n    # Keep the bit from 0 position to i position\n    right = ((1 << i) - 1) & num\n    return right | mask\n\ndef insert_mult_bits(num, bits, len, i):\n    mask = num >> i\n    mask = (mask << len) | bits\n    mask = mask << i\n    right = ((1 << i) - 1) & num\n    return right | mask\n"
  },
  {
    "id": 212,
    "category": "bit",
    "file_name": "bit_operation",
    "codes": "\"\"\"\nFundamental bit operation:\n    get_bit(num, i): get an exact bit at specific index\n    set_bit(num, i): set a bit at specific index\n    clear_bit(num, i): clear a bit at specific index\n    update_bit(num, i, bit): update a bit at specific index\n\"\"\"\n\n\"\"\"\nThis function shifts 1 over by i bits, creating a value being like 0001000. By\nperforming an AND with num, we clear all bits other than the bit at bit i.\nFinally we compare that to 0\n\"\"\"\ndef get_bit(num, i):\n    return (num & (1 << i)) != 0\n\n\"\"\"\nThis function shifts 1 over by i bits, creating a value being like 0001000. By\nperforming an OR with num, only value at bit i will change.\n\"\"\"\ndef set_bit(num, i):\n    return num | (1 << i)\n\n\"\"\"\nThis method operates in almost the reverse of set_bit\n\"\"\"\ndef clear_bit(num, i):\n    mask = ~(1 << i)\n    return num & mask\n\n\"\"\"\nTo set the ith bit to value, we first clear the bit at position i by using a\nmask. Then, we shift the intended value. Finally we OR these two numbers\n\"\"\"\ndef update_bit(num, i, bit):\n    mask = ~(1 << i)\n    return (num & mask) | (bit << i)\n"
  },
  {
    "id": 213,
    "category": "bit",
    "file_name": "reverse_bits",
    "codes": "\"\"\"\nReverse bits of a given 32 bits unsigned integer.\n\nFor example, given input 43261596\n(represented in binary as 00000010100101000001111010011100),\nreturn 964176192\n(represented in binary as 00111001011110000010100101000000).\n\"\"\"\ndef reverse_bits(n):\n    m = 0\n    i = 0\n    while i < 32:\n        m = (m << 1) + (n & 1)\n        n >>= 1\n        i += 1\n    return m\n"
  },
  {
    "id": 214,
    "category": "bit",
    "file_name": "single_number3",
    "codes": "\"\"\"\nGiven an array of numbers nums,\nin which exactly two elements appear only once\nand all the other elements appear exactly twice.\nFind the two elements that appear only once.\nLimitation: Time Complexity: O(N) and Space Complexity O(1)\n\nFor example:\n\nGiven nums = [1, 2, 1, 3, 2, 5], return [3, 5].\n\nNote:\nThe order of the result is not important.\nSo in the above example, [5, 3] is also correct.\n\n\nSolution:\n1. Use XOR to cancel out the pairs and isolate A^B\n2. It is guaranteed that at least 1 bit exists in A^B since\n   A and B are different numbers. ex) 010 ^ 111 = 101\n3. Single out one bit R (right most bit in this solution) to use it as a pivot\n4. Divide all numbers into two groups.\n   One group with a bit in the position R\n   One group without a bit in the position R\n5. Use the same strategy we used in step 1 to isolate A and B from each group.\n\"\"\"\n\n\ndef single_number3(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # isolate a^b from pairs using XOR\n    ab = 0\n    for n in nums:\n        ab ^= n\n\n    # isolate right most bit from a^b\n    right_most = ab & (-ab)\n\n    # isolate a and b from a^b\n    a, b = 0, 0\n    for n in nums:\n        if n & right_most:\n            a ^= n\n        else:\n            b ^= n\n    return [a, b]\n"
  },
  {
    "id": 215,
    "category": "bit",
    "file_name": "power_of_two",
    "codes": "\"\"\"\ngiven an integer, write a function to determine if it is a power of two\n\"\"\"\ndef is_power_of_two(n):\n    \"\"\"\n    :type n: int\n    :rtype: bool\n    \"\"\"\n    return n > 0 and not n & (n-1)\n"
  },
  {
    "id": 216,
    "category": "bit",
    "file_name": "bytes_int_conversion",
    "codes": "from collections import deque\n\n\ndef int_to_bytes_big_endian(num):\n    bytestr = deque()\n    while num > 0:\n        # list.insert(0, ...) is inefficient\n        bytestr.appendleft(num & 0xff)\n        num >>= 8\n    return bytes(bytestr)\n\n\ndef int_to_bytes_little_endian(num):\n    bytestr = []\n    while num > 0:\n        bytestr.append(num & 0xff)\n        num >>= 8\n    return bytes(bytestr)\n\n\ndef bytes_big_endian_to_int(bytestr):\n    num = 0\n    for b in bytestr:\n        num <<= 8\n        num += b\n    return num\n\n\ndef bytes_little_endian_to_int(bytestr):\n    num = 0\n    e = 0\n    for b in bytestr:\n        num += b << e\n        e += 8\n    return num\n"
  },
  {
    "id": 217,
    "category": "bit",
    "file_name": "single_number2",
    "codes": "\"\"\"\nGiven an array of integers, every element appears\nthree times except for one, which appears exactly once.\nFind that single one.\n\nNote:\nYour algorithm should have a linear runtime complexity.\nCould you implement it without using extra memory?\n\n\nSolution:\n32 bits for each integer.\nConsider 1 bit in it, the sum of each integer's corresponding bit\n(except for the single number)\nshould be 0 if mod by 3. Hence, we sum the bits of all\nintegers and mod by 3,\nthe remaining should be the exact bit of the single number.\nIn this way, you get the 32 bits of the single number.\n\"\"\"\n\n# Another awesome answer\ndef single_number2(nums):\n    ones, twos = 0, 0\n    for i in range(len(nums)):\n        ones = (ones ^ nums[i]) & ~twos\n        twos = (twos ^ nums[i]) & ~ones\n    return ones\n"
  },
  {
    "id": 218,
    "category": "bit",
    "file_name": "count_ones",
    "codes": "\"\"\"\nWrite a function that takes an unsigned integer and\nreturns the number of '1' bits it has\n(also known as the Hamming weight).\n\nFor example, the 32-bit integer '11' has binary\nrepresentation 00000000000000000000000000001011,\nso the function should return 3.\n\nT(n)- O(k)   : k is the number of 1s present in binary representation.\nNOTE: this complexity is better than O(log n).\ne.g. for n = 00010100000000000000000000000000\nonly 2 iterations are required.\n\nNumber of loops is\nequal to the number of 1s in the binary representation.\"\"\"\ndef count_ones_recur(n):\n    \"\"\"Using Brian Kernighan's Algorithm. (Recursive Approach)\"\"\"\n\n    if not n:\n        return 0\n    return 1 + count_ones_recur(n & (n-1))\n\n\ndef count_ones_iter(n):\n    \"\"\"Using Brian Kernighan's Algorithm. (Iterative Approach)\"\"\"\n\n    count = 0\n    while n:\n        n &= (n-1)\n        count += 1\n    return count\n"
  },
  {
    "id": 219,
    "category": "bit",
    "file_name": "single_number",
    "codes": "\"\"\"\nGiven an array of integers, every element appears\ntwice except for one. Find that single one.\n\nNOTE: This also works for finding a number occurring odd\n      number of times, where all the other numbers appear\n      even number of times.\n\nNote:\nYour algorithm should have a linear runtime complexity.\nCould you implement it without using extra memory?\n\"\"\"\ndef single_number(nums):\n    \"\"\"\n    Returns single number, if found.\n    Else if all numbers appear twice, returns 0.\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    i = 0\n    for num in nums:\n        i ^= num\n    return i\n"
  },
  {
    "id": 220,
    "category": "graph",
    "file_name": "count_connected_number_of_component",
    "codes": "#count connected no of component using DFS\n'''\nIn graph theory, a component, sometimes called a connected component,\nof an undirected graph is a subgraph in which any\ntwo vertices are connected to each other by paths.\n\nExample:\n\n\n    1                3------------7\n    |\n    |\n    2--------4\n    |        |\n    |        |              output = 2\n    6--------5\n\n'''\n\n# Code is Here\n\ndef dfs(source,visited,adjacency_list):\n    ''' Function that performs DFS '''\n\n    visited[source] = True\n    for child in adjacency_list[source]:\n        if not visited[child]:\n            dfs(child,visited,adjacency_list)\n\ndef count_components(adjacency_list,size):\n    '''\n    Function that counts the Connected components on bases of DFS.\n    return type : int\n    '''\n\n    count = 0\n    visited = [False]*(size+1)\n    for i in range(1,size+1):\n        if not visited[i]:\n            dfs(i,visited,adjacency_list)\n            count+=1\n    return count\n\ndef main():\n    \"\"\"\n    Example application\n    \"\"\"\n    node_count,edge_count = map(int, input(\"Enter the Number of Nodes and Edges \\n\").split(' '))\n    adjacency = [[] for _ in range(node_count+1)]\n    for _ in range(edge_count):\n        print(\"Enter the edge's Nodes in form of `source target`\\n\")\n        source,target = map(int,input().split(' '))\n        adjacency[source].append(target)\n        adjacency[target].append(source)\n    print(\"Total number of Connected Components are : \", count_components(adjacency,node_count))\n\n# Driver code\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "id": 221,
    "category": "graph",
    "file_name": "satisfiability",
    "codes": "\"\"\"\nGiven a formula in conjunctive normal form (2-CNF), finds a way to assign\nTrue/False values to all variables to satisfy all clauses, or reports there\nis no solution.\n\nhttps://en.wikipedia.org/wiki/2-satisfiability\n\n\nFormat:\n        - each clause is a pair of literals\n        - each literal in the form (name, is_neg)\n          where name is an arbitrary identifier,\n          and is_neg is true if the literal is negated\n\"\"\"\n\ndef dfs_transposed(vertex, graph, order, visited):\n    \"\"\"\n    Perform a depth first search traversal of the graph starting at the given vertex.\n    Stores the order in which nodes were visited to the list, in transposed order.\n    \"\"\"\n    visited[vertex] = True\n\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs_transposed(adjacent, graph, order, visited)\n\n    order.append(vertex)\n\n\ndef dfs(vertex, current_comp, vertex_scc, graph, visited):\n    \"\"\"\n    Perform a depth first search traversal of the graph starting at the given vertex.\n    Records all visited nodes as being of a certain strongly connected component.\n    \"\"\"\n    visited[vertex] = True\n    vertex_scc[vertex] = current_comp\n\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs(adjacent, current_comp, vertex_scc, graph, visited)\n\n\ndef add_edge(graph, vertex_from, vertex_to):\n    \"\"\"\n    Add a directed edge to the graph.\n    \"\"\"\n    if vertex_from not in graph:\n        graph[vertex_from] = []\n\n    graph[vertex_from].append(vertex_to)\n\n\ndef scc(graph):\n    ''' Computes the strongly connected components of a graph '''\n    order = []\n    visited = {vertex: False for vertex in graph}\n\n    graph_transposed = {vertex: [] for vertex in graph}\n\n    for (source, neighbours) in graph.iteritems():\n        for target in neighbours:\n            add_edge(graph_transposed, target, source)\n\n    for vertex in graph:\n        if not visited[vertex]:\n            dfs_transposed(vertex, graph_transposed, order, visited)\n\n    visited = {vertex: False for vertex in graph}\n    vertex_scc = {}\n\n    current_comp = 0\n    for vertex in reversed(order):\n        if not visited[vertex]:\n            # Each dfs will visit exactly one component\n            dfs(vertex, current_comp, vertex_scc, graph, visited)\n            current_comp += 1\n\n    return vertex_scc\n\n\ndef build_graph(formula):\n    ''' Builds the implication graph from the formula '''\n    graph = {}\n\n    for clause in formula:\n        for (lit, _) in clause:\n            for neg in [False, True]:\n                graph[(lit, neg)] = []\n\n    for ((a_lit, a_neg), (b_lit, b_neg)) in formula:\n        add_edge(graph, (a_lit, a_neg), (b_lit, not b_neg))\n        add_edge(graph, (b_lit, b_neg), (a_lit, not a_neg))\n\n    return graph\n\n\ndef solve_sat(formula):\n    \"\"\"\n    Solves the 2-SAT problem\n    \"\"\"\n    graph = build_graph(formula)\n    vertex_scc = scc(graph)\n\n    for (var, _) in graph:\n        if vertex_scc[(var, False)] == vertex_scc[(var, True)]:\n            return None  # The formula is contradictory\n\n    comp_repr = {}  # An arbitrary representant from each component\n\n    for vertex in graph:\n        if not vertex_scc[vertex] in comp_repr:\n            comp_repr[vertex_scc[vertex]] = vertex\n\n    comp_value = {}  # True/False value for each strongly connected component\n    components = sorted(vertex_scc.values())\n\n    for comp in components:\n        if comp not in comp_value:\n            comp_value[comp] = False\n\n            (lit, neg) = comp_repr[comp]\n            comp_value[vertex_scc[(lit, not neg)]] = True\n\n    value = {var: comp_value[vertex_scc[(var, False)]] for (var, _) in graph}\n\n    return value\n\n\ndef main():\n    \"\"\"\n    Entry point for testing\n    \"\"\"\n    formula = [(('x', False), ('y', False)),\n               (('y', True), ('y', True)),\n               (('a', False), ('b', False)),\n               (('a', True), ('c', True)),\n               (('c', False), ('b', True))]\n\n    result = solve_sat(formula)\n\n    for (variable, assign) in result.items():\n        print(f\"{variable}:{assign}\")\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "id": 222,
    "category": "graph",
    "file_name": "bellman_ford",
    "codes": "\"\"\"\nDetermination of single-source shortest-path.\n\"\"\"\n\ndef bellman_ford(graph, source):\n    \"\"\"\n    This Bellman-Ford Code is for determination whether we can get\n    shortest path from given graph or not for single-source shortest-paths problem.\n    In other words, if given graph has any negative-weight cycle that is reachable\n    from the source, then it will give answer False for \"no solution exits\".\n    For argument graph, it should be a dictionary type\n    such as\n    graph = {\n        'a': {'b': 6, 'e': 7},\n        'b': {'c': 5, 'd': -4, 'e': 8},\n        'c': {'b': -2},\n        'd': {'a': 2, 'c': 7},\n        'e': {'b': -3}\n    }\n    \"\"\"\n    weight = {}\n    pre_node = {}\n\n    initialize_single_source(graph, source, weight, pre_node)\n\n    for _ in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node\n\n    for node in graph:\n        for adjacent in graph[node]:\n            if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                return False\n\n    return True\n\ndef initialize_single_source(graph, source, weight, pre_node):\n    \"\"\"\n    Initialize data structures for Bellman-Ford algorithm.\n    \"\"\"\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n\n    weight[source] = 0\n"
  },
  {
    "id": 223,
    "category": "graph",
    "file_name": "graph",
    "codes": "\"\"\"\nThese are classes to represent a Graph and its elements.\nIt can be shared across graph algorithms.\n\"\"\"\n\nclass Node:\n    \"\"\"\n    A node/vertex in a graph.\n    \"\"\"\n\n    def __init__(self, name):\n        self.name = name\n\n    @staticmethod\n    def get_name(obj):\n        \"\"\"\n        Return the name of the node\n        \"\"\"\n        if isinstance(obj, Node):\n            return obj.name\n        if isinstance(obj, str):\n            return obj\n        return''\n\n    def __eq__(self, obj):\n        return self.name == self.get_name(obj)\n\n    def __repr__(self):\n        return self.name\n\n    def __hash__(self):\n        return hash(self.name)\n\n    def __ne__(self, obj):\n        return self.name != self.get_name(obj)\n\n    def __lt__(self, obj):\n        return self.name < self.get_name(obj)\n\n    def __le__(self, obj):\n        return self.name <= self.get_name(obj)\n\n    def __gt__(self, obj):\n        return self.name > self.get_name(obj)\n\n    def __ge__(self, obj):\n        return self.name >= self.get_name(obj)\n\n    def __bool__(self):\n        return self.name\n\nclass DirectedEdge:\n    \"\"\"\n    A directed edge in a directed graph.\n    Stores the source and target node of the edge.\n    \"\"\"\n\n    def __init__(self, node_from, node_to):\n        self.source = node_from\n        self.target = node_to\n\n    def __eq__(self, obj):\n        if isinstance(obj, DirectedEdge):\n            return obj.source == self.source and obj.target == self.target\n        return False\n\n    def __repr__(self):\n        return f\"({self.source} -> {self.target})\"\n\nclass DirectedGraph:\n    \"\"\"\n    A directed graph.\n    Stores a set of nodes, edges and adjacency matrix.\n    \"\"\"\n\n    # pylint: disable=dangerous-default-value\n    def __init__(self, load_dict={}):\n        self.nodes = []\n        self.edges = []\n        self.adjacency_list = {}\n\n        if load_dict and isinstance(load_dict, dict):\n            for vertex in load_dict:\n                node_from = self.add_node(vertex)\n                self.adjacency_list[node_from] = []\n                for neighbor in load_dict[vertex]:\n                    node_to = self.add_node(neighbor)\n                    self.adjacency_list[node_from].append(node_to)\n                    self.add_edge(vertex, neighbor)\n\n    def add_node(self, node_name):\n        \"\"\"\n        Add a new named node to the graph.\n        \"\"\"\n        try:\n            return self.nodes[self.nodes.index(node_name)]\n        except ValueError:\n            node = Node(node_name)\n            self.nodes.append(node)\n            return node\n\n    def add_edge(self, node_name_from, node_name_to):\n        \"\"\"\n        Add a new edge to the graph between two nodes.\n        \"\"\"\n        try:\n            node_from = self.nodes[self.nodes.index(node_name_from)]\n            node_to = self.nodes[self.nodes.index(node_name_to)]\n            self.edges.append(DirectedEdge(node_from, node_to))\n        except ValueError:\n            pass\n"
  },
  {
    "id": 224,
    "category": "graph",
    "file_name": "traversal",
    "codes": "\"\"\"\nDifferent ways to traverse a graph\n\"\"\"\n\n# dfs and bfs are the ultimately same except that they are visiting nodes in\n# different order. To simulate this ordering we would use stack for dfs and\n# queue for bfs.\n#\n\ndef dfs_traverse(graph, start):\n    \"\"\"\n    Traversal by depth first search.\n    \"\"\"\n    visited, stack = set(), [start]\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            for next_node in graph[node]:\n                if next_node not in visited:\n                    stack.append(next_node)\n    return visited\n\ndef bfs_traverse(graph, start):\n    \"\"\"\n    Traversal by breadth first search.\n    \"\"\"\n    visited, queue = set(), [start]\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            for next_node in graph[node]:\n                if next_node not in visited:\n                    queue.append(next_node)\n    return visited\n\ndef dfs_traverse_recursive(graph, start, visited=None):\n    \"\"\"\n    Traversal by recursive depth first search.\n    \"\"\"\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for next_node in graph[start]:\n        if next_node not in visited:\n            dfs_traverse_recursive(graph, next_node, visited)\n    return visited\n"
  },
  {
    "id": 225,
    "category": "graph",
    "file_name": "check_digraph_strongly_connected",
    "codes": "\"\"\"\nIn a directed graph, a strongly connected component is a set of vertices such\nthat for any pairs of vertices u and v there exists a path (u-...-v) that\nconnects them. A graph is strongly connected if it is a single strongly\nconnected component.\n\"\"\"\n\nfrom collections import defaultdict\n\nclass Graph:\n    \"\"\"\n    A directed graph where edges are one-way (a two-way edge can be represented by using two edges).\n    \"\"\"\n\n    def __init__(self,vertex_count):\n        \"\"\"\n        Create a new graph with vertex_count vertices.\n        \"\"\"\n\n        self.vertex_count = vertex_count\n        self.graph = defaultdict(list)\n\n    def add_edge(self,source,target):\n        \"\"\"\n        Add an edge going from source to target\n        \"\"\"\n        self.graph[source].append(target)\n\n    def dfs(self):\n        \"\"\"\n        Determine if all nodes are reachable from node 0\n        \"\"\"\n        visited = [False] * self.vertex_count\n        self.dfs_util(0,visited)\n        if visited == [True]*self.vertex_count:\n            return True\n        return False\n\n    def dfs_util(self,source,visited):\n        \"\"\"\n        Determine if all nodes are reachable from the given node\n        \"\"\"\n        visited[source] = True\n        for adjacent in self.graph[source]:\n            if not visited[adjacent]:\n                self.dfs_util(adjacent,visited)\n\n    def reverse_graph(self):\n        \"\"\"\n        Create a new graph where every edge a->b is replaced with an edge b->a\n        \"\"\"\n        reverse_graph = Graph(self.vertex_count)\n        for source, adjacent in self.graph.items():\n            for target in adjacent:\n                # Note: we reverse the order of arguments\n                # pylint: disable=arguments-out-of-order\n                reverse_graph.add_edge(target,source)\n        return reverse_graph\n\n\n    def is_strongly_connected(self):\n        \"\"\"\n        Determine if the graph is strongly connected.\n        \"\"\"\n        if self.dfs():\n            reversed_graph = self.reverse_graph()\n            if reversed_graph.dfs():\n                return True\n        return False\n"
  },
  {
    "id": 226,
    "category": "graph",
    "file_name": "all_pairs_shortest_path",
    "codes": "\"\"\"\nGiven a n*n adjacency array.\nit will give you all pairs shortest path length.\nuse deepcopy to preserve the original information.\n\nTime complexity : O(E^3)\n\nexample\n\na = [[0    , 0.1  , 0.101, 0.142, 0.277],\n     [0.465, 0    , 0.191, 0.192, 0.587],\n     [0.245, 0.554, 0    , 0.333, 0.931],\n     [1.032, 0.668, 0.656, 0    , 0.151],\n     [0.867, 0.119, 0.352, 0.398, 0]]\n\nresult\n\n[[0    , 0.1  , 0.101, 0.142, 0.277],\n [0.436, 0    , 0.191, 0.192, 0.343],\n [0.245, 0.345, 0    , 0.333, 0.484],\n [0.706, 0.27 , 0.461, 0    , 0.151],\n [0.555, 0.119, 0.31 , 0.311, 0]]\n\n\"\"\"\nimport copy\n\ndef all_pairs_shortest_path(adjacency_matrix):\n    \"\"\"\n    Given a matrix of the edge weights between respective nodes, returns a\n    matrix containing the shortest distance distance between the two nodes.\n    \"\"\"\n\n    new_array = copy.deepcopy(adjacency_matrix)\n\n    size = len(new_array)\n    for k in range(size):\n        for i in range(size):\n            for j in range(size):\n                if new_array[i][j] > new_array[i][k] + new_array[k][j]:\n                    new_array[i][j] = new_array[i][k] + new_array[k][j]\n\n    return new_array\n"
  },
  {
    "id": 227,
    "category": "graph",
    "file_name": "prims_minimum_spanning",
    "codes": "'''\nThis Prim's Algorithm Code is for finding weight of minimum spanning tree\nof a connected graph.\nFor argument graph, it should be a dictionary type such as:\n\n    graph = {\n        'a': [ [3, 'b'], [8,'c'] ],\n        'b': [ [3, 'a'], [5, 'd'] ],\n        'c': [ [8, 'a'], [2, 'd'], [4, 'e'] ],\n        'd': [ [5, 'b'], [2, 'c'], [6, 'e'] ],\n        'e': [ [4, 'c'], [6, 'd'] ]\n    }\n\nwhere 'a','b','c','d','e' are nodes (these can be 1,2,3,4,5 as well)\n'''\n\n\nimport heapq  # for priority queue\n\ndef prims_minimum_spanning(graph_used):\n    \"\"\"\n    Prim's algorithm to find weight of minimum spanning tree\n    \"\"\"\n    vis=[]\n    heap=[[0,1]]\n    prim = set()\n    mincost=0\n\n    while len(heap) > 0:\n        cost, node = heapq.heappop(heap)\n        if node in vis:\n            continue\n\n        mincost += cost\n        prim.add(node)\n        vis.append(node)\n\n        for distance, adjacent in graph_used[node]:\n            if adjacent not in vis:\n                heapq.heappush(heap, [distance, adjacent])\n\n    return mincost\n"
  },
  {
    "id": 228,
    "category": "graph",
    "file_name": "transitive_closure_dfs",
    "codes": "\"\"\"\nFinds the transitive closure of a graph.\n\nreference: https://en.wikipedia.org/wiki/Transitive_closure#In_graph_theory\n\"\"\"\n\nclass Graph:\n    \"\"\"\n    This class represents a directed graph using adjacency lists\n    \"\"\"\n    def __init__(self, vertices):\n        # No. of vertices\n        self.vertex_count = vertices\n\n        # default dictionary to store graph\n        self.graph = {}\n\n        # To store transitive closure\n        self.closure = [[0 for j in range(vertices)] for i in range(vertices)]\n\n    def add_edge(self, source, target):\n        \"\"\"\n        Adds a directed edge to the graph\n        \"\"\"\n        if source in self.graph:\n            self.graph[source].append(target)\n        else:\n            self.graph[source] = [target]\n\n    def dfs_util(self, source, target):\n        \"\"\"\n        A recursive DFS traversal function that finds\n        all reachable vertices for source\n        \"\"\"\n\n        # Mark reachability from source to target as true.\n        self.closure[source][target] = 1\n\n        # Find all the vertices reachable through target\n        for adjacent in self.graph[target]:\n            if self.closure[source][adjacent] == 0:\n                self.dfs_util(source, adjacent)\n\n    def transitive_closure(self):\n        \"\"\"\n        The function to find transitive closure. It uses\n        recursive dfs_util()\n        \"\"\"\n\n        # Call the recursive helper function to print DFS\n        # traversal starting from all vertices one by one\n        for i in range(self.vertex_count):\n            self.dfs_util(i, i)\n\n        return self.closure\n"
  },
  {
    "id": 229,
    "category": "graph",
    "file_name": "maximum_flow_bfs",
    "codes": "\"\"\"\nGiven a n*n adjacency array.\nit will give you a maximum flow.\nThis version use BFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23\n\n\"\"\"\nimport copy\nimport queue\nimport math\n\ndef maximum_flow_bfs(adjacency_matrix):\n    \"\"\"\n    Get the maximum flow through a graph using a breadth first search\n    \"\"\"\n    #initial setting\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n\n    while True:\n        #setting min to max_value\n        min_flow = math.inf\n        #save visited nodes\n        visited = [0]*len(new_array)\n        #save parent nodes\n        path = [0]*len(new_array)\n\n        #initialize queue for BFS\n        bfs = queue.Queue()\n\n        #initial setting\n        visited[0] = 1\n        bfs.put(0)\n\n        #BFS to find path\n        while bfs.qsize() > 0:\n            #pop from queue\n            src = bfs.get()\n            for k in range(len(new_array)):\n                #checking capacity and visit\n                if(new_array[src][k] > 0 and visited[k] == 0 ):\n                    #if not, put into queue and chage to visit and save path\n                    visited[k] = 1\n                    bfs.put(k)\n                    path[k] = src\n\n        #if there is no path from src to sink\n        if visited[len(new_array) - 1] == 0:\n            break\n\n        #initial setting\n        tmp = len(new_array) - 1\n\n        #Get minimum flow\n        while tmp != 0:\n            #find minimum flow\n            if min_flow > new_array[path[tmp]][tmp]:\n                min_flow = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n\n        #initial setting\n        tmp = len(new_array) - 1\n\n        #reduce capacity\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min_flow\n            tmp = path[tmp]\n\n        total = total + min_flow\n\n    return total\n"
  },
  {
    "id": 230,
    "category": "graph",
    "file_name": "minimum_spanning_tree",
    "codes": "\"\"\"\nMinimum spanning tree (MST) is going to use an undirected graph\n\"\"\"\n\nimport sys\n\n# pylint: disable=too-few-public-methods\nclass Edge:\n    \"\"\"\n    An edge of an undirected graph\n    \"\"\"\n\n    def __init__(self, source, target, weight):\n        self.source = source\n        self.target = target\n        self.weight = weight\n\n\nclass DisjointSet:\n    \"\"\"\n    The disjoint set is represented with an list <n> of integers where\n    <n[i]> is the parent of the node at position <i>.\n    If <n[i]> = <i>, <i> it's a root, or a head, of a set\n    \"\"\"\n\n    def __init__(self, size):\n        \"\"\"\n        Args:\n            n (int): Number of vertices in the graph\n        \"\"\"\n\n        self.parent = [None] * size # Contains wich node is the parent of the node at poisition <i>\n        self.size = [1] * size # Contains size of node at index <i>, used to optimize merge\n        for i in range(size):\n            self.parent[i] = i # Make all nodes his own parent, creating n sets.\n\n    def merge_set(self, node1, node2):\n        \"\"\"\n        Args:\n            node1, node2 (int): Indexes of nodes whose sets will be merged.\n        \"\"\"\n\n        # Get the set of nodes at position <a> and <b>\n        # If <a> and <b> are the roots, this will be constant O(1)\n        node1 = self.find_set(node1)\n        node2 = self.find_set(node2)\n\n        # Join the shortest node to the longest, minimizing tree size (faster find)\n        if self.size[node1] < self.size[node2]:\n            self.parent[node1] = node2 # Merge set(a) and set(b)\n            self.size[node2] += self.size[node1] # Add size of old set(a) to set(b)\n        else:\n            self.parent[node2] = node1 # Merge set(b) and set(a)\n            self.size[node1] += self.size[node2] # Add size of old set(b) to set(a)\n\n    def find_set(self, node):\n        \"\"\"\n        Get the root element of the set containing <a>\n        \"\"\"\n        if self.parent[node] != node:\n            # Very important, memoize result of the\n            # recursion in the list to optimize next\n            # calls and make this operation practically constant, O(1)\n            self.parent[node] = self.find_set(self.parent[node])\n\n        # node <a> it's the set root, so we can return that index\n        return self.parent[node]\n\n\ndef kruskal(vertex_count, edges, forest):\n    \"\"\"\n    Args:\n        vertex_count (int): Number of vertices in the graph\n        edges (list of Edge): Edges of the graph\n        forest (DisjointSet): DisjointSet of the vertices\n    Returns:\n        int: sum of weights of the minnimum spanning tree\n\n    Kruskal algorithm:\n        This algorithm will find the optimal graph with less edges and less\n        total weight to connect all vertices (MST), the MST will always contain\n        n-1 edges because it's the minimum required to connect n vertices.\n\n    Procedure:\n        Sort the edges (criteria: less weight).\n        Only take edges of nodes in different sets.\n        If we take a edge, we need to merge the sets to discard these.\n        After repeat this until select n-1 edges, we will have the complete MST.\n    \"\"\"\n    edges.sort(key=lambda edge: edge.weight)\n\n    mst = [] # List of edges taken, minimum spanning tree\n\n    for edge in edges:\n        set_u = forest.find_set(edge.u) # Set of the node <u>\n        set_v = forest.find_set(edge.v) # Set of the node <v>\n        if set_u != set_v:\n            forest.merge_set(set_u, set_v)\n            mst.append(edge)\n            if len(mst) == vertex_count-1:\n                # If we have selected n-1 edges, all the other\n                # edges will be discarted, so, we can stop here\n                break\n\n    return sum([edge.weight for edge in mst])\n\n\ndef main():\n    \"\"\"\n    Test. How input works:\n    Input consists of different weighted, connected, undirected graphs.\n    line 1:\n      integers n, m\n    lines 2..m+2:\n      edge with the format -> node index u, node index v, integer weight\n\n    Samples of input:\n\n    5 6\n    1 2 3\n    1 3 8\n    2 4 5\n    3 4 2\n    3 5 4\n    4 5 6\n\n    3 3\n    2 1 20\n    3 1 20\n    2 3 100\n\n    Sum of weights of the optimal paths:\n    14, 40\n    \"\"\"\n    for size in sys.stdin:\n        vertex_count, edge_count = map(int, size.split())\n        forest = DisjointSet(edge_count)\n        edges = [None] * edge_count # Create list of size <m>\n\n        # Read <m> edges from input\n        for i in range(edge_count):\n            source, target, weight = map(int, input().split())\n            source -= 1 # Convert from 1-indexed to 0-indexed\n            target -= 1 # Convert from 1-indexed to 0-indexed\n            edges[i] = Edge(source, target, weight)\n\n        # After finish input and graph creation, use Kruskal algorithm for MST:\n        print(\"MST weights sum:\", kruskal(vertex_count, edges, forest))\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "id": 231,
    "category": "graph",
    "file_name": "strongly_connected_components_kosaraju",
    "codes": "\"\"\"\nImplementing strongly connected components in a graph using Kosaraju's algorithm.\nhttps://en.wikipedia.org/wiki/Kosaraju%27s_algorithm\n\"\"\"\n\n\nclass Kosaraju:\n    \"\"\"\n    Kosaraju's algorithm use depth first search approach to find strongly connected components in a directed graph.\n    Approach:\n        1. Make a DFS call to keep track of finish time of each vertex.\n        2. Tranpose the original graph. ie 1->2 transpose is 1<-2\n        3. Make another DFS call to calculate strongly connected components.\n    \"\"\"\n\n    def dfs(self, i, V, adj, visited, stk):\n        visited[i] = 1\n\n        for x in adj[i]:\n            if visited[x] == -1:\n                self.dfs(x, V, adj, visited, stk)\n\n        stk.append(i)\n\n    def kosaraju(self, V, adj):\n\n        stk, visited = [], [-1]*(V+1)\n\n        for i in range(V):\n            if visited[i] == -1:\n                self.dfs(i, V, adj, visited, stk)\n\n        stk.reverse()\n        res = stk.copy()\n\n        ans, visited1 = 0, [-1]*(V+1)\n\n        adj1 = [[] for x in range(V)]\n\n        for i in range(len(adj)):\n            for x in adj[i]:\n                adj1[x].append(i)\n\n        for i in range(len(res)):\n            if visited1[res[i]] == -1:\n                ans += 1\n                self.dfs(res[i], V, adj1, visited1, stk)\n\n        return ans\n\n\ndef main():\n    \"\"\"\n    Let's look at the sample input.\n\n    6 7  #no of vertex, no of edges\n    0 2  #directed edge 0->2\n    1 0\n    2 3\n    3 1\n    3 4\n    4 5\n    5 4\n\n    calculating no of strongly connected compnenets in a directed graph.\n    answer should be: 2\n    1st strong component: 0->2->3->1->0\n    2nd strongly connected component: 4->5->4\n    \"\"\"\n    V, E = map(int, input().split())\n    adj = [[] for x in range(V)]\n\n    for i in range(E):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n\n    print(Kosaraju().kosaraju(V, adj))\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "id": 232,
    "category": "graph",
    "file_name": "markov_chain",
    "codes": "\"\"\"\nImplements a markov chain. Chains are described using a dictionary:\n\n    my_chain = {\n        'A': {'A': 0.6,\n              'E': 0.4},\n        'E': {'A': 0.7,\n              'E': 0.3}\n    }\n\"\"\"\n\nimport random\n\ndef __choose_state(state_map):\n    \"\"\"\n    Choose the next state randomly\n    \"\"\"\n    choice = random.random()\n    probability_reached = 0\n    for state, probability in state_map.items():\n        probability_reached += probability\n        if probability_reached > choice:\n            return state\n    return None\n\ndef next_state(chain, current_state):\n    \"\"\"\n    Given a markov-chain, randomly chooses the next state given the current state.\n    \"\"\"\n    next_state_map = chain.get(current_state)\n    return __choose_state(next_state_map)\n\ndef iterating_markov_chain(chain, state):\n    \"\"\"\n    Yield a sequence of states given a markov chain and the initial state\n    \"\"\"\n    while True:\n        state = next_state(chain, state)\n        yield state\n"
  },
  {
    "id": 233,
    "category": "graph",
    "file_name": "check_bipartite",
    "codes": "\"\"\"\nBipartite graph is a graph whose vertices can be divided into two disjoint and independent sets.\n(https://en.wikipedia.org/wiki/Bipartite_graph)\n\"\"\"\n\ndef check_bipartite(adj_list):\n    \"\"\"\n    Determine if the given graph is bipartite.\n\n    Time complexity is O(|E|)\n    Space complexity is O(|V|)\n    \"\"\"\n\n    vertices = len(adj_list)\n\n    # Divide vertexes in the graph into set_type 0 and 1\n    # Initialize all set_types as -1\n    set_type = [-1 for v in range(vertices)]\n    set_type[0] = 0\n\n    queue = [0]\n\n    while queue:\n        current = queue.pop(0)\n\n        # If there is a self-loop, it cannot be bipartite\n        if adj_list[current][current]:\n            return False\n\n        for adjacent in range(vertices):\n            if adj_list[current][adjacent]:\n                if set_type[adjacent] == set_type[current]:\n                    return False\n\n                if set_type[adjacent] == -1:\n                    # set type of u opposite of v\n                    set_type[adjacent] = 1 - set_type[current]\n                    queue.append(adjacent)\n\n    return True\n"
  },
  {
    "id": 234,
    "category": "graph",
    "file_name": "tarjan",
    "codes": "\"\"\"\nImplements Tarjan's algorithm for finding strongly connected components\nin a graph.\nhttps://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\"\"\"\nfrom algorithms.graph.graph import DirectedGraph\n\n\n# pylint: disable=too-few-public-methods\nclass Tarjan:\n    \"\"\"\n    A directed graph used for finding strongly connected components\n    \"\"\"\n    def __init__(self, dict_graph):\n        self.graph = DirectedGraph(dict_graph)\n        self.index = 0\n        self.stack = []\n\n        # Runs Tarjan\n        # Set all node index to None\n        for vertex in self.graph.nodes:\n            vertex.index = None\n\n        self.sccs = []\n        for vertex in self.graph.nodes:\n            if vertex.index is None:\n                self.strongconnect(vertex, self.sccs)\n\n    def strongconnect(self, vertex, sccs):\n        \"\"\"\n        Given a vertex, adds all successors of the given vertex to the same connected component\n        \"\"\"\n        # Set the depth index for v to the smallest unused index\n        vertex.index = self.index\n        vertex.lowlink = self.index\n        self.index += 1\n        self.stack.append(vertex)\n        vertex.on_stack = True\n\n        # Consider successors of v\n        for adjacent in self.graph.adjacency_list[vertex]:\n            if adjacent.index is None:\n                # Successor w has not yet been visited; recurse on it\n                self.strongconnect(adjacent, sccs)\n                vertex.lowlink = min(vertex.lowlink, adjacent.lowlink)\n            elif adjacent.on_stack:\n                # Successor w is in stack S and hence in the current SCC\n                # If w is not on stack, then (v, w) is a cross-edge in the DFS\n                # tree and must be ignored\n                # Note: The next line may look odd - but is correct.\n                # It says w.index not w.lowlink; that is deliberate and from the original paper\n                vertex.lowlink = min(vertex.lowlink, adjacent.index)\n\n        # If v is a root node, pop the stack and generate an SCC\n        if vertex.lowlink == vertex.index:\n            # start a new strongly connected component\n            scc = []\n            while True:\n                adjacent = self.stack.pop()\n                adjacent.on_stack = False\n                scc.append(adjacent)\n                if adjacent == vertex:\n                    break\n            scc.sort()\n            sccs.append(scc)\n"
  },
  {
    "id": 235,
    "category": "graph",
    "file_name": "path_between_two_vertices_in_digraph",
    "codes": "\"\"\"\nDetermine if there is a path between nodes in a graph\n\"\"\"\n\nfrom collections import defaultdict\n\n\nclass Graph:\n    \"\"\"\n    A directed graph\n    \"\"\"\n\n    def __init__(self,vertex_count):\n        self.vertex_count = vertex_count\n        self.graph = defaultdict(list)\n        self.has_path = False\n\n    def add_edge(self,source,target):\n        \"\"\"\n        Add a new directed edge to the graph\n        \"\"\"\n        self.graph[source].append(target)\n\n    def dfs(self,source,target):\n        \"\"\"\n        Determine if there is a path from source to target using a depth first search\n        \"\"\"\n        visited = [False] * self.vertex_count\n        self.dfsutil(visited,source,target,)\n\n    def dfsutil(self,visited,source,target):\n        \"\"\"\n        Determine if there is a path from source to target using a depth first search.\n        :param: visited should be an array of booleans determining if the\n        corresponding vertex has been visited already\n        \"\"\"\n        visited[source] = True\n        for i in self.graph[source]:\n            if target in self.graph[source]:\n                self.has_path = True\n                return\n            if not visited[i]:\n                self.dfsutil(visited,source,i)\n\n    def is_reachable(self,source,target):\n        \"\"\"\n        Determine if there is a path from source to target\n        \"\"\"\n        self.has_path = False\n        self.dfs(source,target)\n        return self.has_path\n"
  },
  {
    "id": 236,
    "category": "graph",
    "file_name": "find_all_cliques",
    "codes": "\"\"\"\nFinds all cliques in an undirected graph. A clique is a set of vertices in the\ngraph such that the subgraph is fully connected (ie. for any pair of nodes in\nthe subgraph there is an edge between them).\n\"\"\"\n\ndef find_all_cliques(edges):\n    \"\"\"\n    takes dict of sets\n    each key is a vertex\n    value is set of all edges connected to vertex\n    returns list of lists (each sub list is a maximal clique)\n    implementation of the basic algorithm described in:\n    Bron, Coen; Kerbosch, Joep (1973), \"Algorithm 457: finding all cliques of an undirected graph\",\n    \"\"\"\n\n    def expand_clique(candidates, nays):\n        nonlocal compsub\n        if not candidates and not nays:\n            nonlocal solutions\n            solutions.append(compsub.copy())\n        else:\n            for selected in candidates.copy():\n                candidates.remove(selected)\n                candidates_temp = get_connected(selected, candidates)\n                nays_temp = get_connected(selected, nays)\n                compsub.append(selected)\n                expand_clique(candidates_temp, nays_temp)\n                nays.add(compsub.pop())\n\n    def get_connected(vertex, old_set):\n        new_set = set()\n        for neighbor in edges[str(vertex)]:\n            if neighbor in old_set:\n                new_set.add(neighbor)\n        return new_set\n\n    compsub = []\n    solutions = []\n    possibles = set(edges.keys())\n    expand_clique(possibles, set())\n    return solutions\n"
  },
  {
    "id": 237,
    "category": "graph",
    "file_name": "cycle_detection",
    "codes": "\"\"\"\nGiven a directed graph, check whether it contains a cycle.\n\nReal-life scenario: deadlock detection in a system. Processes may be\nrepresented by vertices, then and an edge A -> B could mean that process A is\nwaiting for B to release its lock on a resource.\n\"\"\"\nfrom enum import Enum\n\n\nclass TraversalState(Enum):\n    \"\"\"\n    For a given node:\n        - WHITE: has not been visited yet\n        - GRAY: is currently being investigated for a cycle\n        - BLACK: is not part of a cycle\n    \"\"\"\n    WHITE = 0\n    GRAY = 1\n    BLACK = 2\n\ndef is_in_cycle(graph, traversal_states, vertex):\n    \"\"\"\n    Determines if the given vertex is in a cycle.\n\n    :param: traversal_states: for each vertex, the state it is in\n    \"\"\"\n    if traversal_states[vertex] == TraversalState.GRAY:\n        return True\n    traversal_states[vertex] = TraversalState.GRAY\n    for neighbor in graph[vertex]:\n        if is_in_cycle(graph, traversal_states, neighbor):\n            return True\n    traversal_states[vertex] = TraversalState.BLACK\n    return False\n\n\ndef contains_cycle(graph):\n    \"\"\"\n    Determines if there is a cycle in the given graph.\n    The graph should be given as a dictionary:\n\n        graph = {'A': ['B', 'C'],\n                 'B': ['D'],\n                 'C': ['F'],\n                 'D': ['E', 'F'],\n                 'E': ['B'],\n                 'F': []}\n    \"\"\"\n    traversal_states = {vertex: TraversalState.WHITE for vertex in graph}\n    for vertex, state in traversal_states.items():\n        if (state == TraversalState.WHITE and\n           is_in_cycle(graph, traversal_states, vertex)):\n            return True\n    return False\n"
  },
  {
    "id": 238,
    "category": "graph",
    "file_name": "dijkstra",
    "codes": "\"\"\"\nDijkstra's single-source shortest-path algorithm\n\"\"\"\n\nclass Dijkstra():\n    \"\"\"\n    A fully connected directed graph with edge weights\n    \"\"\"\n\n    def __init__(self, vertex_count):\n        self.vertex_count = vertex_count\n        self.graph = [[0 for _ in range(vertex_count)] for _ in range(vertex_count)]\n\n    def min_distance(self, dist, min_dist_set):\n        \"\"\"\n        Find the vertex that is closest to the visited set\n        \"\"\"\n        min_dist = float(\"inf\")\n        for target in range(self.vertex_count):\n            if min_dist_set[target]:\n                continue\n            if dist[target] < min_dist:\n                min_dist = dist[target]\n                min_index = target\n        return min_index\n\n    def dijkstra(self, src):\n        \"\"\"\n        Given a node, returns the shortest distance to every other node\n        \"\"\"\n        dist = [float(\"inf\")] * self.vertex_count\n        dist[src] = 0\n        min_dist_set = [False] * self.vertex_count\n\n        for _ in range(self.vertex_count):\n            #minimum distance vertex that is not processed\n            source = self.min_distance(dist, min_dist_set)\n\n            #put minimum distance vertex in shortest tree\n            min_dist_set[source] = True\n\n            #Update dist value of the adjacent vertices\n            for target in range(self.vertex_count):\n                if self.graph[source][target] <= 0 or min_dist_set[target]:\n                    continue\n                if dist[target] > dist[source] + self.graph[source][target]:\n                    dist[target] = dist[source] + self.graph[source][target]\n\n        return dist\n"
  },
  {
    "id": 239,
    "category": "graph",
    "file_name": "clone_graph",
    "codes": "r\"\"\"\nClone an undirected graph. Each node in the graph contains a label and a list\nof its neighbors.\n\n\nOJ's undirected graph serialization:\nNodes are labeled uniquely.\n\nWe use # as a separator for each node, and , as a separator for node label and\neach neighbor of the node.\nAs an example, consider the serialized graph {0,1,2#1,2#2,2}.\n\nThe graph has a total of three nodes, and therefore contains three parts as\nseparated by #.\n\nFirst node is labeled as 0. Connect node 0 to both nodes 1 and 2.\nSecond node is labeled as 1. Connect node 1 to node 2.\nThird node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a\nself-cycle.\nVisually, the graph looks like the following:\n\n       1\n      / \\\n     /   \\\n    0 --- 2\n         / \\\n         \\_/\n\"\"\"\nimport collections\n\n\nclass UndirectedGraphNode:\n    \"\"\"\n    A node in an undirected graph. Contains a label and a list of neighbouring\n    nodes (initially empty).\n    \"\"\"\n\n    def __init__(self, label):\n        self.label = label\n        self.neighbors = []\n\n    def shallow_copy(self):\n        \"\"\"\n        Return a shallow copy of this node (ignoring any neighbors)\n        \"\"\"\n        return UndirectedGraphNode(self.label)\n\n    def add_neighbor(self, node):\n        \"\"\"\n        Adds a new neighbor\n        \"\"\"\n        self.neighbors.append(node)\n\n\ndef clone_graph1(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using a breadth first search (BFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    queue = collections.deque([node])\n    while queue:\n        node = queue.popleft()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:  # neighbor is not visited\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                queue.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy\n\n\ndef clone_graph2(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using an iterative depth first search (DFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                stack.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy\n\n\ndef clone_graph(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using a recursive depth first search (DFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    dfs(node, dic)\n    return node_copy\n\n\ndef dfs(node, dic):\n    \"\"\"\n    Clones a graph using a recursive depth first search. Stores the clones in\n    the dictionary, keyed by the original nodes.\n    \"\"\"\n    for neighbor in node.neighbors:\n        if neighbor not in dic:\n            neighbor_copy = neighbor.shallow_copy()\n            dic[neighbor] = neighbor_copy\n            dic[node].add_neighbor(neighbor_copy)\n            dfs(neighbor, dic)\n        else:\n            dic[node].add_neighbor(dic[neighbor])\n"
  },
  {
    "id": 240,
    "category": "graph",
    "file_name": "maximum_flow",
    "codes": "\"\"\"\nGiven the capacity, source and sink of a graph,\ncomputes the maximum flow from source to sink.\nInput : capacity, source, sink\nOutput : maximum flow from source to sink\nCapacity is a two-dimensional array that is v*v.\ncapacity[i][j] implies the capacity of the edge from i to j.\nIf there is no edge from i to j, capacity[i][j] should be zero.\n\"\"\"\n\nfrom queue import Queue\n\n# pylint: disable=too-many-arguments\ndef dfs(capacity, flow, visit, vertices, idx, sink, current_flow = 1 << 63):\n    \"\"\"\n    Depth First Search implementation for Ford-Fulkerson algorithm.\n    \"\"\"\n\n    # DFS function for ford_fulkerson algorithm.\n    if idx == sink:\n        return current_flow\n    visit[idx] = True\n    for nxt in range(vertices):\n        if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt]-flow[idx][nxt])\n            tmp = dfs(capacity, flow, visit, vertices, nxt, sink, available_flow)\n            if tmp:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n    return 0\n\ndef ford_fulkerson(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using DFS.\n    Time Complexity : O(Ef)\n    E is the number of edges and f is the maximum flow in the graph.\n    \"\"\"\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0]*vertices for _ in range(vertices)]\n    while True:\n        visit = [False for _ in range(vertices)]\n        tmp = dfs(capacity, flow, visit, vertices, source, sink)\n        if tmp:\n            ret += tmp\n        else:\n            break\n    return ret\n\ndef edmonds_karp(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using BFS.\n    Time complexity : O(V*E^2)\n    V is the number of vertices and E is the number of edges.\n    \"\"\"\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0]*vertices for _ in range(vertices)]\n    while True:\n        tmp = 0\n        queue = Queue()\n        visit = [False for _ in range(vertices)]\n        par = [-1 for _ in range(vertices)]\n        visit[source] = True\n        queue.put((source, 1 << 63))\n        # Finds new flow using BFS.\n        while queue.qsize():\n            front = queue.get()\n            idx, current_flow = front\n            if idx == sink:\n                tmp = current_flow\n                break\n            for nxt in range(vertices):\n                if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n                    visit[nxt] = True\n                    par[nxt] = idx\n                    queue.put((nxt, min(current_flow, capacity[idx][nxt]-flow[idx][nxt])))\n        if par[sink] == -1:\n            break\n        ret += tmp\n        parent = par[sink]\n        idx = sink\n        # Update flow array following parent starting from sink.\n        while parent != -1:\n            flow[parent][idx] += tmp\n            flow[idx][parent] -= tmp\n            idx = parent\n            parent = par[parent]\n    return ret\n\ndef dinic_bfs(capacity, flow, level, source, sink):\n    \"\"\"\n    BFS function for Dinic algorithm.\n    Check whether sink is reachable only using edges that is not full.\n    \"\"\"\n    vertices = len(capacity)\n    queue = Queue()\n    queue.put(source)\n    level[source] = 0\n    while queue.qsize():\n        front = queue.get()\n        for nxt in range(vertices):\n            if level[nxt] == -1 and flow[front][nxt] < capacity[front][nxt]:\n                level[nxt] = level[front] + 1\n                queue.put(nxt)\n    return level[sink] != -1\n\ndef dinic_dfs(capacity, flow, level, idx, sink, work, current_flow = 1 << 63):\n    \"\"\"\n    DFS function for Dinic algorithm.\n    Finds new flow using edges that is not full.\n    \"\"\"\n    if idx == sink:\n        return current_flow\n    vertices = len(capacity)\n    while work[idx] < vertices:\n        nxt = work[idx]\n        if level[nxt] == level[idx] + 1 and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])\n            tmp = dinic_dfs(capacity, flow, level, nxt, sink, work, available_flow)\n            if tmp > 0:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n        work[idx] += 1\n    return 0\n\ndef dinic(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using Dinic algorithm.\n    Time complexity : O(V^2*E)\n    V is the number of vertices and E is the number of edges.\n    \"\"\"\n    vertices = len(capacity)\n    flow = [[0]*vertices for i in range(vertices)]\n    ret = 0\n    while True:\n        level = [-1 for i in range(vertices)]\n        work = [0 for i in range(vertices)]\n        if not dinic_bfs(capacity, flow, level, source, sink):\n            break\n        while True:\n            tmp = dinic_dfs(capacity, flow, level, source, sink, work)\n            if tmp > 0:\n                ret += tmp\n            else:\n                break\n    return ret\n"
  },
  {
    "id": 241,
    "category": "graph",
    "file_name": "maximum_flow_dfs",
    "codes": "\"\"\"\nGiven a n*n adjacency array.\nit will give you a maximum flow.\nThis version use DFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23\n\n\"\"\"\nimport copy\nimport math\n\ndef maximum_flow_dfs(adjacency_matrix):\n    \"\"\"\n    Get the maximum flow through a graph using a depth first search\n    \"\"\"\n\n    #initial setting\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n\n    while True:\n        #setting min to max_value\n        min = math.inf\n        #save visited nodes\n        visited = [0]*len(new_array)\n        #save parent nodes\n        path = [0]*len(new_array)\n\n        #initialize stack for DFS\n        stack = []\n\n        #initial setting\n        visited[0] = 1\n        stack.append(0)\n\n        #DFS to find path\n        while len(stack) > 0:\n            #pop from queue\n            src = stack.pop()\n            for k in range(len(new_array)):\n                #checking capacity and visit\n                if new_array[src][k] > 0 and visited[k] == 0:\n                    #if not, put into queue and chage to visit and save path\n                    visited[k] = 1\n                    stack.append(k)\n                    path[k] = src\n\n        #if there is no path from src to sink\n        if visited[len(new_array) - 1] == 0:\n            break\n\n        #initial setting\n        tmp = len(new_array) - 1\n\n        #Get minimum flow\n        while tmp != 0:\n            #find minimum flow\n            if min > new_array[path[tmp]][tmp]:\n                min = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n\n        #initial setting\n        tmp = len(new_array) - 1\n\n        #reduce capacity\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min\n            tmp = path[tmp]\n\n        total = total + min\n\n    return total\n\n"
  },
  {
    "id": 242,
    "category": "graph",
    "file_name": "find_path",
    "codes": "\"\"\"\nFunctions for finding paths in graphs.\n\"\"\"\n\n# pylint: disable=dangerous-default-value\ndef find_path(graph, start, end, path=[]):\n    \"\"\"\n    Find a path between two nodes using recursion and backtracking.\n    \"\"\"\n    path = path + [start]\n    if start == end:\n        return path\n    if not start in graph:\n        return None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_path(graph, node, end, path)\n            return newpath\n    return None\n\n# pylint: disable=dangerous-default-value\ndef find_all_path(graph, start, end, path=[]):\n    \"\"\"\n    Find all paths between two nodes using recursion and backtracking\n    \"\"\"\n    path = path + [start]\n    if start == end:\n        return [path]\n    if not start in graph:\n        return []\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_path(graph, node, end, path)\n            for newpath in newpaths:\n                paths.append(newpath)\n    return paths\n\ndef find_shortest_path(graph, start, end, path=[]):\n    \"\"\"\n    find the shortest path between two nodes\n    \"\"\"\n    path = path + [start]\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    shortest = None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_shortest_path(graph, node, end, path)\n            if newpath:\n                if not shortest or len(newpath) < len(shortest):\n                    shortest = newpath\n    return shortest\n"
  },
  {
    "id": 243,
    "category": "linkedlist",
    "file_name": "first_cyclic_node",
    "codes": "\"\"\"\n    Given a linked list, find the first node of a cycle in it.\n    1 -> 2 -> 3 -> 4 -> 5 -> 1  => 1\n    A -> B -> C -> D -> E -> C  => C\n\n    Note: The solution is a direct implementation\n          Floyd's cycle-finding algorithm (Floyd's Tortoise and Hare).\n\"\"\"\nimport unittest\n\n\nclass Node:\n\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\ndef first_cyclic_node(head):\n    \"\"\"\n    :type head: Node\n    :rtype: Node\n    \"\"\"\n    runner = walker = head\n    while runner and runner.next:\n        runner = runner.next.next\n        walker = walker.next\n        if runner is walker:\n            break\n\n    if runner is None or runner.next is None:\n        return None\n\n    walker = head\n    while runner is not walker:\n        runner, walker = runner.next, walker.next\n    return runner\n\n\nclass TestSuite(unittest.TestCase):\n\n    def test_first_cyclic_node(self):\n\n        # create linked list => A -> B -> C -> D -> E -> C\n        head = Node('A')\n        head.next = Node('B')\n        curr = head.next\n\n        cyclic_node = Node('C')\n        curr.next = cyclic_node\n\n        curr = curr.next\n        curr.next = Node('D')\n        curr = curr.next\n        curr.next = Node('E')\n        curr = curr.next\n        curr.next = cyclic_node\n\n        self.assertEqual('C', first_cyclic_node(head).val)\n\n\nif __name__ == '__main__':\n\n    unittest.main()\n"
  },
  {
    "id": 244,
    "category": "linkedlist",
    "file_name": "reverse",
    "codes": "\"\"\"\nReverse a singly linked list. For example:\n\n1 --> 2 --> 3 --> 4\nAfter reverse:\n4 --> 3 --> 2 --> 1\n\"\"\"\n#\n# Iterative solution\n# T(n)- O(n)\n#\ndef reverse_list(head):\n    \"\"\"\n    :type head: ListNode\n    :rtype: ListNode\n    \"\"\"\n    if not head or not head.next:\n        return head\n    prev = None\n    while head:\n        current = head\n        head = head.next\n        current.next = prev\n        prev = current\n    return prev\n\n\n#\n# Recursive solution\n# T(n)- O(n)\n#\ndef reverse_list_recursive(head):\n    \"\"\"\n    :type head: ListNode\n    :rtype: ListNode\n    \"\"\"\n    if head is None or head.next is None:\n        return head\n    p = head.next\n    head.next = None\n    revrest = reverse_list_recursive(p)\n    p.next = head\n    return revrest\n"
  },
  {
    "id": 245,
    "category": "linkedlist",
    "file_name": "intersection",
    "codes": "\"\"\"\n   This function takes two lists and returns the node they have in common, if any.\n   In this example:\n   1 -> 3 -> 5\n               \\\n                7 -> 9 -> 11\n               /\n   2 -> 4 -> 6\n   ...we would return 7.\n   Note that the node itself is the unique identifier, not the value of the node.\n   \"\"\"\nimport unittest\n\n\nclass Node(object):\n    def __init__(self, val=None):\n        self.val = val\n        self.next = None\n\n\ndef intersection(h1, h2):\n\n    count = 0\n    flag = None\n    h1_orig = h1\n    h2_orig = h2\n\n    while h1 or h2:\n        count += 1\n\n        if not flag and (h1.next is None or h2.next is None):\n            # We hit the end of one of the lists, set a flag for this\n            flag = (count, h1.next, h2.next)\n\n        if h1:\n            h1 = h1.next\n        if h2:\n            h2 = h2.next\n\n    long_len = count    # Mark the length of the longer of the two lists\n    short_len = flag[0]\n\n    if flag[1] is None:\n        shorter = h1_orig\n        longer = h2_orig\n    elif flag[2] is None:\n        shorter = h2_orig\n        longer = h1_orig\n\n    while longer and shorter:\n\n        while long_len > short_len:\n            # force the longer of the two lists to \"catch up\"\n            longer = longer.next\n            long_len -= 1\n\n        if longer == shorter:\n            # The nodes match, return the node\n            return longer\n        else:\n            longer = longer.next\n            shorter = shorter.next\n\n    return None\n\n\nclass TestSuite(unittest.TestCase):\n\n    def test_intersection(self):\n\n        # create linked list as:\n        # 1 -> 3 -> 5\n        #            \\\n        #             7 -> 9 -> 11\n        #            /\n        # 2 -> 4 -> 6\n        a1 = Node(1)\n        b1 = Node(3)\n        c1 = Node(5)\n        d = Node(7)\n        a2 = Node(2)\n        b2 = Node(4)\n        c2 = Node(6)\n        e = Node(9)\n        f = Node(11)\n\n        a1.next = b1\n        b1.next = c1\n        c1.next = d\n        a2.next = b2\n        b2.next = c2\n        c2.next = d\n        d.next = e\n        e.next = f\n\n        self.assertEqual(7, intersection(a1, a2).val)\n\n\nif __name__ == '__main__':\n\n    unittest.main()\n"
  },
  {
    "id": 246,
    "category": "linkedlist",
    "file_name": "is_palindrome",
    "codes": "def is_palindrome(head):\n    if not head:\n        return True\n    # split the list to two parts\n    fast, slow = head.next, head\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    second = slow.next\n    slow.next = None  # Don't forget here! But forget still works!\n    # reverse the second part\n    node = None\n    while second:\n        nxt = second.next\n        second.next = node\n        node = second\n        second = nxt\n    # compare two parts\n    # second part has the same or one less node\n    while node:\n        if node.val != head.val:\n            return False\n        node = node.next\n        head = head.next\n    return True\n\n\ndef is_palindrome_stack(head):\n    if not head or not head.next:\n        return True\n\n    # 1. Get the midpoint (slow)\n    slow = fast = cur = head\n    while fast and fast.next:\n        fast, slow = fast.next.next, slow.next\n\n    # 2. Push the second half into the stack\n    stack = [slow.val]\n    while slow.next:\n        slow = slow.next\n        stack.append(slow.val)\n\n    # 3. Comparison\n    while stack:\n        if stack.pop() != cur.val:\n            return False\n        cur = cur.next\n\n    return True\n\n\ndef is_palindrome_dict(head):\n    \"\"\"\n    This function builds up a dictionary where the keys are the values of the list,\n    and the values are the positions at which these values occur in the list.\n    We then iterate over the dict and if there is more than one key with an odd\n    number of occurrences, bail out and return False.\n    Otherwise, we want to ensure that the positions of occurrence sum to the\n    value of the length of the list - 1, working from the outside of the list inward.\n    For example:\n    Input: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1\n    d = {1: [0,1,5,6], 2: [2,4], 3: [3]}\n    '3' is the middle outlier, 2+4=6, 0+6=6 and 5+1=6 so we have a palindrome.\n    \"\"\"\n    if not head or not head.next:\n        return True\n    d = {}\n    pos = 0\n    while head:\n        if head.val in d.keys():\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            step = 0\n            for i in range(0, len(v)):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n                step += 1\n        if middle > 1:\n            return False\n    return True\n"
  },
  {
    "id": 247,
    "category": "linkedlist",
    "file_name": "is_sorted",
    "codes": "\"\"\"\nGiven a linked list, is_sort function returns true if the list is in sorted\n(increasing) order and return false otherwise. An empty list is considered\nto be sorted.\n\nFor example:\nNull :List is sorted\n1 2 3 4 :List is sorted\n1 2 -1 3 :List is not sorted\n\"\"\"\ndef is_sorted(head):\n    if not head:\n        return True\n    current = head\n    while current.next:\n        if current.val > current.next.val:\n            return False\n        current = current.next\n    return True\n"
  },
  {
    "id": 248,
    "category": "linkedlist",
    "file_name": "add_two_numbers",
    "codes": "\"\"\"\nYou are given two non-empty linked lists representing\ntwo non-negative integers. The digits are stored in reverse order\nand each of their nodes contain a single digit.\nAdd the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero,\nexcept the number 0 itself.\n\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\n\"\"\"\n\nimport unittest\n\n\nclass Node:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\ndef add_two_numbers(left: Node, right: Node) -> Node:\n    head = Node(0)\n    current = head\n    sum = 0\n    while left or right:\n        print(\"adding: \", left.val, right.val)\n        sum //= 10\n        if left:\n            sum += left.val\n            left = left.next\n        if right:\n            sum += right.val\n            right = right.next\n        current.next = Node(sum % 10)\n        current = current.next\n    if sum // 10 == 1:\n        current.next = Node(1)\n    return head.next\n\n\ndef convert_to_list(number: int) -> Node:\n    \"\"\"\n        converts a positive integer into a (reversed) linked list.\n        for example: give 112\n        result 2 -> 1 -> 1\n    \"\"\"\n    if number >= 0:\n        head = Node(0)\n        current = head\n        remainder = number % 10\n        quotient = number // 10\n\n        while quotient != 0:\n            current.next = Node(remainder)\n            current = current.next\n            remainder = quotient % 10\n            quotient //= 10\n        current.next = Node(remainder)\n        return head.next\n    else:\n        print(\"number must be positive!\")\n\n\ndef convert_to_str(l: Node) -> str:\n    \"\"\"\n        converts the non-negative number list into a string.\n    \"\"\"\n    result = \"\"\n    while l:\n        result += str(l.val)\n        l = l.next\n    return result\n\n\nclass TestSuite(unittest.TestCase):\n    \"\"\"\n        testsuite for the linked list structure and\n        the adding function, above.\n    \"\"\"\n\n    def test_convert_to_str(self):\n        number1 = Node(2)\n        number1.next = Node(4)\n        number1.next.next = Node(3)\n        self.assertEqual(\"243\", convert_to_str(number1))\n\n    def test_add_two_numbers(self):\n        # 1. test case\n        number1 = Node(2)\n        number1.next = Node(4)\n        number1.next.next = Node(3)\n        number2 = Node(5)\n        number2.next = Node(6)\n        number2.next.next = Node(4)\n        result = convert_to_str(add_two_numbers(number1, number2))\n        self.assertEqual(\"708\", result)\n\n        # 2. test case\n        number3 = Node(1)\n        number3.next = Node(1)\n        number3.next.next = Node(9)\n        number4 = Node(1)\n        number4.next = Node(0)\n        number4.next.next = Node(1)\n        result = convert_to_str(add_two_numbers(number3, number4))\n        self.assertEqual(\"2101\", result)\n\n        # 3. test case\n        number5 = Node(1)\n        number6 = Node(0)\n        result = convert_to_str(add_two_numbers(number5, number6))\n        self.assertEqual(\"1\", result)\n\n        # 4. test case\n        number7 = Node(9)\n        number7.next = Node(1)\n        number7.next.next = Node(1)\n        number8 = Node(1)\n        number8.next = Node(0)\n        number8.next.next = Node(1)\n        result = convert_to_str(add_two_numbers(number7, number8))\n        self.assertEqual(\"022\", result)\n\n    def test_convert_to_list(self):\n        result = convert_to_str(convert_to_list(112))\n        self.assertEqual(\"211\", result)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"
  },
  {
    "id": 249,
    "category": "linkedlist",
    "file_name": "kth_to_last",
    "codes": "class Node():\n    def __init__(self, val=None):\n        self.val = val\n        self.next = None\n\n\ndef kth_to_last_eval(head, k):\n    \"\"\"\n    This is a suboptimal, hacky method using eval(), which is not\n     safe for user input. We guard against danger by ensuring k in an int\n    \"\"\"\n    if not isinstance(k, int) or not head.val:\n        return False\n\n    nexts = '.'.join(['next' for n in range(1, k+1)])\n    seeker = str('.'.join(['head', nexts]))\n\n    while head:\n        if eval(seeker) is None:\n            return head\n        else:\n            head = head.next\n\n    return False\n\n\ndef kth_to_last_dict(head, k):\n    \"\"\"\n    This is a brute force method where we keep a dict the size of the list\n    Then we check it for the value we need. If the key is not in the dict,\n    our and statement will short circuit and return False\n    \"\"\"\n    if not (head and k > -1):\n        return False\n    d = dict()\n    count = 0\n    while head:\n        d[count] = head\n        head = head.next\n        count += 1\n    return len(d)-k in d and d[len(d)-k]\n\n\ndef kth_to_last(head, k):\n    \"\"\"\n    This is an optimal method using iteration.\n    We move p1 k steps ahead into the list.\n    Then we move p1 and p2 together until p1 hits the end.\n    \"\"\"\n    if not (head or k > -1):\n        return False\n    p1 = head\n    p2 = head\n    for i in range(1, k+1):\n        if p1 is None:\n            # Went too far, k is not valid\n            raise IndexError\n        p1 = p1.next\n    while p1:\n        p1 = p1.next\n        p2 = p2.next\n    return p2\n\n\ndef print_linked_list(head):\n    string = \"\"\n    while head.next:\n        string += head.val + \" -> \"\n        head = head.next\n    string += head.val\n    print(string)\n\n\ndef test():\n    # def make_test_li\n    # A A B C D C F G\n    a1 = Node(\"A\")\n    a2 = Node(\"A\")\n    b = Node(\"B\")\n    c1 = Node(\"C\")\n    d = Node(\"D\")\n    c2 = Node(\"C\")\n    f = Node(\"F\")\n    g = Node(\"G\")\n    a1.next = a2\n    a2.next = b\n    b.next = c1\n    c1.next = d\n    d.next = c2\n    c2.next = f\n    f.next = g\n    print_linked_list(a1)\n\n    # test kth_to_last_eval\n    kth = kth_to_last_eval(a1, 4)\n    try:\n        assert kth.val == \"D\"\n    except AssertionError as e:\n        e.args += (\"Expecting D, got %s\" % kth.val,)\n        raise\n\n    # test kth_to_last_dict\n    kth = kth_to_last_dict(a1, 4)\n    try:\n        assert kth.val == \"D\"\n    except AssertionError as e:\n        e.args += (\"Expecting D, got %s\" % kth.val,)\n        raise\n\n    # test kth_to_last\n    kth = kth_to_last(a1, 4)\n    try:\n        assert kth.val == \"D\"\n    except AssertionError as e:\n        e.args += (\"Expecting D, got %s\" % kth.val,)\n        raise\n    print(\"all passed.\")\n\nif __name__ == '__main__':\n    test()\n"
  },
  {
    "id": 250,
    "category": "linkedlist",
    "file_name": "rotate_list",
    "codes": "\"\"\"\nGiven a list, rotate the list to the right by k places,\nwhere k is non-negative.\n\nFor example:\nGiven 1->2->3->4->5->NULL and k = 2,\nreturn 4->5->1->2->3->NULL.\n\"\"\"\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\ndef rotate_right(head, k):\n    \"\"\"\n    :type head: ListNode\n    :type k: int\n    :rtype: ListNode\n    \"\"\"\n    if not head or not head.next:\n        return head\n    current = head\n    length = 1\n    # count length of the list\n    while current.next:\n        current = current.next\n        length += 1\n    # make it circular\n    current.next = head\n    k = k % length\n    # rotate until length-k\n    for i in range(length-k):\n        current = current.next\n    head = current.next\n    current.next = None\n    return head\n"
  },
  {
    "id": 251,
    "category": "linkedlist",
    "file_name": "merge_two_list",
    "codes": "\"\"\"\nMerge two sorted linked lists and return it as a new list. The new list should\nbe made by splicing together the nodes of the first two lists.\n\nFor example:\nInput: 1->2->4, 1->3->4\nOutput: 1->1->2->3->4->4\n\"\"\"\nclass Node:\n\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef merge_two_list(l1, l2):\n    ret = cur = Node(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            cur.next = l1\n            l1 = l1.next\n        else:\n            cur.next = l2\n            l2 = l2.next\n        cur = cur.next\n    cur.next = l1 or l2\n    return ret.next\n\n# recursively\ndef merge_two_list_recur(l1, l2):\n    if not l1 or not l2:\n        return l1 or l2\n    if l1.val < l2.val:\n        l1.next = merge_two_list_recur(l1.next, l2)\n        return l1\n    else:\n        l2.next = merge_two_list_recur(l1, l2.next)\n        return l2\n"
  },
  {
    "id": 252,
    "category": "linkedlist",
    "file_name": "partition",
    "codes": "\"\"\"\nWrite code to partition a linked list around a value x, such that all nodes less\nthan x come before all nodes greater than or equal to x.  If x is contained\nwithin the list, the values of x only need to be after the elements less than x.\nThe partition element x can appear anywhere in the \"right partition\";\nit does not need to appear between the left and right partitions.\n\n3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 [partition=5]\n3 -> 1 -> 2 -> 10 -> 5 -> 5 -> 8\n\nWe assume the values of all linked list nodes are int and that x in an int.\n\"\"\"\n\n\nclass Node():\n    def __init__(self, val=None):\n        self.val = int(val)\n        self.next = None\n\n\ndef print_linked_list(head):\n    string = \"\"\n    while head.next:\n        string += str(head.val) + \" -> \"\n        head = head.next\n    string += str(head.val)\n    print(string)\n\n\ndef partition(head, x):\n    left = None\n    right = None\n    prev = None\n    current = head\n    while current:\n        if int(current.val) >= x:\n            if not right:\n                right = current\n        else:\n            if not left:\n                left = current\n            else:\n                prev.next = current.next\n                left.next = current\n                left = current\n                left.next = right\n        if prev and prev.next is None:\n            break\n        # cache previous value in case it needs to be pointed elsewhere\n        prev = current\n        current = current.next\n\n\ndef test():\n    a = Node(\"3\")\n    b = Node(\"5\")\n    c = Node(\"8\")\n    d = Node(\"5\")\n    e = Node(\"10\")\n    f = Node(\"2\")\n    g = Node(\"1\")\n\n    a.next = b\n    b.next = c\n    c.next = d\n    d.next = e\n    e.next = f\n    f.next = g\n\n    print_linked_list(a)\n    partition(a, 5)\n    print_linked_list(a)\n\n\nif __name__ == '__main__':\n    test()\n"
  },
  {
    "id": 253,
    "category": "linkedlist",
    "file_name": "remove_range",
    "codes": "\"\"\"\nGiven a linked list, remove_range function accepts a starting and ending index\nas parameters and removes the elements at those indexes (inclusive) from the list\n\nFor example:\nList: [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92]\nremove_range(list, 3, 8);\nList becomes: [8, 13, 17, 23, 0, 92]\n\nlegal range of the list (0 < start index < end index < size of list).\n\"\"\"\ndef remove_range(head, start, end):\n    assert(start <= end)\n    # Case: remove node at head\n    if start == 0:\n        for i in range(0, end+1):\n            if head != None:\n                head = head.next\n    else:\n        current = head\n        # Move pointer to start position\n        for i in range(0,start-1):\n            current = current.next\n        # Remove data until the end\n        for i in range(0, end-start + 1):\n            if current != None and current.next != None:\n                current.next = current.next.next\n    return head\n"
  },
  {
    "id": 254,
    "category": "linkedlist",
    "file_name": "swap_in_pairs",
    "codes": "\"\"\"\nGiven a linked list, swap every two adjacent nodes\nand return its head.\n\nFor example,\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\n\nYour algorithm should use only constant space.\nYou may not modify the values in the list,\nonly nodes itself can be changed.\n\"\"\"\nclass Node(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef swap_pairs(head):\n    if not head:\n        return head\n    start = Node(0)\n    start.next = head\n    current = start\n    while current.next and current.next.next:\n        first = current.next\n        second = current.next.next\n        first.next = second.next\n        current.next = second\n        current.next.next = first\n        current = current.next.next\n    return start.next\n"
  },
  {
    "id": 255,
    "category": "linkedlist",
    "file_name": "delete_node",
    "codes": "\"\"\"\nWrite a function to delete a node (except the tail)\nin a singly linked list, given only access to that node.\n\nSupposed the linked list is 1 -> 2 -> 3 -> 4 and\nyou are given the third node with value 3,\nthe linked list should become 1 -> 2 -> 4 after calling your function.\n\"\"\"\nimport unittest\n\n\nclass Node:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\ndef delete_node(node):\n    if node is None or node.next is None:\n        raise ValueError\n    node.val = node.next.val\n    node.next = node.next.next\n\n\nclass TestSuite(unittest.TestCase):\n\n    def test_delete_node(self):\n\n        # make linkedlist 1 -> 2 -> 3 -> 4\n        head = Node(1)\n        curr = head\n        for i in range(2, 6):\n            curr.next = Node(i)\n            curr = curr.next\n\n        # node3 = 3\n        node3 = head.next.next\n\n        # after delete_node => 1 -> 2 -> 4\n        delete_node(node3)\n\n        curr = head\n        self.assertEqual(1, curr.val)\n\n        curr = curr.next\n        self.assertEqual(2, curr.val)\n\n        curr = curr.next\n        self.assertEqual(4, curr.val)\n\n        curr = curr.next\n        self.assertEqual(5, curr.val)\n\n        tail = curr\n        self.assertIsNone(tail.next)\n\n        self.assertRaises(ValueError, delete_node, tail)\n        self.assertRaises(ValueError, delete_node, tail.next)\n\n\nif __name__ == '__main__':\n\n    unittest.main()\n"
  },
  {
    "id": 256,
    "category": "linkedlist",
    "file_name": "remove_duplicates",
    "codes": "class Node():\n    def __init__(self, val = None):\n        self.val = val\n        self.next = None\n\ndef remove_dups(head):\n    \"\"\"\n    Time Complexity: O(N)\n    Space Complexity: O(N)\n    \"\"\"\n    hashset = set()\n    prev = Node()\n    while head:\n        if head.val in hashset:\n            prev.next = head.next\n        else:\n            hashset.add(head.val)\n            prev = head\n        head = head.next\n\ndef remove_dups_wothout_set(head):\n    \"\"\"\n    Time Complexity: O(N^2)\n    Space Complexity: O(1)\n    \"\"\"\n    current = head\n    while current:\n        runner = current\n        while runner.next:\n            if runner.next.val == current.val:\n                runner.next = runner.next.next\n            else:\n                runner = runner.next\n        current = current.next\n\ndef print_linked_list(head):\n    string = \"\"\n    while head.next:\n        string += head.val + \" -> \"\n        head = head.next\n    string += head.val\n    print(string)\n\n# A A B C D C F G\n\na1 = Node(\"A\")\na2 = Node(\"A\")\nb = Node(\"B\")\nc1 = Node(\"C\")\nd = Node(\"D\")\nc2 = Node(\"C\")\nf = Node(\"F\")\ng = Node(\"G\")\n\na1.next = a2\na2.next = b\nb.next = c1\nc1.next = d\nd.next = c2\nc2.next = f\nf.next = g\n\nremove_dups(a1)\nprint_linked_list(a1)\nremove_dups_wothout_set(a1)\nprint_linked_list(a1)\n"
  },
  {
    "id": 257,
    "category": "linkedlist",
    "file_name": "linkedlist",
    "codes": "# Pros\n# Linked Lists have constant-time insertions and deletions in any position,\n# in comparison, arrays require O(n) time to do the same thing.\n# Linked lists can continue to expand without having to specify\n# their size ahead of time (remember our lectures on Array sizing\n# from the Array Sequence section of the course!)\n\n# Cons\n# To access an element in a linked list, you need to take O(k) time\n# to go from the head of the list to the kth element.\n# In contrast, arrays have constant time operations to access\n# elements in an array.\n\nclass DoublyLinkedListNode(object):\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n        self.prev = None\n\n\nclass SinglyLinkedListNode(object):\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n"
  },
  {
    "id": 258,
    "category": "linkedlist",
    "file_name": "is_cyclic",
    "codes": "\"\"\"\nGiven a linked list, determine if it has a cycle in it.\n\nFollow up:\nCan you solve it without using extra space?\n\"\"\"\nclass Node:\n\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef is_cyclic(head):\n    \"\"\"\n    :type head: Node\n    :rtype: bool\n    \"\"\"\n    if not head:\n        return False\n    runner = head\n    walker = head\n    while runner.next and runner.next.next:\n        runner = runner.next.next\n        walker = walker.next\n        if runner == walker:\n            return True\n    return False\n"
  },
  {
    "id": 259,
    "category": "linkedlist",
    "file_name": "copy_random_pointer",
    "codes": "\"\"\"\nA linked list is given such that each node contains an additional random\npointer which could point to any node in the list or null.\n\nReturn a deep copy of the list.\n\"\"\"\nfrom collections import defaultdict\n\n\nclass RandomListNode(object):\n    def __init__(self, label):\n        self.label = label\n        self.next = None\n        self.random = None\n\n\ndef copy_random_pointer_v1(head):\n    \"\"\"\n    :type head: RandomListNode\n    :rtype: RandomListNode\n    \"\"\"\n    dic = dict()\n    m = n = head\n    while m:\n        dic[m] = RandomListNode(m.label)\n        m = m.next\n    while n:\n        dic[n].next = dic.get(n.next)\n        dic[n].random = dic.get(n.random)\n        n = n.next\n    return dic.get(head)\n\n\n# O(n)\ndef copy_random_pointer_v2(head):\n    \"\"\"\n    :type head: RandomListNode\n    :rtype: RandomListNode\n    \"\"\"\n    copy = defaultdict(lambda: RandomListNode(0))\n    copy[None] = None\n    node = head\n    while node:\n        copy[node].label = node.label\n        copy[node].next = copy[node.next]\n        copy[node].random = copy[node.random]\n        node = node.next\n    return copy[head]\n"
  },
  {
    "id": 260,
    "category": "ml",
    "file_name": "nearest_neighbor",
    "codes": "import math\n\ndef distance(x,y):\n    \"\"\"[summary]\n    HELPER-FUNCTION\n    calculates the (eulidean) distance between vector x and y.\n\n    Arguments:\n        x {[tuple]} -- [vector]\n        y {[tuple]} -- [vector]\n    \"\"\"\n    assert len(x) == len(y), \"The vector must have same length\"\n    result = ()\n    sum = 0\n    for i in range(len(x)):\n        result += (x[i] -y[i],)\n    for component in result:\n        sum += component**2\n    return math.sqrt(sum)\n\n\ndef nearest_neighbor(x, tSet):\n    \"\"\"[summary]\n    Implements the nearest neighbor algorithm\n\n    Arguments:\n        x {[tupel]} -- [vector]\n        tSet {[dict]} -- [training set]\n\n    Returns:\n        [type] -- [result of the AND-function]\n    \"\"\"\n    assert isinstance(x, tuple) and isinstance(tSet, dict)\n    current_key = ()\n    min_d = float('inf')\n    for key in tSet:\n        d = distance(x, key)\n        if d < min_d:\n            min_d = d\n            current_key = key\n    return tSet[current_key]\n"
  },
  {
    "id": 261,
    "category": "distribution",
    "file_name": "histogram",
    "codes": "\"\"\"\nHistogram function.\n\nHistogram is an accurate representation of the distribution of numerical data.\nIt is an estimate of the probability distribution of a continuous variable.\nhttps://en.wikipedia.org/wiki/Histogram\n\nExample:\n    list_1 = [3, 3, 2, 1]\n    :return {1: 1, 2: 1, 3: 2}\n\n    list_2 = [2, 3, 5, 5, 5, 6, 4, 3, 7]\n    :return {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}\n\"\"\"\n\n\ndef get_histogram(input_list: list) -> dict:\n    \"\"\"\n    Get histogram representation\n    :param input_list: list with different and unordered values\n    :return histogram: dict with histogram of input_list\n    \"\"\"\n    # Create dict to store histogram\n    histogram = {}\n    # For each list value, add one to the respective histogram dict position\n    for i in input_list:\n        histogram[i] = histogram.get(i, 0) + 1\n    return histogram\n"
  },
  {
    "id": 262,
    "category": "heap",
    "file_name": "binary_heap",
    "codes": "r\"\"\"\nBinary Heap. A min heap is a complete binary tree where each node is smaller than\nits children. The root, therefore, is the minimum element in the tree. The min\nheap uses an array to represent the data and operation. For example a min heap:\n\n     4\n   /   \\\n  50    7\n / \\   /\n55 90 87\n\nHeap [0, 4, 50, 7, 55, 90, 87]\n\nMethod in class: insert, remove_min\nFor example insert(2) in a min heap:\n\n     4                     4                     2\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     2       -->     50    4\n / \\   /  \\           /  \\   / \\             /  \\  /  \\\n55 90 87   2         55  90 87  7           55  90 87  7\n\nFor example remove_min() in a min heap:\n\n     4                     87                    7\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     7       -->     50    87\n / \\   /              /  \\                   /  \\\n55 90 87             55  90                 55  90\n\n\"\"\"\nfrom abc import ABCMeta, abstractmethod\n\n\nclass AbstractHeap(metaclass=ABCMeta):\n    \"\"\"Abstract Class for Binary Heap.\"\"\"\n\n    def __init__(self):\n        \"\"\"Pass.\"\"\"\n\n    @abstractmethod\n    def perc_up(self, i):\n        \"\"\"Pass.\"\"\"\n\n    @abstractmethod\n    def insert(self, val):\n        \"\"\"Pass.\"\"\"\n\n    @abstractmethod\n    def perc_down(self, i):\n        \"\"\"Pass.\"\"\"\n\n    @abstractmethod\n    def min_child(self, i):\n        \"\"\"Pass.\"\"\"\n\n    @abstractmethod\n    def remove_min(self):\n        \"\"\"Pass.\"\"\"\n\n\nclass BinaryHeap(AbstractHeap):\n    \"\"\"Binary Heap Class\"\"\"\n\n    def __init__(self):\n        self.current_size = 0\n        self.heap = [(0)]\n\n    def perc_up(self, i):\n        while i // 2 > 0:\n            if self.heap[i] < self.heap[i // 2]:\n                # Swap value of child with value of its parent\n                self.heap[i], self.heap[i//2] = self.heap[i//2], self.heap[i]\n            i = i // 2\n\n    def insert(self, val):\n        \"\"\"\n        Method insert always start by inserting the element at the bottom.\n        It inserts rightmost spot so as to maintain the complete tree property.\n        Then, it fixes the tree by swapping the new element with its parent,\n        until it finds an appropriate spot for the element. It essentially\n        perc_up the minimum element\n        Complexity: O(logN)\n        \"\"\"\n        self.heap.append(val)\n        self.current_size = self.current_size + 1\n        self.perc_up(self.current_size)\n\n        \"\"\"\n        Method min_child returns the index of smaller of 2 children of parent at index i\n        \"\"\"\n\n    def min_child(self, i):\n        if 2 * i + 1 > self.current_size:  # No right child\n            return 2 * i\n        if self.heap[2 * i] > self.heap[2 * i + 1]:\n            return 2 * i + 1\n        return 2 * i\n\n    def perc_down(self, i):\n        while 2 * i < self.current_size:\n            min_child = self.min_child(i)\n            if self.heap[min_child] < self.heap[i]:\n                # Swap min child with parent\n                self.heap[min_child], self.heap[i] = self.heap[i], self.heap[min_child]\n            i = min_child\n    \"\"\"\n        Remove Min method removes the minimum element and swap it with the last\n        element in the heap( the bottommost, rightmost element). Then, it\n        perc_down this element, swapping it with one of its children until the\n        min heap property is restored\n        Complexity: O(logN)\n    \"\"\"\n\n    def remove_min(self):\n        ret = self.heap[1]      # the smallest value at beginning\n        # Replace it by the last value\n        self.heap[1] = self.heap[self.current_size]\n        self.current_size = self.current_size - 1\n        self.heap.pop()\n        self.perc_down(1)\n        return ret\n"
  },
  {
    "id": 263,
    "category": "heap",
    "file_name": "skyline",
    "codes": "# -*- coding: utf-8 -*-\n\"\"\"\nA city's skyline is the outer contour of the silhouette formed by all the buildings\nin that city when viewed from a distance.\nNow suppose you are given the locations and height of all the buildings\nas shown on a cityscape photo (Figure A),\nwrite a program to output the skyline formed by these buildings collectively (Figure B).\n\nThe geometric information of each building is represented by a triplet of integers [Li, Ri, Hi],\nwhere Li and Ri are the x coordinates of the left and right edge of the ith building, respectively,\nand Hi is its height. It is guaranteed that 0 \u2264 Li, Ri \u2264 INT_MAX, 0 < Hi \u2264 INT_MAX, and Ri - Li > 0.\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n\nFor instance, the dimensions of all buildings in Figure A are recorded as:\n[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\n\nThe output is a list of \"key points\" (red dots in Figure B) in the format of\n[ [x1,y1], [x2, y2], [x3, y3], ... ]\nthat uniquely defines a skyline.\nA key point is the left endpoint of a horizontal line segment. Note that the last key point,\nwhere the rightmost building ends,\nis merely used to mark the termination of the skyline, and always has zero height.\nAlso, the ground in between any two adjacent buildings should be considered part of the skyline contour.\n\nFor instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\n\nNotes:\n\nThe number of buildings in any input list is guaranteed to be in the range [0, 10000].\nThe input list is already sorted in ascending order by the left x position Li.\nThe output list must be sorted by the x position.\nThere must be no consecutive horizontal lines of equal height in the output skyline. For instance,\n[...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged\ninto one in the final output as such: [...[2 3], [4 5], [12 7], ...]\n\n\"\"\"\nimport heapq\n\ndef get_skyline(lrh):\n    \"\"\"\n    Wortst Time Complexity: O(NlogN)\n    :type buildings: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    skyline, live = [], []\n    i, n = 0, len(lrh)\n    while i < n or live:\n        if not live or i < n and lrh[i][0] <= -live[0][1]:\n            x = lrh[i][0]\n            while i < n and lrh[i][0] == x:\n                heapq.heappush(live, (-lrh[i][2], -lrh[i][1]))\n                i += 1\n        else:\n            x = -live[0][1]\n            while live and -live[0][1] <= x:\n                heapq.heappop(live)\n        height = len(live) and -live[0][0]\n        if not skyline or height != skyline[-1][1]:\n            skyline += [x, height],\n    return skyline\n"
  },
  {
    "id": 264,
    "category": "heap",
    "file_name": "merge_sorted_k_lists",
    "codes": "\"\"\"\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n\"\"\"\n\n\nfrom heapq import heappop, heapreplace, heapify\nfrom queue import PriorityQueue\n\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    \"\"\" ListNode Class\"\"\"\n\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n\ndef merge_k_lists(lists):\n    \"\"\" Merge Lists \"\"\"\n    dummy = node = ListNode(0)\n    list_h = [(n.val, n) for n in lists if n]\n    heapify(list_h)\n    while list_h:\n        _, n_val = list_h[0]\n        if n_val.next is None:\n            heappop(list_h)  # only change heap size when necessary\n        else:\n            heapreplace(list_h, (n_val.next.val, n_val.next))\n        node.next = n_val\n        node = node.next\n\n    return dummy.next\n\n\ndef merge_k_lists(lists):\n    \"\"\" Merge List \"\"\"\n    dummy = ListNode(None)\n    curr = dummy\n    q = PriorityQueue()\n    for node in lists:\n        if node:\n            q.put((node.val, node))\n    while not q.empty():\n        curr.next = q.get()[1]  # These two lines seem to\n        curr = curr.next  # be equivalent to :-   curr = q.get()[1]\n        if curr.next:\n            q.put((curr.next.val, curr.next))\n    return dummy.next\n\n\n\"\"\"\nI think my code's complexity is also O(nlogk) and not using heap or priority queue,\nn means the total elements and k means the size of list.\n\nThe mergeTwoLists function in my code comes from the problem Merge Two Sorted Lists\nwhose complexity obviously is O(n), n is the sum of length of l1 and l2.\n\nTo put it simpler, assume the k is 2^x, So the progress of combination is like a full binary tree,\nfrom bottom to top. So on every level of tree, the combination complexity is n,\nbecause every level have all n numbers without repetition.\nThe level of tree is x, ie log k. So the complexity is O(n log k).\n\nfor example, 8 ListNode, and the length of every ListNode is x1, x2,\nx3, x4, x5, x6, x7, x8, total is n.\n\non level 3: x1+x2, x3+x4, x5+x6, x7+x8 sum: n\n\non level 2: x1+x2+x3+x4, x5+x6+x7+x8 sum: n\n\non level 1: x1+x2+x3+x4+x5+x6+x7+x8 sum: n\n\"\"\"\n"
  },
  {
    "id": 265,
    "category": "heap",
    "file_name": "sliding_window_max",
    "codes": "\"\"\"\nGiven an array nums, there is a sliding window of size k\nwhich is moving from the very left of the array to the very right.\nYou can only see the k numbers in the window.\nEach time the sliding window moves right by one position.\n\nFor example,\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\n\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\nTherefore, return the max sliding window as [3,3,5,5,6,7].\n\"\"\"\nimport collections\n\n\ndef max_sliding_window(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if not nums:\n        return nums\n    queue = collections.deque()\n    res = []\n    for num in nums:\n        if len(queue) < k:\n            queue.append(num)\n        else:\n            res.append(max(queue))\n            queue.popleft()\n            queue.append(num)\n    res.append(max(queue))\n    return res\n"
  },
  {
    "id": 266,
    "category": "heap",
    "file_name": "k_closest_points",
    "codes": "\"\"\"Given a list of points, find the k closest to the origin.\n\nIdea: Maintain a max heap of k elements.\nWe can iterate through all points.\nIf a point p has a smaller distance to the origin than the top element of a\nheap, we add point p to the heap and remove the top element.\nAfter iterating through all points, our heap contains the k closest points to\nthe origin.\n\"\"\"\n\n\nfrom heapq import heapify, heappushpop\n\n\ndef k_closest(points, k, origin=(0, 0)):\n    # Time: O(k+(n-k)logk)\n    # Space: O(k)\n    \"\"\"Initialize max heap with first k points.\n    Python does not support a max heap; thus we can use the default min heap\n    where the keys (distance) are negated.\n    \"\"\"\n    heap = [(-distance(p, origin), p) for p in points[:k]]\n    heapify(heap)\n\n    \"\"\"\n    For every point p in points[k:],\n    check if p is smaller than the root of the max heap;\n    if it is, add p to heap and remove root. Reheapify.\n    \"\"\"\n    for point in points[k:]:\n        dist = distance(point, origin)\n\n        heappushpop(heap, (-dist, point))  # heappushpop does conditional check\n        \"\"\"Same as:\n            if d < -heap[0][0]:\n                heappush(heap, (-d,p))\n                heappop(heap)\n\n        Note: heappushpop is more efficient than separate push and pop calls.\n        Each heappushpop call takes O(logk) time.\n        \"\"\"\n\n    return [point for nd, point in heap]  # return points in heap\n\n\ndef distance(point, origin=(0, 0)):\n    \"\"\" Calculates the distance for a point from origo\"\"\"\n    return (point[0] - origin[0])**2 + (point[1] - origin[1])**2\n"
  },
  {
    "id": 267,
    "category": "arrays",
    "file_name": "trimmean",
    "codes": "\"\"\"\nWhen make reliable means, we need to neglect best and worst values.\nFor example, when making average score on athletes we need this option.\nSo, this algorithm affixes some percentage to neglect when making mean.\nFor example, if you suggest 20%, it will neglect the best 10% of values\nand the worst 10% of values.\n\nThis algorithm takes an array and percentage to neglect. After sorted,\nif index of array is larger or smaller than desired ratio, we don't\ncompute it.\n\nCompleity: O(n)\n\"\"\"\ndef trimmean(arr, per):\n    ratio = per/200\n    # /100 for easy calculation by *, and /2 for easy adaption to best and worst parts.\n    cal_sum = 0\n    # sum value to be calculated to trimmean.\n    arr.sort()\n    neg_val = int(len(arr)*ratio)\n    arr = arr[neg_val:len(arr)-neg_val]\n    for i in arr:\n        cal_sum += i\n    return cal_sum/len(arr)\n"
  },
  {
    "id": 268,
    "category": "arrays",
    "file_name": "delete_nth",
    "codes": "\"\"\"\nGiven a list lst and a number N, create a new list\nthat contains each number of the list at most N times without reordering.\n\nFor example if N = 2, and the input is [1,2,3,1,2,1,2,3], you take [1,2,3,1,2], \ndrop the next [1,2] since this would lead to 1 and 2 being in the result 3 times, and then take 3, \nwhich leads to [1,2,3,1,2,3]\n\"\"\"\nimport collections\n\n\n# Time complexity O(n^2)\ndef delete_nth_naive(array, n):\n    ans = []\n    for num in array:\n        if ans.count(num) < n:\n            ans.append(num)\n    return ans\n\n\n# Time Complexity O(n), using hash tables.\ndef delete_nth(array, n):\n    result = []\n    counts = collections.defaultdict(int)  # keep track of occurrences\n\n    for i in array:\n\n        if counts[i] < n:\n            result.append(i)\n            counts[i] += 1\n\n    return result\n"
  },
  {
    "id": 269,
    "category": "arrays",
    "file_name": "garage",
    "codes": "\"\"\"\nThere is a parking lot with only one empty spot. Given the initial state\nof the parking lot and the final state. Each step we are only allowed to\nmove a car\nout of its place and move it into the empty spot.\nThe goal is to find out the least movement needed to rearrange\nthe parking lot from the initial state to the final state.\n\nSay the initial state is an array:\n\n[1, 2, 3, 0, 4],\nwhere 1, 2, 3, 4 are different cars, and 0 is the empty spot.\n\nAnd the final state is\n\n[0, 3, 2, 1, 4].\nWe can swap 1 with 0 in the initial array to get [0, 2, 3, 1, 4] and so on.\nEach step swap with 0 only.\n\nEdit:\nNow also prints the sequence of changes in states.\nOutput of this example :-\n\ninitial: [1, 2, 3, 0, 4]\nfinal:   [0, 3, 2, 1, 4]\nSteps =  4\nSequence : \n0 2 3 1 4\n2 0 3 1 4\n2 3 0 1 4\n0 3 2 1 4\n\"\"\"\n\n\ndef garage(initial, final):\n\n    initial = initial[::]      # prevent changes in original 'initial'\n    seq = []                   # list of each step in sequence\n    steps = 0\n    while initial != final:\n        zero = initial.index(0)\n        if zero != final.index(0):  # if zero isn't where it should be,\n            car_to_move = final[zero]   # what should be where zero is,\n            pos = initial.index(car_to_move)         # and where is it?\n            initial[zero], initial[pos] = initial[pos], initial[zero]\n        else:\n            for i in range(len(initial)):\n                if initial[i] != final[i]:\n                    initial[zero], initial[i] = initial[i], initial[zero]\n                    break\n        seq.append(initial[::])\n        steps += 1\n\n    return steps, seq       \n    # e.g.:  4, [{0, 2, 3, 1, 4}, {2, 0, 3, 1, 4}, \n    #            {2, 3, 0, 1, 4}, {0, 3, 2, 1, 4}]\n\n\"\"\"\nthus:\n1 2 3 0 4 -- zero = 3, true, car_to_move = final[3] = 1,\n             pos = initial.index(1) = 0, switched [0], [3]\n0 2 3 1 4 -- zero = 0, f, initial[1] != final[1], switched 0,1\n2 0 3 1 4 -- zero = 1, t, car_to_move = final[1] = 3,\n             pos = initial.index(3) = 2, switched [1], [2]\n2 3 0 1 4 -- zero = 2, t, car_to_move = final[2] = 2, \n             pos = initial.index(2) = 0, switched [0], [2]\n0 3 2 1 4 -- initial == final\n\"\"\""
  },
  {
    "id": 270,
    "category": "arrays",
    "file_name": "n_sum",
    "codes": "\"\"\"\nGiven an array of n integers, are there elements a, b, .. , n in nums\nsuch that a + b + .. + n = target?\n\nFind all unique n-tuplets in the array which gives the sum of target.\n\nExample:\n    basic:\n        Given:\n            n = 4\n            nums = [1, 0, -1, 0, -2, 2]\n            target = 0,\n        return [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n\n    advanced:\n        Given:\n            n = 2\n            nums = [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]]\n            target = -5\n            def sum(a, b):\n                return [a[0] + b[1], a[1] + b[0]]\n            def compare(num, target):\n                if num[0] < target:\n                    return -1\n                elif if num[0] > target:\n                    return 1\n                else:\n                    return 0\n        return [[-9, 5], [8, 4]]\n(TL:DR) because -9 + 4 = -5\n\"\"\"\n\n\ndef n_sum(n, nums, target, **kv):\n    \"\"\"\n    n: int\n    nums: list[object]\n    target: object\n    sum_closure: function, optional\n        Given two elements of nums, return sum of both.\n    compare_closure: function, optional\n        Given one object of nums and target, return -1, 1, or 0.\n    same_closure: function, optional\n        Given two object of nums, return bool.\n    return: list[list[object]]\n\n    Note:\n    1. type of sum_closure's return should be same \n       as type of compare_closure's first param\n    \"\"\"\n\n    def sum_closure_default(a, b):\n        return a + b\n\n    def compare_closure_default(num, target):\n        \"\"\" above, below, or right on? \"\"\"\n        if num < target:\n            return -1\n        elif num > target:\n            return 1\n        else:\n            return 0\n\n    def same_closure_default(a, b):\n        return a == b\n\n    def n_sum(n, nums, target):\n        if n == 2:      # want answers with only 2 terms? easy!\n            results = two_sum(nums, target)\n        else:\n            results = []\n            prev_num = None\n            for index, num in enumerate(nums):\n                if prev_num is not None and \\\n                   same_closure(prev_num, num):\n                    continue\n\n                prev_num = num\n                n_minus1_results = (\n                    n_sum(                      # recursive call\n                        n - 1,                  # a\n                        nums[index + 1:],       # b\n                        target - num            # c\n                        )   # x = n_sum( a, b, c )\n                    )   # n_minus1_results = x\n\n                n_minus1_results = (\n                    append_elem_to_each_list(num, n_minus1_results)\n                    )\n                results += n_minus1_results\n        return union(results)\n\n    def two_sum(nums, target):\n        nums.sort()\n        lt = 0\n        rt = len(nums) - 1\n        results = []\n        while lt < rt:\n            sum_ = sum_closure(nums[lt], nums[rt])\n            flag = compare_closure(sum_, target)\n            if flag == -1:\n                lt += 1\n            elif flag == 1:\n                rt -= 1\n            else:\n                results.append(sorted([nums[lt], nums[rt]]))\n                lt += 1\n                rt -= 1\n                while (lt < len(nums) and\n                       same_closure(nums[lt - 1], nums[lt])):\n                    lt += 1\n                while (0 <= rt and\n                       same_closure(nums[rt], nums[rt + 1])):\n                    rt -= 1\n        return results\n\n    def append_elem_to_each_list(elem, container):\n        results = []\n        for elems in container:\n            elems.append(elem)\n            results.append(sorted(elems))\n        return results\n\n    def union(duplicate_results):\n        results = []\n\n        if len(duplicate_results) != 0:\n            duplicate_results.sort()\n            results.append(duplicate_results[0])\n            for result in duplicate_results[1:]:\n                if results[-1] != result:\n                    results.append(result)\n\n        return results\n\n    sum_closure = kv.get('sum_closure', sum_closure_default)\n    same_closure = kv.get('same_closure', same_closure_default)\n    compare_closure = kv.get('compare_closure', compare_closure_default)\n    nums.sort()\n    return n_sum(n, nums, target)\n"
  },
  {
    "id": 271,
    "category": "arrays",
    "file_name": "flatten",
    "codes": "\"\"\"\nImplement Flatten Arrays.\nGiven an array that may contain nested arrays,\nproduce a single resultant array.\n\"\"\"\nfrom collections.abc import Iterable\n\n\n# return list\ndef flatten(input_arr, output_arr=None):\n    if output_arr is None:\n        output_arr = []\n    for ele in input_arr:\n        if not isinstance(ele, str) and isinstance(ele, Iterable):\n            flatten(ele, output_arr)    #tail-recursion\n        else:\n            output_arr.append(ele)      #produce the result\n    return output_arr\n\n\n# returns iterator\ndef flatten_iter(iterable):\n    \"\"\"\n    Takes as input multi dimensional iterable and\n    returns generator which produces one dimensional output.\n    \"\"\"\n    for element in iterable:\n        if not isinstance(element, str) and isinstance(element, Iterable):\n            yield from flatten_iter(element)    \n        else:\n            yield element\n"
  },
  {
    "id": 272,
    "category": "arrays",
    "file_name": "two_sum",
    "codes": "\"\"\"\nGiven an array of integers, return indices of the two numbers\nsuch that they add up to a specific target.\n\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\n\nExample:\n    Given nums = [2, 7, 11, 15], target = 9,\n\n    Because nums[0] + nums[1] = 2 + 7 = 9,\n    return (0, 1)\n\"\"\"\n\n\ndef two_sum(array, target):\n    dic = {}\n    for i, num in enumerate(array):\n        if num in dic:\n            return dic[num], i\n        else:\n            dic[target - num] = i\n    return None\n"
  },
  {
    "id": 273,
    "category": "arrays",
    "file_name": "summarize_ranges",
    "codes": "\"\"\"\nGiven a sorted integer array without duplicates,\nreturn the summary of its ranges.\n\nFor example, given [0, 1, 2, 4, 5, 7], return [(0, 2), (4, 5), (7, 7)].\n\"\"\"\n\n\nfrom typing import List\n\ndef summarize_ranges(array: List[int]) -> List[str]:\n    res = []\n    if len(array) == 1:\n        return [str(array[0])]\n    it = iter(array)\n    start = end = next(it)\n    for num in it:\n        if num - end == 1:\n            end = num\n        else:\n            res.append((start, end) if start != end else (start,))\n            start = end = num\n    res.append((start, end) if start != end else (start,))\n    return [f\"{r[0]}-{r[1]}\" if len(r) > 1 else str(r[0]) for r in res]\n\n"
  },
  {
    "id": 274,
    "category": "arrays",
    "file_name": "max_ones_index",
    "codes": "\"\"\"\nFind the index of 0 to be replaced with 1 to get\nlongest continuous sequence\nof 1s in a binary array.\nReturns index of 0 to be\nreplaced with 1 to get longest\ncontinuous sequence of 1s.\nIf there is no 0 in array, then\nit returns -1.\n\ne.g.\nlet input array = [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]\nIf we replace 0 at index 3 with 1, we get the longest continuous\nsequence of 1s in the array.\nSo the function return => 3\n\"\"\"\n\n\ndef max_ones_index(arr):\n\n    n = len(arr)\n    max_count = 0\n    max_index = 0\n    prev_zero = -1\n    prev_prev_zero = -1\n\n    for curr in range(n):\n\n        # If current element is 0,\n        # then calculate the difference\n        # between curr and prev_prev_zero\n        if arr[curr] == 0:\n            if curr - prev_prev_zero > max_count:\n                max_count = curr - prev_prev_zero\n                max_index = prev_zero\n\n            prev_prev_zero = prev_zero\n            prev_zero = curr\n\n    if n - prev_prev_zero > max_count:\n        max_index = prev_zero\n\n    return max_index\n"
  },
  {
    "id": 275,
    "category": "arrays",
    "file_name": "plus_one",
    "codes": "\"\"\"\nGiven a non-negative number represented as an array of digits,\nadding one to each numeral.\n\nThe digits are stored big-endian, such that the most significant\ndigit is at the head of the list.\n\"\"\"\n\n\ndef plus_one_v1(digits):\n    \"\"\"\n    :type digits: List[int]\n    :rtype: List[int]\n    \"\"\"\n    digits[-1] = digits[-1] + 1\n    res = []\n    ten = 0\n    i = len(digits)-1\n    while i >= 0 or ten == 1:\n        summ = 0\n        if i >= 0:\n            summ += digits[i]\n        if ten:\n            summ += 1\n        res.append(summ % 10)\n        ten = summ // 10\n        i -= 1\n    return res[::-1]\n\n\ndef plus_one_v2(digits):\n    n = len(digits)\n    for i in range(n-1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    digits.insert(0, 1)\n    return digits\n\n\ndef plus_one_v3(num_arr):\n\n    for idx in reversed(list(enumerate(num_arr))):\n        num_arr[idx[0]] = (num_arr[idx[0]] + 1) % 10\n        if num_arr[idx[0]]:\n            return num_arr\n    return [1] + num_arr\n"
  },
  {
    "id": 276,
    "category": "arrays",
    "file_name": "josephus",
    "codes": "\"\"\"\nThere are people sitting in a circular fashion,\nprint every third member while removing them,\nthe next counter starts immediately after the member is removed.\nPrint till all the members are exhausted.\n\nFor example:\nInput: consider 123456789 members sitting in a circular fashion,\nOutput: 369485271\n\"\"\"\n\ndef josephus(int_list, skip):\n    skip = skip - 1                     # list starts with 0 index\n    idx = 0\n    len_list = (len(int_list))\n    while len_list > 0:\n        idx = (skip + idx) % len_list   # hash index to every 3rd\n        yield int_list.pop(idx)\n        len_list -= 1\n"
  },
  {
    "id": 277,
    "category": "arrays",
    "file_name": "limit",
    "codes": "\"\"\"\nSometimes you need to limit array result to use. Such as you only need the \n value over 10 or, you need value under than 100. By use this algorithms, you\n can limit your array to specific value\n\nIf array, Min, Max value was given, it returns array that contains values of \n given array which was larger than Min, and lower than Max. You need to give\n 'unlimit' to use only Min or Max.\n\nex) limit([1,2,3,4,5], None, 3) = [1,2,3]\n\nComplexity = O(n)\n\"\"\"\n\n# tl:dr -- array slicing by value\ndef limit(arr, min_lim=None, max_lim=None):\n    if len(arr) == 0:\n        return arr\n\n    if min_lim is None:\n        min_lim = min(arr)\n    if max_lim is None:\n        max_lim = max(arr)\n\n    return list(filter(lambda x: (min_lim <= x <= max_lim), arr))\n"
  },
  {
    "id": 278,
    "category": "arrays",
    "file_name": "three_sum",
    "codes": "\"\"\"\nGiven an array S of n integers, are there three distinct elements\na, b, c in S such that a + b + c = 0?\nFind all unique triplets in the array which gives the sum of zero.\n\nNote: The solution set must not contain duplicate triplets.\n\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n{\n  (-1, 0, 1),\n  (-1, -1, 2)\n}\n\"\"\"\n\n\ndef three_sum(array):\n    \"\"\"\n    :param array: List[int]\n    :return: Set[ Tuple[int, int, int] ]\n    \"\"\"\n    res = set()\n    array.sort()\n    for i in range(len(array) - 2):\n        if i > 0 and array[i] == array[i - 1]:\n            continue\n        l, r = i + 1, len(array) - 1\n        while l < r:\n            s = array[i] + array[l] + array[r]\n            if s > 0:\n                r -= 1\n            elif s < 0:\n                l += 1\n            else:\n                # found three sum\n                res.add((array[i], array[l], array[r]))\n\n                # remove duplicates\n                while l < r and array[l] == array[l + 1]:\n                    l += 1\n\n                while l < r and array[r] == array[r - 1]:\n                    r -= 1\n\n                l += 1\n                r -= 1\n    return res\n"
  },
  {
    "id": 279,
    "category": "arrays",
    "file_name": "missing_ranges",
    "codes": "\"\"\"\nFind missing ranges between low and high in the given array.\nEx) [3, 5] lo=1 hi=10 => answer: [(1, 2), (4, 4), (6, 10)]\n\"\"\"\n\ndef missing_ranges(arr, lo, hi):\n\n    res = []\n    start = lo\n\n    for n in arr:\n\n        if n == start:\n            start += 1\n        elif n > start:\n            res.append((start, n-1))\n            start = n + 1\n\n    if start <= hi:                 # after done iterating thru array,\n        res.append((start, hi))     # append remainder to list\n\n    return res\n"
  },
  {
    "id": 280,
    "category": "arrays",
    "file_name": "top_1",
    "codes": "\"\"\"\nThis algorithm receives an array and returns most_frequent_value\nAlso, sometimes it is possible to have multiple 'most_frequent_value's,\nso this function returns a list. This result can be used to find a \nrepresentative value in an array.\n\nThis algorithm gets an array, makes a dictionary of it,\n finds the most frequent count, and makes the result list.\n\nFor example: top_1([1, 1, 2, 2, 3, 4]) will return [1, 2]\n\n(TL:DR) Get mathematical Mode\nComplexity: O(n)\n\"\"\"\ndef top_1(arr):\n    values = {}\n    #reserve each value which first appears on keys\n    #reserve how many time each value appears by index number on values\n    result = []\n    f_val = 0\n\n    for i in arr:\n        if i in values:\n            values[i] += 1\n        else:\n            values[i] = 1\n\n    f_val = max(values.values())\n        \n    for i in values.keys():\n        if values[i] == f_val:\n            result.append(i)\n        else:\n            continue\n    \n    return result\n    "
  },
  {
    "id": 281,
    "category": "arrays",
    "file_name": "remove_duplicates",
    "codes": "\"\"\"\nThis algorithm removes any duplicates from an array and returns a new array with those duplicates\nremoved.\n\nFor example:\n\nInput: [1, 1 ,1 ,2 ,2 ,3 ,4 ,4 ,\"hey\", \"hey\", \"hello\", True, True]\nOutput: [1, 2, 3, 4, 'hey', 'hello']\n\"\"\"\n\ndef remove_duplicates(array):\n    new_array = []\n\n    for item in array:\n        if item not in new_array:\n            new_array.append(item)\n\n    return new_array"
  },
  {
    "id": 282,
    "category": "arrays",
    "file_name": "move_zeros",
    "codes": "\"\"\"\nWrite an algorithm that takes an array and moves all of the zeros to the end,\npreserving the order of the other elements.\n    move_zeros([false, 1, 0, 1, 2, 0, 1, 3, \"a\"])\n    returns => [false, 1, 1, 2, 1, 3, \"a\", 0, 0]\n\nThe time complexity of the below algorithm is O(n).\n\"\"\"\n\n\n# False == 0 is True\ndef move_zeros(array):\n    result = []\n    zeros = 0\n\n    for i in array:\n            if i == 0 and type(i) != bool:  # not using `not i` to avoid `False`, `[]`, etc.\n                zeros += 1\n            else:\n                result.append(i)\n    \n    result.extend([0] * zeros)\n    return result\n\n\nprint(move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \"a\"]))"
  },
  {
    "id": 283,
    "category": "arrays",
    "file_name": "rotate",
    "codes": "\"\"\"\nRotate an array of n elements to the right by k steps.\n\nFor example, with n = 7 and k = 3,\nthe array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].\n\nNote:\nTry to come up as many solutions as you can,\nthere are at least 3 different ways to solve this problem.\n\"\"\"\n\n\ndef rotate_v1(array, k):\n    \"\"\"\n    Rotate the entire array 'k' times\n    T(n)- O(nk)\n\n    :type array: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify array in-place instead.\n    \"\"\"\n    array = array[:]\n    n = len(array)\n    for i in range(k):      # unused variable is not a problem\n        temp = array[n - 1]\n        for j in range(n-1, 0, -1):\n            array[j] = array[j - 1]\n        array[0] = temp\n    return array\n\n\ndef rotate_v2(array, k):\n    \"\"\"\n    Reverse segments of the array, followed by the entire array\n    T(n)- O(n)\n    :type array: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    array = array[:]\n\n    def reverse(arr, a, b):\n        while a < b:\n            arr[a], arr[b] = arr[b], arr[a]\n            a += 1\n            b -= 1\n\n    n = len(array)\n    k = k % n\n    reverse(array, 0, n - k - 1)\n    reverse(array, n - k, n - 1)\n    reverse(array, 0, n - 1)\n    return array\n\n\ndef rotate_v3(array, k):\n    if array is None:\n        return None\n    length = len(array)\n    k = k % length\n    return array[length - k:] + array[:length - k]\n"
  },
  {
    "id": 284,
    "category": "arrays",
    "file_name": "longest_non_repeat",
    "codes": "\"\"\"\nGiven a string, find the length of the longest substring\nwithout repeating characters.\n\nExamples:\nGiven \"abcabcbb\", the answer is \"abc\", which the length is 3.\nGiven \"bbbbb\", the answer is \"b\", with the length of 1.\nGiven \"pwwkew\", the answer is \"wke\", with the length of 3.\nNote that the answer must be a substring,\n\"pwke\" is a subsequence and not a substring.\n\"\"\"\n\n\ndef longest_non_repeat_v1(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    \"\"\"\n    if string is None:\n        return 0\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if string[i] in dict:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        max_length = max(max_length, i - j + 1)\n    return max_length\n\ndef longest_non_repeat_v2(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Uses alternative algorithm.\n    \"\"\"\n    if string is None:\n        return 0\n    start, max_len = 0, 0\n    used_char = {}\n    for index, char in enumerate(string):\n        if char in used_char and start <= used_char[char]:\n            start = used_char[char] + 1\n        else:\n            max_len = max(max_len, index - start + 1)\n        used_char[char] = index\n    return max_len\n\n# get functions of above, returning the max_len and substring\ndef get_longest_non_repeat_v1(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Return max_len and the substring as a tuple\n    \"\"\"\n    if string is None:\n        return 0, ''\n    sub_string = ''\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if string[i] in dict:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        if i - j + 1 > max_length:\n            max_length = i - j + 1\n            sub_string = string[j: i + 1]\n    return max_length, sub_string\n\ndef get_longest_non_repeat_v2(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Uses alternative algorithm.\n    Return max_len and the substring as a tuple\n    \"\"\"\n    if string is None:\n        return 0, ''\n    sub_string = ''\n    start, max_len = 0, 0\n    used_char = {}\n    for index, char in enumerate(string):\n        if char in used_char and start <= used_char[char]:\n            start = used_char[char] + 1\n        else:\n            if index - start + 1 > max_len:\n                max_len = index - start + 1\n                sub_string = string[start: index + 1]\n        used_char[char] = index\n    return max_len, sub_string\n\ndef get_longest_non_repeat_v3(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Uses window sliding approach.\n    Return max_len and the substring as a tuple\n    \"\"\"\n    longest_substring = ''\n    seen = set()\n    start_idx = 0\n    for i in range(len(string)):\n        while string[i] in seen:\n            seen.remove(string[start_idx])\n            start_idx += 1\n        seen.add(string[i])\n        longest_substring = max(longest_substring, string[start_idx: i+1], key=len)\n    return len(longest_substring), longest_substring\n"
  },
  {
    "id": 285,
    "category": "arrays",
    "file_name": "merge_intervals",
    "codes": "\"\"\"\nIn mathematics, a (real) interval is a set of real\n numbers with the property that any number that lies\n between two numbers in the set is also included in the set.\n\"\"\"\n\n\nclass Interval:\n    \"\"\"\n    A set of real numbers with methods to determine if other\n     numbers are included in the set.\n    Includes related methods to merge and print interval sets.\n    \"\"\"\n    def __init__(self, start=0, end=0):\n        self.start = start\n        self.end = end\n\n    def __repr__(self):\n        return \"Interval ({}, {})\".format(self.start, self.end)\n\n    def __iter__(self):\n        return iter(range(self.start, self.end))\n\n    def __getitem__(self, index):\n        if index < 0:\n            return self.end + index\n        return self.start + index\n\n    def __len__(self):\n        return self.end - self.start\n\n    def __contains__(self, item):\n        if self.start >= item >= self.end:\n            return True\n        return False\n\n    def __eq__(self, other):\n        if self.start == other.start and self.end == other.end:\n            return True\n        return False\n\n    def as_list(self):\n        \"\"\" Return interval as list. \"\"\"\n        return list(self)\n\n    @staticmethod\n    def merge(intervals):\n        \"\"\" Merge two intervals into one. \"\"\"\n        out = []\n        for i in sorted(intervals, key=lambda i: i.start):\n            if out and i.start <= out[-1].end:\n                out[-1].end = max(out[-1].end, i.end)\n            else:\n                out += i,\n        return out\n\n    @staticmethod\n    def print_intervals(intervals):\n        \"\"\" Print out the intervals. \"\"\"\n        res = []\n        for i in intervals:\n            res.append(repr(i))\n        print(\"\".join(res))\n\n\ndef merge_intervals(intervals):\n    \"\"\" Merge intervals in the form of a list. \"\"\"\n    if intervals is None:\n        return None\n    intervals.sort(key=lambda i: i[0])\n    out = [intervals.pop(0)]\n    for i in intervals:\n        if out[-1][-1] >= i[0]:\n            out[-1][-1] = max(out[-1][-1], i[-1])\n        else:\n            out.append(i)\n    return out\n"
  },
  {
    "id": 286,
    "category": "tree",
    "file_name": "invert_tree",
    "codes": "# invert a binary tree\n\ndef reverse(root):\n    if root is None:\n        return\n    root.left, root.right = root.right, root.left\n    if root.left:\n        reverse(root.left)\n    if root.right:\n        reverse(root.right)\n"
  },
  {
    "id": 287,
    "category": "tree",
    "file_name": "tree",
    "codes": "class TreeNode:\n    def __init__(self, val=0):\n        self.val = val\n        self.left = None\n        self.right = None\n"
  },
  {
    "id": 288,
    "category": "tree",
    "file_name": "is_subtree",
    "codes": "\"\"\"\nGiven two binary trees s and t, check if t is a subtree of s.\nA subtree of a tree t is a tree consisting of a node in t and\nall of its descendants in t.\n\nExample 1:\n\nGiven s:\n\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n\nGiven t:\n\n   4\n  / \\\n 1   2\nReturn true, because t is a subtree of s.\n\nExample 2:\n\nGiven s:\n\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n    /\n   0\n\nGiven t:\n\n     3\n    /\n   4\n  / \\\n 1   2\nReturn false, because even though t is part of s,\nit does not contain all descendants of t.\n\nFollow up:\nWhat if one tree is significantly lager than the other?\n\"\"\"\nimport collections\n\n\ndef is_subtree(big, small):\n    flag = False\n    queue = collections.deque()\n    queue.append(big)\n    while queue:\n        node = queue.popleft()\n        if node.val == small.val:\n            flag = comp(node, small)\n            break\n        else:\n            queue.append(node.left)\n            queue.append(node.right)\n    return flag\n\n\ndef comp(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None and q is not None:\n        return p.val == q.val and comp(p.left,q.left) and comp(p.right, q.right)\n    return False\n"
  },
  {
    "id": 289,
    "category": "tree",
    "file_name": "same_tree",
    "codes": "\"\"\"\nGiven two binary trees, write a function to check\nif they are equal or not.\n\nTwo binary trees are considered equal if they are\nstructurally identical and the nodes have the same value.\n\"\"\"\n\n\ndef is_same_tree(tree_p, tree_q):\n    if tree_p is None and tree_q is None:\n        return True\n    if tree_p is not None and tree_q is not None and tree_p.val == tree_q.val:\n        return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)\n    return False\n\n# Time Complexity O(min(N,M))\n# where N and M are the number of nodes for the trees.\n\n# Space Complexity O(min(height1, height2))\n# levels of recursion is the mininum height between the two trees.\n"
  },
  {
    "id": 290,
    "category": "tree",
    "file_name": "binary_tree_paths",
    "codes": "def binary_tree_paths(root):\n    res = []\n    if root is None:\n        return res\n    dfs(res, root, str(root.val))\n    return res\n\n\ndef dfs(res, root, cur):\n    if root.left is None and root.right is None:\n        res.append(cur)\n    if root.left:\n        dfs(res, root.left, cur+'->'+str(root.left.val))\n    if root.right:\n        dfs(res, root.right, cur+'->'+str(root.right.val))\n"
  },
  {
    "id": 291,
    "category": "tree",
    "file_name": "path_sum2",
    "codes": "\"\"\"\nGiven a binary tree and a sum, find all root-to-leaf\npaths where each path's sum equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\nreturn\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n\"\"\"\n\n\ndef path_sum(root, sum):\n    if root is None:\n        return []\n    res = []\n    dfs(root, sum, [], res)\n    return res\n\n\ndef dfs(root, sum, ls, res):\n    if root.left is None and root.right is None and root.val == sum:\n        ls.append(root.val)\n        res.append(ls)\n    if root.left is not None:\n        dfs(root.left, sum-root.val, ls+[root.val], res)\n    if root.right is not None:\n        dfs(root.right, sum-root.val, ls+[root.val], res)\n\n\n# DFS with stack\ndef path_sum2(root, s):\n    if root is None:\n        return []\n    res = []\n    stack = [(root, [root.val])]\n    while stack:\n        node, ls = stack.pop()\n        if node.left is None and node.right is None and sum(ls) == s:\n            res.append(ls)\n        if node.left is not None:\n            stack.append((node.left, ls+[node.left.val]))\n        if node.right is not None:\n            stack.append((node.right, ls+[node.right.val]))\n    return res\n\n\n# BFS with queue\ndef path_sum3(root, sum):\n    if root is None:\n        return []\n    res = []\n    queue = [(root, root.val, [root.val])]\n    while queue:\n        node, val, ls = queue.pop(0)  # popleft\n        if node.left is None and node.right is None and val == sum:\n            res.append(ls)\n        if node.left is not None:\n            queue.append((node.left, val+node.left.val, ls+[node.left.val]))\n        if node.right is not None:\n            queue.append((node.right, val+node.right.val, ls+[node.right.val]))\n    return res\n"
  },
  {
    "id": 292,
    "category": "tree",
    "file_name": "min_height",
    "codes": "from tree import TreeNode\n\n\ndef min_depth(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    if root.left is not None or root.right is not None:\n        return max(self.minDepth(root.left), self.minDepth(root.right))+1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n\n\n# iterative\ndef min_height(root):\n    if root is None:\n        return 0\n    height = 0\n    level = [root]\n    while level:\n        height += 1\n        new_level = []\n        for node in level:\n            if node.left is None and node.right is None:\n                return height\n            if node.left is not None:\n                new_level.append(node.left)\n            if node.right is not None:\n                new_level.append(node.right)\n        level = new_level\n    return height\n\n\ndef print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)\n\n\nif __name__ == '__main__':\n    tree = TreeNode(10)\n    tree.left = TreeNode(12)\n    tree.right = TreeNode(15)\n    tree.left.left  = TreeNode(25)\n    tree.left.left.right  = TreeNode(100)\n    tree.left.right = TreeNode(30)\n    tree.right.left = TreeNode(36)\n\n    height = min_height(tree)\n    print_tree(tree)\n    print(\"height:\", height)\n"
  },
  {
    "id": 293,
    "category": "tree",
    "file_name": "bin_tree_to_list",
    "codes": "from tree.tree import TreeNode\n\n\ndef bin_tree_to_list(root):\n    \"\"\"\n    type root: root class\n    \"\"\"\n    if not root:\n        return root\n    root = bin_tree_to_list_util(root)\n    while root.left:\n        root = root.left\n    return root\n\n\ndef bin_tree_to_list_util(root):\n    if not root:\n        return root\n    if root.left:\n        left = bin_tree_to_list_util(root.left)\n        while left.right:\n            left = left.right\n        left.right = root\n        root.left = left\n    if root.right:\n        right = bin_tree_to_list_util(root.right)\n        while right.left:\n            right = right.left\n        right.left = root\n        root.right = right\n    return root\n\n\ndef print_tree(root):\n    while root:\n        print(root.val)\n        root = root.right\n"
  },
  {
    "id": 294,
    "category": "tree",
    "file_name": "is_symmetric",
    "codes": "\"\"\"\nGiven a binary tree, check whether it is a mirror of\nitself (ie, symmetric around its center).\n\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\nBut the following [1,2,2,null,3,null,3] is not:\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\nNote:\nBonus points if you could solve it both recursively and iteratively.\n\"\"\"\n\n# TC: O(b) SC: O(log n)\ndef is_symmetric(root):\n    if root is None:\n        return True\n    return helper(root.left, root.right)\n\n\ndef helper(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None or q is not None or q.val != p.val:\n        return False\n    return helper(p.left, q.right) and helper(p.right, q.left)\n\n\ndef is_symmetric_iterative(root):\n    if root is None:\n        return True\n    stack = [[root.left, root.right]]\n    while stack:\n        left, right = stack.pop()  # popleft\n        if left is None and right is None:\n            continue\n        if left is None or right is None:\n            return False\n        if left.val == right.val:\n            stack.append([left.left, right.right])\n            stack.append([left.right, right.left])\n        else:\n            return False\n    return True\n"
  },
  {
    "id": 295,
    "category": "tree",
    "file_name": "longest_consecutive",
    "codes": "\"\"\"\nGiven a binary tree, find the length of the longest consecutive sequence path.\n\nThe path refers to any sequence of nodes from some starting node to any node\nin the tree along the parent-child connections.\nThe longest consecutive path need to be from parent to child\n(cannot be the reverse).\n\nFor example,\n   1\n    \\\n     3\n    / \\\n   2   4\n        \\\n         5\nLongest consecutive sequence path is 3-4-5, so return 3.\n   2\n    \\\n     3\n    /\n   2\n  /\n 1\n\"\"\"\n\n\ndef longest_consecutive(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    max_len = 0\n    dfs(root, 0, root.val, max_len)\n    return max_len\n\n\ndef dfs(root, cur, target, max_len):\n    if root is None:\n        return\n    if root.val == target:\n        cur += 1\n    else:\n        cur = 1\n    max_len = max(cur, max_len)\n    dfs(root.left, cur, root.val+1, max_len)\n    dfs(root.right, cur, root.val+1, max_len)\n"
  },
  {
    "id": 296,
    "category": "tree",
    "file_name": "b_tree",
    "codes": "\"\"\"\nB-tree is used to disk operations. Each node (except root) contains\nat least t-1 keys (t children) and at most 2*t - 1 keys (2*t children)\nwhere t is the degree of b-tree. It is not a kind of typical bst tree, because\nthis tree grows up.\nB-tree is balanced which means that the difference between height of left\nsubtree and right subtree is at most 1.\n\nComplexity\n    n - number of elements\n    t - degree of tree\n    Tree always has height at most logt (n+1)/2\n    Algorithm        Average        Worst case\n    Space            O(n)           O(n)\n    Search           O(log n)       O(log n)\n    Insert           O(log n)       O(log n)\n    Delete           O(log n)       O(log n)\n\"\"\"\n\n\nclass Node:\n    \"\"\" Class of Node\"\"\"\n\n    def __init__(self):\n        # self.is_leaf = is_leaf\n        self.keys = []\n        self.children = []\n\n    def __repr__(self):\n        return \"<id_node: {0}>\".format(self.keys)\n\n    @property\n    def is_leaf(self):\n        \"\"\" Return if it is a leaf\"\"\"\n        return len(self.children) == 0\n\n\nclass BTree:\n    \"\"\" Class of BTree \"\"\"\n\n    def __init__(self, t_val=2):\n        self.min_numbers_of_keys = t_val - 1\n        self.max_number_of_keys = 2 * t_val - 1\n\n        self.root = Node()\n\n    def _split_child(self, parent: Node, child_index: int):\n        new_right_child = Node()\n        half_max = self.max_number_of_keys // 2\n        child = parent.children[child_index]\n        middle_key = child.keys[half_max]\n        new_right_child.keys = child.keys[half_max + 1:]\n        child.keys = child.keys[:half_max]\n        # child is left child of parent after splitting\n\n        if not child.is_leaf:\n            new_right_child.children = child.children[half_max + 1:]\n            child.children = child.children[:half_max + 1]\n\n        parent.keys.insert(child_index, middle_key)\n        parent.children.insert(child_index + 1, new_right_child)\n\n    def insert_key(self, key):\n        \"\"\" overflow, tree increases in height \"\"\"\n        if len(self.root.keys) >= self.max_number_of_keys:\n            new_root = Node()\n            new_root.children.append(self.root)\n            self.root = new_root\n            self._split_child(new_root, 0)\n            self._insert_to_nonfull_node(self.root, key)\n        else:\n            self._insert_to_nonfull_node(self.root, key)\n\n    def _insert_to_nonfull_node(self, node: Node, key):\n        i = len(node.keys) - 1\n        while i >= 0 and node.keys[i] >= key:  # find position where insert key\n            i -= 1\n\n        if node.is_leaf:\n            node.keys.insert(i + 1, key)\n        else:\n            # overflow\n            if len(node.children[i + 1].keys) >= self.max_number_of_keys:\n                self._split_child(node, i + 1)\n                # decide which child is going to have a new key\n                if node.keys[i + 1] < key:\n                    i += 1\n\n            self._insert_to_nonfull_node(node.children[i + 1], key)\n\n    def find(self, key) -> bool:\n        \"\"\" Finds key \"\"\"\n        current_node = self.root\n        while True:\n            i = len(current_node.keys) - 1\n            while i >= 0 and current_node.keys[i] > key:\n                i -= 1\n            if i >= 0 and current_node.keys[i] == key:\n                return True\n            if current_node.is_leaf:\n                return False\n            current_node = current_node.children[i + 1]\n\n    def remove_key(self, key):\n        self._remove_key(self.root, key)\n\n    def _remove_key(self, node: Node, key) -> bool:\n        try:\n            key_index = node.keys.index(key)\n            if node.is_leaf:\n                node.keys.remove(key)\n            else:\n                self._remove_from_nonleaf_node(node, key_index)\n            return True\n\n        except ValueError:  # key not found in node\n            if node.is_leaf:\n                print(\"Key not found.\")\n                return False  # key not found\n            else:\n                i = 0\n                number_of_keys = len(node.keys)\n                # decide in which subtree may be key\n                while i < number_of_keys and key > node.keys[i]:\n                    i += 1\n\n                action_performed = self._repair_tree(node, i)\n                if action_performed:\n                    return self._remove_key(node, key)\n                else:\n                    return self._remove_key(node.children[i], key)\n\n    def _repair_tree(self, node: Node, child_index: int) -> bool:\n        child = node.children[child_index]\n        # The leaf/node is correct\n        if self.min_numbers_of_keys < len(child.keys) <= self.max_number_of_keys:\n            return False\n\n        if child_index > 0 and len(node.children[child_index - 1].keys) > self.min_numbers_of_keys:\n            self._rotate_right(node, child_index)\n            return True\n\n        if (child_index < len(node.children) - 1\n                and len(node.children[child_index + 1].keys) > self.min_numbers_of_keys):  # 0 <-- 1\n            self._rotate_left(node, child_index)\n            return True\n\n        if child_index > 0:\n            # merge child with brother on the left\n            self._merge(node, child_index - 1, child_index)\n        else:\n            # merge child with brother on the right\n            self._merge(node, child_index, child_index + 1)\n\n        return True\n\n    def _rotate_left(self, parent_node: Node, child_index: int):\n        \"\"\"\n        Take key from right brother of the child and transfer to the child\n        \"\"\"\n        new_child_key = parent_node.keys[child_index]\n        new_parent_key = parent_node.children[child_index + 1].keys.pop(0)\n        parent_node.children[child_index].keys.append(new_child_key)\n        parent_node.keys[child_index] = new_parent_key\n\n        if not parent_node.children[child_index + 1].is_leaf:\n            ownerless_child = parent_node.children[child_index\n                                                   + 1].children.pop(0)\n            # make ownerless_child as a new biggest child (with highest key)\n            # -> transfer from right subtree to left subtree\n            parent_node.children[child_index].children.append(ownerless_child)\n\n    def _rotate_right(self, parent_node: Node, child_index: int):\n        \"\"\"\n        Take key from left brother of the child and transfer to the child\n        \"\"\"\n        parent_key = parent_node.keys[child_index - 1]\n        new_parent_key = parent_node.children[child_index - 1].keys.pop()\n        parent_node.children[child_index].keys.insert(0, parent_key)\n        parent_node.keys[child_index - 1] = new_parent_key\n\n        if not parent_node.children[child_index - 1].is_leaf:\n            ownerless_child = parent_node.children[child_index\n                                                   - 1].children.pop()\n            # make ownerless_child as a new lowest child (with lowest key)\n            # -> transfer from left subtree to right subtree\n            parent_node.children[child_index].children.insert(\n                0, ownerless_child)\n\n    def _merge(self, parent_node: Node, to_merge_index: int, transfered_child_index: int):\n        from_merge_node = parent_node.children.pop(transfered_child_index)\n        parent_key_to_merge = parent_node.keys.pop(to_merge_index)\n        to_merge_node = parent_node.children[to_merge_index]\n        to_merge_node.keys.append(parent_key_to_merge)\n        to_merge_node.keys.extend(from_merge_node.keys)\n\n        if not to_merge_node.is_leaf:\n            to_merge_node.children.extend(from_merge_node.children)\n\n        if parent_node == self.root and not parent_node.keys:\n            self.root = to_merge_node\n\n    def _remove_from_nonleaf_node(self, node: Node, key_index: int):\n        key = node.keys[key_index]\n        left_subtree = node.children[key_index]\n        if len(left_subtree.keys) > self.min_numbers_of_keys:\n            largest_key = self._find_largest_and_delete_in_left_subtree(\n                left_subtree)\n        elif len(node.children[key_index + 1].keys) > self.min_numbers_of_keys:\n            largest_key = self._find_largest_and_delete_in_right_subtree(\n                node.children[key_index + 1])\n        else:\n            self._merge(node, key_index, key_index + 1)\n            return self._remove_key(node, key)\n\n        node.keys[key_index] = largest_key\n\n    def _find_largest_and_delete_in_left_subtree(self, node: Node):\n        if node.is_leaf:\n            return node.keys.pop()\n        else:\n            ch_index = len(node.children) - 1\n            self._repair_tree(node, ch_index)\n            largest_key_in_subtree = self._find_largest_and_delete_in_left_subtree(\n                node.children[len(node.children) - 1])\n            # self._repair_tree(node, ch_index)\n            return largest_key_in_subtree\n\n    def _find_largest_and_delete_in_right_subtree(self, node: Node):\n        if node.is_leaf:\n            return node.keys.pop(0)\n        else:\n            ch_index = 0\n            self._repair_tree(node, ch_index)\n            largest_key_in_subtree = self._find_largest_and_delete_in_right_subtree(\n                node.children[0])\n            # self._repair_tree(node, ch_index)\n            return largest_key_in_subtree\n\n    def traverse_tree(self):\n        self._traverse_tree(self.root)\n        print()\n\n    def _traverse_tree(self, node: Node):\n        if node.is_leaf:\n            print(node.keys, end=\" \")\n        else:\n            for i, key in enumerate(node.keys):\n                self._traverse_tree(node.children[i])\n                print(key, end=\" \")\n            self._traverse_tree(node.children[-1])\n"
  },
  {
    "id": 297,
    "category": "tree",
    "file_name": "lowest_common_ancestor",
    "codes": "\"\"\"\nGiven a binary tree, find the lowest common ancestor\n(LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia:\n    \u201cThe lowest common ancestor is defined between two nodes\n    v and w as the lowest node in T that has both v and w as\n    descendants\n    (where we allow a node to be a descendant of itself).\u201d\n\n        _______3______\n       /              \\\n    ___5__          ___1__\n   /      \\        /      \\\n   6      _2       0       8\n         /  \\\n         7   4\nFor example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3.\nAnother example is LCA of nodes 5 and 4 is 5,\nsince a node can be a descendant of itself according to the LCA definition.\n\"\"\"\n\n\ndef lca(root, p, q):\n    \"\"\"\n    :type root: TreeNode\n    :type p: TreeNode\n    :type q: TreeNode\n    :rtype: TreeNode\n    \"\"\"\n    if root is None or root is p or root is q:\n        return root\n    left = lca(root.left, p, q)\n    right = lca(root.right, p, q)\n    if left is not None and right is not None:\n        return root\n    return left if left else right\n"
  },
  {
    "id": 298,
    "category": "tree",
    "file_name": "path_sum",
    "codes": "\"\"\"\nGiven a binary tree and a sum, determine if the tree has a root-to-leaf\npath such that adding up all the values along the path equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\nreturn true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.\n\"\"\"\n\n\ndef has_path_sum(root, sum):\n    \"\"\"\n    :type root: TreeNode\n    :type sum: int\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return False\n    if root.left is None and root.right is None and root.val == sum:\n        return True\n    sum -= root.val\n    return has_path_sum(root.left, sum) or has_path_sum(root.right, sum)\n\n\n# DFS with stack\ndef has_path_sum2(root, sum):\n    if root is None:\n        return False\n    stack = [(root, root.val)]\n    while stack:\n        node, val = stack.pop()\n        if node.left is None and node.right is None:\n            if val == sum:\n                return True\n        if node.left is not None:\n            stack.append((node.left, val+node.left.val))\n        if node.right is not None:\n            stack.append((node.right, val+node.right.val))\n    return False\n\n\n# BFS with queue\ndef has_path_sum3(root, sum):\n    if root is None:\n        return False\n    queue = [(root, sum-root.val)]\n    while queue:\n        node, val = queue.pop(0)  # popleft\n        if node.left is None and node.right is None:\n            if val == 0:\n                return True\n        if node.left is not None:\n            queue.append((node.left, val-node.left.val))\n        if node.right is not None:\n            queue.append((node.right, val-node.right.val))\n    return False\n"
  },
  {
    "id": 299,
    "category": "tree",
    "file_name": "deepest_left",
    "codes": "# Given a binary tree, find the deepest node\n# that is the left child of its parent node.\n\n# Example:\n\n     # 1\n   # /   \\\n  # 2     3\n # / \\     \\\n# 4   5     6\n           # \\\n            # 7\n# should return 4.\n\nfrom tree.tree import TreeNode\n\n\nclass DeepestLeft:\n    def __init__(self):\n        self.depth = 0\n        self.Node = None\n\n\ndef find_deepest_left(root, is_left, depth, res):\n    if not root:\n        return\n    if is_left and depth > res.depth:\n        res.depth = depth\n        res.Node = root\n    find_deepest_left(root.left, True, depth + 1, res)\n    find_deepest_left(root.right, False, depth + 1, res)\n\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.right = TreeNode(6)\n    root.right.right.right = TreeNode(7)\n\n    res = DeepestLeft()\n    find_deepest_left(root, True, 1, res)\n    if res.Node:\n        print(res.Node.val)\n"
  },
  {
    "id": 300,
    "category": "tree",
    "file_name": "construct_tree_postorder_preorder",
    "codes": "\"\"\"\n    Given two arrays representing preorder and postorder traversal of a full\n    binary tree, construct the binary tree and print the inorder traversal of the\n    tree.\n    A full binary tree has either 0 or 2 children.\n    Algorithm:\n        1. Assign the first element of preorder array as root of the tree.\n        2. Find the same element in the postorder array and divide the postorder\n            array into left and right subtree.\n        3. Repeat the above steps for all the elements and construct the tree.\n    Eg: pre[] = {1, 2, 4, 8, 9, 5, 3, 6, 7}\n        post[] = {8, 9, 4, 5, 2, 6, 7, 3, 1}\n        Tree:\n                1\n              /   \\\n             2     3\n            / \\   / \\\n           4   5 6   7\n          / \\\n         8   9\n      Output: 8 4 9 2 5 1 6 3 7\n\"\"\"\n\nclass TreeNode:\n\n    def __init__(self, val, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\npre_index = 0\n        \ndef construct_tree_util(pre: list, post: list, low: int, high: int, size: int):\n    \"\"\"\n        Recursive function that constructs tree from preorder and postorder array.\n        \n        preIndex is a global variable that keeps track of the index in preorder\n        array.\n        preorder and postorder array are represented are pre[] and post[] respectively.\n        low and high are the indices for the postorder array.\n    \"\"\"\n\n    global pre_index\n\n    if pre_index == -1:\n        pre_index = 0\n  \n    \n    #Base case\n    if(pre_index >= size or low > high):\n        return None\n\n    root = TreeNode(pre[pre_index])\n    pre_index += 1\n\n    #If only one element in the subarray return root\n    if(low == high or pre_index >= size):\n        return root\n\n    #Find the next element of pre[] in post[]\n    i = low\n    while i <= high:\n        if(pre[pre_index] == post[i]):\n            break\n\n        i += 1\n\n    #Use index of element present in postorder to divide postorder array\n    #to two parts: left subtree and right subtree\n    if(i <= high):\n        root.left = construct_tree_util(pre, post, low, i, size)\n        root.right = construct_tree_util(pre, post, i+1, high, size)\n\n    return root\n\n\ndef construct_tree(pre: list, post: list, size: int):\n    \"\"\"\n        Main Function that will construct the full binary tree from given preorder\n        and postorder array.\n    \"\"\"\n\n    global pre_index\n    root = construct_tree_util(pre, post, 0, size-1, size)\n\n    return print_inorder(root)\n\n\n\ndef print_inorder(root: TreeNode, result = None):\n    \"\"\"\n        Prints the tree constructed in inorder format\n    \"\"\"\n    if root is None:\n        return []\n    if result is None: \n        result = []\n        \n    print_inorder(root.left, result)\n    result.append(root.val)\n    print_inorder(root.right, result)\n    return result\n\nif __name__ == '__main__':\n    pre = [1, 2, 4, 5, 3, 6, 7]\n    post = [4, 5, 2, 6, 7, 3, 1]\n    size = len(pre)\n\n    result = construct_tree(pre, post, size)\n\n    print(result)\n"
  },
  {
    "id": 301,
    "category": "tree",
    "file_name": "max_height",
    "codes": "\"\"\"\nGiven a binary tree, find its maximum depth.\n\nThe maximum depth is the number of nodes along the\nlongest path from the root node down to the farthest leaf node.\n\"\"\"\n\n# def max_height(root):\n#     if not root:\n#         return 0\n#     return max(maxDepth(root.left), maxDepth(root.right)) + 1\n\n# iterative\n\nfrom tree import TreeNode\n\n\ndef max_height(root):\n    if root is None:\n        return 0\n    height = 0\n    queue = [root]\n    while queue:\n        height += 1\n        level = []\n        while queue:\n            node = queue.pop(0)\n            if node.left is not None:\n                level.append(node.left)\n            if node.right is not None:\n                level.append(node.right)\n        queue = level\n    return height\n\n\ndef print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)\n\n\nif __name__ == '__main__':\n    tree = TreeNode(10)\n    tree.left = TreeNode(12)\n    tree.right = TreeNode(15)\n    tree.left.left = TreeNode(25)\n    tree.left.left.right = TreeNode(100)\n    tree.left.right = TreeNode(30)\n    tree.right.left = TreeNode(36)\n\n    height = max_height(tree)\n    print_tree(tree)\n    print(\"height:\", height)\n"
  },
  {
    "id": 302,
    "category": "tree",
    "file_name": "max_path_sum",
    "codes": "def max_path_sum(root):\n    maximum = float(\"-inf\")\n    helper(root, maximum)\n    return maximum\n\n\ndef helper(root, maximum):\n    if root is None:\n        return 0\n    left = helper(root.left, maximum)\n    right = helper(root.right, maximum)\n    maximum = max(maximum, left+right+root.val)\n    return root.val + maximum\n"
  },
  {
    "id": 303,
    "category": "tree",
    "file_name": "pretty_print",
    "codes": "# a -> Adam -> Book -> 4\n# b -> Bill -> Computer -> 5\n#           -> TV -> 6\n#      Jill -> Sports -> 1\n# c -> Bill -> Sports -> 3\n# d -> Adam -> Computer -> 3\n#      Quin -> Computer -> 3\n# e -> Quin -> Book -> 5\n#           -> TV -> 2\n# f -> Adam -> Computer -> 7\n\nfrom __future__ import print_function\n\n\ndef tree_print(tree):\n    for key in tree:\n        print(key, end=' ')  # end=' ' prevents a newline character\n        tree_element = tree[key]  # multiple lookups is expensive, even amortized O(1)!\n        for subElem in tree_element:\n            print(\" -> \", subElem, end=' ')\n            if type(subElem) != str:  # OP wants indenting after digits\n                print(\"\\n \")  # newline and a space to match indenting\n        print()  # forces a newline\n"
  },
  {
    "id": 304,
    "category": "tree",
    "file_name": "is_balanced",
    "codes": "def is_balanced(root):\n    return __is_balanced_recursive(root)\n\n\ndef __is_balanced_recursive(root):\n    \"\"\"\n    O(N) solution\n    \"\"\"\n    return -1 != __get_depth(root)\n\n\ndef __get_depth(root):\n    \"\"\"\n    return 0 if unbalanced else depth + 1\n    \"\"\"\n    if root is None:\n        return 0\n    left = __get_depth(root.left)\n    right = __get_depth(root.right)\n    if abs(left-right) > 1 or -1 in [left, right]:\n        return -1\n    return 1 + max(left, right)\n\n\n# def is_balanced(root):\n#     \"\"\"\n#     O(N^2) solution\n#     \"\"\"\n#     left = max_height(root.left)\n#     right = max_height(root.right)\n#     return abs(left-right) <= 1 and is_balanced(root.left) and\n#     is_balanced(root.right)\n\n# def max_height(root):\n#     if root is None:\n#         return 0\n#     return max(max_height(root.left), max_height(root.right)) + 1\n"
  },
  {
    "id": 305,
    "category": "fenwick_tree",
    "file_name": "fenwick_tree",
    "codes": "\"\"\"\nFenwick Tree / Binary Indexed Tree\n\nConsider we have an array arr[0 . . . n-1]. We would like to\n1. Compute the sum of the first i elements.\n2. Modify the value of a specified element of the array arr[i] = x where 0 <= i <= n-1.\n\nA simple solution is to run a loop from 0 to i-1 and calculate the sum of the elements. To update a value, simply do arr[i] = x.\nThe first operation takes O(n) time and the second operation takes O(1) time.\nAnother simple solution is to create an extra array and store the sum of the first i-th elements at the i-th index in this new array.\nThe sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now.\nThis works well if there are a large number of query operations but a very few number of update operations.\n\n\nThere are two solutions that can perform both the query and update operations in O(logn) time.\n1. Fenwick Tree\n2. Segment Tree\n\nCompared with Segment Tree, Binary Indexed Tree requires less space and is easier to implement.\n\"\"\"\n\nclass Fenwick_Tree(object):\n    def __init__(self, freq):\n        self.arr = freq\n        self.n = len(freq)\n        \n    def get_sum(self, bit_tree, i):\n        \"\"\"\n             Returns sum of arr[0..index]. This function assumes that the array is preprocessed and partial sums of array elements are stored in bit_tree[]. \n        \"\"\"\n\n        s = 0\n      \n        # index in bit_tree[] is 1 more than the index in arr[] \n        i = i+1\n      \n        # Traverse ancestors of bit_tree[index] \n        while i > 0: \n      \n            # Add current element of bit_tree to sum \n            s += bit_tree[i] \n      \n            # Move index to parent node in getSum View \n            i -= i & (-i) \n        return s \n      \n    def update_bit(self, bit_tree, i, v):\n        \"\"\"\n             Updates a node in Binary Index Tree (bit_tree) at given index in bit_tree. The given value 'val' is added to bit_tree[i] and all of its ancestors in tree. \n        \"\"\"\n      \n        # index in bit_ree[] is 1 more than the index in arr[] \n        i += 1\n      \n        # Traverse all ancestors and add 'val' \n        while i <= self.n: \n      \n            # Add 'val' to current node of bit_tree \n            bit_tree[i] += v \n      \n            # Update index to that of parent in update View \n            i += i & (-i) \n      \n      \n    def construct(self):\n        \"\"\"\n             Constructs and returns a Binary Indexed Tree for given array of size n. \n        \"\"\"\n      \n        # Create and initialize bit_ree[] as 0 \n        bit_tree = [0]*(self.n+1) \n      \n        # Store the actual values in bit_ree[] using update() \n        for i in range(self.n): \n            self.update_bit(bit_tree, i, self.arr[i]) \n\n        return bit_tree \n"
  },
  {
    "id": 306,
    "category": "segment_tree",
    "file_name": "segment_tree",
    "codes": "'''\nSegment_tree creates a segment tree with a given array and function,\nallowing queries to be done later in log(N) time\nfunction takes 2 values and returns a same type value\n'''\nclass SegmentTree:\n    def __init__(self,arr,function):\n        self.segment = [0 for x in range(3*len(arr)+3)]\n        self.arr = arr\n        self.fn = function\n        self.make_tree(0,0,len(arr)-1)\n\n    def make_tree(self,i,l,r):\n        if l==r:\n            self.segment[i] = self.arr[l]\n        elif l<r:\n            self.make_tree(2*i+1,l,int((l+r)/2))\n            self.make_tree(2*i+2,int((l+r)/2)+1,r)\n            self.segment[i] = self.fn(self.segment[2*i+1],self.segment[2*i+2])\n\n    def __query(self,i,L,R,l,r):\n        if l>R or r<L or L>R or l>r:\n            return None\n        if L>=l and R<=r:\n            return self.segment[i]\n        val1 = self.__query(2*i+1,L,int((L+R)/2),l,r)\n        val2 = self.__query(2*i+2,int((L+R+2)/2),R,l,r)\n        print(L,R,\" returned \",val1,val2)\n        if val1 != None:\n            if val2 != None:\n                return self.fn(val1,val2)\n            return val1\n        return val2\n        \n\n    def query(self,L,R):\n        return self.__query(0,0,len(self.arr)-1,L,R)\n\n'''\nExample -\nmytree = SegmentTree([2,4,5,3,4],max)\nmytree.query(2,4)\nmytree.query(0,3) ...\n\nmytree = SegmentTree([4,5,2,3,4,43,3],sum)\nmytree.query(1,8)\n...\n\n'''\n"
  },
  {
    "id": 307,
    "category": "segment_tree",
    "file_name": "iterative_segment_tree",
    "codes": "\"\"\"\nSegmentTree creates a segment tree with a given array and a \"commutative\" function,\nthis non-recursive version uses less memory than the recursive version and include:\n1. range queries in log(N) time\n2. update an element in log(N) time\nthe function should be commutative and takes 2 values and returns the same type value\n\nExamples -\nmytree = SegmentTree([2, 4, 5, 3, 4],max)\nprint(mytree.query(2, 4))\nmytree.update(3, 6)\nprint(mytree.query(0, 3)) ...\n\nmytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b)\nprint(mytree.query(0, 6))\nmytree.update(2, -10)\nprint(mytree.query(0, 6)) ...\n\nmytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1]))\nprint(mytree.query(0, 2))\nmytree.update(2, (-1, 2))\nprint(mytree.query(0, 2)) ...\n\"\"\"\n\n\nclass SegmentTree:\n    def __init__(self, arr, function):\n        self.tree = [None for _ in range(len(arr))] + arr\n        self.size = len(arr)\n        self.fn = function\n        self.build_tree()\n\n    def build_tree(self):\n        for i in range(self.size - 1, 0, -1):\n            self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])\n\n    def update(self, p, v):\n        p += self.size\n        self.tree[p] = v\n        while p > 1:\n            p = p // 2\n            self.tree[p] = self.fn(self.tree[p * 2], self.tree[p * 2 + 1])\n\n    def query(self, l, r):\n        l, r = l + self.size, r + self.size\n        res = None\n        while l <= r:\n            if l % 2 == 1:\n                res = self.tree[l] if res is None else self.fn(res, self.tree[l])\n            if r % 2 == 0:\n                res = self.tree[r] if res is None else self.fn(res, self.tree[r])\n            l, r = (l + 1) // 2, (r - 1) // 2\n        return res\n"
  },
  {
    "id": 308,
    "category": "traversal",
    "file_name": "postorder",
    "codes": "'''\nTime complexity : O(n)\n'''\n\nclass Node:\n\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef postorder(root):\n    res_temp = []\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res_temp.append(root.val)\n        if root.left:\n            stack.append(root.left)\n        if root.right:\n            stack.append(root.right)\n    while res_temp:\n        res.append(res_temp.pop())\n    return res\n\n# Recursive Implementation\ndef postorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    postorder_rec(root.left, res)\n    postorder_rec(root.right, res)\n    res.append(root.val)\n    return res\n\n"
  },
  {
    "id": 309,
    "category": "traversal",
    "file_name": "preorder",
    "codes": "'''\nTime complexity : O(n)\n'''\n\n\nclass Node:\n    \"\"\" This is a class of Node \"\"\"\n\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef preorder(root):\n    \"\"\" Function to Preorder \"\"\"\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res.append(root.val)\n        if root.right:\n            stack.append(root.right)\n        if root.left:\n            stack.append(root.left)\n    return res\n\ndef preorder_rec(root, res=None):\n    \"\"\" Recursive Implementation \"\"\"\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    res.append(root.val)\n    preorder_rec(root.left, res)\n    preorder_rec(root.right, res)\n    return res\n"
  },
  {
    "id": 310,
    "category": "traversal",
    "file_name": "inorder",
    "codes": "'''\nTime complexity : O(n)\n'''\n\n\nclass Node:\n\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef inorder(root):\n    \"\"\" In order function \"\"\"\n    res = []\n    if not root:\n        return res\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        res.append(root.val)\n        root = root.right\n    return res\n\ndef inorder_rec(root, res=None):\n    \"\"\" Recursive Implementation \"\"\"\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    inorder_rec(root.left, res)\n    res.append(root.val)\n    inorder_rec(root.right, res)\n    return res\n\n\nif __name__ == '__main__':\n    n1 = Node(100)\n    n2 = Node(50)\n    n3 = Node(150)\n    n4 = Node(25)\n    n5 = Node(75)\n    n6 = Node(125)\n    n7 = Node(175)\n    n1.left, n1.right = n2, n3\n    n2.left, n2.right = n4, n5\n    n3.left, n3.right = n6, n7\n\n    assert inorder(n1) == [25, 50, 75, 100, 125, 150, 175]\n    assert inorder_rec(n1) == [25, 50, 75, 100, 125, 150, 175]\n"
  },
  {
    "id": 311,
    "category": "traversal",
    "file_name": "zigzag",
    "codes": "\"\"\"\nGiven a binary tree, return the zigzag level order traversal\nof its nodes' values.\n(ie, from left to right, then right to left\nfor the next level and alternate between).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its zigzag level order traversal as:\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n\"\"\"\n\n\ndef zigzag_level(root):\n    res = []\n    if not root:\n        return res\n    level = [root]\n    flag = 1\n    while level:\n        current = []\n        new_level = []\n        for node in level:\n            current.append(node.val)\n            if node.left:\n                new_level.append(node.left)\n            if node.right:\n                new_level.append(node.right)\n        level = new_level\n        res.append(current[::flag])\n        flag *= -1\n    return res\n"
  },
  {
    "id": 312,
    "category": "traversal",
    "file_name": "level_order",
    "codes": "\"\"\"\nGiven a binary tree, return the level order traversal of\nits nodes' values. (ie, from left to right, level by level).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\"\"\"\n\n\ndef level_order(root):\n    ans = []\n    if not root:\n        return ans\n    level = [root]\n    while level:\n        current = []\n        new_level = []\n        for node in level:\n            current.append(node.val)\n            if node.left:\n                new_level.append(node.left)\n            if node.right:\n                new_level.append(node.right)\n        level = new_level\n        ans.append(current)\n    return ans\n"
  },
  {
    "id": 313,
    "category": "avl",
    "file_name": "avl",
    "codes": "\"\"\" Imports TreeNodes\"\"\"\nfrom tree.tree import TreeNode\n\n\nclass AvlTree(object):\n    \"\"\"\n    An avl tree.\n    \"\"\"\n\n    def __init__(self):\n        # Root node of the tree.\n        self.node = None\n        self.height = -1\n        self.balance = 0\n\n    def insert(self, key):\n        \"\"\"\n        Insert new key into node\n        \"\"\"\n        # Create new node\n        node = TreeNode(key)\n        if not self.node:\n            self.node = node\n            self.node.left = AvlTree()\n            self.node.right = AvlTree()\n        elif key < self.node.val:\n            self.node.left.insert(key)\n        elif key > self.node.val:\n            self.node.right.insert(key)\n        self.re_balance()\n\n    def re_balance(self):\n        \"\"\"\n        Re balance tree. After inserting or deleting a node,\n        \"\"\"\n        self.update_heights(recursive=False)\n        self.update_balances(False)\n\n        while self.balance < -1 or self.balance > 1:\n            if self.balance > 1:\n                if self.node.left.balance < 0:\n                    self.node.left.rotate_left()\n                    self.update_heights()\n                    self.update_balances()\n                self.rotate_right()\n                self.update_heights()\n                self.update_balances()\n\n            if self.balance < -1:\n                if self.node.right.balance > 0:\n                    self.node.right.rotate_right()\n                    self.update_heights()\n                    self.update_balances()\n                self.rotate_left()\n                self.update_heights()\n                self.update_balances()\n\n    def update_heights(self, recursive=True):\n        \"\"\"\n        Update tree height\n        \"\"\"\n        if self.node:\n            if recursive:\n                if self.node.left:\n                    self.node.left.update_heights()\n                if self.node.right:\n                    self.node.right.update_heights()\n\n            self.height = 1 + max(self.node.left.height,\n                                  self.node.right.height)\n        else:\n            self.height = -1\n\n    def update_balances(self, recursive=True):\n        \"\"\"\n        Calculate tree balance factor\n\n        \"\"\"\n        if self.node:\n            if recursive:\n                if self.node.left:\n                    self.node.left.update_balances()\n                if self.node.right:\n                    self.node.right.update_balances()\n\n            self.balance = self.node.left.height - self.node.right.height\n        else:\n            self.balance = 0\n\n    def rotate_right(self):\n        \"\"\"\n        Right rotation\n        \"\"\"\n        new_root = self.node.left.node\n        new_left_sub = new_root.right.node\n        old_root = self.node\n\n        self.node = new_root\n        old_root.left.node = new_left_sub\n        new_root.right.node = old_root\n\n    def rotate_left(self):\n        \"\"\"\n        Left rotation\n        \"\"\"\n        new_root = self.node.right.node\n        new_left_sub = new_root.left.node\n        old_root = self.node\n\n        self.node = new_root\n        old_root.right.node = new_left_sub\n        new_root.left.node = old_root\n\n    def in_order_traverse(self):\n        \"\"\"\n        In-order traversal of the tree\n        \"\"\"\n        result = []\n\n        if not self.node:\n            return result\n\n        result.extend(self.node.left.in_order_traverse())\n        result.append(self.node.key)\n        result.extend(self.node.right.in_order_traverse())\n        return result\n"
  },
  {
    "id": 314,
    "category": "red_black_tree",
    "file_name": "red_black_tree",
    "codes": "\"\"\"\nImplementation of Red-Black tree.\n\"\"\"\n\n\nclass RBNode:\n    def __init__(self, val, is_red, parent=None, left=None, right=None):\n        self.val = val\n        self.parent = parent\n        self.left = left\n        self.right = right\n        self.color = is_red\n\n\nclass RBTree:\n    def __init__(self):\n        self.root = None\n\n    def left_rotate(self, node):\n        # set the node as the left child node of the current node's right node\n        right_node = node.right\n        if right_node is None:\n            return\n        else:\n            # right node's left node become the right node of current node\n            node.right = right_node.left\n            if right_node.left is not None:\n                right_node.left.parent = node\n            right_node.parent = node.parent\n            # check the parent case\n            if node.parent is None:\n                self.root = right_node\n            elif node is node.parent.left:\n                node.parent.left = right_node\n            else:\n                node.parent.right = right_node\n            right_node.left = node\n            node.parent = right_node\n\n    def right_rotate(self, node):\n        # set the node as the right child node of the current node's left node\n        left_node = node.left\n        if left_node is None:\n            return\n        else:\n            # left node's right  node become the left node of current node\n            node.left = left_node.right\n            if left_node.right is not None:\n                left_node.right.parent = node\n            left_node.parent = node.parent\n            # check the parent case\n            if node.parent is None:\n                self.root = left_node\n            elif node is node.parent.left:\n                node.parent.left = left_node\n            else:\n                node.parent.right = left_node\n            left_node.right = node\n            node.parent = left_node\n\n    def insert(self, node):\n        # the inserted node's color is default is red\n        root = self.root\n        insert_node_parent = None\n        # find the position of inserted node\n        while root is not None:\n            insert_node_parent = root\n            if insert_node_parent.val < node.val:\n                root = root.right\n            else:\n                root = root.left\n        # set the n ode's parent node\n        node.parent = insert_node_parent\n        if insert_node_parent is None:\n            # case 1  inserted tree is null\n            self.root = node\n        elif insert_node_parent.val > node.val:\n            # case 2 not null and find left or right\n            insert_node_parent.left = node\n        else:\n            insert_node_parent.right = node\n        node.left = None\n        node.right = None\n        node.color = 1\n        # fix the tree to \n        self.fix_insert(node)\n\n    def fix_insert(self, node):\n        # case 1 the parent is null, then set the inserted node as root and color = 0\n        if node.parent is None:\n            node.color = 0\n            self.root = node\n            return\n            # case 2 the parent color is black, do nothing\n        # case 3 the parent color is red\n        while node.parent and node.parent.color == 1:\n            if node.parent is node.parent.parent.left:\n                uncle_node = node.parent.parent.right\n                if uncle_node and uncle_node.color == 1:\n                    # case 3.1 the uncle node is red\n                    # then set parent and uncle color is black and grandparent is red\n                    # then node => node.parent\n                    node.parent.color = 0\n                    node.parent.parent.right.color = 0\n                    node.parent.parent.color = 1\n                    node = node.parent.parent\n                    continue\n                elif node is node.parent.right:\n                    # case 3.2 the uncle node is black or null, and the node is right of parent\n                    # then set his parent node is current node\n                    # left rotate the node and continue the next\n                    node = node.parent\n                    self.left_rotate(node)\n                # case 3.3 the uncle node is black and parent node is left\n                # then parent node set black and grandparent set red\n                node.parent.color = 0\n                node.parent.parent.color = 1\n                self.right_rotate(node.parent.parent)\n            else:\n                uncle_node = node.parent.parent.left\n                if uncle_node and uncle_node.color == 1:\n                    # case 3.1 the uncle node is red\n                    # then set parent and uncle color is black and grandparent is red\n                    # then node => node.parent\n                    node.parent.color = 0\n                    node.parent.parent.left.color = 0\n                    node.parent.parent.color = 1\n                    node = node.parent.parent\n                    continue\n                elif node is node.parent.left:\n                    # case 3.2 the uncle node is black or null, and the node is right of parent\n                    # then set his parent node is current node\n                    # left rotate the node and continue the next\n                    node = node.parent\n                    self.right_rotate(node)\n                # case 3.3 the uncle node is black and parent node is left\n                # then parent node set black and grandparent set red\n                node.parent.color = 0\n                node.parent.parent.color = 1\n                self.left_rotate(node.parent.parent)\n        self.root.color = 0\n\n    def transplant(self, node_u, node_v):\n        \"\"\"\n        replace u with v\n        :param node_u: replaced node\n        :param node_v: \n        :return: None\n        \"\"\"\n        if node_u.parent is None:\n            self.root = node_v\n        elif node_u is node_u.parent.left:\n            node_u.parent.left = node_v\n        elif node_u is node_u.parent.right:\n            node_u.parent.right = node_v\n        # check is node_v is None \n        if node_v:\n            node_v.parent = node_u.parent\n\n    def maximum(self, node):\n        \"\"\"\n        find the max node when node regard as a root node   \n        :param node: \n        :return: max node \n        \"\"\"\n        temp_node = node\n        while temp_node.right is not None:\n            temp_node = temp_node.right\n        return temp_node\n\n    def minimum(self, node):\n        \"\"\"\n        find the minimum node when node regard as a root node   \n        :param node:\n        :return: minimum node \n        \"\"\"\n        temp_node = node\n        while temp_node.left:\n            temp_node = temp_node.left\n        return temp_node\n\n    def delete(self, node):\n        # find the node position\n        node_color = node.color\n        if node.left is None:\n            temp_node = node.right\n            self.transplant(node, node.right)\n        elif node.right is None:\n            temp_node = node.left\n            self.transplant(node, node.left)\n        else:\n            # both child exits ,and find minimum child of right child\n            node_min = self.minimum(node.right)\n            node_color = node_min.color\n            temp_node = node_min.right\n            ## \n            if node_min.parent is not node:\n                self.transplant(node_min, node_min.right)\n                node_min.right = node.right\n                node_min.right.parent = node_min\n            self.transplant(node, node_min)\n            node_min.left = node.left\n            node_min.left.parent = node_min\n            node_min.color = node.color\n        # when node is black, then need to fix it with 4 cases\n        if node_color == 0:\n            self.delete_fixup(temp_node)\n\n    def delete_fixup(self, node):\n        # 4 cases\n        while node is not self.root and node.color == 0:\n            # node is not root and color is black\n            if node is node.parent.left:\n                # node is left node\n                node_brother = node.parent.right\n\n                # case 1: node's red, can not get black node\n                # set brother is black and parent is red \n                if node_brother.color == 1:\n                    node_brother.color = 0\n                    node.parent.color = 1\n                    self.left_rotate(node.parent)\n                    node_brother = node.parent.right\n\n                # case 2: brother node is black, and its children node is both black\n                if (node_brother.left is None or node_brother.left.color == 0) and (\n                                node_brother.right is None or node_brother.right.color == 0):\n                    node_brother.color = 1\n                    node = node.parent\n                else:\n\n                    # case 3: brother node is black , and its left child node is red and right is black\n                    if node_brother.right is None or node_brother.right.color == 0:\n                        node_brother.color = 1\n                        node_brother.left.color = 0\n                        self.right_rotate(node_brother)\n                        node_brother = node.parent.right\n\n                    # case 4: brother node is black, and right is red, and left is any color\n                    node_brother.color = node.parent.color\n                    node.parent.color = 0\n                    node_brother.right.color = 0\n                    self.left_rotate(node.parent)\n                    node = self.root\n            else:\n                node_brother = node.parent.left\n                if node_brother.color == 1:\n                    node_brother.color = 0\n                    node.parent.color = 1\n                    self.left_rotate(node.parent)\n                    node_brother = node.parent.right\n                if (node_brother.left is None or node_brother.left.color == 0) and (\n                                node_brother.right is None or node_brother.right.color == 0):\n                    node_brother.color = 1\n                    node = node.parent\n                else:\n                    if node_brother.left is None or node_brother.left.color == 0:\n                        node_brother.color = 1\n                        node_brother.right.color = 0\n                        self.left_rotate(node_brother)\n                        node_brother = node.parent.left\n                    node_brother.color = node.parent.color\n                    node.parent.color = 0\n                    node_brother.left.color = 0\n                    self.right_rotate(node.parent)\n                    node = self.root\n        node.color = 0\n\n    def inorder(self):\n        res = []\n        if not self.root:\n            return res\n        stack = []\n        root = self.root\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            res.append({'val': root.val, 'color': root.color})\n            root = root.right\n        return res\n\n\nif __name__ == \"__main__\":\n    rb = RBTree()\n    children = [11, 2, 14, 1, 7, 15, 5, 8, 4]\n    for child in children:\n        node = RBNode(child, 1)\n        print(child)\n        rb.insert(node)\n    print(rb.inorder())\n"
  },
  {
    "id": 315,
    "category": "trie",
    "file_name": "trie",
    "codes": "\"\"\"\nImplement a trie with insert, search, and startsWith methods.\n\nNote:\nYou may assume that all inputs are consist of lowercase letters a-z.\n\"\"\"\nimport collections\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.is_word = False\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current = self.root\n        for letter in word:\n            current = current.children[letter]\n        current.is_word = True\n\n    def search(self, word):\n        current = self.root\n        for letter in word:\n            current = current.children.get(letter)\n            if current is None:\n                return False\n        return current.is_word\n\n    def starts_with(self, prefix):\n        current = self.root\n        for letter in prefix:\n            current = current.children.get(letter)\n            if current is None:\n                return False\n        return True\n\n"
  },
  {
    "id": 316,
    "category": "trie",
    "file_name": "add_and_search",
    "codes": "\"\"\"\nWe are asked to design an efficient data structure\nthat allows us to add and search for words.\nThe search can be a literal word or regular expression\ncontaining \u201c.\u201d, where \u201c.\u201d can be any letter.\n\nExample:\naddWord(\u201cbad\u201d)\naddWord(\u201cdad\u201d)\naddWord(\u201cmad\u201d)\nsearch(\u201cpad\u201d) -> false\nsearch(\u201cbad\u201d) -> true\nsearch(\u201c.ad\u201d) -> true\nsearch(\u201cb..\u201d) -> true\n\"\"\"\nimport collections\n\nclass TrieNode(object):\n    def __init__(self, letter, is_terminal=False):\n        self.children = dict()\n        self.letter = letter\n        self.is_terminal = is_terminal\n\nclass WordDictionary(object):\n    def __init__(self):\n        self.root = TrieNode(\"\")\n\n    def add_word(self, word):\n        cur = self.root\n        for letter in word:\n            if letter not in cur.children:\n                cur.children[letter] = TrieNode(letter)\n            cur = cur.children[letter]\n        cur.is_terminal = True\n\n    def search(self, word, node=None):\n        cur = node\n        if not cur:\n            cur = self.root\n        for i, letter in enumerate(word):\n            # if dot\n            if letter == \".\":\n                if i == len(word) - 1: # if last character\n                    for child in cur.children.itervalues():\n                        if child.is_terminal:\n                            return True\n                    return False\n                for child in cur.children.itervalues():\n                    if self.search(word[i+1:], child) == True:\n                        return True\n                return False\n            # if letter\n            if letter not in cur.children:\n                return False\n            cur = cur.children[letter]\n        return cur.is_terminal\n\nclass WordDictionary2(object):\n    def __init__(self):\n        self.word_dict = collections.defaultdict(list)\n\n\n    def add_word(self, word):\n        if word:\n            self.word_dict[len(word)].append(word)\n\n    def search(self, word):\n        if not word:\n            return False\n        if '.' not in word:\n            return word in self.word_dict[len(word)]\n        for v in self.word_dict[len(word)]:\n            # match xx.xx.x with yyyyyyy\n            for i, ch in enumerate(word):\n                if ch != v[i] and ch != '.':\n                    break\n            else:\n                return True\n        return False\n"
  },
  {
    "id": 317,
    "category": "bst",
    "file_name": "array_to_bst",
    "codes": "\"\"\"\nGiven an array where elements are sorted in ascending order,\nconvert it to a height balanced BST.\n\"\"\"\n\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\ndef array_to_bst(nums):\n    if not nums:\n        return None\n    mid = len(nums)//2\n    node = TreeNode(nums[mid])\n    node.left = array_to_bst(nums[:mid])\n    node.right = array_to_bst(nums[mid+1:])\n    return node\n"
  },
  {
    "id": 318,
    "category": "bst",
    "file_name": "bst",
    "codes": "\"\"\"\nImplement Binary Search Tree. It has method:\n    1. Insert\n    2. Search\n    3. Size\n    4. Traversal (Preorder, Inorder, Postorder)\n\"\"\"\n\nimport unittest\n\nclass Node(object):\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BST(object):\n    def __init__(self):\n        self.root = None\n\n    def get_root(self):\n        return self.root\n\n    \"\"\"\n        Get the number of elements\n        Using recursion. Complexity O(logN)\n    \"\"\"\n    def size(self):\n        return self.recur_size(self.root)\n\n    def recur_size(self, root):\n        if root is None:\n            return 0\n        else:\n            return 1 + self.recur_size(root.left) + self.recur_size(root.right)\n\n    \"\"\"\n        Search data in bst\n        Using recursion. Complexity O(logN)\n    \"\"\"\n    def search(self, data):\n        return self.recur_search(self.root, data)\n\n    def recur_search(self, root, data):\n        if root is None:\n            return False\n        if root.data == data:\n            return True\n        elif data > root.data:     # Go to right root\n            return self.recur_search(root.right, data)\n        else:                      # Go to left root\n            return self.recur_search(root.left, data)\n\n    \"\"\"\n        Insert data in bst\n        Using recursion. Complexity O(logN)\n    \"\"\"\n    def insert(self, data):\n        if self.root:\n            return self.recur_insert(self.root, data)\n        else:\n            self.root = Node(data)\n            return True\n\n    def recur_insert(self, root, data):\n        if root.data == data:      # The data is already there\n            return False\n        elif data < root.data:     # Go to left root\n            if root.left:          # If left root is a node\n                return self.recur_insert(root.left, data)\n            else:                  # left root is a None\n                root.left = Node(data)\n                return True\n        else:                      # Go to right root\n            if root.right:         # If right root is a node\n                return self.recur_insert(root.right, data)\n            else:\n                root.right = Node(data)\n                return True\n\n    \"\"\"\n        Preorder, Postorder, Inorder traversal bst\n    \"\"\"\n    def preorder(self, root):\n        if root:\n            print(str(root.data), end = ' ')\n            self.preorder(root.left)\n            self.preorder(root.right)\n\n    def inorder(self, root):\n        if root:\n            self.inorder(root.left)\n            print(str(root.data), end = ' ')\n            self.inorder(root.right)\n\n    def postorder(self, root):\n        if root:\n            self.postorder(root.left)\n            self.postorder(root.right)\n            print(str(root.data), end = ' ')\n\n\"\"\"\n    The tree is created for testing:\n\n                    10\n                 /      \\\n               6         15\n              / \\       /   \\\n            4     9   12      24\n                 /          /    \\\n                7         20      30\n                         /\n                       18\n\"\"\"\n\nclass TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.tree = BST()\n        self.tree.insert(10)\n        self.tree.insert(15)\n        self.tree.insert(6)\n        self.tree.insert(4)\n        self.tree.insert(9)\n        self.tree.insert(12)\n        self.tree.insert(24)\n        self.tree.insert(7)\n        self.tree.insert(20)\n        self.tree.insert(30)\n        self.tree.insert(18)\n\n    def test_search(self):\n        self.assertTrue(self.tree.search(24))\n        self.assertFalse(self.tree.search(50))\n\n    def test_size(self):\n        self.assertEqual(11, self.tree.size())\n\nif __name__ == '__main__':\n    unittest.main()\n"
  },
  {
    "id": 319,
    "category": "bst",
    "file_name": "depth_sum",
    "codes": "\"\"\"\nWrite a function depthSum returns the sum of the values stored\nin a binary search tree of integers weighted by the depth of each value.\n\nFor example:\n\n                    9\n                 /      \\\n               6         12\n              / \\       /   \\\n            3     8   10      15\n                 /              \\\n                7                18\n\n    depth_sum = 1*9 + 2*(6+12) + 3*(3+8+10+15) + 4*(7+18)\n\n\"\"\"\nimport unittest\nfrom bst import Node\nfrom bst import bst\n\ndef depth_sum(root, n):\n    if root:\n        return recur_depth_sum(root, 1)\n\ndef recur_depth_sum(root, n):\n    if root is None:\n        return 0\n    elif root.left is None and root.right is None:\n        return root.data * n\n    else:\n        return n * root.data + recur_depth_sum(root.left, n+1) + recur_depth_sum(root.right, n+1)\n\n\"\"\"\n    The tree is created for testing:\n\n                    9\n                 /      \\\n               6         12\n              / \\       /   \\\n            3     8   10      15\n                 /              \\\n                7                18\n\n    depth_sum = 1*9 + 2*(6+12) + 3*(3+8+10+15) + 4*(7+18)\n\n\"\"\"\n\nclass TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.tree = bst()\n        self.tree.insert(9)\n        self.tree.insert(6)\n        self.tree.insert(12)\n        self.tree.insert(3)\n        self.tree.insert(8)\n        self.tree.insert(10)\n        self.tree.insert(15)\n        self.tree.insert(7)\n        self.tree.insert(18)\n\n    def test_depth_sum(self):\n        self.assertEqual(253, depth_sum(self.tree.root, 4))\n\nif __name__ == '__main__':\n    unittest.main()\n"
  },
  {
    "id": 320,
    "category": "bst",
    "file_name": "num_empty",
    "codes": "\"\"\"\nWrite a function num_empty returns returns the number of empty branches in a\ntree. Function should count the total number of empty branches among the nodes\nof the tree. A leaf node has two empty branches. In the case, if root is None,\nit considered as a 1 empty branch\nFor example: the following tree has 10 empty branch (* is empty branch)\n\n                    9 __\n                 /      \\___\n               6            12\n              / \\          /   \\\n            3     8       10      15\n          /  \\   / \\     /  \\    /   \\\n         *    * 7   *   *    *  *    18\n               / \\                   /  \\\n              *   *                 *    *\n\n    empty_branch = 10\n\n\"\"\"\nimport unittest\nfrom bst import Node\nfrom bst import bst\n\ndef num_empty(root):\n    if root is None:\n        return 1\n    elif root.left is None and root.right:\n        return 1 + num_empty(root.right)\n    elif root.right is None and root.left:\n        return 1 + num_empty(root.left)\n    else:\n        return num_empty(root.left) + num_empty(root.right)\n\n\"\"\"\n    The tree is created for testing:\n\n                    9\n                 /      \\\n               6         12\n              / \\       /   \\\n            3     8   10      15\n                 /              \\\n                7                18\n\n    num_empty = 10\n\n\"\"\"\n\nclass TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.tree = bst()\n        self.tree.insert(9)\n        self.tree.insert(6)\n        self.tree.insert(12)\n        self.tree.insert(3)\n        self.tree.insert(8)\n        self.tree.insert(10)\n        self.tree.insert(15)\n        self.tree.insert(7)\n        self.tree.insert(18)\n\n    def test_num_empty(self):\n        self.assertEqual(10, num_empty(self.tree.root))\n\nif __name__ == '__main__':\n    unittest.main()\n"
  },
  {
    "id": 321,
    "category": "bst",
    "file_name": "height",
    "codes": "\"\"\"\nWrite a function height returns the height of a tree. The height is defined to\nbe the number of levels. The empty tree has height 0, a tree of one node has\nheight 1, a root node with one or two leaves as children has height 2, and so on\nFor example: height of tree is 4\n\n                    9\n                 /      \\\n               6         12\n              / \\       /   \\\n            3     8   10      15\n                 /              \\\n                7                18\n\n    height = 4\n\n\"\"\"\nimport unittest\nfrom bst import Node\nfrom bst import bst\n\ndef height(root):\n    if root is None:\n        return 0\n    else:\n        return 1 + max(height(root.left), height(root.right))\n\n\"\"\"\n    The tree is created for testing:\n\n                    9\n                 /      \\\n               6         12\n              / \\       /   \\\n            3     8   10      15\n                 /              \\\n                7                18\n\n    count_left_node = 4\n\n\"\"\"\n\nclass TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.tree = bst()\n        self.tree.insert(9)\n        self.tree.insert(6)\n        self.tree.insert(12)\n        self.tree.insert(3)\n        self.tree.insert(8)\n        self.tree.insert(10)\n        self.tree.insert(15)\n        self.tree.insert(7)\n        self.tree.insert(18)\n\n    def test_height(self):\n        self.assertEqual(4, height(self.tree.root))\n\nif __name__ == '__main__':\n    unittest.main()\n"
  },
  {
    "id": 322,
    "category": "bst",
    "file_name": "bst_closest_value",
    "codes": "# Given a non-empty binary search tree and a target value,\n# find the value in the BST that is closest to the target.\n\n# Note:\n# Given target value is a floating point.\n# You are guaranteed to have only one unique value in the BST\n# that is closest to the target.\n\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\ndef closest_value(root, target):\n    \"\"\"\n    :type root: TreeNode\n    :type target: float\n    :rtype: int\n    \"\"\"\n    a = root.val\n    kid = root.left if target < a else root.right\n    if not kid:\n        return a\n    b = closest_value(kid, target)\n    return min((a,b), key=lambda x: abs(target-x))\n"
  },
  {
    "id": 323,
    "category": "bst",
    "file_name": "successor",
    "codes": "def successor(root, node):\n    succ = None\n    while root:\n        if node.val < root.val:\n            succ = root\n            root = root.left\n        else:\n            root = root.right\n    return succ\n"
  },
  {
    "id": 324,
    "category": "bst",
    "file_name": "BSTIterator",
    "codes": "\nclass BSTIterator:\n    def __init__(self, root):\n        self.stack = []\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def has_next(self):\n        return bool(self.stack)\n\n    def next(self):\n        node = self.stack.pop()\n        tmp = node\n        if tmp.right:\n            tmp = tmp.right\n            while tmp:\n                self.stack.append(tmp)\n                tmp = tmp.left\n        return node.val\n\n\n\n\n"
  },
  {
    "id": 325,
    "category": "bst",
    "file_name": "unique_bst",
    "codes": "\"\"\"\nGiven n, how many structurally unique BST's\n(binary search trees) that store values 1...n?\n\nFor example,\nGiven n = 3, there are a total of 5 unique BST's.\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\"\"\"\n\n\n\"\"\"\nTaking 1~n as root respectively:\n1 as root: # of trees = F(0) * F(n-1)  // F(0) == 1\n2 as root: # of trees = F(1) * F(n-2)\n3 as root: # of trees = F(2) * F(n-3)\n...\nn-1 as root: # of trees = F(n-2) * F(1)\nn as root:   # of trees = F(n-1) * F(0)\n\nSo, the formulation is:\nF(n) = F(0) * F(n-1) + F(1) * F(n-2) + F(2) * F(n-3) + ... + F(n-2) * F(1) + F(n-1) * F(0)\n\"\"\"\n\ndef num_trees(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n+1):\n        for j in range(i+1):\n            dp[i] += dp[i-j] * dp[j-1]\n    return dp[-1]\n"
  },
  {
    "id": 326,
    "category": "bst",
    "file_name": "kth_smallest",
    "codes": "class Node:\n\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef kth_smallest(root, k):\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if k == 0:\n            break\n        root = root.right\n    return root.val\n\n\nclass Solution(object):\n    def kth_smallest(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        count = []\n        self.helper(root, count)\n        return count[k-1]\n\n    def helper(self, node, count):\n        if not node:\n            return\n\n        self.helper(node.left, count)\n        count.append(node.val)\n        self.helper(node.right, count)\n\nif __name__ == '__main__':\n    n1 = Node(100)\n    n2 = Node(50)\n    n3 = Node(150)\n    n4 = Node(25)\n    n5 = Node(75)\n    n6 = Node(125)\n    n7 = Node(175)\n    n1.left, n1.right = n2, n3\n    n2.left, n2.right = n4, n5\n    n3.left, n3.right = n6, n7\n    print(kth_smallest(n1, 2))\n    print(Solution().kth_smallest(n1, 2))\n"
  },
  {
    "id": 327,
    "category": "bst",
    "file_name": "is_bst",
    "codes": "\"\"\"\nGiven a binary tree, determine if it is a valid binary search tree (BST).\n\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes\nwith keys less than the node's key.\nThe right subtree of a node contains only nodes\nwith keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\n    2\n   / \\\n  1   3\nBinary tree [2,1,3], return true.\nExample 2:\n    1\n   / \\\n  2   3\nBinary tree [1,2,3], return false.\n\"\"\"\n\ndef is_bst(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n\n    stack = []\n    pre = None\n    \n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if pre and root.val <= pre.val:\n            return False\n        pre = root\n        root = root.right\n\n    return True\n"
  },
  {
    "id": 328,
    "category": "bst",
    "file_name": "lowest_common_ancestor",
    "codes": "\"\"\"\nGiven a binary search tree (BST),\nfind the lowest common ancestor (LCA) of two given nodes in the BST.\n\nAccording to the definition of LCA on Wikipedia:\n    \u201cThe lowest common ancestor is defined between two\n    nodes v and w as the lowest node in T that has both v and w\n    as descendants (where we allow a node to be a descendant of itself).\u201d\n\n        _______6______\n       /              \\\n    ___2__          ___8__\n   /      \\        /      \\\n   0      _4       7       9\n         /  \\\n         3   5\n\nFor example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6.\nAnother example is LCA of nodes 2 and 4 is 2,\nsince a node can be a descendant of itself according to the LCA definition.\n\"\"\"\n\n\ndef lowest_common_ancestor(root, p, q):\n    \"\"\"\n    :type root: Node\n    :type p: Node\n    :type q: Node\n    :rtype: Node\n    \"\"\"\n    while root:\n        if p.val > root.val < q.val:\n            root = root.right\n        elif p.val < root.val > q.val:\n            root = root.left\n        else:\n            return root\n"
  },
  {
    "id": 329,
    "category": "bst",
    "file_name": "predecessor",
    "codes": "def predecessor(root, node):\n    pred = None\n    while root:\n        if node.val > root.val:\n            pred = root\n            root = root.right\n        else:\n            root = root.left\n    return pred\n"
  },
  {
    "id": 330,
    "category": "bst",
    "file_name": "serialize_deserialize",
    "codes": "\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\ndef serialize(root):\n    def build_string(node):\n        if node:\n            vals.append(str(node.val))\n            build_string(node.left)\n            build_string(node.right)\n        else:\n            vals.append(\"#\")\n    vals = []\n    build_string(root)\n    return \" \".join(vals)\n\n\ndef deserialize(data):\n    def build_tree():\n        val = next(vals)\n        if val == \"#\":\n            return None\n        node = TreeNode(int(val))\n        node.left = build_tree()\n        node.right = build_tree()\n        return node\n    vals = iter(data.split())\n    return build_tree()\n"
  },
  {
    "id": 331,
    "category": "bst",
    "file_name": "delete_node",
    "codes": "\"\"\"\nGiven a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\n\nBasically, the deletion can be divided into two stages:\n\nSearch for a node to remove.\nIf the node is found, delete the node.\nNote: Time complexity should be O(height of tree).\n\nExample:\n\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nGiven key to delete is 3. So we find the node with value 3 and delete it.\n\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\nAnother valid answer is [5,2,6,null,4,null,7].\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n\"\"\"\n\nclass Solution(object):\n    def delete_node(self, root, key):\n        \"\"\"\n        :type root: TreeNode\n        :type key: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root: return None\n\n        if root.val == key:\n            if root.left:\n                # Find the right most leaf of the left sub-tree\n                left_right_most = root.left\n                while left_right_most.right:\n                    left_right_most = left_right_most.right\n                # Attach right child to the right of that leaf\n                left_right_most.right = root.right\n                # Return left child instead of root, a.k.a delete root\n                return root.left\n            else:\n                return root.right\n        # If left or right child got deleted, the returned root is the child of the deleted node.\n        elif root.val > key:\n            root.left = self.deleteNode(root.left, key)\n        else:\n            root.right = self.deleteNode(root.right, key)\n        return root\n"
  },
  {
    "id": 332,
    "category": "bst",
    "file_name": "count_left_node",
    "codes": "\"\"\"\nWrite a function count_left_node returns the number of left children in the\ntree. For example: the following tree has four left children (the nodes\nstoring the values 6, 3, 7, and 10):\n\n                    9\n                 /      \\\n               6         12\n              / \\       /   \\\n            3     8   10      15\n                 /              \\\n                7                18\n\n    count_left_node = 4\n\n\"\"\"\nimport unittest\nfrom bst import Node\nfrom bst import bst\n\ndef count_left_node(root):\n    if root is None:\n        return 0\n    elif root.left is None:\n        return count_left_node(root.right)\n    else:\n        return 1 + count_left_node(root.left) + count_left_node(root.right)\n\n\"\"\"\n    The tree is created for testing:\n\n                    9\n                 /      \\\n               6         12\n              / \\       /   \\\n            3     8   10      15\n                 /              \\\n                7                18\n\n    count_left_node = 4\n\n\"\"\"\n\nclass TestSuite(unittest.TestCase):\n    def setUp(self):\n        self.tree = bst()\n        self.tree.insert(9)\n        self.tree.insert(6)\n        self.tree.insert(12)\n        self.tree.insert(3)\n        self.tree.insert(8)\n        self.tree.insert(10)\n        self.tree.insert(15)\n        self.tree.insert(7)\n        self.tree.insert(18)\n\n    def test_count_left_node(self):\n        self.assertEqual(4, count_left_node(self.tree.root))\n\nif __name__ == '__main__':\n    unittest.main()\n"
  },
  {
    "id": 333,
    "category": "compression",
    "file_name": "elias",
    "codes": "\"\"\"\nElias \u03b3 code or Elias gamma code is a universal code\nencoding positive integers.\nIt is used most commonly when coding integers whose\nupper-bound cannot be determined beforehand.\nElias \u03b4 code or Elias delta code is a universal code\n encoding the positive integers,\nthat includes Elias \u03b3 code when calculating.\nBoth were developed by Peter Elias.\n\n\"\"\"\nfrom math import log\n\nlog2 = lambda x: log(x, 2)\n\n# Calculates the binary number\ndef binary(x, l=1):\n\tfmt = '{0:0%db}' % l\n\treturn fmt.format(x)\n\n# Calculates the unary number\ndef unary(x):\n\treturn (x-1)*'1'+'0'\n\ndef elias_generic(lencoding, x):\n\t\"\"\"\n\tThe compressed data is calculated in two parts.\n\tThe first part is the unary number of 1 + \u230alog2(x)\u230b.\n\tThe second part is the binary number of x - 2^(\u230alog2(x)\u230b).\n\tFor the final result we add these two parts.\n\t\"\"\"\n\tif x == 0:\n\t\treturn '0'\n\t\n\tfirst_part = 1 + int(log2(x))\n\t\n\ta = x - 2**(int(log2(x)))\n\t\n\tk = int(log2(x))\n\n\treturn lencoding(first_part) + binary(a, k)\n\ndef elias_gamma(x):\n\t\"\"\"\n\tFor the first part we put the unary number of x.\n\t\"\"\"\n\treturn elias_generic(unary, x)\n\ndef elias_delta(x):\n\t\"\"\"\n\tFor the first part we put the elias_g of the number.\n\t\"\"\"\n\treturn elias_generic(elias_gamma, x)\n"
  },
  {
    "id": 334,
    "category": "compression",
    "file_name": "rle_compression",
    "codes": "\"\"\"\nRun-length encoding (RLE) is a simple compression algorithm \nthat gets a stream of data as the input and returns a\nsequence of counts of consecutive data values in a row.\nWhen decompressed the data will be fully recovered as RLE\nis a lossless data compression.\n\"\"\"\n\ndef encode_rle(input):\n    \"\"\"\n    Gets a stream of data and compresses it\n    under a Run-Length Encoding.\n    :param input: The data to be encoded.\n    :return: The encoded string.\n    \"\"\"\n    if not input: return ''\n\n    encoded_str = ''\n    prev_ch = ''\n    count = 1\n\n    for ch in input:\n\n        # Check If the subsequent character does not match\n        if ch != prev_ch:\n            # Add the count and character\n            if prev_ch:\n                encoded_str += str(count) + prev_ch\n            # Reset the count and set the character\n            count = 1\n            prev_ch = ch\n        else:\n            # Otherwise increment the counter\n            count += 1\n    else:\n        return encoded_str + (str(count) + prev_ch)\n\n\ndef decode_rle(input):\n    \"\"\"\n    Gets a stream of data and decompresses it\n    under a Run-Length Decoding.\n    :param input: The data to be decoded.\n    :return: The decoded string.\n    \"\"\"\n    decode_str = ''\n    count = ''\n\n    for ch in input:\n        # If not numerical\n        if not ch.isdigit():\n            # Expand it for the decoding\n            decode_str += ch * int(count)\n            count = ''\n        else:\n            # Add it in the counter\n            count += ch\n    return decode_str\n"
  },
  {
    "id": 335,
    "category": "compression",
    "file_name": "huffman_coding",
    "codes": "\"\"\"\nHuffman coding is an efficient method of compressing data without losing information.\nThis algorithm analyzes the symbols that appear in a message.\nSymbols that appear more often will be encoded as a shorter-bit string\nwhile symbols that aren't used as much will be encoded as longer strings.\n\"\"\"\n\nfrom collections import defaultdict, deque\nimport heapq\n\n\nclass Node:\n    def __init__(self, frequency=0, sign=None, left=None, right=None):\n        self.frequency = frequency\n        self.sign = sign\n        self.left = left\n        self.right = right\n\n    def __lt__(self, other):\n        return self.frequency < other.frequency\n\n    def __gt__(self, other):\n        return self.frequency > other.frequency\n\n    def __eq__(self, other):\n        return self.frequency == other.frequency\n\n    def __str__(self):\n        return \"<ch: {0}: {1}>\".format(self.sign, self.frequency)\n\n    def __repr__(self):\n        return \"<ch: {0}: {1}>\".format(self.sign, self.frequency)\n\n\nclass HuffmanReader:\n    def __init__(self, file):\n        self.file = file\n        self.buffer = []\n        self.is_last_byte = False\n\n    def get_number_of_additional_bits_in_the_last_byte(self) -> int:\n        bin_num = self.get_bit() + self.get_bit() + self.get_bit()\n        return int(bin_num, 2)\n\n    def load_tree(self) -> Node:\n        \"\"\"\n        Load tree from file\n\n        :return:\n        \"\"\"\n        node_stack = deque()\n        queue_leaves = deque()\n        root = Node()\n\n        current_node = root\n        is_end_of_tree = False\n        while not is_end_of_tree:\n            current_bit = self.get_bit()\n            if current_bit == \"0\":\n                current_node.left = Node()\n                current_node.right = Node()\n                node_stack.append(current_node.right)  # going to left node, right push on stack\n                current_node = current_node.left\n            else:\n                queue_leaves.append(current_node)\n                if node_stack:\n                    current_node = node_stack.pop()\n                else:\n                    is_end_of_tree = True\n\n        self._fill_tree(queue_leaves)\n\n        return root\n\n    def _fill_tree(self, leaves_queue):\n        \"\"\"\n        Load values to tree after reading tree\n        :param leaves_queue:\n        :return:\n        \"\"\"\n        leaves_queue.reverse()\n        while leaves_queue:\n            node = leaves_queue.pop()\n            s = int(self.get_byte(), 2)\n            node.sign = s\n\n    def _load_byte(self, buff_limit=8) -> bool:\n        \"\"\"\n        Load next byte is buffer is less than buff_limit\n        :param buff_limit:\n        :return: True if there is enough bits in buffer to read\n        \"\"\"\n        if len(self.buffer) <= buff_limit:\n            byte = self.file.read(1)\n\n            if not byte:\n                return False\n\n            i = int.from_bytes(byte, \"big\")\n            self.buffer.extend(list(\"{0:08b}\".format(i)))\n\n        return True\n\n    def get_bit(self, buff_limit=8):\n        if self._load_byte(buff_limit):\n            bit = self.buffer.pop(0)\n            return bit\n        else:\n            return -1\n\n    def get_byte(self):\n        if self._load_byte():\n            byte_list = self.buffer[:8]\n            self.buffer = self.buffer[8:]\n\n            return \"\".join(byte_list)\n        else:\n            return -1\n\n\nclass HuffmanWriter:\n    def __init__(self, file):\n        self.file = file\n        self.buffer = \"\"\n        self.saved_bits = 0\n\n    def write_char(self, char):\n        self.write_int(ord(char))\n\n    def write_int(self, num):\n        bin_int = \"{0:08b}\".format(num)\n        self.write_bits(bin_int)\n\n    def write_bits(self, bits):\n        self.saved_bits += len(bits)\n\n        self.buffer += bits\n\n        while len(self.buffer) >= 8:\n            i = int(self.buffer[:8], 2)\n            self.file.write(bytes([i]))\n            self.buffer = self.buffer[8:]\n\n    def save_tree(self, tree):\n        \"\"\"\n        Generate and save tree code to file\n        :param tree:\n        :return:\n        \"\"\"\n        signs = []\n        tree_code = \"\"\n\n        def get_code_tree(T):\n            nonlocal tree_code\n            if T.sign is not None:\n                signs.append(T.sign)\n            if T.left:\n                tree_code += \"0\"\n                get_code_tree(T.left)\n            if T.right:\n                tree_code += \"1\"\n                get_code_tree(T.right)\n\n        get_code_tree(tree)\n        self.write_bits(tree_code + \"1\")  # \"1\" indicates that tree ended (it will be needed to load the tree)\n        for int_sign in signs:\n            self.write_int(int_sign)\n\n    def _save_information_about_additional_bits(self, additional_bits: int):\n        \"\"\"\n        Overwrite first three bits in the file\n        :param additional_bits: number of bits that were appended to fill last byte\n        :return:\n        \"\"\"\n        self.file.seek(0)\n        first_byte_raw = self.file.read(1)\n        self.file.seek(0)\n        first_byte = \"{0:08b}\".format(int.from_bytes(first_byte_raw, \"big\"))\n        # overwrite first three bits\n        first_byte = first_byte[3:]\n        first_byte = \"{0:03b}\".format(additional_bits) + first_byte\n\n        self.write_bits(first_byte)\n\n    def close(self):\n        additional_bits = 8 - len(self.buffer)\n        if additional_bits != 8:  # buffer is empty, no need to append extra \"0\"\n            self.write_bits(\"0\" * additional_bits)\n            self._save_information_about_additional_bits(additional_bits)\n\n\nclass TreeFinder:\n    \"\"\"\n    Class to help find signs in tree\n    \"\"\"\n\n    def __init__(self, tree):\n        self.root = tree\n        self.current_node = tree\n        self.found = None\n\n    def find(self, bit):\n        \"\"\"\n        Find sign in tree\n        :param bit:\n        :return: True if sign is found\n        \"\"\"\n        if bit == \"0\":\n            self.current_node = self.current_node.left\n        elif bit == \"1\":\n            self.current_node = self.current_node.right\n        else:\n            self._reset()\n            return True\n\n        if self.current_node.sign is not None:\n            self._reset(self.current_node.sign)\n            return True\n        else:\n            return False\n\n    def _reset(self, found=\"\"):\n        self.found = found\n        self.current_node = self.root\n\n\nclass HuffmanCoding:\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def decode_file(file_in_name, file_out_name):\n        with open(file_in_name, \"rb\") as file_in, open(file_out_name, \"wb\") as file_out:\n            reader = HuffmanReader(file_in)\n            additional_bits = reader.get_number_of_additional_bits_in_the_last_byte()\n            tree = reader.load_tree()\n\n            HuffmanCoding._decode_and_write_signs_to_file(file_out, reader, tree, additional_bits)\n\n        print(\"File decoded.\")\n\n    @staticmethod\n    def _decode_and_write_signs_to_file(file, reader: HuffmanReader, tree: Node, additional_bits: int):\n        tree_finder = TreeFinder(tree)\n        is_end_of_file = False\n\n        while not is_end_of_file:\n            bit = reader.get_bit()\n            if bit != -1:\n                while not tree_finder.find(bit):  # read whole code\n                    bit = reader.get_bit(0)\n                file.write(bytes([tree_finder.found]))\n            else:  # There is last byte in buffer to parse\n                is_end_of_file = True\n                last_byte = reader.buffer\n                last_byte = last_byte[:-additional_bits]  # remove additional \"0\" used to fill byte\n                for bit in last_byte:\n                    if tree_finder.find(bit):\n                        file.write(bytes([tree_finder.found]))\n\n    @staticmethod\n    def encode_file(file_in_name, file_out_name):\n        with open(file_in_name, \"rb\") as file_in, open(file_out_name, mode=\"wb+\") as file_out:\n            signs_frequency = HuffmanCoding._get_char_frequency(file_in)\n            file_in.seek(0)\n            tree = HuffmanCoding._create_tree(signs_frequency)\n            codes = HuffmanCoding._generate_codes(tree)\n\n            writer = HuffmanWriter(file_out)\n            writer.write_bits(\"000\")  # leave space to save how many bits will be appended to fill the last byte\n            writer.save_tree(tree)\n            HuffmanCoding._encode_and_write_signs_to_file(file_in, writer, codes)\n            writer.close()\n\n        print(\"File encoded.\")\n\n    @staticmethod\n    def _encode_and_write_signs_to_file(file, writer: HuffmanWriter, codes: dict):\n        sign = file.read(1)\n        while sign:\n            int_char = int.from_bytes(sign, \"big\")\n            writer.write_bits(codes[int_char])\n            sign = file.read(1)\n\n    @staticmethod\n    def _get_char_frequency(file) -> dict:\n        is_end_of_file = False\n        signs_frequency = defaultdict(lambda: 0)\n        while not is_end_of_file:\n            prev_pos = file.tell()\n            sign = file.read(1)\n            curr_pos = file.tell()\n            if prev_pos == curr_pos:\n                is_end_of_file = True\n            else:\n                signs_frequency[int.from_bytes(sign, \"big\")] += 1\n\n        return signs_frequency\n\n    @staticmethod\n    def _generate_codes(tree: Node) -> dict:\n        codes = dict()\n        HuffmanCoding._go_through_tree_and_create_codes(tree, \"\", codes)\n        return codes\n\n    @staticmethod\n    def _create_tree(signs_frequency: dict) -> Node:\n        nodes = [Node(frequency=frequency, sign=char_int) for char_int, frequency in signs_frequency.items()]\n        heapq.heapify(nodes)\n\n        while len(nodes) > 1:\n            left = heapq.heappop(nodes)\n            right = heapq.heappop(nodes)\n            new_node = Node(frequency=left.frequency + right.frequency, left=left, right=right)\n            heapq.heappush(nodes, new_node)\n\n        return nodes[0]  # root\n\n    @staticmethod\n    def _go_through_tree_and_create_codes(tree: Node, code: str, dict_codes: dict):\n        if tree.sign is not None:\n            dict_codes[tree.sign] = code\n\n        if tree.left:\n            HuffmanCoding._go_through_tree_and_create_codes(tree.left, code + \"0\", dict_codes)\n\n        if tree.right:\n            HuffmanCoding._go_through_tree_and_create_codes(tree.right, code + \"1\", dict_codes)\n"
  },
  {
    "id": 336,
    "category": "matrix",
    "file_name": "sum_sub_squares",
    "codes": "# Function to find sum of all\n# sub-squares of size k x k in a given\n# square matrix of size n x n\ndef sum_sub_squares(matrix, k):\n    n = len(matrix)\n    result = [[0 for i in range(k)] for j in range(k)]\n\n    if k > n:\n        return\n    for i in range(n - k + 1):\n        l = 0\n        for j in range(n - k + 1):\n            sum = 0\n\n            # Calculate and print sum of current sub-square\n            for p in range(i, k + i):\n                for q in range(j, k + j):\n                    sum += matrix[p][q]\n\n            result[i][l] = sum\n            l += 1\n\n    return result\n"
  },
  {
    "id": 337,
    "category": "matrix",
    "file_name": "copy_transform",
    "codes": "def rotate_clockwise(matrix):\n    new = []\n    for row in reversed(matrix):\n        for i, elem in enumerate(row):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new\n\n\ndef rotate_counterclockwise(matrix):\n    new = []\n    for row in matrix:\n        for i, elem in enumerate(reversed(row)):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new\n\n\ndef top_left_invert(matrix):\n    new = []\n    for row in matrix:\n        for i, elem in enumerate(row):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new\n\n\ndef bottom_left_invert(matrix):\n    new = []\n    for row in reversed(matrix):\n        for i, elem in enumerate(reversed(row)):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new\n\n\nif __name__ == '__main__':\n    def print_matrix(matrix, name):\n        print('{}:\\n['.format(name))\n        for row in matrix:\n            print('  {}'.format(row))\n        print(']\\n')\n\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9],\n    ]\n\n    print_matrix(matrix, 'initial')\n    print_matrix(rotate_clockwise(matrix), 'clockwise')\n    print_matrix(rotate_counterclockwise(matrix), 'counterclockwise')\n    print_matrix(top_left_invert(matrix), 'top left invert')\n    print_matrix(bottom_left_invert(matrix), 'bottom left invert')\n"
  },
  {
    "id": 338,
    "category": "matrix",
    "file_name": "bomb_enemy",
    "codes": "\"\"\"\nGiven a 2D grid, each cell is either a wall 'W',\nan enemy 'E' or empty '0' (the number zero),\nreturn the maximum enemies you can kill using one bomb.\nThe bomb kills all the enemies in the same row and column from\nthe planted point until it hits the wall since the wall is too strong\nto be destroyed.\nNote that you can only put the bomb at an empty cell.\n\nExample:\nFor the given grid\n\n0 E 0 0\nE 0 W E\n0 E 0 0\n\nreturn 3. (Placing a bomb at (1,1) kills 3 enemies)\n\"\"\"\n\n\ndef max_killed_enemies(grid):\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    max_killed = 0\n    row_e, col_e = 0, [0] * n\n    # iterates over all cells in the grid\n    for i in range(m):\n        for j in range(n):\n            # makes sure we are next to a wall.\n            if j == 0 or grid[i][j-1] == 'W':\n                row_e = row_kills(grid, i, j)\n            # makes sure we are next to a wall.\n            if i == 0 or grid[i-1][j] == 'W':\n                col_e[j] = col_kills(grid, i, j)\n            # makes sure the cell contains a 0\n            if grid[i][j] == '0':\n                # updates the variable\n                max_killed = max(max_killed, row_e + col_e[j])\n\n    return max_killed\n\n\n# calculate killed enemies for row i from column j\ndef row_kills(grid, i, j):\n    num = 0\n    len_row = len(grid[0])\n    while j < len_row and grid[i][j] != 'W':\n        if grid[i][j] == 'E':\n            num += 1\n        j += 1\n    return num\n\n\n# calculate killed enemies for  column j from row i\ndef col_kills(grid, i, j):\n    num = 0\n    len_col = len(grid)\n    while i < len_col and grid[i][j] != 'W':\n        if grid[i][j] == 'E':\n            num += 1\n        i += 1\n    return num\n\n\n# ----------------- TESTS -------------------------\n\n\"\"\"\n    Testsuite for the project\n\"\"\"\n\nimport unittest\n\n\nclass TestBombEnemy(unittest.TestCase):\n    def test_3x4(self):\n        grid1 = [[\"0\", \"E\", \"0\", \"0\"],\n                 [\"E\", \"0\", \"W\", \"E\"],\n                 [\"0\", \"E\", \"0\", \"0\"]]\n        self.assertEqual(3, max_killed_enemies(grid1))\n\n    def test_4x4(self):\n        grid1 = [\n                [\"0\", \"E\", \"0\", \"E\"],\n                [\"E\", \"E\", \"E\", \"0\"],\n                [\"E\", \"0\", \"W\", \"E\"],\n                [\"0\", \"E\", \"0\", \"0\"]]\n        grid2 = [\n                [\"0\", \"0\", \"0\", \"E\"],\n                [\"E\", \"0\", \"0\", \"0\"],\n                [\"E\", \"0\", \"W\", \"E\"],\n                [\"0\", \"E\", \"0\", \"0\"]]\n        self.assertEqual(5, max_killed_enemies(grid1))\n        self.assertEqual(3, max_killed_enemies(grid2))\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"
  },
  {
    "id": 339,
    "category": "matrix",
    "file_name": "cholesky_matrix_decomposition",
    "codes": "\"\"\"\nCholesky matrix decomposition is used to find the decomposition of a\nHermitian positive-definite matrix A\ninto matrix V, so that V * V* = A, where V* denotes the conjugate\ntranspose of L.\nThe dimensions of the matrix A must match.\n\nThis method is mainly used for numeric solution of linear equations Ax = b.\n\nexample:\nInput matrix A:\n[[  4,  12, -16],\n [ 12,  37, -43],\n [-16, -43,  98]]\n\nResult:\n[[2.0, 0.0, 0.0],\n[6.0, 1.0, 0.0],\n[-8.0, 5.0, 3.0]]\n\nTime complexity of this algorithm is O(n^3), specifically about (n^3)/3\n\n\"\"\"\nimport math\n\n\ndef cholesky_decomposition(A):\n    \"\"\"\n    :param A: Hermitian positive-definite matrix of type List[List[float]]\n    :return: matrix of type List[List[float]] if A can be decomposed,\n    otherwise None\n    \"\"\"\n    n = len(A)\n    for ai in A:\n        if len(ai) != n:\n            return None\n    V = [[0.0] * n for _ in range(n)]\n    for j in range(n):\n        sum_diagonal_element = 0\n        for k in range(j):\n            sum_diagonal_element = sum_diagonal_element + math.pow(V[j][k], 2)\n        sum_diagonal_element = A[j][j] - sum_diagonal_element\n        if sum_diagonal_element <= 0:\n            return None\n        V[j][j] = math.pow(sum_diagonal_element, 0.5)\n        for i in range(j+1, n):\n            sum_other_element = 0\n            for k in range(j):\n                sum_other_element += V[i][k]*V[j][k]\n            V[i][j] = (A[i][j] - sum_other_element)/V[j][j]\n    return V\n"
  },
  {
    "id": 340,
    "category": "matrix",
    "file_name": "matrix_exponentiation",
    "codes": "def multiply(matA: list, matB: list) -> list:\n    \"\"\"\n    Multiplies two square matrices matA and matB of size n x n\n    Time Complexity: O(n^3)\n    \"\"\"\n    n = len(matA)\n    matC = [[0 for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                matC[i][j] += matA[i][k] * matB[k][j]\n\n    return matC\n\n\ndef identity(n: int) -> list:\n    \"\"\"\n    Returns the Identity matrix of size n x n\n    Time Complexity: O(n^2)\n    \"\"\"\n    I = [[0 for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        I[i][i] = 1\n\n    return I\n\n\ndef matrix_exponentiation(mat: list, n: int) -> list:\n    \"\"\"\n    Calculates mat^n by repeated squaring\n    Time Complexity: O(d^3 log(n))\n                     d: dimension of the square matrix mat\n                     n: power the matrix is raised to\n    \"\"\"\n    if n == 0:\n        return identity(len(mat))\n    elif n % 2 == 1:\n        return multiply(matrix_exponentiation(mat, n - 1), mat)\n    else:\n        tmp = matrix_exponentiation(mat, n // 2)\n        return multiply(tmp, tmp)\n"
  },
  {
    "id": 341,
    "category": "matrix",
    "file_name": "sparse_dot_vector",
    "codes": "#! /usr/bin/env python3\n\n\"\"\"\nSuppose we have very large sparse vectors, which contains a lot of\nzeros and double .\n\nfind a data structure to store them\nget the dot product of them\n\"\"\"\n\n\ndef vector_to_index_value_list(vector):\n    return [(i, v) for i, v in enumerate(vector) if v != 0.0]\n\n\ndef dot_product(iv_list1, iv_list2):\n\n    product = 0\n    p1 = len(iv_list1) - 1\n    p2 = len(iv_list2) - 1\n\n    while p1 >= 0 and p2 >= 0:\n        i1, v1 = iv_list1[p1]\n        i2, v2 = iv_list2[p2]\n\n        if i1 < i2:\n            p1 -= 1\n        elif i2 < i1:\n            p2 -= 1\n        else:\n            product += v1 * v2\n            p1 -= 1\n            p2 -= 1\n\n    return product\n\n\ndef __test_simple():\n    print(dot_product(vector_to_index_value_list([1., 2., 3.]),\n                      vector_to_index_value_list([0., 2., 2.])))\n    # 10\n\n\ndef __test_time():\n    vector_length = 1024\n    vector_count = 1024\n    nozero_counut = 10\n\n    def random_vector():\n        import random\n        vector = [0 for _ in range(vector_length)]\n        for i in random.sample(range(vector_length), nozero_counut):\n            vector[i] = random.random()\n        return vector\n\n    vectors = [random_vector() for _ in range(vector_count)]\n    iv_lists = [vector_to_index_value_list(vector) for vector in vectors]\n\n    import time\n\n    time_start = time.time()\n    for i in range(vector_count):\n        for j in range(i):\n            dot_product(iv_lists[i], iv_lists[j])\n    time_end = time.time()\n\n    print(time_end - time_start, 'seconds')\n\n\nif __name__ == '__main__':\n    __test_simple()\n    __test_time()\n"
  },
  {
    "id": 342,
    "category": "matrix",
    "file_name": "sort_matrix_diagonally",
    "codes": "\"\"\"\nGiven a m * n matrix mat of integers,\nsort it diagonally in ascending order\nfrom the top-left to the bottom-right\nthen return the sorted array.\n\nmat = [\n    [3,3,1,1],\n    [2,2,1,2],\n    [1,1,1,2]\n]\n\nShould return:\n[\n    [1,1,1,1],\n    [1,2,2,2],\n    [1,2,3,3]\n]\n\"\"\"\n\nfrom heapq import heappush, heappop\nfrom typing import List\n\n\ndef sort_diagonally(mat: List[List[int]]) -> List[List[int]]:\n    # If the input is a vector, return the vector\n    if len(mat) == 1 or len(mat[0]) == 1:\n        return mat\n\n    # Rows + columns - 1\n    # The -1 helps you to not repeat a column\n    for i in range(len(mat)+len(mat[0])-1):\n        # Process the rows\n        if i+1 < len(mat):\n            # Initialize heap, set row and column\n            h = []\n            row = len(mat)-(i+1)\n            col = 0\n\n            # Traverse diagonally, and add the values to the heap\n            while row < len(mat):\n                heappush(h, (mat[row][col]))\n                row += 1\n                col += 1\n\n            # Sort the diagonal\n            row = len(mat)-(i+1)\n            col = 0\n            while h:\n                ele = heappop(h)\n                mat[row][col] = ele\n                row += 1\n                col += 1\n        else:\n            # Process the columns\n            # Initialize heap, row and column\n            h = []\n            row = 0\n            col = i - (len(mat)-1)\n\n            # Traverse Diagonally\n            while col < len(mat[0]) and row < len(mat):\n                heappush(h, (mat[row][col]))\n                row += 1\n                col += 1\n\n            # Sort the diagonal\n            row = 0\n            col = i - (len(mat)-1)\n            while h:\n                ele = heappop(h)\n                mat[row][col] = ele\n                row += 1\n                col += 1\n\n    # Return the updated matrix\n    return mat\n"
  },
  {
    "id": 343,
    "category": "matrix",
    "file_name": "multiply",
    "codes": "\"\"\"\nThis algorithm takes two compatible two dimensional matrix\nand return their product\nSpace complexity: O(n^2)\nPossible edge case: the number of columns of multiplicand not consistent with\nthe number of rows of multiplier, will raise exception\n\"\"\"\n\n\ndef multiply(multiplicand: list, multiplier: list) -> list:\n    \"\"\"\n    :type A: List[List[int]]\n    :type B: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    multiplicand_row, multiplicand_col = len(\n        multiplicand), len(multiplicand[0])\n    multiplier_row, multiplier_col = len(multiplier), len(multiplier[0])\n    if(multiplicand_col != multiplier_row):\n        raise Exception(\n            \"Multiplicand matrix not compatible with Multiplier matrix.\")\n    # create a result matrix\n    result = [[0] * multiplier_col for i in range(multiplicand_row)]\n    for i in range(multiplicand_row):\n        for j in range(multiplier_col):\n            for k in range(len(multiplier)):\n                result[i][j] += multiplicand[i][k] * multiplier[k][j]\n    return result\n"
  },
  {
    "id": 344,
    "category": "matrix",
    "file_name": "count_paths",
    "codes": "#\n# Count the number of unique paths from a[0][0] to a[m-1][n-1]\n# We are allowed to move either right or down from a cell in the matrix.\n# Approaches-\n# (i) Recursion- Recurse starting from a[m-1][n-1], upwards and leftwards,\n#                add the path count of both recursions and return count.\n# (ii) Dynamic Programming- Start from a[0][0].Store the count in a count\n#                           matrix. Return count[m-1][n-1]\n# T(n)- O(mn), S(n)- O(mn)\n#\n\n\ndef count_paths(m, n):\n    if m < 1 or n < 1:\n        return -1\n    count = [[None for j in range(n)] for i in range(m)]\n\n    # Taking care of the edge cases- matrix of size 1xn or mx1\n    for i in range(n):\n        count[0][i] = 1\n    for j in range(m):\n        count[j][0] = 1\n\n    for i in range(1, m):\n        for j in range(1, n):\n            # Number of ways to reach a[i][j] = number of ways to reach\n            #                                   a[i-1][j] + a[i][j-1]\n            count[i][j] = count[i - 1][j] + count[i][j - 1]\n\n    print(count[m - 1][n - 1])\n\n\ndef main():\n    m, n = map(int, input('Enter two positive integers: ').split())\n    count_paths(m, n)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "id": 345,
    "category": "matrix",
    "file_name": "rotate_image",
    "codes": "\"\"\"\nYou are given an n x n 2D mat representing an image.\n\nRotate the image by 90 degrees (clockwise).\n\nFollow up:\nCould you do this in-place?\n\"\"\"\n\n\n# clockwise rotate\n# first reverse up to down, then swap the symmetry\n# 1 2 3     7 8 9     7 4 1\n# 4 5 6  => 4 5 6  => 8 5 2\n# 7 8 9     1 2 3     9 6 3\n\ndef rotate(mat):\n    if not mat:\n        return mat\n    mat.reverse()\n    for i in range(len(mat)):\n        for j in range(i):\n            mat[i][j], mat[j][i] = mat[j][i], mat[i][j]\n    return mat\n\n\nif __name__ == \"__main__\":\n    mat = [[1, 2, 3],\n           [4, 5, 6],\n           [7, 8, 9]]\n    print(mat)\n    rotate(mat)\n    print(mat)\n"
  },
  {
    "id": 346,
    "category": "matrix",
    "file_name": "sudoku_validator",
    "codes": "\"\"\"\nWrite a function validSolution/ValidateSolution/valid_solution()\nthat accepts a 2D array representing a Sudoku board, and returns true\nif it is a valid solution, or false otherwise. The cells of the sudoku\nboard may also contain 0's, which will represent empty cells.\nBoards containing one or more zeroes are considered to be invalid solutions.\nThe board is always 9 cells by 9 cells, and every cell only contains integers\nfrom 0 to 9.\n\n(More info at: http://en.wikipedia.org/wiki/Sudoku)\n\"\"\"\n\n# Using dict/hash-table\nfrom collections import defaultdict\n\n\ndef valid_solution_hashtable(board):\n    for i in range(len(board)):\n        dict_row = defaultdict(int)\n        dict_col = defaultdict(int)\n        for j in range(len(board[0])):\n            value_row = board[i][j]\n            value_col = board[j][i]\n            if not value_row or value_col == 0:\n                return False\n            if value_row in dict_row:\n                return False\n            else:\n                dict_row[value_row] += 1\n\n            if value_col in dict_col:\n                return False\n            else:\n                dict_col[value_col] += 1\n\n    for i in range(3):\n        for j in range(3):\n            grid_add = 0\n            for k in range(3):\n                for l in range(3):\n                    grid_add += board[i * 3 + k][j * 3 + l]\n            if grid_add != 45:\n                return False\n    return True\n\n\n# Without hash-table/dict\ndef valid_solution(board):\n    correct = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    # check rows\n    for row in board:\n        if sorted(row) != correct:\n            return False\n\n    # check columns\n    for column in zip(*board):\n        if sorted(column) != correct:\n            return False\n\n    # check regions\n    for i in range(3):\n        for j in range(3):\n            region = []\n            for line in board[i*3:(i+1)*3]:\n                region += line[j*3:(j+1)*3]\n\n            if sorted(region) != correct:\n                return False\n\n    # if everything correct\n    return True\n\n\n# Using set\ndef valid_solution_set(board):\n    valid = set(range(1, 10))\n\n    for row in board:\n        if set(row) != valid:\n            return False\n\n    for col in [[row[i] for row in board] for i in range(9)]:\n        if set(col) != valid:\n            return False\n\n    for x in range(3):\n        for y in range(3):\n            if set(sum([row[x*3:(x+1)*3] for row in board[y*3:(y+1)*3]], [])) != valid:\n                return False\n\n    return True\n"
  },
  {
    "id": 347,
    "category": "matrix",
    "file_name": "matrix_inversion",
    "codes": "\"\"\"\nInverts an invertible n x n matrix -- i.e., given an n x n matrix A, returns\nan n x n matrix B such that AB = BA = In, the n x n identity matrix.\n\nFor a 2 x 2 matrix, inversion is simple using the cofactor equation. For\nlarger matrices, this is a four step process:\n1. calculate the matrix of minors: create an n x n matrix by considering each\nposition in the original matrix in turn. Exclude the current row and column\nand calculate the determinant of the remaining matrix, then place that value\nin the current position's equivalent in the matrix of minors.\n2. create the matrix of cofactors: take the matrix of minors and multiply\nalternate values by -1 in a checkerboard pattern.\n3. adjugate: hold the top left to bottom right diagonal constant, but swap all\nother values over it.\n4. multiply the adjugated matrix by 1 / the determinant of the original matrix\n\nThis code combines steps 1 and 2 into one method to reduce traversals of the\nmatrix.\n\nPossible edge cases: will not work for 0x0 or 1x1 matrix, though these are\ntrivial to calculate without use of this file.\n\"\"\"\nimport fractions\n\n\ndef invert_matrix(m):\n    \"\"\"invert an n x n matrix\"\"\"\n    # Error conditions\n    if not array_is_matrix(m):\n        print(\"Invalid matrix: array is not a matrix\")\n        return [[-1]]\n    elif len(m) != len(m[0]):\n        print(\"Invalid matrix: matrix is not square\")\n        return [[-2]]\n    elif len(m) < 2:\n        print(\"Invalid matrix: matrix is too small\")\n        return [[-3]]\n    elif get_determinant(m) == 0:\n        print(\"Invalid matrix: matrix is square, but singular (determinant = 0)\")\n        return [[-4]]\n\n    # Calculation\n    elif len(m) == 2:\n        # simple case\n        multiplier = 1 / get_determinant(m)\n        inverted = [[multiplier] * len(m) for n in range(len(m))]\n        inverted[0][1] = inverted[0][1] * -1 * m[0][1]\n        inverted[1][0] = inverted[1][0] * -1 * m[1][0]\n        inverted[0][0] = multiplier * m[1][1]\n        inverted[1][1] = multiplier * m[0][0]\n        return inverted\n    else:\n        \"\"\"some steps combined in helpers to reduce traversals\"\"\"\n        # get matrix of minors w/ \"checkerboard\" signs\n        m_of_minors = get_matrix_of_minors(m)\n\n        # calculate determinant (we need to know 1/det)\n        multiplier = fractions.Fraction(1, get_determinant(m))\n\n        # adjugate (swap on diagonals) and multiply by 1/det\n        inverted = transpose_and_multiply(m_of_minors, multiplier)\n\n        return inverted\n\n\ndef get_determinant(m):\n    \"\"\"recursively calculate the determinant of an n x n matrix, n >= 2\"\"\"\n    if len(m) == 2:\n        # trivial case\n        return (m[0][0] * m[1][1]) - (m[0][1] * m[1][0])\n    else:\n        sign = 1\n        det = 0\n        for i in range(len(m)):\n            det += sign * m[0][i] * get_determinant(get_minor(m, 0, i))\n            sign *= -1\n        return det\n\n\ndef get_matrix_of_minors(m):\n    \"\"\"get the matrix of minors and alternate signs\"\"\"\n    matrix_of_minors = [[0 for i in range(len(m))] for j in range(len(m))]\n    for row in range(len(m)):\n        for col in range(len(m[0])):\n            if (row + col) % 2 == 0:\n                sign = 1\n            else:\n                sign = -1\n            matrix_of_minors[row][col] = sign * get_determinant(get_minor(m, row, col))\n    return matrix_of_minors\n\n\ndef get_minor(m, row, col):\n    \"\"\"\n    get the minor of the matrix position m[row][col]\n    (all values m[r][c] where r != row and c != col)\n    \"\"\"\n    minors = []\n    for i in range(len(m)):\n        if i != row:\n            new_row = m[i][:col]\n            new_row.extend(m[i][col + 1:])\n            minors.append(new_row)\n    return minors\n\n\ndef transpose_and_multiply(m, multiplier=1):\n    \"\"\"swap values along diagonal, optionally adding multiplier\"\"\"\n    for row in range(len(m)):\n        for col in range(row + 1):\n            temp = m[row][col] * multiplier\n            m[row][col] = m[col][row] * multiplier\n            m[col][row] = temp\n    return m\n\n\ndef array_is_matrix(m):\n    if len(m) == 0:\n        return False\n    first_col = len(m[0])\n    for row in m:\n        if len(row) != first_col:\n            return False\n    return True\n"
  },
  {
    "id": 348,
    "category": "matrix",
    "file_name": "search_in_sorted_matrix",
    "codes": "#\n# Search a key in a row wise and column wise sorted (non-decreasing) matrix.\n# m- Number of rows in the matrix\n# n- Number of columns in the matrix\n# T(n)- O(m+n)\n#\n\n\ndef search_in_a_sorted_matrix(mat, m, n, key):\n    i, j = m-1, 0\n    while i >= 0 and j < n:\n        if key == mat[i][j]:\n            print('Key %s found at row- %s column- %s' % (key, i+1, j+1))\n            return\n        if key < mat[i][j]:\n            i -= 1\n        else:\n            j += 1\n    print('Key %s not found' % (key))\n\n\ndef main():\n    mat = [\n           [2, 5, 7],\n           [4, 8, 13],\n           [9, 11, 15],\n           [12, 17, 20]\n          ]\n    key = 13\n    print(mat)\n    search_in_a_sorted_matrix(mat, len(mat), len(mat[0]), key)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "id": 349,
    "category": "matrix",
    "file_name": "sparse_mul",
    "codes": "\"\"\"\nGiven two sparse matrices A and B, return the result of AB.\n\nYou may assume that A's column number is equal to B's row number.\n\nExample:\n\nA = [\n  [ 1, 0, 0],\n  [-1, 0, 3]\n]\n\nB = [\n  [ 7, 0, 0 ],\n  [ 0, 0, 0 ],\n  [ 0, 0, 1 ]\n]\n\n\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |\nAB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\n                  | 0 0 1 |\n\"\"\"\n\n\n# Python solution without table (~156ms):\ndef multiply(self, a, b):\n    \"\"\"\n    :type A: List[List[int]]\n    :type B: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    if a is None or b is None:\n        return None\n    m, n, l = len(a), len(b[0]), len(b[0])\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")\n    c = [[0 for _ in range(l)] for _ in range(m)]\n    for i, row in enumerate(a):\n        for k, eleA in enumerate(row):\n            if eleA:\n                for j, eleB in enumerate(b[k]):\n                    if eleB:\n                        c[i][j] += eleA * eleB\n    return c\n\n\n# Python solution with only one table for B (~196ms):\ndef multiply(self, a, b):\n    \"\"\"\n    :type A: List[List[int]]\n    :type B: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    if a is None or b is None:\n        return None\n    m, n, l = len(a), len(a[0]), len(b[0])\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")\n    c = [[0 for _ in range(l)] for _ in range(m)]\n    table_b = {}\n    for k, row in enumerate(b):\n        table_b[k] = {}\n        for j, eleB in enumerate(row):\n            if eleB:\n                table_b[k][j] = eleB\n    for i, row in enumerate(a):\n        for k, eleA in enumerate(row):\n            if eleA:\n                for j, eleB in table_b[k].iteritems():\n                    c[i][j] += eleA * eleB\n    return c\n\n\n# Python solution with two tables (~196ms):\ndef multiply(self, a, b):\n    \"\"\"\n    :type A: List[List[int]]\n    :type B: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    if a is None or b is None:\n        return None\n    m, n = len(a), len(b[0])\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")\n    l = len(b[0])\n    table_a, table_b = {}, {}\n    for i, row in enumerate(a):\n        for j, ele in enumerate(row):\n            if ele:\n                if i not in table_a:\n                    table_a[i] = {}\n                table_a[i][j] = ele\n    for i, row in enumerate(b):\n        for j, ele in enumerate(row):\n            if ele:\n                if i not in table_b:\n                    table_b[i] = {}\n                table_b[i][j] = ele\n    c = [[0 for j in range(l)] for i in range(m)]\n    for i in table_a:\n        for k in table_a[i]:\n            if k not in table_b:\n                continue\n            for j in table_b[k]:\n                c[i][j] += table_a[i][k] * table_b[k][j]\n    return c\n"
  },
  {
    "id": 350,
    "category": "matrix",
    "file_name": "spiral_traversal",
    "codes": "\"\"\"\nGiven a matrix of m x n elements (m rows, n columns),\nreturn all elements of the matrix in spiral order.\nFor example,\nGiven the following matrix:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\n\nYou should return [1,2,3,6,9,8,7,4,5].\n\"\"\"\n\n\ndef spiral_traversal(matrix):\n    res = []\n    if len(matrix) == 0:\n        return res\n    row_begin = 0\n    row_end = len(matrix) - 1\n    col_begin = 0\n    col_end = len(matrix[0]) - 1\n\n    while row_begin <= row_end and col_begin <= col_end:\n        for i in range(col_begin, col_end+1):\n            res.append(matrix[row_begin][i])\n        row_begin += 1\n\n        for i in range(row_begin, row_end+1):\n            res.append(matrix[i][col_end])\n        col_end -= 1\n\n        if row_begin <= row_end:\n            for i in range(col_end, col_begin-1, -1):\n                res.append(matrix[row_end][i])\n        row_end -= 1\n\n        if col_begin <= col_end:\n            for i in range(row_end, row_begin-1, -1):\n                res.append(matrix[i][col_begin])\n        col_begin += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    mat = [[1, 2, 3],\n           [4, 5, 6],\n           [7, 8, 9]]\n    print(spiral_traversal(mat))\n"
  },
  {
    "id": 351,
    "category": "matrix",
    "file_name": "crout_matrix_decomposition",
    "codes": "\"\"\"\nCrout matrix decomposition is used to find two matrices that, when multiplied\ngive our input matrix, so L * U = A.\nL stands for lower and L has non-zero elements only on diagonal and below.\nU stands for upper and U has non-zero elements only on diagonal and above.\n\nThis can for example be used to solve systems of linear equations.\nThe last if is used  if  to avoid dividing by zero.\n\nExample:\nWe input the A matrix:\n[[1,2,3],\n[3,4,5],\n[6,7,8]]\n\nWe get:\nL = [1.0,  0.0, 0.0]\n    [3.0, -2.0, 0.0]\n    [6.0, -5.0, 0.0]\nU = [1.0,  2.0, 3.0]\n    [0.0,  1.0, 2.0]\n    [0.0,  0.0, 1.0]\n\nWe can check that L * U = A.\n\nI think the complexity should be O(n^3).\n\"\"\"\n\n\ndef crout_matrix_decomposition(A):\n    n = len(A)\n    L = [[0.0] * n for i in range(n)]\n    U = [[0.0] * n for i in range(n)]\n    for j in range(n):\n        U[j][j] = 1.0\n        for i in range(j, n):\n            alpha = float(A[i][j])\n            for k in range(j):\n                alpha -= L[i][k]*U[k][j]\n            L[i][j] = float(alpha)\n        for i in range(j+1, n):\n            tempU = float(A[j][i])\n            for k in range(j):\n                tempU -= float(L[j][k]*U[k][i])\n            if int(L[j][j]) == 0:\n                L[j][j] = float(0.1**40)\n            U[j][i] = float(tempU/L[j][j])\n    return (L, U)\n"
  }
]